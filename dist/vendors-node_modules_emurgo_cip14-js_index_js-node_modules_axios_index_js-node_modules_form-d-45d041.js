(self["webpackChunkwallet_test"] = self["webpackChunkwallet_test"] || []).push([["vendors-node_modules_emurgo_cip14-js_index_js-node_modules_axios_index_js-node_modules_form-d-45d041"],{

/***/ "./node_modules/@emurgo/cip14-js/index.js":
/*!************************************************!*\
  !*** ./node_modules/@emurgo/cip14-js/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var blake2b_1 = __importDefault(__webpack_require__(/*! blake2b */ "./node_modules/blake2b/index.js"));

var bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js"); /// note: this function can't be inverted due to the hash


var DATA = "asset";

var AssetFingerprint = /*#__PURE__*/function () {
  function AssetFingerprint(hashBuf) {
    _classCallCheck(this, AssetFingerprint);

    this.hashBuf = hashBuf;
  }

  _createClass(AssetFingerprint, [{
    key: "fingerprint",
    value: function fingerprint() {
      var words = bech32_1.bech32.toWords(this.hashBuf);
      return bech32_1.bech32.encode(DATA, words);
    }
  }, {
    key: "hash",
    value: function hash() {
      return Buffer.from(this.hashBuf).toString("hex");
    }
  }, {
    key: "prefix",
    value: function prefix() {
      return DATA;
    } // The last six characters of the data part form a checksum and contain no information

  }, {
    key: "checksum",
    value: function checksum() {
      return this.fingerprint().slice(-6);
    }
  }], [{
    key: "fromHash",
    value: function fromHash(hash) {
      return new AssetFingerprint(hash);
    }
  }, {
    key: "fromParts",
    value: function fromParts(policyId, assetName) {
      // see https://github.com/cardano-foundation/CIPs/pull/64
      var hashBuf = (0, blake2b_1["default"])(20).update(new Uint8Array([].concat(_toConsumableArray(policyId), _toConsumableArray(assetName)))).digest("binary");
      return AssetFingerprint.fromHash(hashBuf);
    }
  }, {
    key: "fromBech32",
    value: function fromBech32(fingerprint) {
      var _bech32_1$bech32$deco = bech32_1.bech32.decode(fingerprint),
          prefix = _bech32_1$bech32$deco.prefix,
          words = _bech32_1$bech32$deco.words;

      if (prefix !== DATA) {
        throw new Error("Invalid asset fingerprint");
      }

      var hashBuf = Buffer.from(bech32_1.bech32.fromWords(words));
      return AssetFingerprint.fromHash(hashBuf);
    }
  }]);

  return AssetFingerprint;
}();

exports["default"] = AssetFingerprint;

/***/ }),

/***/ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/*
 * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.

var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);

for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}

var encode = function encode(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer),
      i,
      len = bytes.length,
      base64 = '';

  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }

  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }

  return base64;
};

var decode = function decode(base64) {
  var bufferLength = base64.length * 0.75,
      len = base64.length,
      i,
      p = 0,
      encoded1,
      encoded2,
      encoded3,
      encoded4;

  if (base64[base64.length - 1] === '=') {
    bufferLength--;

    if (base64[base64.length - 2] === '=') {
      bufferLength--;
    }
  }

  var arraybuffer = new ArrayBuffer(bufferLength),
      bytes = new Uint8Array(arraybuffer);

  for (i = 0; i < len; i += 4) {
    encoded1 = lookup[base64.charCodeAt(i)];
    encoded2 = lookup[base64.charCodeAt(i + 1)];
    encoded3 = lookup[base64.charCodeAt(i + 2)];
    encoded4 = lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }

  return arraybuffer;
};



/***/ }),

/***/ "./node_modules/accepts/index.js":
/*!***************************************!*\
  !*** ./node_modules/accepts/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(/*! negotiator */ "./node_modules/negotiator/index.js");

var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
/**
 * Module exports.
 * @public
 */


module.exports = Accepts;
/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts(req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req);
  }

  this.headers = req.headers;
  this.negotiator = new Negotiator(req);
}
/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */


Accepts.prototype.type = Accepts.prototype.types = function (types_) {
  var types = types_; // support flattened arguments

  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length);

    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i];
    }
  } // no types, return all requested types


  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes();
  } // no accept header, return first given type


  if (!this.headers.accept) {
    return types[0];
  }

  var mimes = types.map(extToMime);
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first = accepts[0];
  return first ? types[mimes.indexOf(first)] : false;
};
/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */


Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_; // support flattened arguments

  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length);

    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i];
    }
  } // no encodings, return all requested encodings


  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings();
  }

  return this.negotiator.encodings(encodings)[0] || false;
};
/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */


Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_; // support flattened arguments

  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length);

    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i];
    }
  } // no charsets, return all requested charsets


  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets();
  }

  return this.negotiator.charsets(charsets)[0] || false;
};
/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */


Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
  var languages = languages_; // support flattened arguments

  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length);

    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i];
    }
  } // no languages, return all requested languages


  if (!languages || languages.length === 0) {
    return this.negotiator.languages();
  }

  return this.negotiator.languages(languages)[0] || false;
};
/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */


function extToMime(type) {
  return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */


function validMime(type) {
  return typeof type === 'string';
}

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");

var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");

var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'


        setTimeout(onloadend);
      };
    } // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js"); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {



module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */

function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      forcedJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators["boolean"], '1.0.0')
    }, false);
  } // filter out skipped interceptors


  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }

  var newConfig = config;

  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();

    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/

  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });
  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data) || headers && headers['Content-Type'] === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }

          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {



module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = function isAxiosError(payload) {
  return _typeof(payload) === 'object' && payload.isAxiosError === true;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {}; // eslint-disable-next-line func-names

['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return _typeof(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');
/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */

function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');

  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }

  return false;
}
/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */


validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  } // eslint-disable-next-line func-names


  return function (value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console

      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */


function assertOptions(options, schema, allowUnknown) {
  if (_typeof(options) !== 'object') {
    throw new TypeError('options must be an object');
  }

  var keys = Object.keys(options);
  var i = keys.length;

  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];

    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);

      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }

      continue;
    }

    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js"); // utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function
  /* obj1, obj2, obj3, ... */
merge() {
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/base64id/lib/base64id.js":
/*!***********************************************!*\
  !*** ./node_modules/base64id/lib/base64id.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/*!
 * base64id v0.1.0
 */

/**
 * Module dependencies
 */
var crypto = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
/**
 * Constructor
 */


var Base64Id = function Base64Id() {};
/**
 * Get random bytes
 *
 * Uses a buffer if available, falls back to crypto.randomBytes
 */


Base64Id.prototype.getRandomBytes = function (bytes) {
  var BUFFER_SIZE = 4096;
  var self = this;
  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }

  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
  var threshold = parseInt(bytesInBuffer * 0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
    this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  } // No buffered bytes available or index above threshold


  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      });
    } // Fall back to sync call when no buffered bytes are available


    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }

  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
  this.bytesBufferIndex++;
  return result;
};
/**
 * Generates a base64 id
 *
 * (Original version from socket.io <http://socket.io>)
 */


Base64Id.prototype.generateId = function () {
  var rand = Buffer.alloc(15); // multiple of 3 for base64

  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }

  this.sequenceNumber = this.sequenceNumber + 1 | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);

  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function (i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }

  return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
};
/**
 * Export
 */


exports = module.exports = new Base64Id();

/***/ }),

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bech32m = exports.bech32 = void 0;
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var ALPHABET_MAP = {};

for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}

function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}

function prefixChk(prefix) {
  var chk = 1;

  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }

  chk = polymodStep(chk);

  for (var _i = 0; _i < prefix.length; ++_i) {
    var v = prefix.charCodeAt(_i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }

  return chk;
}

function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];

  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;

    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }

  return result;
}

function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}

function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}

function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}

function getLibraryFromEncoding(encoding) {
  var ENCODING_CONST;

  if (encoding === 'bech32') {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 0x2bc830a3;
  }

  function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase(); // determine chk mod

    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';

    for (var i = 0; i < words.length; ++i) {
      var _x = words[i];
      if (_x >> 5 !== 0) throw new Error('Non 5-bit word');
      chk = polymodStep(chk) ^ _x;
      result += ALPHABET.charAt(_x);
    }

    for (var _i2 = 0; _i2 < 6; ++_i2) {
      chk = polymodStep(chk);
    }

    chk ^= ENCODING_CONST;

    for (var _i3 = 0; _i3 < 6; ++_i3) {
      var v = chk >> (5 - _i3) * 5 & 0x1f;
      result += ALPHABET.charAt(v);
    }

    return result;
  }

  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case

    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];

    for (var i = 0; i < wordChars.length; ++i) {
      var c = wordChars.charAt(i);
      var v = ALPHABET_MAP[c];
      if (v === undefined) return 'Unknown character ' + c;
      chk = polymodStep(chk) ^ v; // not in the checksum?

      if (i + 6 >= wordChars.length) continue;
      words.push(v);
    }

    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
    return {
      prefix: prefix,
      words: words
    };
  }

  function decodeUnsafe(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
  }

  function decode(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
    throw new Error(res);
  }

  return {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
  };
}

exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

/***/ }),

/***/ "./node_modules/blake2b-wasm/blake2b.js":
/*!**********************************************!*\
  !*** ./node_modules/blake2b-wasm/blake2b.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null))["catch"](cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new ((__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer))(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

/***/ }),

/***/ "./node_modules/blake2b-wasm/index.js":
/*!********************************************!*\
  !*** ./node_modules/blake2b-wasm/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var wasm = __webpack_require__(/*! ./blake2b */ "./node_modules/blake2b-wasm/blake2b.js")();

var head = 64;
var freeList = [];
module.exports = Blake2b;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;

function Blake2b(digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');
  if (!digestLength) digestLength = 32;

  if (noAssert !== true) {
    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);
    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }

  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();
  wasm.memory.fill(0, 0, 64);
  wasm.memory[0] = this.digestLength;
  wasm.memory[1] = key ? key.length : 0;
  wasm.memory[2] = 1; // fanout

  wasm.memory[3] = 1; // depth

  if (salt) wasm.memory.set(salt, 32);
  if (personal) wasm.memory.set(personal, 48);
  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state

  wasm.exports.blake2b_init(this.pointer, this.digestLength);

  if (key) {
    this.update(key);
    wasm.memory.fill(0, head, head + key.length); // whiteout key

    wasm.memory[this.pointer + 200] = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(this.finalized === false, 'Hash instance finalized');
  assert(input, 'input must be TypedArray or Buffer');
  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.set(input, head);
  wasm.exports.blake2b_update(this.pointer, head, head + input.length);
  return this;
};

Blake2b.prototype.digest = function (enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  wasm.exports.blake2b_final(this.pointer);

  if (!enc || enc === 'binary') {
    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  }

  if (enc === 'hex') {
    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
  }

  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer');

  for (var i = 0; i < this.digestLength; i++) {
    enc[i] = wasm.memory[this.pointer + 128 + i];
  }

  return enc;
}; // libsodium compat


Blake2b.prototype["final"] = Blake2b.prototype.digest;
Blake2b.WASM = wasm && wasm.buffer;
Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined';

Blake2b.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported')); // backwards compat, can be removed in a new major

  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve();else reject();
      cb(err);
    });
  });
  return p;
};

Blake2b.prototype.ready = Blake2b.ready;

function noop() {}

function hexSlice(buf, start, len) {
  var str = '';

  for (var i = 0; i < len; i++) {
    str += toHex(buf[start + i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

/***/ }),

/***/ "./node_modules/blake2b/index.js":
/*!***************************************!*\
  !*** ./node_modules/blake2b/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var b2wasm = __webpack_require__(/*! blake2b-wasm */ "./node_modules/blake2b-wasm/index.js"); // 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array


function ADD64AA(v, a, b) {
  var o0 = v[a] + v[b];
  var o1 = v[a + 1] + v[b + 1];

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits


function ADD64AC(v, a, b0, b1) {
  var o0 = v[a] + b0;

  if (b0 < 0) {
    o0 += 0x100000000;
  }

  var o1 = v[a + 1] + b1;

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // Little-endian byte access


function B2B_GET32(arr, i) {
  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
} // G Mixing function
// The ROTRs are inlined for speed


function B2B_G(a, b, c, d, ix, iy) {
  var x0 = m[ix];
  var x1 = m[ix + 1];
  var y0 = m[iy];
  var y1 = m[iy + 1];
  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s

  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits

  var xor0 = v[d] ^ v[a];
  var xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor0 >>> 24 ^ xor1 << 8;
  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v, a, b);
  ADD64AC(v, a, y0, y1); // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits

  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor0 >>> 16 ^ xor1 << 16;
  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor1 >>> 31 ^ xor0 << 1;
  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
} // Initialization Vector


var BLAKE2B_IV32 = new Uint32Array([0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85, 0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A, 0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C, 0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19]);
var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; // These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s

var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
  return x * 2;
})); // Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s

var v = new Uint32Array(32);
var m = new Uint32Array(32);

function blake2bCompress(ctx, last) {
  var i = 0; // init work variables

  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i];
    v[i + 16] = BLAKE2B_IV32[i];
  } // low 64 bits of offset


  v[24] = v[24] ^ ctx.t;
  v[25] = v[25] ^ ctx.t / 0x100000000; // high 64 bits not supported, offset may not be higher than 2**53-1
  // last block flag set ?

  if (last) {
    v[28] = ~v[28];
    v[29] = ~v[29];
  } // get little-endian words


  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i);
  } // twelve rounds of mixing


  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
  }
} // reusable parameter_block


var parameter_block = new Uint8Array([0, 0, 0, 0, //  0: outlen, keylen, fanout, depth
0, 0, 0, 0, //  4: leaf length, sequential mode
0, 0, 0, 0, //  8: node offset
0, 0, 0, 0, // 12: node offset
0, 0, 0, 0, // 16: node depth, inner length, rfu
0, 0, 0, 0, // 20: rfu
0, 0, 0, 0, // 24: rfu
0, 0, 0, 0, // 28: rfu
0, 0, 0, 0, // 32: salt
0, 0, 0, 0, // 36: salt
0, 0, 0, 0, // 40: salt
0, 0, 0, 0, // 44: salt
0, 0, 0, 0, // 48: personal
0, 0, 0, 0, // 52: personal
0, 0, 0, 0, // 56: personal
0, 0, 0, 0 // 60: personal
]); // Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key

function Blake2b(outlen, key, salt, personal) {
  // zero out parameter_block before usage
  parameter_block.fill(0); // state, 'param block'

  this.b = new Uint8Array(128);
  this.h = new Uint32Array(16);
  this.t = 0; // input count

  this.c = 0; // pointer within buffer

  this.outlen = outlen; // output length in bytes

  parameter_block[0] = outlen;
  if (key) parameter_block[1] = key.length;
  parameter_block[2] = 1; // fanout

  parameter_block[3] = 1; // depth

  if (salt) parameter_block.set(salt, 32);
  if (personal) parameter_block.set(personal, 48); // initialize hash state

  for (var i = 0; i < 16; i++) {
    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
  } // key the hash, if applicable


  if (key) {
    blake2bUpdate(this, key); // at the end

    this.c = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(input != null, 'input must be Uint8Array or Buffer');
  blake2bUpdate(this, input);
  return this;
};

Blake2b.prototype.digest = function (out) {
  var buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out;
  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
  blake2bFinal(this, buf);
  if (out === 'hex') return hexSlice(buf);
  return buf;
};

Blake2b.prototype["final"] = Blake2b.prototype.digest;

Blake2b.ready = function (cb) {
  b2wasm.ready(function () {
    cb(); // ignore the error
  });
}; // Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)


function blake2bUpdate(ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c; // add counters

      blake2bCompress(ctx, false); // compress (not last)

      ctx.c = 0; // counter to zero
    }

    ctx.b[ctx.c++] = input[i];
  }
} // Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest


function blake2bFinal(ctx, out) {
  ctx.t += ctx.c; // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0;
  }

  blake2bCompress(ctx, true); // final block flag = 1

  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
  }

  return out;
}

function hexSlice(buf) {
  var str = '';

  for (var i = 0; i < buf.length; i++) {
    str += toHex(buf[i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

var Proto = Blake2b;

module.exports = function createHash(outlen, key, salt, personal, noAssert) {
  if (noAssert !== true) {
    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  return new Proto(outlen, key, salt, personal);
};

module.exports.ready = function (cb) {
  b2wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
b2wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    Proto = b2wasm;
  }
});

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }

  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }

  return fromArrayLike(arrayView);
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }

    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  var i;

  for (i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
          thirdByte = void 0,
          fourthByte = void 0,
          tempCodePoint = void 0;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = (first << 24) + // Overflow
  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}

function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage


var errors = {};

function E(sym, getMessage, Base) {
  errors[sym] = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);

    var _super = _createSuper(NodeError);

    function NodeError() {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _super.call(this);
      Object.defineProperty(_assertThisInitialized(_this), 'message', {
        value: getMessage.apply(_assertThisInitialized(_this), arguments),
        writable: true,
        configurable: true
      }); // Add the error code to the name to include it in the stack trace.

      _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
      // from the name.

      _this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.

      delete _this.name;
      return _this;
    }

    _createClass(NodeError, [{
      key: "code",
      get: function get() {
        return sym;
      },
      set: function set(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value: value,
          writable: true
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
      }
    }]);

    return NodeError;
  }(Base);
}

E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;

  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);

    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }

    received += 'n';
  }

  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);

function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;

  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }

  return "".concat(val.slice(0, i)).concat(res);
} // CHECK FUNCTIONS
// ===============


function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');

  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}

function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;

    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }

    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }

  checkBounds(buf, offset, byteLength);
}

function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}

function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
} // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  var i;

  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
} // Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219


var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);

  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;

    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }

  return table;
}(); // Return not function with Error if BigInt not supported


function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}

function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

/***/ }),

/***/ "./node_modules/bufferutil/fallback.js":
/*!*********************************************!*\
  !*** ./node_modules/bufferutil/fallback.js ***!
  \*********************************************/
/***/ ((module) => {


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */

var mask = function mask(source, _mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ _mask[i & 3];
  }
};
/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */


var unmask = function unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  var length = buffer.length;

  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = {
  mask: mask,
  unmask: unmask
};

/***/ }),

/***/ "./node_modules/bufferutil/index.js":
/*!******************************************!*\
  !*** ./node_modules/bufferutil/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __dirname = "/";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "./node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "./node_modules/bufferutil/fallback.js");
}

/***/ }),

/***/ "./node_modules/builtin-status-codes/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/builtin-status-codes/browser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/cookie/index.js":
/*!**************************************!*\
  !*** ./node_modules/cookie/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var opt = options || {};
  var pairs = str.split(';');
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var index = pair.indexOf('='); // skip things that don't look like key=value

    if (index < 0) {
      continue;
    }

    var key = pair.substring(0, index).trim(); // only assign once

    if (undefined == obj[key]) {
      var val = pair.substring(index + 1, pair.length).trim(); // quoted values

      if (val[0] === '"') {
        val = val.slice(1, -1);
      }

      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */


function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid');
    }

    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;

      case 'lax':
        str += '; SameSite=Lax';
        break;

      case 'strict':
        str += '; SameSite=Strict';
        break;

      case 'none':
        str += '; SameSite=None';
        break;

      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */


function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

/***/ }),

/***/ "./node_modules/cors/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/cors/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function () {
  'use strict';

  var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

  var vary = __webpack_require__(/*! vary */ "./node_modules/vary/index.js");

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }

      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
        headers = [],
        isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin); // reflect origin

      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;

    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }

    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }

    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers

      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }

    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;

    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }

    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }

    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();

    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }

    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];

      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
        method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureMethods(options, req));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;

    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function optionsCallback(req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;

          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function originCallback(origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  } // can pass either an options hash, an options delegate, or nothing


  module.exports = middlewareWrapper;
})();

/***/ }),

/***/ "./node_modules/engine.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/engine.io/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/engine.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/engine.io/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/engine.io/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* eslint-env browser */
module.exports = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' ? self.FormData : window.FormData;

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */
module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json");

/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js");

var extname = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/**
 * Module variables.
 * @private
 */


var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */

exports.charset = charset;
exports.charsets = {
  lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null); // Populate the extensions/types maps

populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && db[match[1].toLowerCase()];

  if (mime && mime.charset) {
    return mime.charset;
  } // default text/* to utf-8


  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8';
  }

  return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */


function contentType(str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false;
  }

  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

  if (!mime) {
    return false;
  } // TODO: use content-type or other module


  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime);
    if (charset) mime += '; charset=' + charset.toLowerCase();
  }

  return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */


function extension(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type); // get extensions

  var exts = match && exports.extensions[match[1].toLowerCase()];

  if (!exts || !exts.length) {
    return false;
  }

  return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */


function lookup(path) {
  if (!path || typeof path !== 'string') {
    return false;
  } // get the extension ("ext" or ".ext" or full path)


  var extension = extname('x.' + path).toLowerCase().substr(1);

  if (!extension) {
    return false;
  }

  return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */


function populateMaps(extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana'];
  Object.keys(db).forEach(function forEachMimeType(type) {
    var mime = db[type];
    var exts = mime.extensions;

    if (!exts || !exts.length) {
      return;
    } // mime -> extensions


    extensions[type] = exts; // extension -> mime

    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source);
        var to = preference.indexOf(mime.source);

        if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
          // skip the remapping
          continue;
        }
      } // set the extension -> mime


      types[extension] = type;
    }
  });
}

/***/ }),

/***/ "./node_modules/nanoassert/index.js":
/*!******************************************!*\
  !*** ./node_modules/nanoassert/index.js ***!
  \******************************************/
/***/ ((module) => {

assert.notEqual = notEqual;
assert.notOk = notOk;
assert.equal = equal;
assert.ok = assert;
module.exports = assert;

function equal(a, b, m) {
  assert(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual(a, b, m) {
  assert(a != b, m); // eslint-disable-line eqeqeq
}

function notOk(t, m) {
  assert(!t, m);
}

function assert(t, m) {
  if (!t) throw new Error(m || 'AssertionError');
}

/***/ }),

/***/ "./node_modules/negotiator/index.js":
/*!******************************************!*\
  !*** ./node_modules/negotiator/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */


var preferredCharsets = __webpack_require__(/*! ./lib/charset */ "./node_modules/negotiator/lib/charset.js");

var preferredEncodings = __webpack_require__(/*! ./lib/encoding */ "./node_modules/negotiator/lib/encoding.js");

var preferredLanguages = __webpack_require__(/*! ./lib/language */ "./node_modules/negotiator/lib/language.js");

var preferredMediaTypes = __webpack_require__(/*! ./lib/mediaType */ "./node_modules/negotiator/lib/mediaType.js");
/**
 * Module exports.
 * @public
 */


module.exports = Negotiator;
module.exports.Negotiator = Negotiator;
/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
}; // Backwards compatibility


Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

/***/ }),

/***/ "./node_modules/negotiator/lib/charset.js":
/*!************************************************!*\
  !*** ./node_modules/negotiator/lib/charset.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;
/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */


function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;
  var charset = match[1];
  var q = 1;

  if (match[2]) {
    var params = match[2].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');

      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}
/**
 * Get the priority of a charset.
 * @private
 */


function getCharsetPriority(charset, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the charset.
 * @private
 */


function specify(charset, spec, index) {
  var s = 0;

  if (spec.charset.toLowerCase() === charset.toLowerCase()) {
    s |= 1;
  } else if (spec.charset !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */


function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  }); // sorted list of accepted charsets

  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full charset string.
 * @private
 */


function getFullCharset(spec) {
  return spec.charset;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/encoding.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/encoding.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;
/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */


function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;
  var encoding = match[1];
  var q = 1;

  if (match[2]) {
    var params = match[2].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');

      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}
/**
 * Get the priority of an encoding.
 * @private
 */


function getEncodingPriority(encoding, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the encoding.
 * @private
 */


function specify(encoding, spec, index) {
  var s = 0;

  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
    s |= 1;
  } else if (spec.encoding !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

;
/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  }); // sorted list of accepted encodings

  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full encoding string.
 * @private
 */


function getFullEncoding(spec) {
  return spec.encoding;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/language.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/language.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;
/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a language from the Accept-Language header.
 * @private
 */


function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;
  var prefix = match[1];
  var suffix = match[2];
  var full = prefix;
  if (suffix) full += "-" + suffix;
  var q = 1;

  if (match[3]) {
    var params = match[3].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}
/**
 * Get the priority of a language.
 * @private
 */


function getLanguagePriority(language, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the language.
 * @private
 */


function specify(language, spec, index) {
  var p = parseLanguage(language);
  if (!p) return null;
  var s = 0;

  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

;
/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  }); // sorted list of accepted languages

  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full language string.
 * @private
 */


function getFullLanguage(spec) {
  return spec.full;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/mediaType.js":
/*!**************************************************!*\
  !*** ./node_modules/negotiator/lib/mediaType.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;
/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a media type from the Accept header.
 * @private
 */


function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;
  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1]; // get the value, unwrapping quotes

      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      } // store parameter


      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}
/**
 * Get the priority of a media type.
 * @private
 */


function getMediaTypePriority(type, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the media type.
 * @private
 */


function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4;
  } else if (spec.type != '*') {
    return null;
  }

  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2;
  } else if (spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);

  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1;
    } else {
      return null;
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred media types from an Accept header.
 * @public
 */


function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  }); // sorted list of accepted types

  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full type string.
 * @private
 */


function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}
/**
 * Count the number of quotes in a string.
 * @private
 */


function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}
/**
 * Split a key value pair.
 * @private
 */


function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}
/**
 * Split an Accept header into media types.
 * @private
 */


function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  } // trim accepts


  accepts.length = j + 1;
  return accepts;
}
/**
 * Split a string of parameters.
 * @private
 */


function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  } // trim parameters


  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}

/***/ }),

/***/ "./node_modules/node-gyp-build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-gyp-build/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var os = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())); // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'


var runtimeRequire =  true ? require : 0; // eslint-disable-line

var vars = process.config && process.config.variables || {};
var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
var abi = process.versions.modules; // TODO: support old node where this is undef

var runtime = isElectron() ? 'electron' : 'node';
var arch = os.arch();
var platform = os.platform();
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
var uv = (process.versions.uv || '').split('.')[0];
module.exports = load;

function load(dir) {
  return runtimeRequire(load.path(dir));
}

load.path = function (dir) {
  dir = path.resolve(dir || '.');

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
    if (release) return release;
    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
    if (debug) return debug;
  }

  var prebuild = resolve(dir);
  if (prebuild) return prebuild;
  var nearby = resolve(path.dirname(process.execPath));
  if (nearby) return nearby;
  var target = ['platform=' + platform, 'arch=' + arch, 'runtime=' + runtime, 'abi=' + abi, 'uv=' + uv, armv ? 'armv=' + armv : '', 'libc=' + libc, 'node=' + process.versions.node, process.versions.electron ? 'electron=' + process.versions.electron : '',  true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ');
  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');

  function resolve(dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
    if (!tuple) return; // Find most specific flavor first

    var prebuilds = path.join(dir, 'prebuilds', tuple.name);
    var parsed = readdirSync(prebuilds).map(parseTags);
    var candidates = parsed.filter(matchTags(runtime, abi));
    var winner = candidates.sort(compareTags(runtime))[0];
    if (winner) return path.join(prebuilds, winner.file);
  }
};

function readdirSync(dir) {
  try {
    return fs.readdirSync(dir);
  } catch (err) {
    return [];
  }
}

function getFirst(dir, filter) {
  var files = readdirSync(dir).filter(filter);
  return files[0] && path.join(dir, files[0]);
}

function matchBuild(name) {
  return /\.node$/.test(name);
}

function parseTuple(name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-');
  if (arr.length !== 2) return;
  var platform = arr[0];
  var architectures = arr[1].split('+');
  if (!platform) return;
  if (!architectures.length) return;
  if (!architectures.every(Boolean)) return;
  return {
    name: name,
    platform: platform,
    architectures: architectures
  };
}

function matchTuple(platform, arch) {
  return function (tuple) {
    if (tuple == null) return false;
    if (tuple.platform !== platform) return false;
    return tuple.architectures.includes(arch);
  };
}

function compareTuples(a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length;
}

function parseTags(file) {
  var arr = file.split('.');
  var extension = arr.pop();
  var tags = {
    file: file,
    specificity: 0
  };
  if (extension !== 'node') return;

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i];

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag;
    } else if (tag === 'napi') {
      tags.napi = true;
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3);
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2);
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4);
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag;
    } else {
      continue;
    }

    tags.specificity++;
  }

  return tags;
}

function matchTags(runtime, abi) {
  return function (tags) {
    if (tags == null) return false;
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
    if (tags.abi !== abi && !tags.napi) return false;
    if (tags.uv && tags.uv !== uv) return false;
    if (tags.armv && tags.armv !== armv) return false;
    if (tags.libc && tags.libc !== libc) return false;
    return true;
  };
}

function runtimeAgnostic(tags) {
  return tags.runtime === 'node' && tags.napi;
}

function compareTags(runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1;
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1;
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1;
    } else {
      return 0;
    }
  };
}

function isElectron() {
  if (process.versions && process.versions.electron) return true;
  if (process.env.ELECTRON_RUN_AS_NODE) return true;
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
}

function isAlpine(platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release');
} // Exposed for unit tests
// TODO: move to lib


load.parseTags = parseTags;
load.matchTags = matchTags;
load.compareTags = compareTags;
load.parseTuple = parseTuple;
load.matchTuple = matchTuple;
load.compareTuples = compareTuples;

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ ((module) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(/*! util */ "?d17e");

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "./node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js"),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(/*! util */ "?ed1b"),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module) => {

 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");
exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "./node_modules/readable-stream/lib/internal/streams/pipeline.js");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Adapter = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var Adapter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Adapter, _events_1$EventEmitte);

  var _super = _createSuper(Adapter);

  /**
   * In-memory adapter constructor.
   *
   * @param {Namespace} nsp
   */
  function Adapter(nsp) {
    var _this;

    _classCallCheck(this, Adapter);

    _this = _super.call(this);
    _this.nsp = nsp;
    _this.rooms = new Map();
    _this.sids = new Map();
    _this.encoder = nsp.server.encoder;
    return _this;
  }
  /**
   * To be overridden
   */


  _createClass(Adapter, [{
    key: "init",
    value: function init() {}
    /**
     * To be overridden
     */

  }, {
    key: "close",
    value: function close() {}
    /**
     * Adds a socket to a list of room.
     *
     * @param {SocketId}  id      the socket id
     * @param {Set<Room>} rooms   a set of rooms
     * @public
     */

  }, {
    key: "addAll",
    value: function addAll(id, rooms) {
      if (!this.sids.has(id)) {
        this.sids.set(id, new Set());
      }

      var _iterator = _createForOfIteratorHelper(rooms),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var room = _step.value;
          this.sids.get(id).add(room);

          if (!this.rooms.has(room)) {
            this.rooms.set(room, new Set());
            this.emit("create-room", room);
          }

          if (!this.rooms.get(room).has(id)) {
            this.rooms.get(room).add(id);
            this.emit("join-room", room, id);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Removes a socket from a room.
     *
     * @param {SocketId} id     the socket id
     * @param {Room}     room   the room name
     */

  }, {
    key: "del",
    value: function del(id, room) {
      if (this.sids.has(id)) {
        this.sids.get(id)["delete"](room);
      }

      this._del(room, id);
    }
  }, {
    key: "_del",
    value: function _del(room, id) {
      var _room = this.rooms.get(room);

      if (_room != null) {
        var deleted = _room["delete"](id);

        if (deleted) {
          this.emit("leave-room", room, id);
        }

        if (_room.size === 0 && this.rooms["delete"](room)) {
          this.emit("delete-room", room);
        }
      }
    }
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param {SocketId} id   the socket id
     */

  }, {
    key: "delAll",
    value: function delAll(id) {
      if (!this.sids.has(id)) {
        return;
      }

      var _iterator2 = _createForOfIteratorHelper(this.sids.get(id)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var room = _step2.value;

          this._del(room, id);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.sids["delete"](id);
    }
    /**
     * Broadcasts a packet.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @public
     */

  }, {
    key: "broadcast",
    value: function broadcast(packet, opts) {
      var flags = opts.flags || {};
      var packetOpts = {
        preEncoded: true,
        "volatile": flags["volatile"],
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      var encodedPackets = this.encoder.encode(packet);
      this.apply(opts, function (socket) {
        socket.client.writeToEngine(encodedPackets, packetOpts);
      });
    }
    /**
     * Gets a list of sockets by sid.
     *
     * @param {Set<Room>} rooms   the explicit set of rooms to check.
     */

  }, {
    key: "sockets",
    value: function sockets(rooms) {
      var sids = new Set();
      this.apply({
        rooms: rooms
      }, function (socket) {
        sids.add(socket.id);
      });
      return Promise.resolve(sids);
    }
    /**
     * Gets the list of rooms a given socket has joined.
     *
     * @param {SocketId} id   the socket id
     */

  }, {
    key: "socketRooms",
    value: function socketRooms(id) {
      return this.sids.get(id);
    }
    /**
     * Returns the matching socket instances
     *
     * @param opts - the filters to apply
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets(opts) {
      var sockets = [];
      this.apply(opts, function (socket) {
        sockets.push(socket);
      });
      return Promise.resolve(sockets);
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to join
     */

  }, {
    key: "addSockets",
    value: function addSockets(opts, rooms) {
      this.apply(opts, function (socket) {
        socket.join(rooms);
      });
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to leave
     */

  }, {
    key: "delSockets",
    value: function delSockets(opts, rooms) {
      this.apply(opts, function (socket) {
        rooms.forEach(function (room) {
          return socket.leave(room);
        });
      });
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param opts - the filters to apply
     * @param close - whether to close the underlying connection
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets(opts, close) {
      this.apply(opts, function (socket) {
        socket.disconnect(close);
      });
    }
  }, {
    key: "apply",
    value: function apply(opts, callback) {
      var rooms = opts.rooms;
      var except = this.computeExceptSids(opts.except);

      if (rooms.size) {
        var ids = new Set();

        var _iterator3 = _createForOfIteratorHelper(rooms),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var room = _step3.value;
            if (!this.rooms.has(room)) continue;

            var _iterator4 = _createForOfIteratorHelper(this.rooms.get(room)),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var id = _step4.value;
                if (ids.has(id) || except.has(id)) continue;
                var socket = this.nsp.sockets.get(id);

                if (socket) {
                  callback(socket);
                  ids.add(id);
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        var _iterator5 = _createForOfIteratorHelper(this.sids),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 1),
                _id = _step5$value[0];

            if (except.has(_id)) continue;

            var _socket = this.nsp.sockets.get(_id);

            if (_socket) callback(_socket);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }
  }, {
    key: "computeExceptSids",
    value: function computeExceptSids(exceptRooms) {
      var exceptSids = new Set();

      if (exceptRooms && exceptRooms.size > 0) {
        var _iterator6 = _createForOfIteratorHelper(exceptRooms),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var room = _step6.value;

            if (this.rooms.has(room)) {
              this.rooms.get(room).forEach(function (sid) {
                return exceptSids.add(sid);
              });
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }

      return exceptSids;
    }
    /**
     * Send a packet to the other Socket.IO servers in the cluster
     * @param packet - an array of arguments, which may include an acknowledgement callback at the end
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(packet) {
      throw new Error("this adapter does not support the serverSideEmit() functionality");
    }
  }]);

  return Adapter;
}(events_1.EventEmitter);

exports.Adapter = Adapter;

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/binary.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reconstructPacket = exports.deconstructPacket = void 0;

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */


function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
}

exports.deconstructPacket = deconstructPacket;

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (is_binary_1.isBinary(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }

    return _newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */


function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
}

exports.reconstructPacket = reconstructPacket;

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }

  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var binary_1 = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-parser/dist/binary.js");

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */


exports.protocol = 5;
var PacketType;

(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */


var Encoder = /*#__PURE__*/function () {
  function Encoder() {
    _classCallCheck(this, Encoder);
  }

  _createClass(Encoder, [{
    key: "encode",
    value:
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    function encode(obj) {
      debug("encoding packet %j", obj);

      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }

      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */

  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type; // attachments if we have them

      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      } // if we have a namespace other than `/`
      // we append it followed by a comma `,`


      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      } // immediately followed by the id


      if (null != obj.id) {
        str += obj.id;
      } // json data


      if (null != obj.data) {
        str += JSON.stringify(obj.data);
      }

      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */

  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = binary_1.deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      return buffers; // write all the buffers
    }
  }]);

  return Encoder;
}();

exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */

var Decoder = /*#__PURE__*/function (_Emitter) {
  _inherits(Decoder, _Emitter);

  var _super = _createSuper(Decoder);

  function Decoder() {
    _classCallCheck(this, Decoder);

    return _super.call(this);
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */


  _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;

      if (typeof obj === "string") {
        packet = this.decodeString(obj);

        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);

          if (packet) {
            // received final buffer
            this.reconstructor = null;

            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */

  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0; // look up type

      var p = {
        type: Number(str.charAt(0))
      };

      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      } // look up attachments if type binary


      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;

        while (str.charAt(++i) !== "-" && i != str.length) {}

        var buf = str.substring(start, i);

        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }

        p.attachments = Number(buf);
      } // look up namespace (if any)


      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;

        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }

        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      } // look up id


      var next = str.charAt(i + 1);

      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;

        while (++i) {
          var _c = str.charAt(i);

          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }

          if (i === str.length) break;
        }

        p.id = Number(str.substring(_start2, i + 1));
      } // look up json data


      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));

        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }

      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return _typeof(payload) === "object";

        case PacketType.DISCONNECT:
          return payload === undefined;

        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || _typeof(payload) === "object";

        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;

        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);

  return Decoder;
}(Emitter);

exports.Decoder = Decoder;

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */


var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);

    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */


  _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);

      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }

      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */

  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);

  return BinaryReconstructor;
}();

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/is-binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/is-binary.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */

function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}

exports.isBinary = isBinary;

function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }

  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (isBinary(obj)) {
    return true;
  }

  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

exports.hasBinary = hasBinary;

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/socket.io-parser/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/common.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io-parser/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/socket.io/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/socket.io/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/stream-http/index.js":
/*!*******************************************!*\
  !*** ./node_modules/stream-http/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ClientRequest = __webpack_require__(/*! ./lib/request */ "./node_modules/stream-http/lib/request.js");

var response = __webpack_require__(/*! ./lib/response */ "./node_modules/stream-http/lib/response.js");

var extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var statusCodes = __webpack_require__(/*! builtin-status-codes */ "./node_modules/builtin-status-codes/browser.js");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var http = exports;

http.request = function (opts, cb) {
  if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol
  // will result in a (valid) protocol-relative url. However, this won't work if
  // the protocol is something else, like 'file:'

  var defaultProtocol = __webpack_require__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || '/'; // Necessary for IPv6 addresses

  if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.

  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
  opts.method = (opts.method || 'GET').toUpperCase();
  opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode

  var req = new ClientRequest(opts);
  if (cb) req.on('response', cb);
  return req;
};

http.get = function get(opts, cb) {
  var req = http.request(opts, cb);
  req.end();
  return req;
};

http.ClientRequest = ClientRequest;
http.IncomingMessage = response.IncomingMessage;

http.Agent = function () {};

http.Agent.defaultMaxSockets = 4;
http.globalAgent = new http.Agent();
http.STATUS_CODES = statusCodes;
http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];

/***/ }),

/***/ "./node_modules/stream-http/lib/capability.js":
/*!****************************************************!*\
  !*** ./node_modules/stream-http/lib/capability.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.fetch = isFunction(__webpack_require__.g.fetch) && isFunction(__webpack_require__.g.ReadableStream);
exports.writableStream = isFunction(__webpack_require__.g.WritableStream);
exports.abortController = isFunction(__webpack_require__.g.AbortController); // The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.

var xhr;

function getXHR() {
  // Cache the xhr value
  if (xhr !== undefined) return xhr;

  if (__webpack_require__.g.XMLHttpRequest) {
    xhr = new __webpack_require__.g.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work
    // cross domain), use the page location. Otherwise use example.com
    // Note: this doesn't actually make an http request.

    try {
      xhr.open('GET', __webpack_require__.g.XDomainRequest ? '/' : 'https://example.com');
    } catch (e) {
      xhr = null;
    }
  } else {
    // Service workers don't have XHR
    xhr = null;
  }

  return xhr;
}

function checkTypeSupport(type) {
  var xhr = getXHR();
  if (!xhr) return false;

  try {
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {}

  return false;
} // If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().


exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer'); // These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.

exports.msstream = !exports.fetch && checkTypeSupport('ms-stream');
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer'); // If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().

exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

function isFunction(value) {
  return typeof value === 'function';
}

xhr = null; // Help gc

/***/ }),

/***/ "./node_modules/stream-http/lib/request.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-http/lib/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var response = __webpack_require__(/*! ./response */ "./node_modules/stream-http/lib/response.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;

function decideMode(preferBinary, useFetch) {
  if (capability.fetch && useFetch) {
    return 'fetch';
  } else if (capability.mozchunkedarraybuffer) {
    return 'moz-chunked-arraybuffer';
  } else if (capability.msstream) {
    return 'ms-stream';
  } else if (capability.arraybuffer && preferBinary) {
    return 'arraybuffer';
  } else {
    return 'text';
  }
}

var ClientRequest = module.exports = function (opts) {
  var self = this;
  stream.Writable.call(self);
  self._opts = opts;
  self._body = [];
  self._headers = {};
  if (opts.auth) self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'));
  Object.keys(opts.headers).forEach(function (name) {
    self.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;

  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
    // If the use of XHR should be preferred. Not typically needed.
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === 'prefer-streaming') {
    // If streaming is a high priority but binary compatibility and
    // the accuracy of the 'content-type' header aren't
    preferBinary = false;
  } else if (opts.mode === 'allow-wrong-content-type') {
    // If streaming is more important than preserving the 'content-type' header
    preferBinary = !capability.overrideMimeType;
  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
    // Use binary if text streaming may corrupt data or the content-type header, or for speed
    preferBinary = true;
  } else {
    throw new Error('Invalid value for opts.mode');
  }

  self._mode = decideMode(preferBinary, useFetch);
  self._fetchTimer = null;
  self._socketTimeout = null;
  self._socketTimer = null;
  self.on('finish', function () {
    self._onFinish();
  });
};

inherits(ClientRequest, stream.Writable);

ClientRequest.prototype.setHeader = function (name, value) {
  var self = this;
  var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe
  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
  // http-browserify did it, so I will too.

  if (unsafeHeaders.indexOf(lowerName) !== -1) return;
  self._headers[lowerName] = {
    name: name,
    value: value
  };
};

ClientRequest.prototype.getHeader = function (name) {
  var header = this._headers[name.toLowerCase()];

  if (header) return header.value;
  return null;
};

ClientRequest.prototype.removeHeader = function (name) {
  var self = this;
  delete self._headers[name.toLowerCase()];
};

ClientRequest.prototype._onFinish = function () {
  var self = this;
  if (self._destroyed) return;
  var opts = self._opts;

  if ('timeout' in opts && opts.timeout !== 0) {
    self.setTimeout(opts.timeout);
  }

  var headersObj = self._headers;
  var body = null;

  if (opts.method !== 'GET' && opts.method !== 'HEAD') {
    body = new Blob(self._body, {
      type: (headersObj['content-type'] || {}).value || ''
    });
  } // create flattened list of headers


  var headersList = [];
  Object.keys(headersObj).forEach(function (keyName) {
    var name = headersObj[keyName].name;
    var value = headersObj[keyName].value;

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        headersList.push([name, v]);
      });
    } else {
      headersList.push([name, value]);
    }
  });

  if (self._mode === 'fetch') {
    var signal = null;

    if (capability.abortController) {
      var controller = new AbortController();
      signal = controller.signal;
      self._fetchAbortController = controller;

      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
        self._fetchTimer = __webpack_require__.g.setTimeout(function () {
          self.emit('requestTimeout');
          if (self._fetchAbortController) self._fetchAbortController.abort();
        }, opts.requestTimeout);
      }
    }

    __webpack_require__.g.fetch(self._opts.url, {
      method: self._opts.method,
      headers: headersList,
      body: body || undefined,
      mode: 'cors',
      credentials: opts.withCredentials ? 'include' : 'same-origin',
      signal: signal
    }).then(function (response) {
      self._fetchResponse = response;

      self._resetTimers(false);

      self._connect();
    }, function (reason) {
      self._resetTimers(true);

      if (!self._destroyed) self.emit('error', reason);
    });
  } else {
    var xhr = self._xhr = new __webpack_require__.g.XMLHttpRequest();

    try {
      xhr.open(self._opts.method, self._opts.url, true);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    } // Can't set responseType on really old browsers


    if ('responseType' in xhr) xhr.responseType = self._mode;
    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;
    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

    if ('requestTimeout' in opts) {
      xhr.timeout = opts.requestTimeout;

      xhr.ontimeout = function () {
        self.emit('requestTimeout');
      };
    }

    headersList.forEach(function (header) {
      xhr.setRequestHeader(header[0], header[1]);
    });
    self._response = null;

    xhr.onreadystatechange = function () {
      switch (xhr.readyState) {
        case rStates.LOADING:
        case rStates.DONE:
          self._onXHRProgress();

          break;
      }
    }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined
    // in onprogress, not in onreadystatechange with xhr.readyState = 3


    if (self._mode === 'moz-chunked-arraybuffer') {
      xhr.onprogress = function () {
        self._onXHRProgress();
      };
    }

    xhr.onerror = function () {
      if (self._destroyed) return;

      self._resetTimers(true);

      self.emit('error', new Error('XHR error'));
    };

    try {
      xhr.send(body);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    }
  }
};
/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */


function statusValid(xhr) {
  try {
    var status = xhr.status;
    return status !== null && status !== 0;
  } catch (e) {
    return false;
  }
}

ClientRequest.prototype._onXHRProgress = function () {
  var self = this;

  self._resetTimers(false);

  if (!statusValid(self._xhr) || self._destroyed) return;
  if (!self._response) self._connect();

  self._response._onXHRProgress(self._resetTimers.bind(self));
};

ClientRequest.prototype._connect = function () {
  var self = this;
  if (self._destroyed) return;
  self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self));

  self._response.on('error', function (err) {
    self.emit('error', err);
  });

  self.emit('response', self._response);
};

ClientRequest.prototype._write = function (chunk, encoding, cb) {
  var self = this;

  self._body.push(chunk);

  cb();
};

ClientRequest.prototype._resetTimers = function (done) {
  var self = this;
  __webpack_require__.g.clearTimeout(self._socketTimer);
  self._socketTimer = null;

  if (done) {
    __webpack_require__.g.clearTimeout(self._fetchTimer);
    self._fetchTimer = null;
  } else if (self._socketTimeout) {
    self._socketTimer = __webpack_require__.g.setTimeout(function () {
      self.emit('timeout');
    }, self._socketTimeout);
  }
};

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
  var self = this;
  self._destroyed = true;

  self._resetTimers(true);

  if (self._response) self._response._destroyed = true;
  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
  if (err) self.emit('error', err);
};

ClientRequest.prototype.end = function (data, encoding, cb) {
  var self = this;

  if (typeof data === 'function') {
    cb = data;
    data = undefined;
  }

  stream.Writable.prototype.end.call(self, data, encoding, cb);
};

ClientRequest.prototype.setTimeout = function (timeout, cb) {
  var self = this;
  if (cb) self.once('timeout', cb);
  self._socketTimeout = timeout;

  self._resetTimers(false);
};

ClientRequest.prototype.flushHeaders = function () {};

ClientRequest.prototype.setNoDelay = function () {};

ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method


var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];

/***/ }),

/***/ "./node_modules/stream-http/lib/response.js":
/*!**************************************************!*\
  !*** ./node_modules/stream-http/lib/response.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var rStates = exports.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
};

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
  var self = this;
  stream.Readable.call(self);
  self._mode = mode;
  self.headers = {};
  self.rawHeaders = [];
  self.trailers = {};
  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires

  self.on('end', function () {
    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
    process.nextTick(function () {
      self.emit('close');
    });
  });

  if (mode === 'fetch') {
    var read = function read() {
      reader.read().then(function (result) {
        if (self._destroyed) return;
        resetTimers(result.done);

        if (result.done) {
          self.push(null);
          return;
        }

        self.push(Buffer.from(result.value));
        read();
      })["catch"](function (err) {
        resetTimers(true);
        if (!self._destroyed) self.emit('error', err);
      });
    };

    self._fetchResponse = response;
    self.url = response.url;
    self.statusCode = response.status;
    self.statusMessage = response.statusText;
    response.headers.forEach(function (header, key) {
      self.headers[key.toLowerCase()] = header;
      self.rawHeaders.push(key, header);
    });

    if (capability.writableStream) {
      var writable = new WritableStream({
        write: function write(chunk) {
          resetTimers(false);
          return new Promise(function (resolve, reject) {
            if (self._destroyed) {
              reject();
            } else if (self.push(Buffer.from(chunk))) {
              resolve();
            } else {
              self._resumeFetch = resolve;
            }
          });
        },
        close: function close() {
          resetTimers(true);
          if (!self._destroyed) self.push(null);
        },
        abort: function abort(err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        }
      });

      try {
        response.body.pipeTo(writable)["catch"](function (err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        });
        return;
      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this

    } // fallback for when writableStream or pipeTo aren't available


    var reader = response.body.getReader();
    read();
  } else {
    self._xhr = xhr;
    self._pos = 0;
    self.url = xhr.responseURL;
    self.statusCode = xhr.status;
    self.statusMessage = xhr.statusText;
    var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function (header) {
      var matches = header.match(/^([^:]+):\s*(.*)/);

      if (matches) {
        var key = matches[1].toLowerCase();

        if (key === 'set-cookie') {
          if (self.headers[key] === undefined) {
            self.headers[key] = [];
          }

          self.headers[key].push(matches[2]);
        } else if (self.headers[key] !== undefined) {
          self.headers[key] += ', ' + matches[2];
        } else {
          self.headers[key] = matches[2];
        }

        self.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self._charset = 'x-user-defined';

    if (!capability.overrideMimeType) {
      var mimeType = self.rawHeaders['mime-type'];

      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);

        if (charsetMatch) {
          self._charset = charsetMatch[1].toLowerCase();
        }
      }

      if (!self._charset) self._charset = 'utf-8'; // best guess
    }
  }
};

inherits(IncomingMessage, stream.Readable);

IncomingMessage.prototype._read = function () {
  var self = this;
  var resolve = self._resumeFetch;

  if (resolve) {
    self._resumeFetch = null;
    resolve();
  }
};

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
  var self = this;
  var xhr = self._xhr;
  var response = null;

  switch (self._mode) {
    case 'text':
      response = xhr.responseText;

      if (response.length > self._pos) {
        var newData = response.substr(self._pos);

        if (self._charset === 'x-user-defined') {
          var buffer = Buffer.alloc(newData.length);

          for (var i = 0; i < newData.length; i++) {
            buffer[i] = newData.charCodeAt(i) & 0xff;
          }

          self.push(buffer);
        } else {
          self.push(newData, self._charset);
        }

        self._pos = response.length;
      }

      break;

    case 'arraybuffer':
      if (xhr.readyState !== rStates.DONE || !xhr.response) break;
      response = xhr.response;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'moz-chunked-arraybuffer':
      // take whole
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING || !response) break;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'ms-stream':
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING) break;
      var reader = new __webpack_require__.g.MSStreamReader();

      reader.onprogress = function () {
        if (reader.result.byteLength > self._pos) {
          self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
          self._pos = reader.result.byteLength;
        }
      };

      reader.onload = function () {
        resetTimers(true);
        self.push(null);
      }; // reader.onerror = ??? // TODO: this


      reader.readAsArrayBuffer(response);
      break;
  } // The ms-stream case handles end separately in reader.onload()


  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
    resetTimers(true);
    self.push(null);
  }
};

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  var freeModule = ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
  var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if ( true && _typeof(__webpack_require__.amdO) == 'object' && __webpack_require__.amdO) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (freeExports && freeModule) {
    if (module.exports == freeExports) {
      // in Node.js or RingoJS v0.8.0+
      freeModule.exports = punycode;
    } else {
      // in Narwhal or RingoJS v0.7.0-
      for (key in punycode) {
        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
      }
    }
  } else {
    // in Rhino or a web browser
    root.punycode = punycode;
  }
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + _typeof(url));
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return _typeof(arg) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/utf-8-validate/fallback.js":
/*!*************************************************!*\
  !*** ./node_modules/utf-8-validate/fallback.js ***!
  \*************************************************/
/***/ ((module) => {


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */

function isValidUTF8(buf) {
  var len = buf.length;
  var i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // overlong
      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // overlong
      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;

/***/ }),

/***/ "./node_modules/utf-8-validate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/utf-8-validate/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __dirname = "/";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "./node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "./node_modules/utf-8-validate/fallback.js");
}

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/***/ }),

/***/ "./node_modules/vary/index.js":
/*!************************************!*\
  !*** ./node_modules/vary/index.js ***!
  \************************************/
/***/ ((module) => {

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = vary;
module.exports.append = append;
/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append(header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required');
  }

  if (!field) {
    throw new TypeError('field argument is required');
  } // get fields array


  var fields = !Array.isArray(field) ? parse(String(field)) : field; // assert on invalid field names

  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name');
    }
  } // existing, unspecified vary


  if (header === '*') {
    return header;
  } // enumerate current values


  var val = header;
  var vals = parse(header.toLowerCase()); // unspecified vary

  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*';
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase(); // append value (case-preserving)

    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ', ' + fields[i] : fields[i];
    }
  }

  return val;
}
/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */


function parse(header) {
  var end = 0;
  var list = [];
  var start = 0; // gather tokens

  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }

        break;

      case 0x2c:
        /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;

      default:
        end = i + 1;
        break;
    }
  } // final token


  list.push(header.substring(start, end));
  return list;
}
/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */


function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required');
  } // get existing header


  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val) ? val.join(', ') : String(val); // set new header

  if (val = append(header, field)) {
    res.setHeader('Vary', val);
  }
}

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");
WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;
module.exports = WebSocket;

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    EMPTY_BUFFER = _require.EMPTY_BUFFER;
/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */


function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];
  var target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);
  return target;
}
/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */


function _mask(source, mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}
/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */


function _unmask(buffer, mask) {
  for (var i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}
/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */


function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}
/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */


function toBuffer(data) {
  toBuffer.readOnly = true;
  if (Buffer.isBuffer(data)) return data;
  var buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  var bufferUtil = __webpack_require__(/*! bufferutil */ "./node_modules/bufferutil/index.js");

  module.exports = {
    concat: concat,
    mask: function mask(source, _mask2, output, offset, length) {
      if (length < 48) _mask(source, _mask2, output, offset, length);else bufferUtil.mask(source, _mask2, output, offset, length);
    },
    toArrayBuffer: toArrayBuffer,
    toBuffer: toBuffer,
    unmask: function unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);
    }
  };
} catch (e)
/* istanbul ignore next */
{
  module.exports = {
    concat: concat,
    mask: _mask,
    toArrayBuffer: toArrayBuffer,
    toBuffer: toBuffer,
    unmask: _unmask
  };
}

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {



module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: function NOOP() {}
};

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    kForOnEventAttribute = _require.kForOnEventAttribute,
    kListener = _require.kListener;

var kCode = Symbol('kCode');
var kData = Symbol('kData');
var kError = Symbol('kError');
var kMessage = Symbol('kMessage');
var kReason = Symbol('kReason');
var kTarget = Symbol('kTarget');
var kType = Symbol('kType');
var kWasClean = Symbol('kWasClean');
/**
 * Class representing an event.
 */

var Event = /*#__PURE__*/function () {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  function Event(type) {
    _classCallCheck(this, Event);

    this[kTarget] = null;
    this[kType] = type;
  }
  /**
   * @type {*}
   */


  _createClass(Event, [{
    key: "target",
    get: function get() {
      return this[kTarget];
    }
    /**
     * @type {String}
     */

  }, {
    key: "type",
    get: function get() {
      return this[kType];
    }
  }]);

  return Event;
}();

Object.defineProperty(Event.prototype, 'target', {
  enumerable: true
});
Object.defineProperty(Event.prototype, 'type', {
  enumerable: true
});
/**
 * Class representing a close event.
 *
 * @extends Event
 */

var CloseEvent = /*#__PURE__*/function (_Event) {
  _inherits(CloseEvent, _Event);

  var _super = _createSuper(CloseEvent);

  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  function CloseEvent(type) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CloseEvent);

    _this = _super.call(this, type);
    _this[kCode] = options.code === undefined ? 0 : options.code;
    _this[kReason] = options.reason === undefined ? '' : options.reason;
    _this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    return _this;
  }
  /**
   * @type {Number}
   */


  _createClass(CloseEvent, [{
    key: "code",
    get: function get() {
      return this[kCode];
    }
    /**
     * @type {String}
     */

  }, {
    key: "reason",
    get: function get() {
      return this[kReason];
    }
    /**
     * @type {Boolean}
     */

  }, {
    key: "wasClean",
    get: function get() {
      return this[kWasClean];
    }
  }]);

  return CloseEvent;
}(Event);

Object.defineProperty(CloseEvent.prototype, 'code', {
  enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'reason', {
  enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'wasClean', {
  enumerable: true
});
/**
 * Class representing an error event.
 *
 * @extends Event
 */

var ErrorEvent = /*#__PURE__*/function (_Event2) {
  _inherits(ErrorEvent, _Event2);

  var _super2 = _createSuper(ErrorEvent);

  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  function ErrorEvent(type) {
    var _this2;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ErrorEvent);

    _this2 = _super2.call(this, type);
    _this2[kError] = options.error === undefined ? null : options.error;
    _this2[kMessage] = options.message === undefined ? '' : options.message;
    return _this2;
  }
  /**
   * @type {*}
   */


  _createClass(ErrorEvent, [{
    key: "error",
    get: function get() {
      return this[kError];
    }
    /**
     * @type {String}
     */

  }, {
    key: "message",
    get: function get() {
      return this[kMessage];
    }
  }]);

  return ErrorEvent;
}(Event);

Object.defineProperty(ErrorEvent.prototype, 'error', {
  enumerable: true
});
Object.defineProperty(ErrorEvent.prototype, 'message', {
  enumerable: true
});
/**
 * Class representing a message event.
 *
 * @extends Event
 */

var MessageEvent = /*#__PURE__*/function (_Event3) {
  _inherits(MessageEvent, _Event3);

  var _super3 = _createSuper(MessageEvent);

  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  function MessageEvent(type) {
    var _this3;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MessageEvent);

    _this3 = _super3.call(this, type);
    _this3[kData] = options.data === undefined ? null : options.data;
    return _this3;
  }
  /**
   * @type {*}
   */


  _createClass(MessageEvent, [{
    key: "data",
    get: function get() {
      return this[kData];
    }
  }]);

  return MessageEvent;
}(Event);

Object.defineProperty(MessageEvent.prototype, 'data', {
  enumerable: true
});
/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */

var EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener: function addEventListener(type, listener) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        var event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        var event = new CloseEvent('close', {
          code: code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        var event = new ErrorEvent('error', {
          error: error,
          message: error.message
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        var event = new Event('open');
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = listener;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} handler The listener to remove
   * @public
   */
  removeEventListener: function removeEventListener(type, handler) {
    var _iterator = _createForOfIteratorHelper(this.listeners(type)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var listener = _step.value;

        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
};
module.exports = {
  CloseEvent: CloseEvent,
  ErrorEvent: ErrorEvent,
  Event: Event,
  EventTarget: EventTarget,
  MessageEvent: MessageEvent
};

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    tokenChars = _require.tokenChars;
/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */


function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);
}
/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */


function parse(header) {
  var offers = Object.create(null);
  var params = Object.create(null);
  var mustUnescape = false;
  var isEscaping = false;
  var inQuotes = false;
  var extensionName;
  var paramName;
  var start = -1;
  var code = -1;
  var end = -1;
  var i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (i !== 0 && (code === 0x20
      /* ' ' */
      || code === 0x09)
      /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b
      /* ';' */
      || code === 0x2c
      /* ',' */
      ) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        var name = header.slice(start, end);

        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);

        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d
      /* '=' */
      && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22
        /* '"' */
        && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c
        /* '\' */
        ) {
          isEscaping = true;
        } else {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        var value = header.slice(start, end);

        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }

        push(params, paramName, value);

        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  var token = header.slice(start, end);

  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }

    push(offers, extensionName, params);
  }

  return offers;
}
/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */


function format(extensions) {
  return Object.keys(extensions).map(function (extension) {
    var configurations = extensions[extension];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map(function (params) {
      return [extension].concat(Object.keys(params).map(function (k) {
        var values = params[k];
        if (!Array.isArray(values)) values = [values];
        return values.map(function (v) {
          return v === true ? k : "".concat(k, "=").concat(v);
        }).join('; ');
      })).join('; ');
    }).join(', ');
  }).join(', ');
}

module.exports = {
  format: format,
  parse: parse
};

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var kDone = Symbol('kDone');
var kRun = Symbol('kRun');
/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */

var Limiter = /*#__PURE__*/function () {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  function Limiter(concurrency) {
    var _this = this;

    _classCallCheck(this, Limiter);

    this[kDone] = function () {
      _this.pending--;

      _this[kRun]();
    };

    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */


  _createClass(Limiter, [{
    key: "add",
    value: function add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    /**
     * Removes a job from the queue and runs it if possible.
     *
     * @private
     */

  }, {
    key: kRun,
    value: function value() {
      if (this.pending === this.concurrency) return;

      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }]);

  return Limiter;
}();

module.exports = Limiter;

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var zlib = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

var Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");

var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    kStatusCode = _require.kStatusCode;

var TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
var kPerMessageDeflate = Symbol('permessage-deflate');
var kTotalLength = Symbol('total-length');
var kCallback = Symbol('callback');
var kBuffers = Symbol('buffers');
var kError = Symbol('error'); //
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//

var zlibLimiter;
/**
 * permessage-deflate implementation.
 */

var PerMessageDeflate = /*#__PURE__*/function () {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  function PerMessageDeflate(options, isServer, maxPayload) {
    _classCallCheck(this, PerMessageDeflate);

    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;

    if (!zlibLimiter) {
      var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }
  /**
   * @type {String}
   */


  _createClass(PerMessageDeflate, [{
    key: "offer",
    value:
    /**
     * Create an extension negotiation offer.
     *
     * @return {Object} Extension parameters
     * @public
     */
    function offer() {
      var params = {};

      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }

      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }

      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }

      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }

      return params;
    }
    /**
     * Accept an extension negotiation offer/response.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Object} Accepted configuration
     * @public
     */

  }, {
    key: "accept",
    value: function accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    /**
     * Releases all resources used by the extension.
     *
     * @public
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this._inflate) {
        this._inflate.close();

        this._inflate = null;
      }

      if (this._deflate) {
        var callback = this._deflate[kCallback];

        this._deflate.close();

        this._deflate = null;

        if (callback) {
          callback(new Error('The deflate stream was closed while data was being processed'));
        }
      }
    }
    /**
     *  Accept an extension negotiation offer.
     *
     * @param {Array} offers The extension negotiation offers
     * @return {Object} Accepted configuration
     * @private
     */

  }, {
    key: "acceptAsServer",
    value: function acceptAsServer(offers) {
      var opts = this._options;
      var accepted = offers.find(function (params) {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
          return false;
        }

        return true;
      });

      if (!accepted) {
        throw new Error('None of the extension offers can be accepted');
      }

      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }

      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }

      if (typeof opts.serverMaxWindowBits === 'number') {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }

      if (typeof opts.clientMaxWindowBits === 'number') {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }

      return accepted;
    }
    /**
     * Accept the extension negotiation response.
     *
     * @param {Array} response The extension negotiation response
     * @return {Object} Accepted configuration
     * @private
     */

  }, {
    key: "acceptAsClient",
    value: function acceptAsClient(response) {
      var params = response[0];

      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }

      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === 'number') {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }

      return params;
    }
    /**
     * Normalize parameters.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Array} The offers/response with normalized parameters
     * @private
     */

  }, {
    key: "normalizeParams",
    value: function normalizeParams(configurations) {
      var _this = this;

      configurations.forEach(function (params) {
        Object.keys(params).forEach(function (key) {
          var value = params[key];

          if (value.length > 1) {
            throw new Error("Parameter \"".concat(key, "\" must have only a single value"));
          }

          value = value[0];

          if (key === 'client_max_window_bits') {
            if (value !== true) {
              var num = +value;

              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
              }

              value = num;
            } else if (!_this._isServer) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }
          } else if (key === 'server_max_window_bits') {
            var _num = +value;

            if (!Number.isInteger(_num) || _num < 8 || _num > 15) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }

            value = _num;
          } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
            if (value !== true) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }
          } else {
            throw new Error("Unknown parameter \"".concat(key, "\""));
          }

          params[key] = value;
        });
      });
      return configurations;
    }
    /**
     * Decompress data. Concurrency limited.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */

  }, {
    key: "decompress",
    value: function decompress(data, fin, callback) {
      var _this2 = this;

      zlibLimiter.add(function (done) {
        _this2._decompress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Compress data. Concurrency limited.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */

  }, {
    key: "compress",
    value: function compress(data, fin, callback) {
      var _this3 = this;

      zlibLimiter.add(function (done) {
        _this3._compress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Decompress data.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */

  }, {
    key: "_decompress",
    value: function _decompress(data, fin, callback) {
      var _this4 = this;

      var endpoint = this._isServer ? 'client' : 'server';

      if (!this._inflate) {
        var key = "".concat(endpoint, "_max_window_bits");
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw(_objectSpread(_objectSpread({}, this._options.zlibInflateOptions), {}, {
          windowBits: windowBits
        }));
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        this._inflate.on('error', inflateOnError);

        this._inflate.on('data', inflateOnData);
      }

      this._inflate[kCallback] = callback;

      this._inflate.write(data);

      if (fin) this._inflate.write(TRAILER);

      this._inflate.flush(function () {
        var err = _this4._inflate[kError];

        if (err) {
          _this4._inflate.close();

          _this4._inflate = null;
          callback(err);
          return;
        }

        var data = bufferUtil.concat(_this4._inflate[kBuffers], _this4._inflate[kTotalLength]);

        if (_this4._inflate._readableState.endEmitted) {
          _this4._inflate.close();

          _this4._inflate = null;
        } else {
          _this4._inflate[kTotalLength] = 0;
          _this4._inflate[kBuffers] = [];

          if (fin && _this4.params["".concat(endpoint, "_no_context_takeover")]) {
            _this4._inflate.reset();
          }
        }

        callback(null, data);
      });
    }
    /**
     * Compress data.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */

  }, {
    key: "_compress",
    value: function _compress(data, fin, callback) {
      var _this5 = this;

      var endpoint = this._isServer ? 'server' : 'client';

      if (!this._deflate) {
        var key = "".concat(endpoint, "_max_window_bits");
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw(_objectSpread(_objectSpread({}, this._options.zlibDeflateOptions), {}, {
          windowBits: windowBits
        }));
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];

        this._deflate.on('data', deflateOnData);
      }

      this._deflate[kCallback] = callback;

      this._deflate.write(data);

      this._deflate.flush(zlib.Z_SYNC_FLUSH, function () {
        if (!_this5._deflate) {
          //
          // The deflate stream was closed while data was being processed.
          //
          return;
        }

        var data = bufferUtil.concat(_this5._deflate[kBuffers], _this5._deflate[kTotalLength]);
        if (fin) data = data.slice(0, data.length - 4); //
        // Ensure that the callback will not be called again in
        // `PerMessageDeflate#cleanup()`.
        //

        _this5._deflate[kCallback] = null;
        _this5._deflate[kTotalLength] = 0;
        _this5._deflate[kBuffers] = [];

        if (fin && _this5.params["".concat(endpoint, "_no_context_takeover")]) {
          _this5._deflate.reset();
        }

        callback(null, data);
      });
    }
  }], [{
    key: "extensionName",
    get: function get() {
      return 'permessage-deflate';
    }
  }]);

  return PerMessageDeflate;
}();

module.exports = PerMessageDeflate;
/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */

function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */


function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}
/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */


function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Writable = _require.Writable;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    BINARY_TYPES = _require2.BINARY_TYPES,
    EMPTY_BUFFER = _require2.EMPTY_BUFFER,
    kStatusCode = _require2.kStatusCode,
    kWebSocket = _require2.kWebSocket;

var _require3 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    concat = _require3.concat,
    toArrayBuffer = _require3.toArrayBuffer,
    unmask = _require3.unmask;

var _require4 = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    isValidStatusCode = _require4.isValidStatusCode,
    isValidUTF8 = _require4.isValidUTF8;

var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */

var Receiver = /*#__PURE__*/function (_Writable) {
  _inherits(Receiver, _Writable);

  var _super = _createSuper(Receiver);

  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  function Receiver() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Receiver);

    _this = _super.call(this);
    _this._binaryType = options.binaryType || BINARY_TYPES[0];
    _this._extensions = options.extensions || {};
    _this._isServer = !!options.isServer;
    _this._maxPayload = options.maxPayload | 0;
    _this._skipUTF8Validation = !!options.skipUTF8Validation;
    _this[kWebSocket] = undefined;
    _this._bufferedBytes = 0;
    _this._buffers = [];
    _this._compressed = false;
    _this._payloadLength = 0;
    _this._mask = undefined;
    _this._fragmented = 0;
    _this._masked = false;
    _this._fin = false;
    _this._opcode = 0;
    _this._totalPayloadLength = 0;
    _this._messageLength = 0;
    _this._fragments = [];
    _this._state = GET_INFO;
    _this._loop = false;
    return _this;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */


  _createClass(Receiver, [{
    key: "_write",
    value: function _write(chunk, encoding, cb) {
      if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
      this._bufferedBytes += chunk.length;

      this._buffers.push(chunk);

      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */

  }, {
    key: "consume",
    value: function consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length) return this._buffers.shift();

      if (n < this._buffers[0].length) {
        var buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }

      var dst = Buffer.allocUnsafe(n);

      do {
        var _buf = this._buffers[0];
        var offset = dst.length - n;

        if (n >= _buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
          this._buffers[0] = _buf.slice(n);
        }

        n -= _buf.length;
      } while (n > 0);

      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "startLoop",
    value: function startLoop(cb) {
      var err;
      this._loop = true;

      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;

          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;

          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;

          case GET_MASK:
            this.getMask();
            break;

          case GET_DATA:
            err = this.getData(cb);
            break;

          default:
            // `INFLATING`
            this._loop = false;
            return;
        }
      } while (this._loop);

      cb(err);
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getInfo",
    value: function getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      var buf = this.consume(2);

      if ((buf[0] & 0x30) !== 0x00) {
        this._loop = false;
        return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
      }

      var compressed = (buf[0] & 0x40) === 0x40;

      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
      }

      this._fin = (buf[0] & 0x80) === 0x80;
      this._opcode = buf[0] & 0x0f;
      this._payloadLength = buf[1] & 0x7f;

      if (this._opcode === 0x00) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._opcode = this._fragmented;
      } else if (this._opcode === 0x01 || this._opcode === 0x02) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._compressed = compressed;
      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
        }

        if (compressed) {
          this._loop = false;
          return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (this._payloadLength > 0x7d) {
          this._loop = false;
          return error(RangeError, "invalid payload length ".concat(this._payloadLength), true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        }
      } else {
        this._loop = false;
        return error(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
      }

      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 0x80) === 0x80;

      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
      }

      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getPayloadLength16",
    value: function getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getPayloadLength64",
    value: function getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }

      var buf = this.consume(8);
      var num = buf.readUInt32BE(0); //
      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
      // if payload length is greater than this number.
      //

      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
      }

      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    /**
     * Payload length has been read.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "haveLength",
    value: function haveLength() {
      if (this._payloadLength && this._opcode < 0x08) {
        this._totalPayloadLength += this._payloadLength;

        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
        }
      }

      if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */

  }, {
    key: "getMask",
    value: function getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }

      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getData",
    value: function getData(cb) {
      var data = EMPTY_BUFFER;

      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }

        data = this.consume(this._payloadLength);
        if (this._masked) unmask(data, this._mask);
      }

      if (this._opcode > 0x07) return this.controlMessage(data);

      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }

      if (data.length) {
        //
        // This message is not compressed so its length is the sum of the payload
        // length of all fragments.
        //
        this._messageLength = this._totalPayloadLength;

        this._fragments.push(data);
      }

      return this.dataMessage();
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "decompress",
    value: function decompress(data, cb) {
      var _this2 = this;

      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, function (err, buf) {
        if (err) return cb(err);

        if (buf.length) {
          _this2._messageLength += buf.length;

          if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
            return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));
          }

          _this2._fragments.push(buf);
        }

        var er = _this2.dataMessage();

        if (er) return cb(er);

        _this2.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @return {(Error|undefined)} A possible error
     * @private
     */

  }, {
    key: "dataMessage",
    value: function dataMessage() {
      if (this._fin) {
        var messageLength = this._messageLength;
        var fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];

        if (this._opcode === 2) {
          var data;

          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }

          this.emit('message', data, true);
        } else {
          var buf = concat(fragments, messageLength);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('message', buf, false);
        }
      }

      this._state = GET_INFO;
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "controlMessage",
    value: function controlMessage(data) {
      if (this._opcode === 0x08) {
        this._loop = false;

        if (data.length === 0) {
          this.emit('conclude', 1005, EMPTY_BUFFER);
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        } else {
          var code = data.readUInt16BE(0);

          if (!isValidStatusCode(code)) {
            return error(RangeError, "invalid status code ".concat(code), true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
          }

          var buf = data.slice(2);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('conclude', code, buf);
          this.end();
        }
      } else if (this._opcode === 0x09) {
        this.emit('ping', data);
      } else {
        this.emit('pong', data);
      }

      this._state = GET_INFO;
    }
  }]);

  return Receiver;
}(Writable);

module.exports = Receiver;
/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */

function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: ".concat(message) : message);
  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    randomFillSync = _require.randomFillSync;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    EMPTY_BUFFER = _require2.EMPTY_BUFFER;

var _require3 = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    isValidStatusCode = _require3.isValidStatusCode;

var _require4 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    applyMask = _require4.mask,
    toBuffer = _require4.toBuffer;

var mask = Buffer.alloc(4);
/**
 * HyBi Sender implementation.
 */

var Sender = /*#__PURE__*/function () {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  function Sender(socket, extensions) {
    _classCallCheck(this, Sender);

    this._extensions = extensions || {};
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */


  _createClass(Sender, [{
    key: "close",
    value:
    /**
     * Sends a close message to the other peer.
     *
     * @param {Number} [code] The status code component of the body
     * @param {(String|Buffer)} [data] The message component of the body
     * @param {Boolean} [mask=false] Specifies whether or not to mask the message
     * @param {Function} [cb] Callback
     * @public
     */
    function close(code, data, mask, cb) {
      var buf;

      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
        throw new TypeError('First argument must be a valid error code number');
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        var length = Buffer.byteLength(data);

        if (length > 123) {
          throw new RangeError('The message must not be greater than 123 bytes');
        }

        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);

        if (typeof data === 'string') {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }

      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask, cb]);
      } else {
        this.doClose(buf, mask, cb);
      }
    }
    /**
     * Frames and sends a close message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doClose",
    value: function doClose(data, mask, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask: mask,
        readOnly: false
      }), cb);
    }
    /**
     * Sends a ping message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "ping",
    value: function ping(data, mask, cb) {
      var buf = toBuffer(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPing(buf, mask, toBuffer.readOnly, cb);
      }
    }
    /**
     * Frames and sends a ping message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doPing",
    value: function doPing(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a pong message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "pong",
    value: function pong(data, mask, cb) {
      var buf = toBuffer(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPong(buf, mask, toBuffer.readOnly, cb);
      }
    }
    /**
     * Frames and sends a pong message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doPong",
    value: function doPong(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a data message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
     *     or text
     * @param {Boolean} [options.compress=false] Specifies whether or not to
     *     compress `data`
     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "send",
    value: function send(data, options, cb) {
      var buf = toBuffer(data);
      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      var opcode = options.binary ? 2 : 1;
      var rsv1 = options.compress;

      if (this._firstFragment) {
        this._firstFragment = false;

        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }

        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }

      if (options.fin) this._firstFragment = true;

      if (perMessageDeflate) {
        var opts = {
          fin: options.fin,
          rsv1: rsv1,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }), cb);
      }
    }
    /**
     * Dispatches a data message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     `data`
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "dispatch",
    value: function dispatch(data, compress, options, cb) {
      var _this = this;

      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }

      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += data.length;
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, function (_, buf) {
        if (_this._socket.destroyed) {
          var err = new Error('The socket was closed while data was being compressed');
          if (typeof cb === 'function') cb(err);

          for (var i = 0; i < _this._queue.length; i++) {
            var callback = _this._queue[i][4];
            if (typeof callback === 'function') callback(err);
          }

          return;
        }

        _this._bufferedBytes -= data.length;
        _this._deflating = false;
        options.readOnly = false;

        _this.sendFrame(Sender.frame(buf, options), cb);

        _this.dequeue();
      });
    }
    /**
     * Executes queued send operations.
     *
     * @private
     */

  }, {
    key: "dequeue",
    value: function dequeue() {
      while (!this._deflating && this._queue.length) {
        var params = this._queue.shift();

        this._bufferedBytes -= params[1].length;
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    /**
     * Enqueues a send operation.
     *
     * @param {Array} params Send operation parameters.
     * @private
     */

  }, {
    key: "enqueue",
    value: function enqueue(params) {
      this._bufferedBytes += params[1].length;

      this._queue.push(params);
    }
    /**
     * Sends a frame.
     *
     * @param {Buffer[]} list The frame to send
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "sendFrame",
    value: function sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();

        this._socket.write(list[0]);

        this._socket.write(list[1], cb);

        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }], [{
    key: "frame",
    value: function frame(data, options) {
      var merge = options.mask && options.readOnly;
      var offset = options.mask ? 6 : 2;
      var payloadLength = data.length;

      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }

      var target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
      if (options.rsv1) target[0] |= 0x40;
      target[1] = payloadLength;

      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }

      if (!options.mask) return [target, data];
      randomFillSync(mask, 0, 4);
      target[1] |= 0x80;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];

      if (merge) {
        applyMask(data, mask, target, offset, data.length);
        return [target];
      }

      applyMask(data, mask, data, 0, data.length);
      return [target, data];
    }
  }]);

  return Sender;
}();

module.exports = Sender;

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Duplex = _require.Duplex;
/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */


function emitClose(stream) {
  stream.emit('close');
}
/**
 * The listener of the `'end'` event.
 *
 * @private
 */


function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}
/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */


function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();

  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}
/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */


function createWebSocketStream(ws, options) {
  var resumeOnReceiverDrain = true;
  var terminateOnDestroy = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');

      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');

    ws._receiver.on('drain', receiverOnDrain);
  }

  var duplex = new Duplex(_objectSpread(_objectSpread({}, options), {}, {
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  }));
  ws.on('message', function message(msg, isBinary) {
    var data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) {
      resumeOnReceiverDrain = false;

      ws._socket.pause();
    }
  });
  ws.once('error', function error(err) {
    if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.

    terminateOnDestroy = false;
    duplex.destroy(err);
  });
  ws.once('close', function close() {
    if (duplex.destroyed) return;
    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    var called = false;
    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });
    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    } // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.


    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });

      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    tokenChars = _require.tokenChars;
/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */


function parse(header) {
  var protocols = new Set();
  var start = -1;
  var end = -1;
  var i = 0;

  for (i; i < header.length; i++) {
    var code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (i !== 0 && (code === 0x20
    /* ' ' */
    || code === 0x09)
    /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c
    /* ',' */
    ) {
      if (start === -1) {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }

      if (end === -1) end = i;

      var _protocol = header.slice(start, end);

      if (protocols.has(_protocol)) {
        throw new SyntaxError("The \"".concat(_protocol, "\" subprotocol is duplicated"));
      }

      protocols.add(_protocol);
      start = end = -1;
    } else {
      throw new SyntaxError("Unexpected character at index ".concat(i));
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  var protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError("The \"".concat(protocol, "\" subprotocol is duplicated"));
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = {
  parse: parse
};

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

 //
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore

var tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];
/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */

function isValidStatusCode(code) {
  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
}
/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */


function _isValidUTF8(buf) {
  var len = buf.length;
  var i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong
      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong
      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  var _isValidUTF = __webpack_require__(/*! utf-8-validate */ "./node_modules/utf-8-validate/index.js");

  module.exports = {
    isValidStatusCode: isValidStatusCode,
    isValidUTF8: function isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : _isValidUTF(buf);
    },
    tokenChars: tokenChars
  };
} catch (e)
/* istanbul ignore next */
{
  module.exports = {
    isValidStatusCode: isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars: tokenChars
  };
}

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    createHash = _require.createHash;

var extension = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var subprotocol = __webpack_require__(/*! ./subprotocol */ "./node_modules/ws/lib/subprotocol.js");

var WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    GUID = _require2.GUID,
    kWebSocket = _require2.kWebSocket;

var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
var RUNNING = 0;
var CLOSING = 1;
var CLOSED = 2;
/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */

var WebSocketServer = /*#__PURE__*/function (_EventEmitter) {
  _inherits(WebSocketServer, _EventEmitter);

  var _super = _createSuper(WebSocketServer);

  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  function WebSocketServer(options, callback) {
    var _this;

    _classCallCheck(this, WebSocketServer);

    _this = _super.call(this);
    options = _objectSpread({
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null
    }, options);

    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
      throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
    }

    if (options.port != null) {
      _this._server = http.createServer(function (req, res) {
        var body = http.STATUS_CODES[426];
        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });

      _this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      _this._server = options.server;
    }

    if (_this._server) {
      var emitConnection = _this.emit.bind(_assertThisInitialized(_this), 'connection');

      _this._removeListeners = addListeners(_this._server, {
        listening: _this.emit.bind(_assertThisInitialized(_this), 'listening'),
        error: _this.emit.bind(_assertThisInitialized(_this), 'error'),
        upgrade: function upgrade(req, socket, head) {
          _this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};

    if (options.clientTracking) {
      _this.clients = new Set();
      _this._shouldEmitClose = false;
    }

    _this.options = options;
    _this._state = RUNNING;
    return _this;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */


  _createClass(WebSocketServer, [{
    key: "address",
    value: function address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }

      if (!this._server) return null;
      return this._server.address();
    }
    /**
     * Stop the server from accepting new connections and emit the `'close'` event
     * when all existing connections are closed.
     *
     * @param {Function} [cb] A one-time listener for the `'close'` event
     * @public
     */

  }, {
    key: "close",
    value: function close(cb) {
      var _this2 = this;

      if (this._state === CLOSED) {
        if (cb) {
          this.once('close', function () {
            cb(new Error('The server is not running'));
          });
        }

        process.nextTick(emitClose, this);
        return;
      }

      if (cb) this.once('close', cb);
      if (this._state === CLOSING) return;
      this._state = CLOSING;

      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();

          this._removeListeners = this._server = null;
        }

        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        var server = this._server;

        this._removeListeners();

        this._removeListeners = this._server = null; //
        // The HTTP/S server was created internally. Close it, and rely on its
        // `'close'` event.
        //

        server.close(function () {
          emitClose(_this2);
        });
      }
    }
    /**
     * See if a given request should be handled by this server instance.
     *
     * @param {http.IncomingMessage} req Request object to inspect
     * @return {Boolean} `true` if the request is valid, else `false`
     * @public
     */

  }, {
    key: "shouldHandle",
    value: function shouldHandle(req) {
      if (this.options.path) {
        var index = req.url.indexOf('?');
        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path) return false;
      }

      return true;
    }
    /**
     * Handle a HTTP Upgrade request.
     *
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @public
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, head, cb) {
      var _this3 = this;

      socket.on('error', socketOnError);
      var key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'] : false;
      var version = +req.headers['sec-websocket-version'];

      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake(socket, 400);
      }

      var secWebSocketProtocol = req.headers['sec-websocket-protocol'];
      var protocols = new Set();

      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      }

      var secWebSocketExtensions = req.headers['sec-websocket-extensions'];
      var extensions = {};

      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);

        try {
          var offers = extension.parse(secWebSocketExtensions);

          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      } //
      // Optionally call external client verification handler.
      //


      if (this.options.verifyClient) {
        var info = {
          origin: req.headers["".concat(version === 8 ? 'sec-websocket-origin' : 'origin')],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req: req
        };

        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, function (verified, code, message, headers) {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }

            _this3.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }

        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
      }

      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    /**
     * Upgrade the connection to WebSocket.
     *
     * @param {Object} extensions The accepted extensions
     * @param {String} key The value of the `Sec-WebSocket-Key` header
     * @param {Set} protocols The subprotocols
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @throws {Error} If called more than once with the same socket
     * @private
     */

  }, {
    key: "completeUpgrade",
    value: function completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      var _this4 = this;

      //
      // Destroy the socket if the client has already sent a FIN packet.
      //
      if (!socket.readable || !socket.writable) return socket.destroy();

      if (socket[kWebSocket]) {
        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
      }

      if (this._state > RUNNING) return abortHandshake(socket, 503);
      var digest = createHash('sha1').update(key + GUID).digest('base64');
      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', "Sec-WebSocket-Accept: ".concat(digest)];
      var ws = new WebSocket(null);

      if (protocols.size) {
        //
        // Optionally call external protocol selection handler.
        //
        var protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;

        if (protocol) {
          headers.push("Sec-WebSocket-Protocol: ".concat(protocol));
          ws._protocol = protocol;
        }
      }

      if (extensions[PerMessageDeflate.extensionName]) {
        var params = extensions[PerMessageDeflate.extensionName].params;
        var value = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));
        headers.push("Sec-WebSocket-Extensions: ".concat(value));
        ws._extensions = extensions;
      } //
      // Allow external modification/inspection of handshake headers.
      //


      this.emit('headers', headers, req);
      socket.write(headers.concat('\r\n').join('\r\n'));
      socket.removeListener('error', socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });

      if (this.clients) {
        this.clients.add(ws);
        ws.on('close', function () {
          _this4.clients["delete"](ws);

          if (_this4._shouldEmitClose && !_this4.clients.size) {
            process.nextTick(emitClose, _this4);
          }
        });
      }

      cb(ws, req);
    }
  }]);

  return WebSocketServer;
}(EventEmitter);

module.exports = WebSocketServer;
/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */

function addListeners(server, map) {
  for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {
    var event = _Object$keys[_i];
    server.on(event, map[event]);
  }

  return function removeListeners() {
    for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {
      var _event = _Object$keys2[_i2];
      server.removeListener(_event, map[_event]);
    }
  };
}
/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */


function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}
/**
 * Handle premature socket errors.
 *
 * @private
 */


function socketOnError() {
  this.destroy();
}
/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */


function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = _objectSpread({
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message)
    }, headers);
    socket.write("HTTP/1.1 ".concat(code, " ").concat(http.STATUS_CODES[code], "\r\n") + Object.keys(headers).map(function (h) {
      return "".concat(h, ": ").concat(headers[h]);
    }).join('\r\n') + '\r\n\r\n' + message);
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    randomBytes = _require.randomBytes,
    createHash = _require.createHash;

var _require2 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Readable = _require2.Readable;

var _require3 = __webpack_require__(/*! url */ "./node_modules/url/url.js"),
    URL = _require3.URL;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");

var Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");

var _require4 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    BINARY_TYPES = _require4.BINARY_TYPES,
    EMPTY_BUFFER = _require4.EMPTY_BUFFER,
    GUID = _require4.GUID,
    kForOnEventAttribute = _require4.kForOnEventAttribute,
    kListener = _require4.kListener,
    kStatusCode = _require4.kStatusCode,
    kWebSocket = _require4.kWebSocket,
    NOOP = _require4.NOOP;

var _require5 = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js"),
    _require5$EventTarget = _require5.EventTarget,
    addEventListener = _require5$EventTarget.addEventListener,
    removeEventListener = _require5$EventTarget.removeEventListener;

var _require6 = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js"),
    format = _require6.format,
    parse = _require6.parse;

var _require7 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    toBuffer = _require7.toBuffer;

var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
var protocolVersions = [8, 13];
var closeTimeout = 30 * 1000;
/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */

var WebSocket = /*#__PURE__*/function (_EventEmitter) {
  _inherits(WebSocket, _EventEmitter);

  var _super = _createSuper(WebSocket);

  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  function WebSocket(address, protocols, options) {
    var _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this);
    _this._binaryType = BINARY_TYPES[0];
    _this._closeCode = 1006;
    _this._closeFrameReceived = false;
    _this._closeFrameSent = false;
    _this._closeMessage = EMPTY_BUFFER;
    _this._closeTimer = null;
    _this._extensions = {};
    _this._protocol = '';
    _this._readyState = WebSocket.CONNECTING;
    _this._receiver = null;
    _this._sender = null;
    _this._socket = null;

    if (address !== null) {
      _this._bufferedAmount = 0;
      _this._isServer = false;
      _this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (_typeof(protocols) === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(_assertThisInitialized(_this), address, protocols, options);
    } else {
      _this._isServer = true;
    }

    return _this;
  }
  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */


  _createClass(WebSocket, [{
    key: "binaryType",
    get: function get() {
      return this._binaryType;
    },
    set: function set(type) {
      if (!BINARY_TYPES.includes(type)) return;
      this._binaryType = type; //
      // Allow to change `binaryType` on the fly.
      //

      if (this._receiver) this._receiver._binaryType = type;
    }
    /**
     * @type {Number}
     */

  }, {
    key: "bufferedAmount",
    get: function get() {
      if (!this._socket) return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    /**
     * @type {String}
     */

  }, {
    key: "extensions",
    get: function get() {
      return Object.keys(this._extensions).join();
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onclose",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onerror",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onopen",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onmessage",
    get: function get() {
      return null;
    }
    /**
     * @type {String}
     */

  }, {
    key: "protocol",
    get: function get() {
      return this._protocol;
    }
    /**
     * @type {Number}
     */

  }, {
    key: "readyState",
    get: function get() {
      return this._readyState;
    }
    /**
     * @type {String}
     */

  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
    /**
     * Set up the socket and the internal resources.
     *
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Object} options Options object
     * @param {Number} [options.maxPayload=0] The maximum allowed message size
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @private
     */

  }, {
    key: "setSocket",
    value: function setSocket(socket, head, options) {
      var receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on('conclude', receiverOnConclude);
      receiver.on('drain', receiverOnDrain);
      receiver.on('error', receiverOnError);
      receiver.on('message', receiverOnMessage);
      receiver.on('ping', receiverOnPing);
      receiver.on('pong', receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0) socket.unshift(head);
      socket.on('close', socketOnClose);
      socket.on('data', socketOnData);
      socket.on('end', socketOnEnd);
      socket.on('error', socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit('open');
    }
    /**
     * Emit the `'close'` event.
     *
     * @private
     */

  }, {
    key: "emitClose",
    value: function emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
        return;
      }

      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }

      this._receiver.removeAllListeners();

      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
    }
    /**
     * Start a closing handshake.
     *
     *          +----------+   +-----------+   +----------+
     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
     *    |     +----------+   +-----------+   +----------+     |
     *          +----------+   +-----------+         |
     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
     *          +----------+   +-----------+   |
     *    |           |                        |   +---+        |
     *                +------------------------+-->|fin| - - - -
     *    |         +---+                      |   +---+
     *     - - - - -|fin|<---------------------+
     *              +---+
     *
     * @param {Number} [code] Status code explaining why the connection is closing
     * @param {(String|Buffer)} [data] The reason why the connection is
     *     closing
     * @public
     */

  }, {
    key: "close",
    value: function close(code, data) {
      var _this2 = this;

      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake(this, this._req, msg);
      }

      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }

        return;
      }

      this._readyState = WebSocket.CLOSING;

      this._sender.close(code, data, !this._isServer, function (err) {
        //
        // This error is handled by the `'error'` listener on the socket. We only
        // want to know if the close frame has been sent here.
        //
        if (err) return;
        _this2._closeFrameSent = true;

        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {
          _this2._socket.end();
        }
      }); //
      // Specify a timeout for the closing handshake to complete.
      //


      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    /**
     * Send a ping.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the ping is sent
     * @public
     */

  }, {
    key: "ping",
    value: function ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the pong is sent
     * @public
     */

  }, {
    key: "pong",
    value: function pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} [options] Options object
     * @param {Boolean} [options.binary] Specifies whether `data` is binary or
     *     text
     * @param {Boolean} [options.compress] Specifies whether or not to compress
     *     `data`
     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when data is written out
     * @public
     */

  }, {
    key: "send",
    value: function send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      var opts = _objectSpread({
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);

      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }

      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */

  }, {
    key: "terminate",
    value: function terminate() {
      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake(this, this._req, msg);
      }

      if (this._socket) {
        this._readyState = WebSocket.CLOSING;

        this._socket.destroy();
      }
    }
  }]);

  return WebSocket;
}(EventEmitter);
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */


Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});
['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(function (property) {
  Object.defineProperty(WebSocket.prototype, property, {
    enumerable: true
  });
}); //
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//

['open', 'error', 'close', 'message'].forEach(function (method) {
  Object.defineProperty(WebSocket.prototype, "on".concat(method), {
    enumerable: true,
    get: function get() {
      var _iterator = _createForOfIteratorHelper(this.listeners(method)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          if (listener[kForOnEventAttribute]) return listener[kListener];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return null;
    },
    set: function set(handler) {
      var _iterator2 = _createForOfIteratorHelper(this.listeners(method)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;

          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (typeof handler !== 'function') return;
      this.addEventListener(method, handler, _defineProperty({}, kForOnEventAttribute, true));
    }
  });
});
WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;
module.exports = WebSocket;
/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */

function initAsClient(websocket, address, protocols, options) {
  var opts = _objectSpread(_objectSpread({
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10
  }, options), {}, {
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  });

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError("Unsupported protocol version: ".concat(opts.protocolVersion, " ") + "(supported versions: ".concat(protocolVersions.join(', '), ")"));
  }

  var parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError("Invalid URL: ".concat(address));
    }

    websocket._url = address;
  }

  var isSecure = parsedUrl.protocol === 'wss:';
  var isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {
    throw new SyntaxError('The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"');
  }

  if (isUnixSocket && !parsedUrl.pathname) {
    throw new SyntaxError("The URL's pathname is empty");
  }

  if (parsedUrl.hash) {
    throw new SyntaxError('The URL contains a fragment identifier');
  }

  var defaultPort = isSecure ? 443 : 80;
  var key = randomBytes(16).toString('base64');
  var get = isSecure ? https.get : http.get;
  var protocolSet = new Set();
  var perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = _objectSpread({
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  }, opts.headers);
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
    opts.headers['Sec-WebSocket-Extensions'] = format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));
  }

  if (protocols.length) {
    var _iterator3 = _createForOfIteratorHelper(protocols),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var protocol = _step3.value;

        if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError('An invalid or duplicated subprotocol was specified');
        }

        protocolSet.add(protocol);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }

  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }

  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = "".concat(parsedUrl.username, ":").concat(parsedUrl.password);
  }

  if (isUnixSocket) {
    var parts = opts.path.split(':');
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  var req = websocket._req = get(opts);

  if (opts.timeout) {
    req.on('timeout', function () {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', function (err) {
    if (req === null || req.aborted) return;
    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });
  req.on('response', function (res) {
    var location = res.headers.location;
    var statusCode = res.statusCode;

    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();
      var addr = new URL(location, address);
      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(websocket, req, "Unexpected server response: ".concat(res.statusCode));
    }
  });
  req.on('upgrade', function (res, socket, head) {
    websocket.emit('upgrade', res); //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //

    if (websocket.readyState !== WebSocket.CONNECTING) return;
    req = websocket._req = null;
    var digest = createHash('sha1').update(key + GUID).digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    var serverProt = res.headers['sec-websocket-protocol'];
    var protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;
    var secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      var extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        var _message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, _message);
        return;
      }

      var extensionNames = Object.keys(extensions);

      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
        var _message2 = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, _message2);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        var _message3 = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, _message3);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
}
/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */


function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}
/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */


function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}
/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */


function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;
  var err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}
/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */


function sendAfterClose(websocket, data, cb) {
  if (data) {
    var length = toBuffer(data).length; //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //

    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;
  }

  if (cb) {
    var err = new Error("WebSocket is not open: readyState ".concat(websocket.readyState, " ") + "(".concat(readyStates[websocket.readyState], ")"));
    cb(err);
  }
}
/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */


function receiverOnConclude(code, reason) {
  var websocket = this[kWebSocket];
  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;
  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);

  process.nextTick(resume, websocket._socket);
  if (code === 1005) websocket.close();else websocket.close(code, reason);
}
/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */


function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}
/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */


function receiverOnError(err) {
  var websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData); //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //


    process.nextTick(resume, websocket._socket);
    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}
/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */


function receiverOnFinish() {
  this[kWebSocket].emitClose();
}
/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */


function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}
/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */


function receiverOnPing(data) {
  var websocket = this[kWebSocket];
  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}
/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */


function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}
/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */


function resume(stream) {
  stream.resume();
}
/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */


function socketOnClose() {
  var websocket = this[kWebSocket];
  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);
  websocket._readyState = WebSocket.CLOSING;
  var chunk; //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //

  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;
  clearTimeout(websocket._closeTimer);

  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);

    websocket._receiver.on('finish', receiverOnFinish);
  }
}
/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */


function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}
/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */


function socketOnEnd() {
  var websocket = this[kWebSocket];
  websocket._readyState = WebSocket.CLOSING;

  websocket._receiver.end();

  this.end();
}
/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */


function socketOnError() {
  var websocket = this[kWebSocket];
  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/***/ ((module) => {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/commons.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/commons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
var PACKET_TYPES = Object.create(null); // no Map = no polyfill

exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
exports.ERROR_PACKET = ERROR_PACKET;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var commons_js_1 = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/cjs/commons.js");

var base64_arraybuffer_1 = __webpack_require__(/*! @socket.io/base64-arraybuffer */ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js");

var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }

  var type = encodedPacket.charAt(0);

  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }

  var packetType = commons_js_1.PACKET_TYPES_REVERSE[type];

  if (!packetType) {
    return commons_js_1.ERROR_PACKET;
  }

  return encodedPacket.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[type]
  };
};

var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (withNativeArrayBuffer) {
    var decoded = (0, base64_arraybuffer_1.decode)(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};

var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;

    case "arraybuffer":
    default:
      return data;
    // assuming the data is already an ArrayBuffer
  }
};

exports["default"] = decodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var commons_js_1 = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/cjs/commons.js");

var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};

var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
      data = _ref.data;

  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  } // plain string


  return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};

var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();

  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + content);
  };

  return fileReader.readAsDataURL(data);
};

exports["default"] = encodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;

var encodePacket_js_1 = __webpack_require__(/*! ./encodePacket.js */ "./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js");

exports.encodePacket = encodePacket_js_1["default"];

var decodePacket_js_1 = __webpack_require__(/*! ./decodePacket.js */ "./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js");

exports.decodePacket = decodePacket_js_1["default"];
var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    (0, encodePacket_js_1["default"])(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

exports.encodePayload = encodePayload;

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = (0, decodePacket_js_1["default"])(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

exports.decodePayload = decodePayload;
exports.protocol = 4;

/***/ }),

/***/ "./node_modules/engine.io/build/engine.io.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/engine.io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.attach = exports.listen = exports.transports = exports.Server = void 0;

var http_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var server_1 = __webpack_require__(/*! ./server */ "./node_modules/engine.io/build/server.js");

Object.defineProperty(exports, "Server", ({
  enumerable: true,
  get: function get() {
    return server_1.Server;
  }
}));

var index_1 = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io/build/transports/index.js");

exports.transports = index_1["default"];

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/cjs/index.js");

exports.parser = parser;

var userver_1 = __webpack_require__(/*! ./userver */ "./node_modules/engine.io/build/userver.js");

Object.defineProperty(exports, "uServer", ({
  enumerable: true,
  get: function get() {
    return userver_1.uServer;
  }
}));

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/engine.io/build/socket.js");

Object.defineProperty(exports, "Socket", ({
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
}));

var transport_1 = __webpack_require__(/*! ./transport */ "./node_modules/engine.io/build/transport.js");

Object.defineProperty(exports, "Transport", ({
  enumerable: true,
  get: function get() {
    return transport_1.Transport;
  }
}));
exports.protocol = parser.protocol;
/**
 * Creates an http.Server exclusively used for WS upgrades.
 *
 * @param {Number} port
 * @param {Function} callback
 * @param {Object} options
 * @return {Server} websocket.io server
 * @api public
 */

function listen(port, options, fn) {
  if ("function" === typeof options) {
    fn = options;
    options = {};
  }

  var server = (0, http_1.createServer)(function (req, res) {
    res.writeHead(501);
    res.end("Not Implemented");
  }); // create engine server

  var engine = attach(server, options);
  engine.httpServer = server;
  server.listen(port, fn);
  return engine;
}

exports.listen = listen;
/**
 * Captures upgrade requests for a http.Server.
 *
 * @param {http.Server} server
 * @param {Object} options
 * @return {Server} engine server
 * @api public
 */

function attach(server, options) {
  var engine = new server_1.Server(options);
  engine.attach(server, options);
  return engine;
}

exports.attach = attach;

/***/ }),

/***/ "./node_modules/engine.io/build/parser-v3/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

 // imported from https://github.com/socketio/engine.io-parser/tree/2.2.x

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;
/**
 * Module dependencies.
 */

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/engine.io/build/parser-v3/utf8.js");
/**
 * Current protocol version.
 */


exports.protocol = 3;

var hasBinary = function hasBinary(packets) {
  var _iterator = _createForOfIteratorHelper(packets),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var packet = _step.value;

      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
};
/**
 * Packet types.
 */


exports.packets = {
  open: 0 // non-ws
  ,
  close: 1 // non-ws
  ,
  ping: 2,
  pong: 3,
  message: 4,
  upgrade: 5,
  noop: 6
};
var packetslist = Object.keys(exports.packets);
/**
 * Premade error packet.
 */

var err = {
  type: 'error',
  data: 'parser error'
};
var EMPTY_BUFFER = Buffer.concat([]);
/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

function encodePacket(packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  if (Buffer.isBuffer(packet.data)) {
    return encodeBuffer(packet, supportsBinary, callback);
  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
    return encodeBuffer({
      type: packet.type,
      data: arrayBufferToBuffer(packet.data)
    }, supportsBinary, callback);
  } // Sending data as a utf-8 string


  var encoded = exports.packets[packet.type]; // data fragment is optional

  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), {
      strict: false
    }) : String(packet.data);
  }

  return callback('' + encoded);
}

exports.encodePacket = encodePacket;
;
/**
 * Encode Buffer data
 */

function encodeBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var typeBuffer = Buffer.allocUnsafe(1);
  typeBuffer[0] = exports.packets[packet.type];
  return callback(Buffer.concat([typeBuffer, data]));
}
/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */


function encodeBase64Packet(packet, callback) {
  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
  var message = 'b' + exports.packets[packet.type];
  message += data.toString('base64');
  return callback(message);
}

exports.encodeBase64Packet = encodeBase64Packet;
;
/**
 * Decodes a packet. Data also available as an ArrayBuffer if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

function decodePacket(data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }

  var type; // String data

  if (typeof data === 'string') {
    type = data.charAt(0);

    if (type === 'b') {
      return decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);

      if (data === false) {
        return err;
      }
    }

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return {
        type: packetslist[type],
        data: data.substring(1)
      };
    } else {
      return {
        type: packetslist[type]
      };
    }
  } // Binary data


  if (binaryType === 'arraybuffer') {
    // wrap Buffer/ArrayBuffer data into an Uint8Array
    var intArray = new Uint8Array(data);
    type = intArray[0];
    return {
      type: packetslist[type],
      data: intArray.buffer.slice(1)
    };
  }

  if (data instanceof ArrayBuffer) {
    data = arrayBufferToBuffer(data);
  }

  type = data[0];
  return {
    type: packetslist[type],
    data: data.slice(1)
  };
}

exports.decodePacket = decodePacket;
;

function tryDecode(data) {
  try {
    data = utf8.decode(data, {
      strict: false
    });
  } catch (e) {
    return false;
  }

  return data;
}
/**
 * Decodes a packet encoded in a base64 string.
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */


function decodeBase64Packet(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  var data = Buffer.from(msg.substr(1), 'base64');

  if (binaryType === 'arraybuffer') {
    var abv = new Uint8Array(data.length);

    for (var i = 0; i < abv.length; i++) {
      abv[i] = data[i];
    } // @ts-ignore


    data = abv.buffer;
  }

  return {
    type: type,
    data: data
  };
}

exports.decodeBase64Packet = decodeBase64Packet;
;
/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

function encodePayload(packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary && hasBinary(packets)) {
    return encodePayloadAsBinary(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function encodeOne(packet, doneCallback) {
    encodePacket(packet, supportsBinary, false, function (message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function (err, results) {
    return callback(results.join(''));
  });
}

exports.encodePayload = encodePayload;
;

function setLengthHeader(message) {
  return message.length + ':' + message;
}
/**
 * Async array map using after
 */


function map(ary, each, done) {
  var results = new Array(ary.length);
  var count = 0;

  var _loop = function _loop(i) {
    each(ary[i], function (error, msg) {
      results[i] = msg;

      if (++count === ary.length) {
        done(null, results);
      }
    });
  };

  for (var i = 0; i < ary.length; i++) {
    _loop(i);
  }
}
/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */


function decodePayload(data, binaryType, callback) {
  if (typeof data !== 'string') {
    return decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '',
      n,
      msg,
      packet;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    } // @ts-ignore


    if (length === '' || length != (n = Number(length))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var more = callback(packet, i + n, l);
      if (false === more) return;
    } // advance cursor


    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }
}

exports.decodePayload = decodePayload;
;
/**
 *
 * Converts a buffer to a utf8.js encoded string
 *
 * @api private
 */

function bufferToString(buffer) {
  var str = '';

  for (var i = 0, l = buffer.length; i < l; i++) {
    str += String.fromCharCode(buffer[i]);
  }

  return str;
}
/**
 *
 * Converts a utf8.js encoded string to a buffer
 *
 * @api private
 */


function stringToBuffer(string) {
  var buf = Buffer.allocUnsafe(string.length);

  for (var i = 0, l = string.length; i < l; i++) {
    buf.writeUInt8(string.charCodeAt(i), i);
  }

  return buf;
}
/**
 *
 * Converts an ArrayBuffer to a Buffer
 *
 * @api private
 */


function arrayBufferToBuffer(data) {
  // data is either an ArrayBuffer or ArrayBufferView.
  var length = data.byteLength || data.length;
  var offset = data.byteOffset || 0;
  return Buffer.from(data.buffer || data, offset, length);
}
/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {Buffer} encoded payload
 * @api private
 */


function encodePayloadAsBinary(packets, callback) {
  if (!packets.length) {
    return callback(EMPTY_BUFFER);
  }

  map(packets, encodeOneBinaryPacket, function (err, results) {
    return callback(Buffer.concat(results));
  });
}

exports.encodePayloadAsBinary = encodePayloadAsBinary;
;

function encodeOneBinaryPacket(p, doneCallback) {
  function onBinaryPacketEncode(packet) {
    var encodingLength = '' + packet.length;
    var sizeBuffer;

    if (typeof packet === 'string') {
      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
      sizeBuffer[0] = 0; // is a string (not true binary = 0)

      for (var i = 0; i < encodingLength.length; i++) {
        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
      }

      sizeBuffer[sizeBuffer.length - 1] = 255;
      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
    }

    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
    sizeBuffer[0] = 1; // is binary (true binary = 1)

    for (var i = 0; i < encodingLength.length; i++) {
      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
    }

    sizeBuffer[sizeBuffer.length - 1] = 255;
    doneCallback(null, Buffer.concat([sizeBuffer, packet]));
  }

  encodePacket(p, true, true, onBinaryPacketEncode);
}
/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */


function decodePayloadAsBinary(data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];
  var i;

  while (bufferTail.length > 0) {
    var strLen = '';
    var isString = bufferTail[0] === 0;

    for (i = 1;; i++) {
      if (bufferTail[i] === 255) break; // 310 = char length of Number.MAX_VALUE

      if (strLen.length > 310) {
        return callback(err, 0, 1);
      }

      strLen += '' + bufferTail[i];
    }

    bufferTail = bufferTail.slice(strLen.length + 1);
    var msgLength = parseInt(strLen, 10);
    var msg = bufferTail.slice(1, msgLength + 1);
    if (isString) msg = bufferToString(msg);
    buffers.push(msg);
    bufferTail = bufferTail.slice(msgLength + 1);
  }

  var total = buffers.length;

  for (i = 0; i < total; i++) {
    var buffer = buffers[i];
    callback(decodePacket(buffer, binaryType, true), i, total);
  }
}

exports.decodePayloadAsBinary = decodePayloadAsBinary;
;

/***/ }),

/***/ "./node_modules/engine.io/build/parser-v3/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/utf8.js ***!
  \********************************************************/
/***/ ((module) => {

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode

function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  var value;
  var extra;

  while (counter < length) {
    value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
} // Taken from https://mths.be/punycode


function ucs2encode(array) {
  var length = array.length;
  var index = -1;
  var value;
  var output = '';

  while (++index < length) {
    value = array[index];

    if (value > 0xFFFF) {
      value -= 0x10000;
      output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      value = 0xDC00 | value & 0x3FF;
    }

    output += stringFromCharCode(value);
  }

  return output;
}

function checkScalarValue(codePoint, strict) {
  if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    if (strict) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }

    return false;
  }

  return true;
}
/*--------------------------------------------------------------------------*/


function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
}

function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 0xFFFFFF80) == 0) {
    // 1-byte sequence
    return stringFromCharCode(codePoint);
  }

  var symbol = '';

  if ((codePoint & 0xFFFFF800) == 0) {
    // 2-byte sequence
    symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
  } else if ((codePoint & 0xFFFF0000) == 0) {
    // 3-byte sequence
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 0xFFFD;
    }

    symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 0xFFE00000) == 0) {
    // 4-byte sequence
    symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }

  symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
  return symbol;
}

function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length = codePoints.length;
  var index = -1;
  var codePoint;
  var byteString = '';

  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint, strict);
  }

  return byteString;
}
/*--------------------------------------------------------------------------*/


function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error('Invalid byte index');
  }

  var continuationByte = byteArray[byteIndex] & 0xFF;
  byteIndex++;

  if ((continuationByte & 0xC0) == 0x80) {
    return continuationByte & 0x3F;
  } // If we end up here, it’s not a continuation byte


  throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;

  if (byteIndex > byteCount) {
    throw Error('Invalid byte index');
  }

  if (byteIndex == byteCount) {
    return false;
  } // Read first byte


  byte1 = byteArray[byteIndex] & 0xFF;
  byteIndex++; // 1-byte sequence (no continuation bytes)

  if ((byte1 & 0x80) == 0) {
    return byte1;
  } // 2-byte sequence


  if ((byte1 & 0xE0) == 0xC0) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 0x1F) << 6 | byte2;

    if (codePoint >= 0x80) {
      return codePoint;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 3-byte sequence (may include unpaired surrogates)


  if ((byte1 & 0xF0) == 0xE0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;

    if (codePoint >= 0x0800) {
      return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 4-byte sequence


  if ((byte1 & 0xF8) == 0xF0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;

    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      return codePoint;
    }
  }

  throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;

function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;

  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }

  return ucs2encode(codePoints);
}

module.exports = {
  version: '2.1.2',
  encode: utf8encode,
  decode: utf8decode
};

/***/ }),

/***/ "./node_modules/engine.io/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Server = exports.BaseServer = void 0;

var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

var url_1 = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var base64id = __webpack_require__(/*! base64id */ "./node_modules/base64id/lib/base64id.js");

var transports_1 = __webpack_require__(/*! ./transports */ "./node_modules/engine.io/build/transports/index.js");

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/engine.io/build/socket.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var cookie_1 = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js");

var ws_1 = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");

var debug = (0, debug_1["default"])("engine");

var BaseServer = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(BaseServer, _events_1$EventEmitte);

  var _super = _createSuper(BaseServer);

  /**
   * Server constructor.
   *
   * @param {Object} opts - options
   * @api public
   */
  function BaseServer() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseServer);

    _this = _super.call(this);
    _this.clients = {};
    _this.clientsCount = 0;
    _this.opts = _extends({
      wsEngine: ws_1.Server,
      pingTimeout: 20000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6,
      transports: Object.keys(transports_1["default"]),
      allowUpgrades: true,
      httpCompression: {
        threshold: 1024
      },
      cors: false,
      allowEIO3: false
    }, opts);

    if (opts.cookie) {
      _this.opts.cookie = _extends({
        name: "io",
        path: "/",
        // @ts-ignore
        httpOnly: opts.cookie.path !== false,
        sameSite: "lax"
      }, opts.cookie);
    }

    if (_this.opts.cors) {
      _this.corsMiddleware = __webpack_require__(/*! cors */ "./node_modules/cors/lib/index.js")(_this.opts.cors);
    }

    if (opts.perMessageDeflate) {
      _this.opts.perMessageDeflate = _extends({
        threshold: 1024
      }, opts.perMessageDeflate);
    }

    _this.init();

    return _this;
  }
  /**
   * Returns a list of available transports for upgrade given a certain transport.
   *
   * @return {Array}
   * @api public
   */


  _createClass(BaseServer, [{
    key: "upgrades",
    value: function upgrades(transport) {
      if (!this.opts.allowUpgrades) return [];
      return transports_1["default"][transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {http.IncomingMessage}
     * @return {Boolean} whether the request is valid
     * @api private
     */

  }, {
    key: "verify",
    value: function verify(req, upgrade, fn) {
      // transport check
      var transport = req._query.transport;

      if (!~this.opts.transports.indexOf(transport)) {
        debug('unknown transport "%s"', transport);
        return fn(Server.errors.UNKNOWN_TRANSPORT, {
          transport: transport
        });
      } // 'Origin' header check


      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);

      if (isOriginInvalid) {
        var origin = req.headers.origin;
        req.headers.origin = null;
        debug("origin header invalid");
        return fn(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin: origin
        });
      } // sid check


      var sid = req._query.sid;

      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug('unknown sid "%s"', sid);
          return fn(Server.errors.UNKNOWN_SID, {
            sid: sid
          });
        }

        var previousTransport = this.clients[sid].transport.name;

        if (!upgrade && previousTransport !== transport) {
          debug("bad request: unexpected transport without upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport: transport,
            previousTransport: previousTransport
          });
        }
      } else {
        // handshake is GET only
        if ("GET" !== req.method) {
          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }

        if (transport === "websocket" && !upgrade) {
          debug("invalid transport upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_HANDSHAKE_ERROR"
          });
        }

        if (!this.opts.allowRequest) return fn();
        return this.opts.allowRequest(req, function (message, success) {
          if (!success) {
            return fn(Server.errors.FORBIDDEN, {
              message: message
            });
          }

          fn();
        });
      }

      fn();
    }
    /**
     * Closes all clients.
     *
     * @api public
     */

  }, {
    key: "close",
    value: function close() {
      debug("closing all open clients");

      for (var i in this.clients) {
        if (this.clients.hasOwnProperty(i)) {
          this.clients[i].close(true);
        }
      }

      this.cleanup();
      return this;
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {Object} request object
     * @api public
     */

  }, {
    key: "generateId",
    value: function generateId(req) {
      return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transport name
     * @param {Object} request object
     * @param {Function} closeConnection
     *
     * @api protected
     */

  }, {
    key: "handshake",
    value: function () {
      var _handshake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(transportName, req, closeConnection) {
        var _this2 = this;

        var protocol, id, transport, socket;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

                if (!(protocol === 3 && !this.opts.allowEIO3)) {
                  _context.next = 6;
                  break;
                }

                debug("unsupported protocol version");
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                  message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                  context: {
                    protocol: protocol
                  }
                });
                closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
                return _context.abrupt("return");

              case 6:
                _context.prev = 6;
                _context.next = 9;
                return this.generateId(req);

              case 9:
                id = _context.sent;
                _context.next = 18;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](6);
                debug("error while generating an id");
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.BAD_REQUEST,
                  message: Server.errorMessages[Server.errors.BAD_REQUEST],
                  context: {
                    name: "ID_GENERATION_ERROR",
                    error: _context.t0
                  }
                });
                closeConnection(Server.errors.BAD_REQUEST);
                return _context.abrupt("return");

              case 18:
                debug('handshaking client "%s"', id);
                _context.prev = 19;
                transport = this.createTransport(transportName, req);

                if ("polling" === transportName) {
                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                  transport.httpCompression = this.opts.httpCompression;
                } else if ("websocket" === transportName) {
                  transport.perMessageDeflate = this.opts.perMessageDeflate;
                }

                if (req._query && req._query.b64) {
                  transport.supportsBinary = false;
                } else {
                  transport.supportsBinary = true;
                }

                _context.next = 31;
                break;

              case 25:
                _context.prev = 25;
                _context.t1 = _context["catch"](19);
                debug('error handshaking to transport "%s"', transportName);
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.BAD_REQUEST,
                  message: Server.errorMessages[Server.errors.BAD_REQUEST],
                  context: {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                    error: _context.t1
                  }
                });
                closeConnection(Server.errors.BAD_REQUEST);
                return _context.abrupt("return");

              case 31:
                socket = new socket_1.Socket(id, this, transport, req, protocol);
                transport.on("headers", function (headers, req) {
                  var isInitialRequest = !req._query.sid;

                  if (isInitialRequest) {
                    if (_this2.opts.cookie) {
                      headers["Set-Cookie"] = [// @ts-ignore
                      (0, cookie_1.serialize)(_this2.opts.cookie.name, id, _this2.opts.cookie)];
                    }

                    _this2.emit("initial_headers", headers, req);
                  }

                  _this2.emit("headers", headers, req);
                });
                transport.onRequest(req);
                this.clients[id] = socket;
                this.clientsCount++;
                socket.once("close", function () {
                  delete _this2.clients[id];
                  _this2.clientsCount--;
                });
                this.emit("connection", socket);
                return _context.abrupt("return", transport);

              case 39:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 12], [19, 25]]);
      }));

      function handshake(_x, _x2, _x3) {
        return _handshake.apply(this, arguments);
      }

      return handshake;
    }()
  }]);

  return BaseServer;
}(events_1.EventEmitter);

exports.BaseServer = BaseServer;
/**
 * Protocol errors mappings.
 */

BaseServer.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4,
  UNSUPPORTED_PROTOCOL_VERSION: 5
};
BaseServer.errorMessages = {
  0: "Transport unknown",
  1: "Session ID unknown",
  2: "Bad handshake method",
  3: "Bad request",
  4: "Forbidden",
  5: "Unsupported protocol version"
};

var Server = /*#__PURE__*/function (_BaseServer) {
  _inherits(Server, _BaseServer);

  var _super2 = _createSuper(Server);

  function Server() {
    _classCallCheck(this, Server);

    return _super2.apply(this, arguments);
  }

  _createClass(Server, [{
    key: "init",
    value:
    /**
     * Initialize websocket server
     *
     * @api protected
     */
    function init() {
      var _this3 = this;

      if (!~this.opts.transports.indexOf("websocket")) return;
      if (this.ws) this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });

      if (typeof this.ws.on === "function") {
        this.ws.on("headers", function (headersArray, req) {
          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
          // we could also try to parse the array and then sync the values, but that will be error-prone
          var additionalHeaders = {};
          var isInitialRequest = !req._query.sid;

          if (isInitialRequest) {
            _this3.emit("initial_headers", additionalHeaders, req);
          }

          _this3.emit("headers", additionalHeaders, req);

          Object.keys(additionalHeaders).forEach(function (key) {
            headersArray.push("".concat(key, ": ").concat(additionalHeaders[key]));
          });
        });
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.ws) {
        debug("closing webSocketServer");
        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again
      }
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */

  }, {
    key: "prepare",
    value: function prepare(req) {
      // try to leverage pre-existing `req._query` (e.g: from connect)
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
      }
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_1["default"][transportName](req);
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {http.IncomingMessage} request
     * @param {http.ServerResponse|http.OutgoingMessage} response
     * @api public
     */

  }, {
    key: "handleRequest",
    value: function handleRequest(req, res) {
      var _this4 = this;

      debug('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this4.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortRequest(res, errorCode, errorContext);
          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this4.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return abortRequest(res, errorCode, errorContext);
          };

          _this4.handshake(req._query.transport, req, closeConnection);
        }
      };

      if (this.corsMiddleware) {
        this.corsMiddleware.call(null, req, res, function () {
          _this4.verify(req, false, callback);
        });
      } else {
        this.verify(req, false, callback);
      }
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     *
     * @api public
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, upgradeHead) {
      var _this5 = this;

      this.prepare(req);
      this.verify(req, true, function (errorCode, errorContext) {
        if (errorCode) {
          _this5.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortUpgrade(socket, errorCode, errorContext);
          return;
        }

        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api

        upgradeHead = null; // delegate to ws

        _this5.ws.handleUpgrade(req, socket, head, function (websocket) {
          _this5.onWebSocket(req, socket, websocket);
        });
      });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @api private
     */

  }, {
    key: "onWebSocket",
    value: function onWebSocket(req, socket, websocket) {
      websocket.on("error", onUpgradeError);

      if (transports_1["default"][req._query.transport] !== undefined && !transports_1["default"][req._query.transport].prototype.handlesUpgrades) {
        debug("transport doesnt handle upgraded requests");
        websocket.close();
        return;
      } // get client id


      var id = req._query.sid; // keep a reference to the ws.Socket

      req.websocket = websocket;

      if (id) {
        var client = this.clients[id];

        if (!client) {
          debug("upgrade attempt for closed client");
          websocket.close();
        } else if (client.upgrading) {
          debug("transport has already been trying to upgrade");
          websocket.close();
        } else if (client.upgraded) {
          debug("transport had already been upgraded");
          websocket.close();
        } else {
          debug("upgrading existing transport"); // transport error handling takes over

          websocket.removeListener("error", onUpgradeError);
          var transport = this.createTransport(req._query.transport, req);

          if (req._query && req._query.b64) {
            transport.supportsBinary = false;
          } else {
            transport.supportsBinary = true;
          }

          transport.perMessageDeflate = this.opts.perMessageDeflate;
          client.maybeUpgrade(transport);
        }
      } else {
        var closeConnection = function closeConnection(errorCode, errorContext) {
          return abortUpgrade(socket, errorCode, errorContext);
        };

        this.handshake(req._query.transport, req, closeConnection);
      }

      function onUpgradeError() {
        debug("websocket error before upgrade"); // websocket.close() not needed
      }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     * @api public
     */

  }, {
    key: "attach",
    value: function attach(server) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var path = (options.path || "/engine.io").replace(/\/$/, "");
      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path

      path += "/";

      function check(req) {
        return path === req.url.substr(0, path.length);
      } // cache and clean up listeners


      var listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this)); // add request handler

      server.on("request", function (req, res) {
        if (check(req)) {
          debug('intercepting request for path "%s"', path);

          _this6.handleRequest(req, res);
        } else {
          var i = 0;
          var l = listeners.length;

          for (; i < l; i++) {
            listeners[i].call(server, req, res);
          }
        }
      });

      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", function (req, socket, head) {
          if (check(req)) {
            _this6.handleUpgrade(req, socket, head);
          } else if (false !== options.destroyUpgrade) {
            // default node behavior is to disconnect when no handlers
            // but by adding a handler, we prevent that
            // and if no eio thing handles the upgrade
            // then the socket needs to die!
            setTimeout(function () {
              // @ts-ignore
              if (socket.writable && socket.bytesWritten <= 0) {
                return socket.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }]);

  return Server;
}(BaseServer);

exports.Server = Server;
/**
 * Close the HTTP long-polling request
 *
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @api private
 */

function abortRequest(res, errorCode, errorContext) {
  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
  res.writeHead(statusCode, {
    "Content-Type": "application/json"
  });
  res.end(JSON.stringify({
    code: errorCode,
    message: message
  }));
}
/**
 * Close the WebSocket connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 *
 * @api private
 */


function abortUpgrade(socket, errorCode) {
  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  socket.on("error", function () {
    debug("ignoring error from closed connection");
  });

  if (socket.writable) {
    var message = errorContext.message || Server.errorMessages[errorCode];
    var length = Buffer.byteLength(message);
    socket.write("HTTP/1.1 400 Bad Request\r\n" + "Connection: close\r\n" + "Content-type: text/html\r\n" + "Content-Length: " + length + "\r\n" + "\r\n" + message);
  }

  socket.destroy();
}
/* eslint-disable */

/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore


var validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];

function checkInvalidHeaderChar(val) {
  val += "";
  if (val.length < 1) return false;

  if (!validHdrChars[val.charCodeAt(0)]) {
    debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
    return true;
  }

  if (val.length < 2) return false;

  if (!validHdrChars[val.charCodeAt(1)]) {
    debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
    return true;
  }

  if (val.length < 3) return false;

  if (!validHdrChars[val.charCodeAt(2)]) {
    debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
    return true;
  }

  if (val.length < 4) return false;

  if (!validHdrChars[val.charCodeAt(3)]) {
    debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
    return true;
  }

  for (var i = 4; i < val.length; ++i) {
    if (!validHdrChars[val.charCodeAt(i)]) {
      debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
      return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/engine.io/build/socket.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/socket.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Socket = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var timers_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'timers'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var debug = (0, debug_1["default"])("engine:socket");

var Socket = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Socket, _events_1$EventEmitte);

  var _super = _createSuper(Socket);

  /**
   * Client class (abstract).
   *
   * @api private
   */
  function Socket(id, server, transport, req, protocol) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.id = id;
    _this.server = server;
    _this.upgrading = false;
    _this.upgraded = false;
    _this.readyState = "opening";
    _this.writeBuffer = [];
    _this.packetsFn = [];
    _this.sentCallbackFn = [];
    _this.cleanupFn = [];
    _this.request = req;
    _this.protocol = protocol; // Cache IP since it might not be in the req later

    if (req.websocket && req.websocket._socket) {
      _this.remoteAddress = req.websocket._socket.remoteAddress;
    } else {
      _this.remoteAddress = req.connection.remoteAddress;
    }

    _this.checkIntervalTimer = null;
    _this.upgradeTimeoutTimer = null;
    _this.pingTimeoutTimer = null;
    _this.pingIntervalTimer = null;

    _this.setTransport(transport);

    _this.onOpen();

    return _this;
  }

  _createClass(Socket, [{
    key: "readyState",
    get: function get() {
      return this._readyState;
    },
    set: function set(state) {
      debug("readyState updated from %s to %s", this._readyState, state);
      this._readyState = state;
    }
    /**
     * Called upon transport considered open.
     *
     * @api private
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open"; // sends an `open` packet

      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout
      }));

      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }

      this.emit("open");

      if (this.protocol === 3) {
        // in protocol v3, the client sends a ping, and the server answers with a pong
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
      } else {
        // in protocol v4, the server sends a ping, and the client answers with a pong
        this.schedulePing();
      }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("open" !== this.readyState) {
        return debug("packet received with closed socket");
      } // export packet event


      debug("received packet ".concat(packet.type));
      this.emit("packet", packet); // Reset ping timeout on any packet, incoming data is a good sign of
      // other side's liveness

      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);

      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got ping");
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;

        case "pong":
          if (this.transport.protocol === 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got pong");
          this.pingIntervalTimer.refresh();
          this.emit("heartbeat");
          break;

        case "error":
          this.onClose("parse error");
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} error object
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("transport error");
      this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */

  }, {
    key: "schedulePing",
    value: function schedulePing() {
      var _this2 = this;

      this.pingIntervalTimer = (0, timers_1.setTimeout)(function () {
        debug("writing ping packet - expecting pong within %sms", _this2.server.opts.pingTimeout);

        _this2.sendPacket("ping");

        _this2.resetPingTimeout(_this2.server.opts.pingTimeout);
      }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @api private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout(timeout) {
      var _this3 = this;

      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      this.pingTimeoutTimer = (0, timers_1.setTimeout)(function () {
        if (_this3.readyState === "closed") return;

        _this3.onClose("ping timeout");
      }, timeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var onError = this.onError.bind(this);
      var onPacket = this.onPacket.bind(this);
      var flush = this.flush.bind(this);
      var onClose = this.onClose.bind(this, "transport close");
      this.transport = transport;
      this.transport.once("error", onError);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", flush);
      this.transport.once("close", onClose); // this function will manage packet events (also message callbacks)

      this.setupSendCallback();
      this.cleanupFn.push(function () {
        transport.removeListener("error", onError);
        transport.removeListener("packet", onPacket);
        transport.removeListener("drain", flush);
        transport.removeListener("close", onClose);
      });
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "maybeUpgrade",
    value: function maybeUpgrade(transport) {
      var _this4 = this;

      debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
      this.upgrading = true; // set transport upgrade timer

      this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(function () {
        debug("client did not complete upgrade - closing transport");
        cleanup();

        if ("open" === transport.readyState) {
          transport.close();
        }
      }, this.server.opts.upgradeTimeout);

      var onPacket = function onPacket(packet) {
        if ("ping" === packet.type && "probe" === packet.data) {
          debug("got probe ping packet, sending pong");
          transport.send([{
            type: "pong",
            data: "probe"
          }]);

          _this4.emit("upgrading", transport);

          clearInterval(_this4.checkIntervalTimer);
          _this4.checkIntervalTimer = setInterval(check, 100);
        } else if ("upgrade" === packet.type && _this4.readyState !== "closed") {
          debug("got upgrade packet - upgrading");
          cleanup();

          _this4.transport.discard();

          _this4.upgraded = true;

          _this4.clearTransport();

          _this4.setTransport(transport);

          _this4.emit("upgrade", transport);

          _this4.flush();

          if (_this4.readyState === "closing") {
            transport.close(function () {
              _this4.onClose("forced close");
            });
          }
        } else {
          cleanup();
          transport.close();
        }
      }; // we force a polling cycle to ensure a fast upgrade


      var check = function check() {
        if ("polling" === _this4.transport.name && _this4.transport.writable) {
          debug("writing a noop packet to polling for fast upgrade");

          _this4.transport.send([{
            type: "noop"
          }]);
        }
      };

      var cleanup = function cleanup() {
        _this4.upgrading = false;
        clearInterval(_this4.checkIntervalTimer);
        _this4.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(_this4.upgradeTimeoutTimer);
        _this4.upgradeTimeoutTimer = null;
        transport.removeListener("packet", onPacket);
        transport.removeListener("close", onTransportClose);
        transport.removeListener("error", onError);

        _this4.removeListener("close", onClose);
      };

      var onError = function onError(err) {
        debug("client did not complete upgrade - %s", err);
        cleanup();
        transport.close();
        transport = null;
      };

      var onTransportClose = function onTransportClose() {
        onError("transport closed");
      };

      var onClose = function onClose() {
        onError("socket closed");
      };

      transport.on("packet", onPacket);
      transport.once("close", onTransportClose);
      transport.once("error", onError);
      this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @api private
     */

  }, {
    key: "clearTransport",
    value: function clearTransport() {
      var cleanup;
      var toCleanUp = this.cleanupFn.length;

      for (var i = 0; i < toCleanUp; i++) {
        cleanup = this.cleanupFn.shift();
        cleanup();
      } // silence further transport errors and prevent uncaught exceptions


      this.transport.on("error", function () {
        debug("error triggered by discarded transport");
      }); // ensure transport won't stay open

      this.transport.close();
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */

  }, {
    key: "onClose",
    value: function onClose(reason, description) {
      var _this5 = this;

      if ("closed" !== this.readyState) {
        this.readyState = "closed"; // clear timers

        (0, timers_1.clearTimeout)(this.pingIntervalTimer);
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        clearInterval(this.checkIntervalTimer);
        this.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still
        // grab the writeBuffer on 'close' event

        process.nextTick(function () {
          _this5.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    /**
     * Setup and manage send callback
     *
     * @api private
     */

  }, {
    key: "setupSendCallback",
    value: function setupSendCallback() {
      var _this6 = this;

      // the message was sent successfully, execute the callback
      var onDrain = function onDrain() {
        if (_this6.sentCallbackFn.length > 0) {
          var seqFn = _this6.sentCallbackFn.splice(0, 1)[0];

          if ("function" === typeof seqFn) {
            debug("executing send callback");
            seqFn(_this6.transport);
          } else if (Array.isArray(seqFn)) {
            debug("executing batch send callback");
            var l = seqFn.length;
            var i = 0;

            for (; i < l; i++) {
              if ("function" === typeof seqFn[i]) {
                seqFn[i](_this6.transport);
              }
            }
          }
        }
      };

      this.transport.on("drain", onDrain);
      this.cleanupFn.push(function () {
        _this6.transport.removeListener("drain", onDrain);
      });
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "send",
    value: function send(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
  }, {
    key: "write",
    value: function write(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @api private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, callback) {
      if ("function" === typeof options) {
        callback = options;
        options = null;
      }

      options = options || {};
      options.compress = false !== options.compress;

      if ("closing" !== this.readyState && "closed" !== this.readyState) {
        debug('sending packet "%s" (%s)', type, data);
        var packet = {
          type: type,
          options: options
        };
        if (data) packet.data = data; // exports packetCreate event

        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet); // add send callback to object, if defined

        if (callback) this.packetsFn.push(callback);
        this.flush();
      }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @api private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
        debug("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        var wbuf = this.writeBuffer;
        this.writeBuffer = [];

        if (!this.transport.supportsFraming) {
          this.sentCallbackFn.push(this.packetsFn);
        } else {
          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
        }

        this.packetsFn = [];
        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @api private
     */

  }, {
    key: "getAvailableUpgrades",
    value: function getAvailableUpgrades() {
      var availableUpgrades = [];
      var allUpgrades = this.server.upgrades(this.transport.name);
      var i = 0;
      var l = allUpgrades.length;

      for (; i < l; ++i) {
        var upg = allUpgrades[i];

        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }

      return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "close",
    value: function close(discard) {
      if ("open" !== this.readyState) return;
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        this.once("drain", this.closeTransport.bind(this, discard));
        return;
      }

      this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @api private
     */

  }, {
    key: "closeTransport",
    value: function closeTransport(discard) {
      if (discard) this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }]);

  return Socket;
}(events_1.EventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./node_modules/engine.io/build/transport.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/transport.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Transport = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var parser_v4 = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/cjs/index.js");

var parser_v3 = __webpack_require__(/*! ./parser-v3/index */ "./node_modules/engine.io/build/parser-v3/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:transport");
/**
 * Noop function.
 *
 * @api private
 */

function noop() {}

var Transport = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Transport, _events_1$EventEmitte);

  var _super = _createSuper(Transport);

  /**
   * Transport constructor.
   *
   * @param {http.IncomingMessage} request
   * @api public
   */
  function Transport(req) {
    var _this;

    _classCallCheck(this, Transport);

    _this = _super.call(this);
    _this.readyState = "open";
    _this.discarded = false;
    _this.protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

    _this.parser = _this.protocol === 4 ? parser_v4 : parser_v3;
    return _this;
  }

  _createClass(Transport, [{
    key: "readyState",
    get: function get() {
      return this._readyState;
    },
    set: function set(state) {
      debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
      this._readyState = state;
    }
    /**
     * Flags the transport as discarded.
     *
     * @api private
     */

  }, {
    key: "discard",
    value: function discard() {
      this.discarded = true;
    }
    /**
     * Called with an incoming HTTP request.
     *
     * @param {http.IncomingMessage} request
     * @api protected
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      debug("setting request");
      this.req = req;
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close(fn) {
      if ("closed" === this.readyState || "closing" === this.readyState) return;
      this.readyState = "closing";
      this.doClose(fn || noop);
    }
    /**
     * Called with a transport error.
     *
     * @param {String} message error
     * @param {Object} error description
     * @api protected
     */

  }, {
    key: "onError",
    value: function onError(msg, desc) {
      if (this.listeners("error").length) {
        var err = new Error(msg); // @ts-ignore

        err.type = "TransportError"; // @ts-ignore

        err.description = desc;
        this.emit("error", err);
      } else {
        debug("ignored transport error %s (%s)", msg, desc);
      }
    }
    /**
     * Called with parsed out a packets from the data stream.
     *
     * @param {Object} packet
     * @api protected
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      this.emit("packet", packet);
    }
    /**
     * Called with the encoded packet data.
     *
     * @param {String} data
     * @api protected
     */

  }, {
    key: "onData",
    value: function onData(data) {
      this.onPacket(this.parser.decodePacket(data));
    }
    /**
     * Called upon transport close.
     *
     * @api protected
     */

  }, {
    key: "onClose",
    value: function onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }]);

  return Transport;
}(events_1.EventEmitter);

exports.Transport = Transport;

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports-uws/polling.js");

var websocket_1 = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io/build/transports-uws/websocket.js");

exports["default"] = {
  polling: polling_1.Polling,
  websocket: websocket_1.WebSocket
};

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/polling.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Polling = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:polling");
var compressionMethods = {
  gzip: zlib_1.createGzip,
  deflate: zlib_1.createDeflate
};

var Polling = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(Polling, _transport_1$Transpor);

  var _super = _createSuper(Polling);

  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  function Polling(req) {
    var _this;

    _classCallCheck(this, Polling);

    _this = _super.call(this, req);
    _this.closeTimeout = 30 * 1000;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
  }, {
    key: "supportsFraming",
    get: function get() {
      return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param req
     *
     * @api private
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      var res = req.res;

      if (req.getMethod() === "get") {
        this.onPollRequest(req, res);
      } else if (req.getMethod() === "post") {
        this.onDataRequest(req, res);
      } else {
        res.writeStatus("500 Internal Server Error");
        res.end();
      }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */

  }, {
    key: "onPollRequest",
    value: function onPollRequest(req, res) {
      var _this2 = this;

      if (this.req) {
        debug("request overlap"); // assert: this.res, '.req and .res should be (un)set together'

        this.onError("overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }

      debug("setting request");
      this.req = req;
      this.res = res;

      var onClose = function onClose() {
        _this2.writable = false;

        _this2.onError("poll connection closed prematurely");
      };

      var cleanup = function cleanup() {
        _this2.req = _this2.res = null;
      };

      req.cleanup = cleanup;
      res.onAborted(onClose);
      this.writable = true;
      this.emit("drain"); // if we're still writable but had a pending close, trigger an empty send

      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{
          type: "noop"
        }]);
      }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */

  }, {
    key: "onDataRequest",
    value: function onDataRequest(req, res) {
      var _this3 = this;

      if (this.dataReq) {
        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
        this.onError("data request overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }

      var expectedContentLength = Number(req.headers["content-length"]);

      if (!expectedContentLength) {
        this.onError("content-length header required");
        res.writeStatus("411 Length Required").end();
        return;
      }

      if (expectedContentLength > this.maxHttpBufferSize) {
        this.onError("payload too large");
        res.writeStatus("413 Payload Too Large").end();
        return;
      }

      var isBinary = "application/octet-stream" === req.headers["content-type"];

      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }

      this.dataReq = req;
      this.dataRes = res;
      var buffer;
      var offset = 0;
      var headers = {
        // text/html is required instead of text/plain to avoid an
        // unwanted download dialog on certain user-agents (GH-43)
        "Content-Type": "text/html"
      };
      this.headers(req, headers);

      for (var key in headers) {
        res.writeHeader(key, String(headers[key]));
      }

      var onEnd = function onEnd(buffer) {
        _this3.onData(buffer.toString());

        _this3.onDataRequestCleanup();

        res.end("ok");
      };

      res.onAborted(function () {
        _this3.onDataRequestCleanup();

        _this3.onError("data request connection closed prematurely");
      });
      res.onData(function (arrayBuffer, isLast) {
        var totalLength = offset + arrayBuffer.byteLength;

        if (totalLength > expectedContentLength) {
          _this3.onError("content-length mismatch");

          res.close(); // calls onAborted

          return;
        }

        if (!buffer) {
          if (isLast) {
            onEnd(Buffer.from(arrayBuffer));
            return;
          }

          buffer = Buffer.allocUnsafe(expectedContentLength);
        }

        Buffer.from(arrayBuffer).copy(buffer, offset);

        if (isLast) {
          if (totalLength != expectedContentLength) {
            _this3.onError("content-length mismatch");

            res.writeStatus("400 Content-Length Mismatch").end();

            _this3.onDataRequestCleanup();

            return;
          }

          onEnd(buffer);
          return;
        }

        offset = totalLength;
      });
    }
    /**
     * Cleanup request.
     *
     * @api private
     */

  }, {
    key: "onDataRequestCleanup",
    value: function onDataRequestCleanup() {
      this.dataReq = this.dataRes = null;
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this4 = this;

      debug('received "%s"', data);

      var callback = function callback(packet) {
        if ("close" === packet.type) {
          debug("got xhr close packet");

          _this4.onClose();

          return false;
        }

        _this4.onPacket(packet);
      };

      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      if (this.writable) {
        // close pending poll request
        this.send([{
          type: "noop"
        }]);
      }

      _get(_getPrototypeOf(Polling.prototype), "onClose", this).call(this);
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this5 = this;

      this.writable = false;

      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({
          type: "close"
        });
        this.shouldClose();
        this.shouldClose = null;
      }

      var doWrite = function doWrite(data) {
        var compress = packets.some(function (packet) {
          return packet.options && packet.options.compress;
        });

        _this5.write(data, {
          compress: compress
        });
      };

      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "write",
    value: function write(data, options) {
      var _this6 = this;

      debug('writing "%s"', data);
      this.doWrite(data, options, function () {
        _this6.req.cleanup();
      });
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      var _this7 = this;

      // explicit UTF-8 is required for pages not served under utf
      var isString = typeof data === "string";
      var contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      var headers = {
        "Content-Type": contentType
      };

      var respond = function respond(data) {
        _this7.headers(_this7.req, headers);

        Object.keys(headers).forEach(function (key) {
          _this7.res.writeHeader(key, String(headers[key]));
        });

        _this7.res.end(data);

        callback();
      };

      if (!this.httpCompression || !options.compress) {
        respond(data);
        return;
      }

      var len = isString ? Buffer.byteLength(data) : data.length;

      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }

      var encoding = accepts(this.req).encodings(["gzip", "deflate"]);

      if (!encoding) {
        respond(data);
        return;
      }

      this.compress(data, encoding, function (err, data) {
        if (err) {
          _this7.res.writeStatus("500 Internal Server Error");

          _this7.res.end();

          callback(err);
          return;
        }

        headers["Content-Encoding"] = encoding;
        respond(data);
      });
    }
    /**
     * Compresses data.
     *
     * @api private
     */

  }, {
    key: "compress",
    value: function compress(data, encoding, callback) {
      debug("compressing");
      var buffers = [];
      var nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function (chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function () {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      var _this8 = this;

      debug("closing");
      var closeTimeoutTimer;

      var onClose = function onClose() {
        clearTimeout(closeTimeoutTimer);
        fn();

        _this8.onClose();
      };

      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{
          type: "close"
        }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    /**
     * Returns headers for a response.
     *
     * @param req - request
     * @param {Object} extra headers
     * @api private
     */

  }, {
    key: "headers",
    value: function headers(req, _headers) {
      _headers = _headers || {}; // prevent XSS warnings on IE
      // https://github.com/LearnBoost/socket.io/pull/1333

      var ua = req.headers["user-agent"];

      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        _headers["X-XSS-Protection"] = "0";
      }

      this.emit("headers", _headers, req);
      return _headers;
    }
  }]);

  return Polling;
}(transport_1.Transport);

exports.Polling = Polling;

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/websocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:ws");

var WebSocket = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(WebSocket, _transport_1$Transpor);

  var _super = _createSuper(WebSocket);

  /**
   * WebSocket transport
   *
   * @param req
   * @api public
   */
  function WebSocket(req) {
    var _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this, req);
    _this.writable = false;
    _this.perMessageDeflate = null;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(WebSocket, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */

  }, {
    key: "handlesUpgrades",
    get: function get() {
      return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */

  }, {
    key: "supportsFraming",
    get: function get() {
      return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this2 = this;

      var packet = packets.shift();

      if (typeof packet === "undefined") {
        this.writable = true;
        this.emit("drain");
        return;
      } // always creates a new object since ws modifies it


      var opts = {};

      if (packet.options) {
        opts.compress = packet.options.compress;
      }

      var send = function send(data) {
        var isBinary = typeof data !== "string";

        var compress = _this2.perMessageDeflate && Buffer.byteLength(data) > _this2.perMessageDeflate.threshold;

        debug('writing "%s"', data);
        _this2.writable = false;

        _this2.socket.send(data, isBinary, compress);

        _this2.send(packets);
      };

      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send(packet.options.wsPreEncoded);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send);
      }
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      debug("closing");
      fn && fn(); // call fn first since socket.close() immediately emits a "close" event

      this.socket.close();
    }
  }]);

  return WebSocket;
}(transport_1.Transport);

exports.WebSocket = WebSocket;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io/build/transports/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports/polling.js");

var polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io/build/transports/polling-jsonp.js");

var websocket_1 = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io/build/transports/websocket.js");

exports["default"] = {
  polling: polling,
  websocket: websocket_1.WebSocket
};
/**
 * Polling polymorphic constructor.
 *
 * @api private
 */

function polling(req) {
  if ("string" === typeof req._query.j) {
    return new polling_jsonp_1.JSONP(req);
  } else {
    return new polling_1.Polling(req);
  }
}

polling.upgradesTo = ["websocket"];

/***/ }),

/***/ "./node_modules/engine.io/build/transports/polling-jsonp.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JSONP = void 0;

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports/polling.js");

var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

var rDoubleSlashes = /\\\\n/g;
var rSlashes = /(\\)?\\n/g;

var JSONP = /*#__PURE__*/function (_polling_1$Polling) {
  _inherits(JSONP, _polling_1$Polling);

  var _super = _createSuper(JSONP);

  /**
   * JSON-P polling transport.
   *
   * @api public
   */
  function JSONP(req) {
    var _this;

    _classCallCheck(this, JSONP);

    _this = _super.call(this, req);
    _this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
    _this.foot = ");";
    return _this;
  }
  /**
   * Handles incoming data.
   * Due to a bug in \n handling by browsers, we expect a escaped string.
   *
   * @api private
   */


  _createClass(JSONP, [{
    key: "onData",
    value: function onData(data) {
      // we leverage the qs module so that we get built-in DoS protection
      // and the fast alternative to decodeURIComponent
      data = qs.parse(data).d;

      if ("string" === typeof data) {
        // client will send already escaped newlines as \\\\n and newlines as \\n
        // \\n must be replaced with \n and \\\\n with \\n
        data = data.replace(rSlashes, function (match, slashes) {
          return slashes ? match : "\n";
        });

        _get(_getPrototypeOf(JSONP.prototype), "onData", this).call(this, data.replace(rDoubleSlashes, "\\n"));
      }
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      // we must output valid javascript, not valid json
      // see: http://timelessrepo.com/json-isnt-a-javascript-subset
      var js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029"); // prepare response

      data = this.head + js + this.foot;

      _get(_getPrototypeOf(JSONP.prototype), "doWrite", this).call(this, data, options, callback);
    }
  }]);

  return JSONP;
}(polling_1.Polling);

exports.JSONP = JSONP;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/polling.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Polling = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:polling");
var compressionMethods = {
  gzip: zlib_1.createGzip,
  deflate: zlib_1.createDeflate
};

var Polling = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(Polling, _transport_1$Transpor);

  var _super = _createSuper(Polling);

  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  function Polling(req) {
    var _this;

    _classCallCheck(this, Polling);

    _this = _super.call(this, req);
    _this.closeTimeout = 30 * 1000;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
  }, {
    key: "supportsFraming",
    get: function get() {
      return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param {http.IncomingMessage}
     * @api private
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      var res = req.res;

      if ("GET" === req.method) {
        this.onPollRequest(req, res);
      } else if ("POST" === req.method) {
        this.onDataRequest(req, res);
      } else {
        res.writeHead(500);
        res.end();
      }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */

  }, {
    key: "onPollRequest",
    value: function onPollRequest(req, res) {
      var _this2 = this;

      if (this.req) {
        debug("request overlap"); // assert: this.res, '.req and .res should be (un)set together'

        this.onError("overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      debug("setting request");
      this.req = req;
      this.res = res;

      var onClose = function onClose() {
        _this2.onError("poll connection closed prematurely");
      };

      var cleanup = function cleanup() {
        req.removeListener("close", onClose);
        _this2.req = _this2.res = null;
      };

      req.cleanup = cleanup;
      req.on("close", onClose);
      this.writable = true;
      this.emit("drain"); // if we're still writable but had a pending close, trigger an empty send

      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{
          type: "noop"
        }]);
      }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */

  }, {
    key: "onDataRequest",
    value: function onDataRequest(req, res) {
      var _this3 = this;

      if (this.dataReq) {
        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
        this.onError("data request overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      var isBinary = "application/octet-stream" === req.headers["content-type"];

      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }

      this.dataReq = req;
      this.dataRes = res;
      var chunks = isBinary ? Buffer.concat([]) : "";

      var cleanup = function cleanup() {
        req.removeListener("data", onData);
        req.removeListener("end", onEnd);
        req.removeListener("close", onClose);
        _this3.dataReq = _this3.dataRes = chunks = null;
      };

      var onClose = function onClose() {
        cleanup();

        _this3.onError("data request connection closed prematurely");
      };

      var onData = function onData(data) {
        var contentLength;

        if (isBinary) {
          chunks = Buffer.concat([chunks, data]);
          contentLength = chunks.length;
        } else {
          chunks += data;
          contentLength = Buffer.byteLength(chunks);
        }

        if (contentLength > _this3.maxHttpBufferSize) {
          chunks = isBinary ? Buffer.concat([]) : "";
          req.connection.destroy();
        }
      };

      var onEnd = function onEnd() {
        _this3.onData(chunks);

        var headers = {
          // text/html is required instead of text/plain to avoid an
          // unwanted download dialog on certain user-agents (GH-43)
          "Content-Type": "text/html",
          "Content-Length": 2
        };
        res.writeHead(200, _this3.headers(req, headers));
        res.end("ok");
        cleanup();
      };

      req.on("close", onClose);
      if (!isBinary) req.setEncoding("utf8");
      req.on("data", onData);
      req.on("end", onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this4 = this;

      debug('received "%s"', data);

      var callback = function callback(packet) {
        if ("close" === packet.type) {
          debug("got xhr close packet");

          _this4.onClose();

          return false;
        }

        _this4.onPacket(packet);
      };

      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      if (this.writable) {
        // close pending poll request
        this.send([{
          type: "noop"
        }]);
      }

      _get(_getPrototypeOf(Polling.prototype), "onClose", this).call(this);
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this5 = this;

      this.writable = false;

      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({
          type: "close"
        });
        this.shouldClose();
        this.shouldClose = null;
      }

      var doWrite = function doWrite(data) {
        var compress = packets.some(function (packet) {
          return packet.options && packet.options.compress;
        });

        _this5.write(data, {
          compress: compress
        });
      };

      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "write",
    value: function write(data, options) {
      var _this6 = this;

      debug('writing "%s"', data);
      this.doWrite(data, options, function () {
        _this6.req.cleanup();
      });
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      var _this7 = this;

      // explicit UTF-8 is required for pages not served under utf
      var isString = typeof data === "string";
      var contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      var headers = {
        "Content-Type": contentType
      };

      var respond = function respond(data) {
        headers["Content-Length"] = "string" === typeof data ? Buffer.byteLength(data) : data.length;

        _this7.res.writeHead(200, _this7.headers(_this7.req, headers));

        _this7.res.end(data);

        callback();
      };

      if (!this.httpCompression || !options.compress) {
        respond(data);
        return;
      }

      var len = isString ? Buffer.byteLength(data) : data.length;

      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }

      var encoding = accepts(this.req).encodings(["gzip", "deflate"]);

      if (!encoding) {
        respond(data);
        return;
      }

      this.compress(data, encoding, function (err, data) {
        if (err) {
          _this7.res.writeHead(500);

          _this7.res.end();

          callback(err);
          return;
        }

        headers["Content-Encoding"] = encoding;
        respond(data);
      });
    }
    /**
     * Compresses data.
     *
     * @api private
     */

  }, {
    key: "compress",
    value: function compress(data, encoding, callback) {
      debug("compressing");
      var buffers = [];
      var nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function (chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function () {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      var _this8 = this;

      debug("closing");
      var closeTimeoutTimer;

      if (this.dataReq) {
        debug("aborting ongoing data request");
        this.dataReq.destroy();
      }

      var onClose = function onClose() {
        clearTimeout(closeTimeoutTimer);
        fn();

        _this8.onClose();
      };

      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{
          type: "close"
        }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} request
     * @param {Object} extra headers
     * @api private
     */

  }, {
    key: "headers",
    value: function headers(req, _headers) {
      _headers = _headers || {}; // prevent XSS warnings on IE
      // https://github.com/LearnBoost/socket.io/pull/1333

      var ua = req.headers["user-agent"];

      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        _headers["X-XSS-Protection"] = "0";
      }

      this.emit("headers", _headers, req);
      return _headers;
    }
  }]);

  return Polling;
}(transport_1.Transport);

exports.Polling = Polling;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/websocket.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:ws");

var WebSocket = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(WebSocket, _transport_1$Transpor);

  var _super = _createSuper(WebSocket);

  /**
   * WebSocket transport
   *
   * @param {http.IncomingMessage}
   * @api public
   */
  function WebSocket(req) {
    var _thisSuper, _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this, req);
    _this.socket = req.websocket;

    _this.socket.on("message", function (data, isBinary) {
      var message = isBinary ? data : data.toString();
      debug('received "%s"', message);

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WebSocket.prototype)), "onData", _thisSuper).call(_thisSuper, message);
    });

    _this.socket.once("close", _this.onClose.bind(_assertThisInitialized(_this)));

    _this.socket.on("error", _this.onError.bind(_assertThisInitialized(_this)));

    _this.writable = true;
    _this.perMessageDeflate = null;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(WebSocket, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */

  }, {
    key: "handlesUpgrades",
    get: function get() {
      return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */

  }, {
    key: "supportsFraming",
    get: function get() {
      return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this2 = this;

      var packet = packets.shift();

      if (typeof packet === "undefined") {
        this.writable = true;
        this.emit("drain");
        return;
      } // always creates a new object since ws modifies it


      var opts = {};

      if (packet.options) {
        opts.compress = packet.options.compress;
      }

      var send = function send(data) {
        if (_this2.perMessageDeflate) {
          var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;

          if (len < _this2.perMessageDeflate.threshold) {
            opts.compress = false;
          }
        }

        debug('writing "%s"', data);
        _this2.writable = false;

        _this2.socket.send(data, opts, function (err) {
          if (err) return _this2.onError("write error", err.stack);

          _this2.send(packets);
        });
      };

      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send(packet.options.wsPreEncoded);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send);
      }
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      debug("closing");
      this.socket.close();
      fn && fn();
    }
  }]);

  return WebSocket;
}(transport_1.Transport);

exports.WebSocket = WebSocket;

/***/ }),

/***/ "./node_modules/engine.io/build/userver.js":
/*!*************************************************!*\
  !*** ./node_modules/engine.io/build/userver.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.uServer = void 0;

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var server_1 = __webpack_require__(/*! ./server */ "./node_modules/engine.io/build/server.js");

var transports_uws_1 = __webpack_require__(/*! ./transports-uws */ "./node_modules/engine.io/build/transports-uws/index.js");

var debug = (0, debug_1["default"])("engine:uws");

var uServer = /*#__PURE__*/function (_server_1$BaseServer) {
  _inherits(uServer, _server_1$BaseServer);

  var _super = _createSuper(uServer);

  function uServer() {
    _classCallCheck(this, uServer);

    return _super.apply(this, arguments);
  }

  _createClass(uServer, [{
    key: "init",
    value: function init() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */

  }, {
    key: "prepare",
    value: function prepare(req, res) {
      req.method = req.getMethod().toUpperCase();
      var params = new URLSearchParams(req.getQuery());
      req._query = Object.fromEntries(params.entries());
      req.headers = {};
      req.forEach(function (key, value) {
        req.headers[key] = value;
      });
      req.connection = {
        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
      };
      res.onAborted(function () {
        debug("response has been aborted");
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_uws_1["default"][transportName](req);
    }
    /**
     * Attach the engine to a µWebSockets.js server
     * @param app
     * @param options
     */

  }, {
    key: "attach",
    value: function attach(app
    /* : TemplatedApp */
    ) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var path = (options.path || "/engine.io").replace(/\/$/, "") + "/";
      app.any(path, this.handleRequest.bind(this)) //
      .ws(path, {
        compression: options.compression,
        idleTimeout: options.idleTimeout,
        maxBackpressure: options.maxBackpressure,
        maxPayloadLength: this.opts.maxHttpBufferSize,
        upgrade: this.handleUpgrade.bind(this),
        open: function open(ws) {
          ws.transport.socket = ws;
          ws.transport.writable = true;
          ws.transport.emit("drain");
        },
        message: function message(ws, _message, isBinary) {
          ws.transport.onData(isBinary ? _message : Buffer.from(_message).toString());
        },
        close: function close(ws, code, message) {
          ws.transport.onClose(code, message);
        }
      });
    }
  }, {
    key: "handleRequest",
    value: function handleRequest(res, req) {
      var _this = this;

      debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
      this.prepare(req, res);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this.emit("connection_error", {
            req: req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });

          _this.abortRequest(req.res, errorCode, errorContext);

          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return _this.abortRequest(res, errorCode, errorContext);
          };

          _this.handshake(req._query.transport, req, closeConnection);
        }
      };

      if (this.corsMiddleware) {
        // needed to buffer headers until the status is computed
        req.res = new ResponseWrapper(res);
        this.corsMiddleware.call(null, req, req.res, function () {
          _this.verify(req, false, callback);
        });
      } else {
        this.verify(req, false, callback);
      }
    }
  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(res, req, context) {
      var _this2 = this;

      debug("on upgrade");
      this.prepare(req, res); // @ts-ignore

      req.res = res;
      this.verify(req, true, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(errorCode, errorContext) {
          var id, transport, client;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!errorCode) {
                    _context.next = 4;
                    break;
                  }

                  _this2.emit("connection_error", {
                    req: req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext
                  });

                  _this2.abortRequest(res, errorCode, errorContext);

                  return _context.abrupt("return");

                case 4:
                  id = req._query.sid;

                  if (!id) {
                    _context.next = 10;
                    break;
                  }

                  client = _this2.clients[id];

                  if (!client) {
                    debug("upgrade attempt for closed client");
                    res.close();
                  } else if (client.upgrading) {
                    debug("transport has already been trying to upgrade");
                    res.close();
                  } else if (client.upgraded) {
                    debug("transport had already been upgraded");
                    res.close();
                  } else {
                    debug("upgrading existing transport");
                    transport = _this2.createTransport(req._query.transport, req);
                    client.maybeUpgrade(transport);
                  }

                  _context.next = 15;
                  break;

                case 10:
                  _context.next = 12;
                  return _this2.handshake(req._query.transport, req, function (errorCode, errorContext) {
                    return _this2.abortRequest(res, errorCode, errorContext);
                  });

                case 12:
                  transport = _context.sent;

                  if (transport) {
                    _context.next = 15;
                    break;
                  }

                  return _context.abrupt("return");

                case 15:
                  res.upgrade({
                    transport: transport
                  }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "abortRequest",
    value: function abortRequest(res, errorCode, errorContext) {
      var statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
      var message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
      res.writeStatus(statusCode);
      res.writeHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: errorCode,
        message: message
      }));
    }
  }]);

  return uServer;
}(server_1.BaseServer);

exports.uServer = uServer;

var ResponseWrapper = /*#__PURE__*/function () {
  function ResponseWrapper(res) {
    _classCallCheck(this, ResponseWrapper);

    this.res = res;
    this.statusWritten = false;
    this.headers = [];
  }

  _createClass(ResponseWrapper, [{
    key: "statusCode",
    set: function set(status) {
      this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
  }, {
    key: "setHeader",
    value: function setHeader(key, value) {
      this.writeHeader(key, value);
    } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134

  }, {
    key: "getHeader",
    value: function getHeader() {}
  }, {
    key: "writeStatus",
    value: function writeStatus(status) {
      this.res.writeStatus(status);
      this.statusWritten = true;
      this.writeBufferedHeaders();
    }
  }, {
    key: "writeHeader",
    value: function writeHeader(key, value) {
      if (key === "Content-Length") {
        // the content length is automatically added by uWebSockets.js
        return;
      }

      if (this.statusWritten) {
        this.res.writeHeader(key, value);
      } else {
        this.headers.push([key, value]);
      }
    }
  }, {
    key: "writeBufferedHeaders",
    value: function writeBufferedHeaders() {
      var _this3 = this;

      this.headers.forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            key = _ref3[0],
            value = _ref3[1];

        _this3.res.writeHeader(key, value);
      });
    }
  }, {
    key: "end",
    value: function end(data) {
      if (!this.statusWritten) {
        // status will be inferred as "200 OK"
        this.writeBufferedHeaders();
      }

      this.res.end(data);
    }
  }, {
    key: "onData",
    value: function onData(fn) {
      this.res.onData(fn);
    }
  }, {
    key: "onAborted",
    value: function onAborted(fn) {
      this.res.onAborted(fn);
    }
  }]);

  return ResponseWrapper;
}();

/***/ }),

/***/ "./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RemoteSocket = exports.BroadcastOperator = void 0;

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var BroadcastOperator = /*#__PURE__*/function () {
  function BroadcastOperator(adapter) {
    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, BroadcastOperator);

    this.adapter = adapter;
    this.rooms = rooms;
    this.exceptRooms = exceptRooms;
    this.flags = flags;
  }
  /**
   * Targets a room when emitting.
   *
   * @param room
   * @return a new BroadcastOperator instance
   * @public
   */


  _createClass(BroadcastOperator, [{
    key: "to",
    value: function to(room) {
      var rooms = new Set(this.rooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return rooms.add(r);
        });
      } else {
        rooms.add(room);
      }

      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      var exceptRooms = new Set(this.exceptRooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return exceptRooms.add(r);
        });
      } else {
        exceptRooms.add(room);
      }

      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      var flags = _extends({}, this.flags, {
        compress: _compress
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      var flags = _extends({}, this.flags, {
        "volatile": true
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      var flags = _extends({}, this.flags, {
        local: true
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (socket_1.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      } // set up packet object


      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      };

      if ("function" == typeof data[data.length - 1]) {
        throw new Error("Callbacks are not supported when broadcasting");
      }

      this.adapter.broadcast(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      });
      return true;
    }
    /**
     * Gets a list of clients.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }

      return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      var _this = this;

      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }).then(function (sockets) {
        return sockets.map(function (socket) {
          if (socket instanceof socket_1.Socket) {
            // FIXME the TypeScript compiler complains about missing private properties
            return socket;
          } else {
            return new RemoteSocket(_this.adapter, socket);
          }
        });
      });
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, close);
    }
  }]);

  return BroadcastOperator;
}();

exports.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */

var RemoteSocket = /*#__PURE__*/function () {
  function RemoteSocket(adapter, details) {
    _classCallCheck(this, RemoteSocket);

    this.id = details.id;
    this.handshake = details.handshake;
    this.rooms = new Set(details.rooms);
    this.data = details.data;
    this.operator = new BroadcastOperator(adapter, new Set([this.id]));
  }

  _createClass(RemoteSocket, [{
    key: "emit",
    value: function emit(ev) {
      var _this$operator;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     * @public
     */

  }, {
    key: "join",
    value: function join(room) {
      return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     * @public
     */

  }, {
    key: "leave",
    value: function leave(room) {
      return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     *
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.operator.disconnectSockets(close);
      return this;
    }
  }]);

  return RemoteSocket;
}();

exports.RemoteSocket = RemoteSocket;

/***/ }),

/***/ "./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Client = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var debugModule = __webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var debug = debugModule("socket.io:client");

var Client = /*#__PURE__*/function () {
  /**
   * Client constructor.
   *
   * @param server instance
   * @param conn
   * @package
   */
  function Client(server, conn) {
    _classCallCheck(this, Client);

    this.sockets = new Map();
    this.nsps = new Map();
    this.server = server;
    this.conn = conn;
    this.encoder = server.encoder;
    this.decoder = new server._parser.Decoder();
    this.id = conn.id;
    this.setup();
  }
  /**
   * @return the reference to the request that originated the Engine.IO connection
   *
   * @public
   */


  _createClass(Client, [{
    key: "request",
    get: function get() {
      return this.conn.request;
    }
    /**
     * Sets up event listeners.
     *
     * @private
     */

  }, {
    key: "setup",
    value: function setup() {
      var _this = this;

      this.onclose = this.onclose.bind(this);
      this.ondata = this.ondata.bind(this);
      this.onerror = this.onerror.bind(this);
      this.ondecoded = this.ondecoded.bind(this); // @ts-ignore

      this.decoder.on("decoded", this.ondecoded);
      this.conn.on("data", this.ondata);
      this.conn.on("error", this.onerror);
      this.conn.on("close", this.onclose);
      this.connectTimeout = setTimeout(function () {
        if (_this.nsps.size === 0) {
          debug("no namespace joined yet, close the client");

          _this.close();
        } else {
          debug("the client has already joined a namespace, nothing to do");
        }
      }, this.server._connectTimeout);
    }
    /**
     * Connects a client to a namespace.
     *
     * @param {String} name - the namespace
     * @param {Object} auth - the auth parameters
     * @private
     */

  }, {
    key: "connect",
    value: function connect(name) {
      var _this2 = this;

      var auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.server._nsps.has(name)) {
        debug("connecting to namespace %s", name);
        return this.doConnect(name, auth);
      }

      this.server._checkNamespace(name, auth, function (dynamicNspName) {
        if (dynamicNspName) {
          _this2.doConnect(name, auth);
        } else {
          debug("creation of namespace %s was denied", name);

          _this2._packet({
            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
            nsp: name,
            data: {
              message: "Invalid namespace"
            }
          });
        }
      });
    }
    /**
     * Connects a client to a namespace.
     *
     * @param name - the namespace
     * @param {Object} auth - the auth parameters
     *
     * @private
     */

  }, {
    key: "doConnect",
    value: function doConnect(name, auth) {
      var _this3 = this;

      var nsp = this.server.of(name);

      var socket = nsp._add(this, auth, function () {
        _this3.sockets.set(socket.id, socket);

        _this3.nsps.set(nsp.name, socket);

        if (_this3.connectTimeout) {
          clearTimeout(_this3.connectTimeout);
          _this3.connectTimeout = undefined;
        }
      });
    }
    /**
     * Disconnects from all namespaces and closes transport.
     *
     * @private
     */

  }, {
    key: "_disconnect",
    value: function _disconnect() {
      var _iterator = _createForOfIteratorHelper(this.sockets.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var socket = _step.value;
          socket.disconnect();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.sockets.clear();
      this.close();
    }
    /**
     * Removes a socket. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        var nsp = this.sockets.get(socket.id).nsp.name;
        this.sockets["delete"](socket.id);
        this.nsps["delete"](nsp);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Closes the underlying connection.
     *
     * @private
     */

  }, {
    key: "close",
    value: function close() {
      if ("open" === this.conn.readyState) {
        debug("forcing transport close");
        this.conn.close();
        this.onclose("forced server close");
      }
    }
    /**
     * Writes a packet to the transport.
     *
     * @param {Object} packet object
     * @param {Object} opts
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.conn.readyState !== "open") {
        debug("ignoring packet write %j", packet);
        return;
      }

      var encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()
      : this.encoder.encode(packet);
      this.writeToEngine(encodedPackets, opts);
    }
  }, {
    key: "writeToEngine",
    value: function writeToEngine(encodedPackets, opts) {
      if (opts["volatile"] && !this.conn.transport.writable) {
        debug("volatile packet is discarded since the transport is not currently writable");
        return;
      }

      var packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];

      var _iterator2 = _createForOfIteratorHelper(packets),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var encodedPacket = _step2.value;
          this.conn.write(encodedPacket, opts);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Called with incoming transport data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      // try/catch is needed for protocol violations (GH-1880)
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onerror(e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      if (socket_io_parser_1.PacketType.CONNECT === packet.type) {
        if (this.conn.protocol === 3) {
          var parsed = url.parse(packet.nsp, true);
          this.connect(parsed.pathname, parsed.query);
        } else {
          this.connect(packet.nsp, packet.data);
        }
      } else {
        var socket = this.nsps.get(packet.nsp);

        if (socket) {
          process.nextTick(function () {
            socket._onpacket(packet);
          });
        } else {
          debug("no socket for namespace %s", packet.nsp);
        }
      }
    }
    /**
     * Handles an error.
     *
     * @param {Object} err object
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      var _iterator3 = _createForOfIteratorHelper(this.sockets.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var socket = _step3.value;

          socket._onerror(err);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.conn.close();
    }
    /**
     * Called upon transport close.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("client close with reason %s", reason); // ignore a potential subsequent `close` event

      this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly

      var _iterator4 = _createForOfIteratorHelper(this.sockets.values()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var socket = _step4.value;

          socket._onclose(reason);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.sockets.clear();
      this.decoder.destroy(); // clean up decoder
    }
    /**
     * Cleans up event listeners.
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.conn.removeListener("data", this.ondata);
      this.conn.removeListener("error", this.onerror);
      this.conn.removeListener("close", this.onclose); // @ts-ignore

      this.decoder.removeListener("decoded", this.ondecoded);

      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }
    }
  }]);

  return Client;
}();

exports.Client = Client;

/***/ }),

/***/ "./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __dirname = "/";


function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Namespace = exports.Socket = exports.Server = void 0;

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var engine_io_1 = __webpack_require__(/*! engine.io */ "./node_modules/engine.io/build/engine.io.js");

var client_1 = __webpack_require__(/*! ./client */ "./node_modules/socket.io/dist/client.js");

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/socket.io/dist/namespace.js");

Object.defineProperty(exports, "Namespace", ({
  enumerable: true,
  get: function get() {
    return namespace_1.Namespace;
  }
}));

var parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ "./node_modules/socket.io/dist/parent-namespace.js");

var socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "./node_modules/socket.io-adapter/dist/index.js");

var parser = __importStar(__webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js"));

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

Object.defineProperty(exports, "Socket", ({
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
}));

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var uws_js_1 = __webpack_require__(/*! ./uws.js */ "./node_modules/socket.io/dist/uws.js");

var debug = (0, debug_1["default"])("socket.io:server");

var clientVersion = (__webpack_require__(/*! ../package.json */ "./node_modules/socket.io/package.json").version);

var dotMapRegex = /\.map/;

var Server = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Server, _typed_events_1$Stric);

  var _super = _createSuper(Server);

  function Server(srv) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Server);

    _this = _super.call(this);
    /**
     * @private
     */

    _this._nsps = new Map();
    _this.parentNsps = new Map();

    if ("object" === _typeof(srv) && srv instanceof Object && !srv.listen) {
      opts = srv;
      srv = undefined;
    }

    _this.path(opts.path || "/socket.io");

    _this.connectTimeout(opts.connectTimeout || 45000);

    _this.serveClient(false !== opts.serveClient);

    _this._parser = opts.parser || parser;
    _this.encoder = new _this._parser.Encoder();

    _this.adapter(opts.adapter || socket_io_adapter_1.Adapter);

    _this.sockets = _this.of("/");
    _this.opts = opts;
    if (srv || typeof srv == "number") _this.attach(srv);
    return _this;
  }

  _createClass(Server, [{
    key: "serveClient",
    value: function serveClient(v) {
      if (!arguments.length) return this._serveClient;
      this._serveClient = v;
      return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */

  }, {
    key: "_checkNamespace",
    value: function _checkNamespace(name, auth, fn) {
      var _this2 = this;

      if (this.parentNsps.size === 0) return fn(false);
      var keysIterator = this.parentNsps.keys();

      var run = function run() {
        var nextFn = keysIterator.next();

        if (nextFn.done) {
          return fn(false);
        }

        nextFn.value(name, auth, function (err, allow) {
          if (err || !allow) {
            return run();
          }

          if (_this2._nsps.has(name)) {
            // the namespace was created in the meantime
            debug("dynamic namespace %s already exists", name);
            return fn(_this2._nsps.get(name));
          }

          var namespace = _this2.parentNsps.get(nextFn.value).createChild(name);

          debug("dynamic namespace %s was created", name); // @ts-ignore

          _this2.sockets.emitReserved("new_namespace", namespace);

          fn(namespace);
        });
      };

      run();
    }
  }, {
    key: "path",
    value: function path(v) {
      if (!arguments.length) return this._path;
      this._path = v.replace(/\/$/, "");

      var escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");

      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
      return this;
    }
  }, {
    key: "connectTimeout",
    value: function connectTimeout(v) {
      if (v === undefined) return this._connectTimeout;
      this._connectTimeout = v;
      return this;
    }
  }, {
    key: "adapter",
    value: function adapter(v) {
      if (!arguments.length) return this._adapter;
      this._adapter = v;

      var _iterator = _createForOfIteratorHelper(this._nsps.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var nsp = _step.value;

          nsp._initAdapter();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "listen",
    value: function listen(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "attach",
    value: function attach(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ("function" == typeof srv) {
        var msg = "You are trying to attach socket.io to an express " + "request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      } // handle a port as a string


      if (Number(srv) == srv) {
        srv = Number(srv);
      }

      if ("number" == typeof srv) {
        debug("creating http server and binding to %d", srv);
        var port = srv;
        srv = http.createServer(function (req, res) {
          res.writeHead(404);
          res.end();
        });
        srv.listen(port);
      } // merge the options passed to the Socket.IO server


      _extends(opts, this.opts); // set engine.io path to `/socket.io`


      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
  }, {
    key: "attachApp",
    value: function attachApp(app
    /*: TemplatedApp */
    ) {
      var _this3 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // merge the options passed to the Socket.IO server
      _extends(opts, this.opts); // set engine.io path to `/socket.io`


      opts.path = opts.path || this._path; // initialize engine

      debug("creating uWebSockets.js-based engine with opts %j", opts);
      var engine = new engine_io_1.uServer(opts);
      engine.attach(app, opts); // bind to engine events

      this.bind(engine);

      if (this._serveClient) {
        // attach static file serving
        app.get("".concat(this._path, "/*"), function (res, req) {
          if (!_this3.clientPathRegex.test(req.getUrl())) {
            req.setYield(true);
            return;
          }

          var filename = req.getUrl().replace(_this3._path, "").replace(/\?.*$/, "").replace(/^\//, "");
          var isMap = dotMapRegex.test(filename);
          var type = isMap ? "map" : "source"; // Per the standard, ETags must be quoted:
          // https://tools.ietf.org/html/rfc7232#section-2.3

          var expectedEtag = '"' + clientVersion + '"';
          var weakEtag = "W/" + expectedEtag;
          var etag = req.getHeader("if-none-match");

          if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
              debug("serve client %s 304", type);
              res.writeStatus("304 Not Modified");
              res.end();
              return;
            }
          }

          debug("serve client %s", type);
          res.writeHeader("cache-control", "public, max-age=0");
          res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript"));
          res.writeHeader("etag", expectedEtag);
          var filepath = path.join(__dirname, "../client-dist/", filename);
          (0, uws_js_1.serveFile)(res, filepath);
        });
      }

      (0, uws_js_1.patchAdapter)(app);
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */

  }, {
    key: "initEngine",
    value: function initEngine(srv, opts) {
      // initialize engine
      debug("creating engine.io instance with opts %j", opts);
      this.eio = (0, engine_io_1.attach)(srv, opts); // attach static file serving

      if (this._serveClient) this.attachServe(srv); // Export http server

      this.httpServer = srv; // bind to engine events

      this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */

  }, {
    key: "attachServe",
    value: function attachServe(srv) {
      var _this4 = this;

      debug("attaching client serving req handler");
      var evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", function (req, res) {
        if (_this4.clientPathRegex.test(req.url)) {
          _this4.serve(req, res);
        } else {
          for (var i = 0; i < evs.length; i++) {
            evs[i].call(srv, req, res);
          }
        }
      });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "serve",
    value: function serve(req, res) {
      var filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
      var isMap = dotMapRegex.test(filename);
      var type = isMap ? "map" : "source"; // Per the standard, ETags must be quoted:
      // https://tools.ietf.org/html/rfc7232#section-2.3

      var expectedEtag = '"' + clientVersion + '"';
      var weakEtag = "W/" + expectedEtag;
      var etag = req.headers["if-none-match"];

      if (etag) {
        if (expectedEtag === etag || weakEtag === etag) {
          debug("serve client %s 304", type);
          res.writeHead(304);
          res.end();
          return;
        }
      }

      debug("serve client %s", type);
      res.setHeader("Cache-Control", "public, max-age=0");
      res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript"));
      res.setHeader("ETag", expectedEtag);
      Server.sendFile(filename, req, res);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "bind",
    value:
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param {engine.Server} engine engine.io (or compatible) server
     * @return self
     * @public
     */
    function bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */

  }, {
    key: "onconnection",
    value: function onconnection(conn) {
      debug("incoming connection with id %s", conn.id);
      var client = new client_1.Client(this, conn);

      if (conn.protocol === 3) {
        // @ts-ignore
        client.connect("/");
      }

      return this;
    }
    /**
     * Looks up a namespace.
     *
     * @param {String|RegExp|Function} name nsp name
     * @param fn optional, nsp `connection` ev handler
     * @public
     */

  }, {
    key: "of",
    value: function of(name, fn) {
      if (typeof name === "function" || name instanceof RegExp) {
        var parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug("initializing parent namespace %s", parentNsp.name);

        if (typeof name === "function") {
          this.parentNsps.set(name, parentNsp);
        } else {
          this.parentNsps.set(function (nsp, conn, next) {
            return next(null, name.test(nsp));
          }, parentNsp);
        }

        if (fn) {
          // @ts-ignore
          parentNsp.on("connect", fn);
        }

        return parentNsp;
      }

      if (String(name)[0] !== "/") name = "/" + name;

      var nsp = this._nsps.get(name);

      if (!nsp) {
        debug("initializing namespace %s", name);
        nsp = new namespace_1.Namespace(this, name);

        this._nsps.set(name, nsp);

        if (name !== "/") {
          // @ts-ignore
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }

      if (fn) nsp.on("connect", fn);
      return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     * @public
     */

  }, {
    key: "close",
    value: function close(fn) {
      var _iterator2 = _createForOfIteratorHelper(this.sockets.sockets.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var socket = _step2.value;

          socket._onclose("server shutting down");
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.engine.close(); // restore the Adapter prototype

      (0, uws_js_1.restoreAdapter)();

      if (this.httpServer) {
        this.httpServer.close(fn);
      } else {
        fn && fn();
      }
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.sockets.use(fn);
      return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.sockets["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param name
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(name) {
      return this.sockets.except(name);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      var _this$sockets;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_this$sockets = this.sockets).emit.apply(_this$sockets, ["message"].concat(args));

      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      var _this$sockets2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_this$sockets2 = this.sockets).emit.apply(_this$sockets2, ["message"].concat(args));

      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      var _this$sockets3;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_this$sockets3 = this.sockets).serverSideEmit.apply(_this$sockets3, [ev].concat(args));
    }
    /**
     * Gets a list of socket ids.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return this.sockets.compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      return this.sockets["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return this.sockets.local;
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.sockets.disconnectSockets(close);
    }
  }], [{
    key: "sendFile",
    value: function sendFile(filename, req, res) {
      var readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
      var encoding = accepts(req).encodings(["br", "gzip", "deflate"]);

      var onError = function onError(err) {
        if (err) {
          res.end();
        }
      };

      switch (encoding) {
        case "br":
          res.writeHead(200, {
            "content-encoding": "br"
          });
          readStream.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
          break;

        case "gzip":
          res.writeHead(200, {
            "content-encoding": "gzip"
          });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
          break;

        case "deflate":
          res.writeHead(200, {
            "content-encoding": "deflate"
          });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
          break;

        default:
          res.writeHead(200);
          (0, stream_1.pipeline)(readStream, res, onError);
      }
    }
  }]);

  return Server;
}(typed_events_1.StrictEventEmitter);

exports.Server = Server;
/**
 * Expose main namespace (/).
 */

var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
  return typeof events_1.EventEmitter.prototype[key] === "function";
});
emitterMethods.forEach(function (fn) {
  Server.prototype[fn] = function () {
    return this.sockets[fn].apply(this.sockets, arguments);
  };
});

module.exports = function (srv, opts) {
  return new Server(srv, opts);
};

module.exports.Server = Server;
module.exports.Namespace = namespace_1.Namespace;
module.exports.Socket = socket_1.Socket;

/***/ }),

/***/ "./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Namespace = exports.RESERVED_EVENTS = void 0;

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "./node_modules/socket.io/dist/broadcast-operator.js");

var debug = (0, debug_1["default"])("socket.io:namespace");
exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);

var Namespace = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Namespace, _typed_events_1$Stric);

  var _super = _createSuper(Namespace);

  /**
   * Namespace constructor.
   *
   * @param server instance
   * @param name
   */
  function Namespace(server, name) {
    var _this;

    _classCallCheck(this, Namespace);

    _this = _super.call(this);
    _this.sockets = new Map();
    /** @private */

    _this._fns = [];
    /** @private */

    _this._ids = 0;
    _this.server = server;
    _this.name = name;

    _this._initAdapter();

    return _this;
  }
  /**
   * Initializes the `Adapter` for this nsp.
   * Run upon changing adapter by `Server#adapter`
   * in addition to the constructor.
   *
   * @private
   */


  _createClass(Namespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      // @ts-ignore
      this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this._fns.push(fn);

      return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(socket, fn) {
      var fns = this._fns.slice(0);

      if (!fns.length) return fn(null);

      function run(i) {
        fns[i](socket, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(null); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */

  }, {
    key: "_add",
    value: function _add(client, query, fn) {
      var _this2 = this;

      debug("adding socket to nsp %s", this.name);
      var socket = new socket_1.Socket(this, client, query);
      this.run(socket, function (err) {
        process.nextTick(function () {
          if ("open" == client.conn.readyState) {
            if (err) {
              if (client.conn.protocol === 3) {
                return socket._error(err.data || err.message);
              } else {
                return socket._error({
                  message: err.message,
                  data: err.data
                });
              }
            } // track socket


            _this2.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic
            // fires before user-set events to prevent state order
            // violations (such as a disconnection before the connection
            // logic is complete)


            socket._onconnect();

            if (fn) fn(); // fire user-set events

            _this2.emitReserved("connect", socket);

            _this2.emitReserved("connection", socket);
          } else {
            debug("next called after client was closed - ignoring socket");
          }
        });
      });
      return socket;
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        this.sockets["delete"](socket.id);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _broadcast_operator_;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_broadcast_operator_ = new broadcast_operator_1.BroadcastOperator(this.adapter)).emit.apply(_broadcast_operator_, [ev].concat(args));
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      }

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */

  }, {
    key: "_onServerSideEmit",
    value: function _onServerSideEmit(args) {
      _get(_getPrototypeOf(Namespace.prototype), "emitUntyped", this).apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }]);

  return Namespace;
}(typed_events_1.StrictEventEmitter);

exports.Namespace = Namespace;

/***/ }),

/***/ "./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ParentNamespace = void 0;

var namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/socket.io/dist/namespace.js");

var ParentNamespace = /*#__PURE__*/function (_namespace_1$Namespac) {
  _inherits(ParentNamespace, _namespace_1$Namespac);

  var _super = _createSuper(ParentNamespace);

  function ParentNamespace(server) {
    var _this;

    _classCallCheck(this, ParentNamespace);

    _this = _super.call(this, server, "/_" + ParentNamespace.count++);
    _this.children = new Set();
    return _this;
  }
  /**
   * @private
   */


  _createClass(ParentNamespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      var _this2 = this;

      var broadcast = function broadcast(packet, opts) {
        _this2.children.forEach(function (nsp) {
          nsp.adapter.broadcast(packet, opts);
        });
      }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?


      this.adapter = {
        broadcast: broadcast
      };
    }
  }, {
    key: "emit",
    value: function emit(ev) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.children.forEach(function (nsp) {
        nsp.emit.apply(nsp, [ev].concat(args));
      });
      return true;
    }
  }, {
    key: "createChild",
    value: function createChild(name) {
      var namespace = new namespace_1.Namespace(this.server, name);
      namespace._fns = this._fns.slice(0);
      this.listeners("connect").forEach(function (listener) {
        return namespace.on("connect", listener);
      });
      this.listeners("connection").forEach(function (listener) {
        return namespace.on("connection", listener);
      });
      this.children.add(namespace);

      this.server._nsps.set(name, namespace);

      return namespace;
    }
  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
      // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
      // the behavior for namespaces created with a function is less clear
      // note²: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
      // may exist on one node but not exist on another (since it is created upon client connection)
      throw new Error("fetchSockets() is not supported on parent namespaces");
    }
  }]);

  return ParentNamespace;
}(namespace_1.Namespace);

exports.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;

/***/ }),

/***/ "./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Socket = exports.RESERVED_EVENTS = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var base64id_1 = __importDefault(__webpack_require__(/*! base64id */ "./node_modules/base64id/lib/base64id.js"));

var broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "./node_modules/socket.io/dist/broadcast-operator.js");

var debug = (0, debug_1["default"])("socket.io:socket");
exports.RESERVED_EVENTS = new Set(["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]);

var Socket = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Socket, _typed_events_1$Stric);

  var _super = _createSuper(Socket);

  /**
   * Interface to a `Client` for a given `Namespace`.
   *
   * @param {Namespace} nsp
   * @param {Client} client
   * @param {Object} auth
   * @package
   */
  function Socket(nsp, client, auth) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.nsp = nsp;
    _this.client = client;
    /**
     * Additional information that can be attached to the Socket instance and which will be used in the fetchSockets method
     */

    _this.data = {};
    _this.connected = false;
    _this.acks = new Map();
    _this.fns = [];
    _this.flags = {};
    _this.server = nsp.server;
    _this.adapter = _this.nsp.adapter;

    if (client.conn.protocol === 3) {
      // @ts-ignore
      _this.id = nsp.name !== "/" ? nsp.name + "#" + client.id : client.id;
    } else {
      _this.id = base64id_1["default"].generateId(); // don't reuse the Engine.IO id because it's sensitive information
    }

    _this.handshake = _this.buildHandshake(auth);
    return _this;
  }
  /**
   * Builds the `handshake` BC object
   *
   * @private
   */


  _createClass(Socket, [{
    key: "buildHandshake",
    value: function buildHandshake(auth) {
      return {
        headers: this.request.headers,
        time: new Date() + "",
        address: this.conn.remoteAddress,
        xdomain: !!this.request.headers.origin,
        // @ts-ignore
        secure: !!this.request.connection.encrypted,
        issued: +new Date(),
        url: this.request.url,
        // @ts-ignore
        query: this.request._query,
        auth: auth
      };
    }
    /**
     * Emits to this client.
     *
     * @return Always returns `true`.
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      }; // access last argument to see if it's an ACK callback

      if (typeof data[data.length - 1] === "function") {
        var id = this.nsp._ids++;
        debug("emitting packet with ack id %d", id);
        this.registerAckCallback(id, data.pop());
        packet.id = id;
      }

      var flags = _extends({}, this.flags);

      this.flags = {};
      this.packet(packet, flags);
      return true;
    }
    /**
     * @private
     */

  }, {
    key: "registerAckCallback",
    value: function registerAckCallback(id, ack) {
      var _this2 = this;

      var timeout = this.flags.timeout;

      if (timeout === undefined) {
        this.acks.set(id, ack);
        return;
      }

      var timer = setTimeout(function () {
        debug("event with ack id %d has timed out after %d ms", id, timeout);

        _this2.acks["delete"](id);

        ack.call(_this2, new Error("operation has timed out"));
      }, timeout);
      this.acks.set(id, function () {
        clearTimeout(timer);

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        ack.apply(_this2, [null].concat(args));
      });
    }
    /**
     * Targets a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return this.newBroadcastOperator().to(room);
    }
    /**
     * Targets a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.newBroadcastOperator()["in"](room);
    }
    /**
     * Excludes a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      return this.newBroadcastOperator().except(room);
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Writes a packet.
     *
     * @param {Object} packet - packet object
     * @param {Object} opts - options
     * @private
     */

  }, {
    key: "packet",
    value: function packet(_packet) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _packet.nsp = this.nsp.name;
      opts.compress = false !== opts.compress;

      this.client._packet(_packet, opts);
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} rooms - room or array of rooms
     * @return a Promise or nothing, depending on the adapter
     * @public
     */

  }, {
    key: "join",
    value: function join(rooms) {
      debug("join room %s", rooms);
      return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     * @return a Promise or nothing, depending on the adapter
     * @public
     */

  }, {
    key: "leave",
    value: function leave(room) {
      debug("leave room %s", room);
      return this.adapter.del(this.id, room);
    }
    /**
     * Leave all rooms.
     *
     * @private
     */

  }, {
    key: "leaveAll",
    value: function leaveAll() {
      this.adapter.delAll(this.id);
    }
    /**
     * Called by `Namespace` upon successful
     * middleware execution (ie: authorization).
     * Socket is added to namespace array before
     * call to join, so adapters can access it.
     *
     * @private
     */

  }, {
    key: "_onconnect",
    value: function _onconnect() {
      debug("socket connected - writing packet");
      this.connected = true;
      this.join(this.id);

      if (this.conn.protocol === 3) {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT
        });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: {
            sid: this.id
          }
        });
      }
    }
    /**
     * Called with each packet. Called by `Client`.
     *
     * @param {Object} packet
     * @private
     */

  }, {
    key: "_onpacket",
    value: function _onpacket(packet) {
      debug("got packet %j", packet);

      switch (packet.type) {
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this._onerror(new Error(packet.data));

      }
    }
    /**
     * Called upon event packet.
     *
     * @param {Packet} packet - packet object
     * @private
     */

  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);

      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }

      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      this.dispatch(args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @param {Number} id - packet id
     * @private
     */

  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        var args = Array.prototype.slice.call(arguments);
        debug("sending ack %j", args);
        self.packet({
          id: id,
          type: socket_io_parser_1.PacketType.ACK,
          data: args
        });
        sent = true;
      };
    }
    /**
     * Called upon ack packet.
     *
     * @private
     */

  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks.get(packet.id);

      if ("function" == typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        this.acks["delete"](packet.id);
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon client disconnect packet.
     *
     * @private
     */

  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("got disconnect packet");

      this._onclose("client namespace disconnect");
    }
    /**
     * Handles a client error.
     *
     * @private
     */

  }, {
    key: "_onerror",
    value: function _onerror(err) {
      if (this.listeners("error").length) {
        this.emitReserved("error", err);
      } else {
        console.error("Missing error handler on `socket`.");
        console.error(err.stack);
      }
    }
    /**
     * Called upon closing. Called by `Client`.
     *
     * @param {String} reason
     * @throw {Error} optional error object
     *
     * @private
     */

  }, {
    key: "_onclose",
    value: function _onclose(reason) {
      if (!this.connected) return this;
      debug("closing socket - reason %s", reason);
      this.emitReserved("disconnecting", reason);
      this.leaveAll();

      this.nsp._remove(this);

      this.client._remove(this);

      this.connected = false;
      this.emitReserved("disconnect", reason);
      return;
    }
    /**
     * Produces an `error` packet.
     *
     * @param {Object} err - error object
     *
     * @private
     */

  }, {
    key: "_error",
    value: function _error(err) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT_ERROR,
        data: err
      });
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     *
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.connected) return this;

      if (close) {
        this.client._disconnect();
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });

        this._onclose("server namespace disconnect");
      }

      return this;
    }
    /**
     * Sets the compress flag.
     *
     * @param {Boolean} compress - if `true`, compresses the sending data
     * @return {Socket} self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because they’re connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
     * sender.
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "broadcast",
    get: function get() {
      return this.newBroadcastOperator();
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return this.newBroadcastOperator().local;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the client:
     *
     * ```
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the client did not acknowledge the event in the given delay
     *   }
     * });
     * ```
     *
     * @returns self
     * @public
     */

  }, {
    key: "timeout",
    value: function timeout(_timeout) {
      this.flags.timeout = _timeout;
      return this;
    }
    /**
     * Dispatch incoming event to socket listeners.
     *
     * @param {Array} event - event that will get emitted
     * @private
     */

  }, {
    key: "dispatch",
    value: function dispatch(event) {
      var _this3 = this;

      debug("dispatching an event %j", event);
      this.run(event, function (err) {
        process.nextTick(function () {
          if (err) {
            return _this3._onerror(err);
          }

          if (_this3.connected) {
            _get(_getPrototypeOf(Socket.prototype), "emitUntyped", _this3).apply(_this3, event);
          } else {
            debug("ignore packet received after disconnection");
          }
        });
      });
    }
    /**
     * Sets up socket middleware.
     *
     * @param {Function} fn - middleware function (event, next)
     * @return {Socket} self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.fns.push(fn);
      return this;
    }
    /**
     * Executes the middleware for an incoming event.
     *
     * @param {Array} event - event that will get emitted
     * @param {Function} fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(event, fn) {
      var fns = this.fns.slice(0);
      if (!fns.length) return fn(null);

      function run(i) {
        fns[i](event, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(null); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Whether the socket is currently disconnected
     */

  }, {
    key: "disconnected",
    get: function get() {
      return !this.connected;
    }
    /**
     * A reference to the request that originated the underlying Engine.IO Socket.
     *
     * @public
     */

  }, {
    key: "request",
    get: function get() {
      return this.client.request;
    }
    /**
     * A reference to the underlying Client transport connection (Engine.IO Socket object).
     *
     * @public
     */

  }, {
    key: "conn",
    get: function get() {
      return this.client.conn;
    }
    /**
     * @public
     */

  }, {
    key: "rooms",
    get: function get() {
      return this.adapter.socketRooms(this.id) || new Set();
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */

  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.push(listener);

      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */

  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.unshift(listener);

      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */

  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }

      if (listener) {
        var listeners = this._anyListeners;

        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }

      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */

  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
  }, {
    key: "newBroadcastOperator",
    value: function newBroadcastOperator() {
      var flags = _extends({}, this.flags);

      this.flags = {};
      return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
    }
  }]);

  return Socket;
}(typed_events_1.StrictEventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StrictEventEmitter = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */


var StrictEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(StrictEventEmitter, _events_1$EventEmitte);

  var _super = _createSuper(StrictEventEmitter);

  function StrictEventEmitter() {
    _classCallCheck(this, StrictEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(StrictEventEmitter, [{
    key: "on",
    value:
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    function on(ev, listener) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "on", this).call(this, ev, listener);
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */

  }, {
    key: "once",
    value: function once(ev, listener) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "once", this).call(this, ev, listener);
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitReserved",
    value: function emitReserved(ev) {
      var _get3;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_get3 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, ev].concat(args));
    }
    /**
     * Emits an event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can get around the strict typing. This is useful for
     * calling `emit.apply`, which can be called as `emitUntyped.apply`.
     *
     * @param ev Event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitUntyped",
    value: function emitUntyped(ev) {
      var _get4;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_get4 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get4, [this, ev].concat(args));
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */

  }, {
    key: "listeners",
    value: function listeners(event) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "listeners", this).call(this, event);
    }
  }]);

  return StrictEventEmitter;
}(events_1.EventEmitter);

exports.StrictEventEmitter = StrictEventEmitter;

/***/ }),

/***/ "./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serveFile = exports.restoreAdapter = exports.patchAdapter = void 0;

var socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "./node_modules/socket.io-adapter/dist/index.js");

var fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var debug = (0, debug_1["default"])("socket.io:adapter-uws");
var SEPARATOR = "\x1f"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var _socket_io_adapter_1$ = socket_io_adapter_1.Adapter.prototype,
    addAll = _socket_io_adapter_1$.addAll,
    del = _socket_io_adapter_1$.del,
    broadcast = _socket_io_adapter_1$.broadcast;

function patchAdapter(app
/* : TemplatedApp */
) {
  socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
    var _this = this;

    var isNew = !this.sids.has(id);
    addAll.call(this, id, rooms);
    var socket = this.nsp.sockets.get(id);

    if (!socket) {
      return;
    }

    if (socket.conn.transport.name === "websocket") {
      subscribe(this.nsp.name, socket, isNew, rooms);
      return;
    }

    if (isNew) {
      socket.conn.on("upgrade", function () {
        var rooms = _this.sids.get(id);

        subscribe(_this.nsp.name, socket, isNew, rooms);
      });
    }
  };

  socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
    del.call(this, id, room);
    var socket = this.nsp.sockets.get(id);

    if (socket && socket.conn.transport.name === "websocket") {
      // @ts-ignore
      var sessionId = socket.conn.id; // @ts-ignore

      var websocket = socket.conn.transport.socket;
      var topic = "".concat(this.nsp.name).concat(SEPARATOR).concat(room);
      debug("unsubscribe connection %s from topic %s", sessionId, topic);
      websocket.unsubscribe(topic);
    }
  };

  socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
    var useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;

    if (!useFastPublish) {
      broadcast.call(this, packet, opts);
      return;
    }

    var flags = opts.flags || {};
    var basePacketOpts = {
      preEncoded: true,
      "volatile": flags["volatile"],
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    var encodedPackets = this.encoder.encode(packet);
    var topic = opts.rooms.size === 0 ? this.nsp.name : "".concat(this.nsp.name).concat(SEPARATOR).concat(opts.rooms.keys().next().value);
    debug("fast publish to %s", topic); // fast publish for clients connected with WebSocket

    encodedPackets.forEach(function (encodedPacket) {
      var isBinary = typeof encodedPacket !== "string"; // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol

      app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
    });
    this.apply(opts, function (socket) {
      if (socket.conn.transport.name !== "websocket") {
        // classic publish for clients connected with HTTP long-polling
        socket.client.writeToEngine(encodedPackets, basePacketOpts);
      }
    });
  };
}

exports.patchAdapter = patchAdapter;

function subscribe(namespaceName, socket, isNew, rooms) {
  // @ts-ignore
  var sessionId = socket.conn.id; // @ts-ignore

  var websocket = socket.conn.transport.socket;

  if (isNew) {
    debug("subscribe connection %s to topic %s", sessionId, namespaceName);
    websocket.subscribe(namespaceName);
  }

  rooms.forEach(function (room) {
    var topic = "".concat(namespaceName).concat(SEPARATOR).concat(room); // '#' can be used as wildcard

    debug("subscribe connection %s to topic %s", sessionId, topic);
    websocket.subscribe(topic);
  });
}

function restoreAdapter() {
  socket_io_adapter_1.Adapter.prototype.addAll = addAll;
  socket_io_adapter_1.Adapter.prototype.del = del;
  socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}

exports.restoreAdapter = restoreAdapter;

var toArrayBuffer = function toArrayBuffer(buffer) {
  var arrayBuffer = buffer.buffer,
      byteOffset = buffer.byteOffset,
      byteLength = buffer.byteLength;
  return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
}; // imported from https://github.com/kolodziejczak-sz/uwebsocket-serve


function serveFile(res
/* : HttpResponse */
, filepath) {
  var _ref = (0, fs_1.statSync)(filepath),
      size = _ref.size;

  var readStream = (0, fs_1.createReadStream)(filepath);

  var destroyReadStream = function destroyReadStream() {
    return !readStream.destroyed && readStream.destroy();
  };

  var onError = function onError(error) {
    destroyReadStream();
    throw error;
  };

  var onDataChunk = function onDataChunk(chunk) {
    var arrayBufferChunk = toArrayBuffer(chunk);
    var lastOffset = res.getWriteOffset();

    var _res$tryEnd = res.tryEnd(arrayBufferChunk, size),
        _res$tryEnd2 = _slicedToArray(_res$tryEnd, 2),
        ok = _res$tryEnd2[0],
        done = _res$tryEnd2[1];

    if (!done && !ok) {
      readStream.pause();
      res.onWritable(function (offset) {
        var _res$tryEnd3 = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size),
            _res$tryEnd4 = _slicedToArray(_res$tryEnd3, 2),
            ok = _res$tryEnd4[0],
            done = _res$tryEnd4[1];

        if (!done && ok) {
          readStream.resume();
        }

        return ok;
      });
    }
  };

  res.onAborted(destroyReadStream);
  readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
}

exports.serveFile = serveFile;

/***/ }),

/***/ "./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Namespace": () => (/* binding */ Namespace),
/* harmony export */   "Server": () => (/* binding */ Server),
/* harmony export */   "Socket": () => (/* binding */ Socket)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "./node_modules/socket.io/dist/index.js");

var Server = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Server,
    Namespace = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Namespace,
    Socket = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Socket;


/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"_from":"axios@^0.21.1","_id":"axios@0.21.4","_inBundle":false,"_integrity":"sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==","_location":"/axios","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"axios@^0.21.1","name":"axios","escapedName":"axios","rawSpec":"^0.21.1","saveSpec":null,"fetchSpec":"^0.21.1"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/axios/-/axios-0.21.4.tgz","_shasum":"c67b90dc0568e5c1cf2b0b858c43ba28e2eda575","_spec":"axios@^0.21.1","_where":"C:\\\\xampp2\\\\htdocs\\\\FM-Wallet-Connector","author":{"name":"Matt Zabriskie"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"bugs":{"url":"https://github.com/axios/axios/issues"},"bundleDependencies":false,"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}],"dependencies":{"follow-redirects":"^1.14.0"},"deprecated":false,"description":"Promise based HTTP client for the browser and node.js","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"homepage":"https://axios-http.com","jsdelivr":"dist/axios.min.js","keywords":["xhr","http","ajax","promise","node"],"license":"MIT","main":"index.js","name":"axios","repository":{"type":"git","url":"git+https://github.com/axios/axios.git"},"scripts":{"build":"NODE_ENV=production grunt build","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","examples":"node ./examples/server.js","fix":"eslint --fix lib/**/*.js","postversion":"git push && git push --tags","preversion":"npm test","start":"node ./sandbox/server.js","test":"grunt test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"},"typings":"./index.d.ts","unpkg":"dist/axios.min.js","version":"0.21.4"}');

/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"_from":"socket.io@^4.4.1","_id":"socket.io@4.4.1","_inBundle":false,"_integrity":"sha512-s04vrBswdQBUmuWJuuNTmXUVJhP0cVky8bBDhdkf8y0Ptsu7fKU2LuLbts9g+pdmAdyMMn8F/9Mf1/wbtUN0fg==","_location":"/socket.io","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"socket.io@^4.4.1","name":"socket.io","escapedName":"socket.io","rawSpec":"^4.4.1","saveSpec":null,"fetchSpec":"^4.4.1"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/socket.io/-/socket.io-4.4.1.tgz","_shasum":"cd6de29e277a161d176832bb24f64ee045c56ab8","_spec":"socket.io@^4.4.1","_where":"C:\\\\xampp2\\\\htdocs\\\\FM-Wallet-Connector","bugs":{"url":"https://github.com/socketio/socket.io/issues"},"bundleDependencies":false,"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","debug":"~4.3.2","engine.io":"~6.1.0","socket.io-adapter":"~2.3.3","socket.io-parser":"~4.0.4"},"deprecated":false,"description":"node.js realtime framework server","devDependencies":{"@types/mocha":"^9.0.0","expect.js":"0.3.1","mocha":"^3.5.3","nyc":"^15.1.0","prettier":"^2.3.2","rimraf":"^3.0.2","socket.io-client":"4.4.1","socket.io-client-v2":"npm:socket.io-client@^2.4.0","superagent":"^6.1.0","supertest":"^6.1.6","ts-node":"^10.2.1","tsd":"^0.17.0","typescript":"^4.4.2","uWebSockets.js":"github:uNetworking/uWebSockets.js#v20.0.0"},"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"engines":{"node":">=10.0.0"},"exports":{"import":"./wrapper.mjs","require":"./dist/index.js","types":"./dist/index.d.ts"},"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"homepage":"https://github.com/socketio/socket.io#readme","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"license":"MIT","main":"./dist/index.js","name":"socket.io","repository":{"type":"git","url":"git://github.com/socketio/socket.io.git"},"scripts":{"compile":"rimraf ./dist && tsc","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/socket.io.ts"},"tsd":{"directory":"test"},"type":"commonjs","types":"./dist/index.d.ts","version":"4.4.1"}');

/***/ })

}])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZW11cmdvX2NpcDE0LWpzX2luZGV4X2pzLW5vZGVfbW9kdWxlc19heGlvc19pbmRleF9qcy1ub2RlX21vZHVsZXNfZm9ybS1kLTQ1ZDA0MS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiLElBQUlBLGVBQWUsR0FBSSxRQUFRLEtBQUtBLGVBQWQsSUFBa0MsVUFBVUMsR0FBVixFQUFlO0FBQ25FLFNBQVFBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFaLEdBQTBCRCxHQUExQixHQUFnQztBQUFFLGVBQVdBO0FBQWIsR0FBdkM7QUFDSCxDQUZEOztBQUdBRSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTUMsU0FBUyxHQUFHUCxlQUFlLENBQUNRLG1CQUFPLENBQUMsZ0RBQUQsQ0FBUixDQUFqQzs7QUFDQSxJQUFNQyxRQUFRLEdBQUdELG1CQUFPLENBQUMsbURBQUQsQ0FBeEIsRUFDQTs7O0FBQ0EsSUFBTUUsSUFBSSxHQUFHLE9BQWI7O0lBQ01DO0FBQ0YsNEJBQVlDLE9BQVosRUFBcUI7QUFBQTs7QUFDakIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0g7Ozs7V0FtQkQsdUJBQWM7QUFDVixVQUFNQyxLQUFLLEdBQUdKLFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkMsT0FBaEIsQ0FBd0IsS0FBS0gsT0FBN0IsQ0FBZDtBQUNBLGFBQU9ILFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkUsTUFBaEIsQ0FBdUJOLElBQXZCLEVBQTZCRyxLQUE3QixDQUFQO0FBQ0g7OztXQUNELGdCQUFPO0FBQ0gsYUFBT0ksTUFBTSxDQUFDQyxJQUFQLENBQVksS0FBS04sT0FBakIsRUFBMEJPLFFBQTFCLENBQW1DLEtBQW5DLENBQVA7QUFDSDs7O1dBQ0Qsa0JBQVM7QUFDTCxhQUFPVCxJQUFQO0FBQ0gsTUFDRDs7OztXQUNBLG9CQUFXO0FBQ1AsYUFBTyxLQUFL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QWpCLENBQXVCNmtCLE1BQU0sR0FBR3l0RCxVQUFoQyxDQUFYLEVBQXdEbjFELElBQXhELENBQW5CO0FBQUE7QUFBQSxZQUFPNmYsRUFBUDtBQUFBLFlBQVdpUyxJQUFYOztBQUNBLFlBQUksQ0FBQ0EsSUFBRCxJQUFTalMsRUFBYixFQUFpQjtBQUNidXlDLFVBQUFBLFVBQVUsQ0FBQ3ZpQyxNQUFYO0FBQ0g7O0FBQ0QsZUFBT2hRLEVBQVA7QUFDSCxPQU5EO0FBT0g7QUFDSixHQWREOztBQWVBbGhCLEVBQUFBLEdBQUcsQ0FBQzZyRCxTQUFKLENBQWN3SyxpQkFBZDtBQUNBNUMsRUFBQUEsVUFBVSxDQUNMdi9DLEVBREwsQ0FDUSxNQURSLEVBQ2dCb2lELFdBRGhCLEVBRUtwaUQsRUFGTCxDQUVRLE9BRlIsRUFFaUJ1OUIsT0FGakIsRUFHS3Y5QixFQUhMLENBR1EsS0FIUixFQUdlbWlELGlCQUhmO0FBSUg7O0FBQ0RuekUsaUJBQUEsR0FBb0IwdkUsU0FBcEI7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDcElBO0FBRU8sSUFBT3hqQixNQUFQLEdBQW9Dd25CLGtEQUFwQztBQUFBLElBQWVuRyxTQUFmLEdBQW9DbUcscURBQXBDO0FBQUEsSUFBMEJwVixNQUExQixHQUFvQ29WLGtEQUFwQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL0BlbXVyZ28vY2lwMTQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2FjY2VwdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2Jhc2U2NGlkL2xpYi9iYXNlNjRpZC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vYmxha2UyYi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYmxha2UyYi9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYnVmZmVydXRpbC9mYWxsYmFjay5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9idWZmZXJ1dGlsL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2J1aWx0aW4tc3RhdHVzLWNvZGVzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvY29tcG9uZW50LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvY29va2llL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2NvcnMvbGliL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL21pbWUtZGIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvbWltZS10eXBlcy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uYW5vYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9saWIvY2hhcnNldC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9lbmNvZGluZy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9sYW5ndWFnZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9tZWRpYVR5cGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvbm9kZS1neXAtYnVpbGQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvb2JqZWN0LWFzc2lnbi9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9kZWNvZGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvZW5jb2RlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9lcnJvcnMtYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fd3JpdGFibGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZW5kLW9mLXN0cmVhbS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvZnJvbS1icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RhdGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbS1icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS1icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1hZGFwdGVyL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2JpbmFyeS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9kaXN0L2lzLWJpbmFyeS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRmLTgtdmFsaWRhdGUvZmFsbGJhY2suanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRmLTgtdmFsaWRhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy92YXJ5L2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvY29uc3RhbnRzLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2V4dGVuc2lvbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvcGVybWVzc2FnZS1kZWZsYXRlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3N1YnByb3RvY29sLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMveHRlbmQvaW1tdXRhYmxlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvY2pzL2NvbW1vbnMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvZGVjb2RlUGFja2V0LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvZW5jb2RlUGFja2V0LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvcGFyc2VyLXYzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvdXRmOC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvc2VydmVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC91c2VydmVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L2Jyb2FkY2FzdC1vcGVyYXRvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3BhcmVudC1uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3R5cGVkLWV2ZW50cy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC91d3MuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmxha2UyYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibGFrZTJiXCIpKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZShcImJlY2gzMlwiKTtcbi8vLyBub3RlOiB0aGlzIGZ1bmN0aW9uIGNhbid0IGJlIGludmVydGVkIGR1ZSB0byB0aGUgaGFzaFxuY29uc3QgREFUQSA9IFwiYXNzZXRcIjtcbmNsYXNzIEFzc2V0RmluZ2VycHJpbnQge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hCdWYpIHtcbiAgICAgICAgdGhpcy5oYXNoQnVmID0gaGFzaEJ1ZjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IYXNoKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NldEZpbmdlcnByaW50KGhhc2gpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhcnRzKHBvbGljeUlkLCBhc3NldE5hbWUpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJkYW5vLWZvdW5kYXRpb24vQ0lQcy9wdWxsLzY0XG4gICAgICAgIGNvbnN0IGhhc2hCdWYgPSAoMCwgYmxha2UyYl8xLmRlZmF1bHQpKDIwKVxuICAgICAgICAgICAgLnVwZGF0ZShuZXcgVWludDhBcnJheShbLi4ucG9saWN5SWQsIC4uLmFzc2V0TmFtZV0pKVxuICAgICAgICAgICAgLmRpZ2VzdChcImJpbmFyeVwiKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0RmluZ2VycHJpbnQuZnJvbUhhc2goaGFzaEJ1Zik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmVjaDMyKGZpbmdlcnByaW50KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShmaW5nZXJwcmludCk7XG4gICAgICAgIGlmIChwcmVmaXggIT09IERBVEEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXNzZXQgZmluZ2VycHJpbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzaEJ1ZiA9IEJ1ZmZlci5mcm9tKGJlY2gzMl8xLmJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0RmluZ2VycHJpbnQuZnJvbUhhc2goaGFzaEJ1Zik7XG4gICAgfVxuICAgIGZpbmdlcnByaW50KCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKHRoaXMuaGFzaEJ1Zik7XG4gICAgICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKERBVEEsIHdvcmRzKTtcbiAgICB9XG4gICAgaGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuaGFzaEJ1ZikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgfVxuICAgIHByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIERBVEE7XG4gICAgfVxuICAgIC8vIFRoZSBsYXN0IHNpeCBjaGFyYWN0ZXJzIG9mIHRoZSBkYXRhIHBhcnQgZm9ybSBhIGNoZWNrc3VtIGFuZCBjb250YWluIG5vIGluZm9ybWF0aW9uXG4gICAgY2hlY2tzdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50KCkuc2xpY2UoLTYpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0RmluZ2VycHJpbnQ7XG4iLG51bGwsIi8qIVxuICogYWNjZXB0c1xuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIE5lZ290aWF0b3IgPSByZXF1aXJlKCduZWdvdGlhdG9yJylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBY2NlcHRzXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFjY2VwdHMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcmVxLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXFcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBY2NlcHRzIChyZXEpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFjY2VwdHMpKSB7XG4gICAgcmV0dXJuIG5ldyBBY2NlcHRzKHJlcSlcbiAgfVxuXG4gIHRoaXMuaGVhZGVycyA9IHJlcS5oZWFkZXJzXG4gIHRoaXMubmVnb3RpYXRvciA9IG5ldyBOZWdvdGlhdG9yKHJlcSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gYHR5cGUocylgIGlzIGFjY2VwdGFibGUsIHJldHVybmluZ1xuICogdGhlIGJlc3QgbWF0Y2ggd2hlbiB0cnVlLCBvdGhlcndpc2UgYHVuZGVmaW5lZGAsIGluIHdoaWNoXG4gKiBjYXNlIHlvdSBzaG91bGQgcmVzcG9uZCB3aXRoIDQwNiBcIk5vdCBBY2NlcHRhYmxlXCIuXG4gKlxuICogVGhlIGB0eXBlYCB2YWx1ZSBtYXkgYmUgYSBzaW5nbGUgbWltZSB0eXBlIHN0cmluZ1xuICogc3VjaCBhcyBcImFwcGxpY2F0aW9uL2pzb25cIiwgdGhlIGV4dGVuc2lvbiBuYW1lXG4gKiBzdWNoIGFzIFwianNvblwiIG9yIGFuIGFycmF5IGBbXCJqc29uXCIsIFwiaHRtbFwiLCBcInRleHQvcGxhaW5cIl1gLiBXaGVuIGEgbGlzdFxuICogb3IgYXJyYXkgaXMgZ2l2ZW4gdGhlIF9iZXN0XyBtYXRjaCwgaWYgYW55IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvaHRtbFxuICogICAgIHRoaXMudHlwZXMoJ2h0bWwnKTtcbiAqICAgICAvLyA9PiBcImh0bWxcIlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKiwgYXBwbGljYXRpb24vanNvblxuICogICAgIHRoaXMudHlwZXMoJ2h0bWwnKTtcbiAqICAgICAvLyA9PiBcImh0bWxcIlxuICogICAgIHRoaXMudHlwZXMoJ3RleHQvaHRtbCcpO1xuICogICAgIC8vID0+IFwidGV4dC9odG1sXCJcbiAqICAgICB0aGlzLnR5cGVzKCdqc29uJywgJ3RleHQnKTtcbiAqICAgICAvLyA9PiBcImpzb25cIlxuICogICAgIHRoaXMudHlwZXMoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAqICAgICAvLyA9PiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKiwgYXBwbGljYXRpb24vanNvblxuICogICAgIHRoaXMudHlwZXMoJ2ltYWdlL3BuZycpO1xuICogICAgIHRoaXMudHlwZXMoJ3BuZycpO1xuICogICAgIC8vID0+IHVuZGVmaW5lZFxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKjtxPS41LCBhcHBsaWNhdGlvbi9qc29uXG4gKiAgICAgdGhpcy50eXBlcyhbJ2h0bWwnLCAnanNvbiddKTtcbiAqICAgICB0aGlzLnR5cGVzKCdodG1sJywgJ2pzb24nKTtcbiAqICAgICAvLyA9PiBcImpzb25cIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlcy4uLlxuICogQHJldHVybiB7U3RyaW5nfEFycmF5fEJvb2xlYW59XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUudHlwZSA9XG5BY2NlcHRzLnByb3RvdHlwZS50eXBlcyA9IGZ1bmN0aW9uICh0eXBlc18pIHtcbiAgdmFyIHR5cGVzID0gdHlwZXNfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmICh0eXBlcyAmJiAhQXJyYXkuaXNBcnJheSh0eXBlcykpIHtcbiAgICB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gdHlwZXMsIHJldHVybiBhbGwgcmVxdWVzdGVkIHR5cGVzXG4gIGlmICghdHlwZXMgfHwgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5tZWRpYVR5cGVzKClcbiAgfVxuXG4gIC8vIG5vIGFjY2VwdCBoZWFkZXIsIHJldHVybiBmaXJzdCBnaXZlbiB0eXBlXG4gIGlmICghdGhpcy5oZWFkZXJzLmFjY2VwdCkge1xuICAgIHJldHVybiB0eXBlc1swXVxuICB9XG5cbiAgdmFyIG1pbWVzID0gdHlwZXMubWFwKGV4dFRvTWltZSlcbiAgdmFyIGFjY2VwdHMgPSB0aGlzLm5lZ290aWF0b3IubWVkaWFUeXBlcyhtaW1lcy5maWx0ZXIodmFsaWRNaW1lKSlcbiAgdmFyIGZpcnN0ID0gYWNjZXB0c1swXVxuXG4gIHJldHVybiBmaXJzdFxuICAgID8gdHlwZXNbbWltZXMuaW5kZXhPZihmaXJzdCldXG4gICAgOiBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBlbmNvZGluZ3Mgb3IgYmVzdCBmaXQgYmFzZWQgb24gYGVuY29kaW5nc2AuXG4gKlxuICogR2l2ZW4gYEFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZWBcbiAqIGFuIGFycmF5IHNvcnRlZCBieSBxdWFsaXR5IGlzIHJldHVybmVkOlxuICpcbiAqICAgICBbJ2d6aXAnLCAnZGVmbGF0ZSddXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGVuY29kaW5ncy4uLlxuICogQHJldHVybiB7U3RyaW5nfEFycmF5fVxuICogQHB1YmxpY1xuICovXG5cbkFjY2VwdHMucHJvdG90eXBlLmVuY29kaW5nID1cbkFjY2VwdHMucHJvdG90eXBlLmVuY29kaW5ncyA9IGZ1bmN0aW9uIChlbmNvZGluZ3NfKSB7XG4gIHZhciBlbmNvZGluZ3MgPSBlbmNvZGluZ3NfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmIChlbmNvZGluZ3MgJiYgIUFycmF5LmlzQXJyYXkoZW5jb2RpbmdzKSkge1xuICAgIGVuY29kaW5ncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbmNvZGluZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gIH1cblxuICAvLyBubyBlbmNvZGluZ3MsIHJldHVybiBhbGwgcmVxdWVzdGVkIGVuY29kaW5nc1xuICBpZiAoIWVuY29kaW5ncyB8fCBlbmNvZGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5lbmNvZGluZ3MoKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5lbmNvZGluZ3MoZW5jb2RpbmdzKVswXSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBjaGFyc2V0cyBvciBiZXN0IGZpdCBiYXNlZCBvbiBgY2hhcnNldHNgLlxuICpcbiAqIEdpdmVuIGBBY2NlcHQtQ2hhcnNldDogdXRmLTgsIGlzby04ODU5LTE7cT0wLjIsIHV0Zi03O3E9MC41YFxuICogYW4gYXJyYXkgc29ydGVkIGJ5IHF1YWxpdHkgaXMgcmV0dXJuZWQ6XG4gKlxuICogICAgIFsndXRmLTgnLCAndXRmLTcnLCAnaXNvLTg4NTktMSddXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNoYXJzZXRzLi4uXG4gKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUuY2hhcnNldCA9XG5BY2NlcHRzLnByb3RvdHlwZS5jaGFyc2V0cyA9IGZ1bmN0aW9uIChjaGFyc2V0c18pIHtcbiAgdmFyIGNoYXJzZXRzID0gY2hhcnNldHNfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmIChjaGFyc2V0cyAmJiAhQXJyYXkuaXNBcnJheShjaGFyc2V0cykpIHtcbiAgICBjaGFyc2V0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzZXRzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gY2hhcnNldHMsIHJldHVybiBhbGwgcmVxdWVzdGVkIGNoYXJzZXRzXG4gIGlmICghY2hhcnNldHMgfHwgY2hhcnNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5jaGFyc2V0cygpXG4gIH1cblxuICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmNoYXJzZXRzKGNoYXJzZXRzKVswXSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBsYW5ndWFnZXMgb3IgYmVzdCBmaXQgYmFzZWQgb24gYGxhbmdzYC5cbiAqXG4gKiBHaXZlbiBgQWNjZXB0LUxhbmd1YWdlOiBlbjtxPTAuOCwgZXMsIHB0YFxuICogYW4gYXJyYXkgc29ydGVkIGJ5IHF1YWxpdHkgaXMgcmV0dXJuZWQ6XG4gKlxuICogICAgIFsnZXMnLCAncHQnLCAnZW4nXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBsYW5ncy4uLlxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbkFjY2VwdHMucHJvdG90eXBlLmxhbmcgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3MgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3VhZ2UgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3VhZ2VzID0gZnVuY3Rpb24gKGxhbmd1YWdlc18pIHtcbiAgdmFyIGxhbmd1YWdlcyA9IGxhbmd1YWdlc19cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKGxhbmd1YWdlcyAmJiAhQXJyYXkuaXNBcnJheShsYW5ndWFnZXMpKSB7XG4gICAgbGFuZ3VhZ2VzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5ndWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxhbmd1YWdlc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vIGxhbmd1YWdlcywgcmV0dXJuIGFsbCByZXF1ZXN0ZWQgbGFuZ3VhZ2VzXG4gIGlmICghbGFuZ3VhZ2VzIHx8IGxhbmd1YWdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmxhbmd1YWdlcygpXG4gIH1cblxuICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmxhbmd1YWdlcyhsYW5ndWFnZXMpWzBdIHx8IGZhbHNlXG59XG5cbi8qKlxuICogQ29udmVydCBleHRuYW1lcyB0byBtaW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGV4dFRvTWltZSAodHlwZSkge1xuICByZXR1cm4gdHlwZS5pbmRleE9mKCcvJykgPT09IC0xXG4gICAgPyBtaW1lLmxvb2t1cCh0eXBlKVxuICAgIDogdHlwZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG1pbWUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRNaW1lICh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNvbmZpZy50cmFuc2l0aW9uYWwgJiYgY29uZmlnLnRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJylcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHtcbiAgICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxuICB9LFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgKGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPT09ICdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG52YXIgY3VycmVudFZlckFyciA9IHBrZy52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cbi8qKlxuICogQ29tcGFyZSBwYWNrYWdlIHZlcnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSB0aGFuVmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24sIHRoYW5WZXJzaW9uKSB7XG4gIHZhciBwa2dWZXJzaW9uQXJyID0gdGhhblZlcnNpb24gPyB0aGFuVmVyc2lvbi5zcGxpdCgnLicpIDogY3VycmVudFZlckFycjtcbiAgdmFyIGRlc3RWZXIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPiBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPCBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICB2YXIgaXNEZXByZWNhdGVkID0gdmVyc2lvbiAmJiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uKTtcblxuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgcGtnLnZlcnNpb24gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQgaW4gJyArIHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09sZGVyVmVyc2lvbjogaXNPbGRlclZlcnNpb24sXG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogYmFzZTY0aWQgdjAuMS4wXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yXG4gKi9cblxudmFyIEJhc2U2NElkID0gZnVuY3Rpb24oKSB7IH07XG5cbi8qKlxuICogR2V0IHJhbmRvbSBieXRlc1xuICpcbiAqIFVzZXMgYSBidWZmZXIgaWYgYXZhaWxhYmxlLCBmYWxscyBiYWNrIHRvIGNyeXB0by5yYW5kb21CeXRlc1xuICovXG5cbkJhc2U2NElkLnByb3RvdHlwZS5nZXRSYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG5cbiAgdmFyIEJVRkZFUl9TSVpFID0gNDA5NlxuICB2YXIgc2VsZiA9IHRoaXM7ICBcbiAgXG4gIGJ5dGVzID0gYnl0ZXMgfHwgMTI7XG5cbiAgaWYgKGJ5dGVzID4gQlVGRkVSX1NJWkUpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzKTtcbiAgfVxuICBcbiAgdmFyIGJ5dGVzSW5CdWZmZXIgPSBwYXJzZUludChCVUZGRVJfU0laRS9ieXRlcyk7XG4gIHZhciB0aHJlc2hvbGQgPSBwYXJzZUludChieXRlc0luQnVmZmVyKjAuODUpO1xuXG4gIGlmICghdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gIH1cblxuICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IG51bGwpIHtcbiAgICAgdGhpcy5ieXRlc0J1ZmZlckluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IGJ5dGVzSW5CdWZmZXIpIHtcbiAgICB0aGlzLmJ5dGVzQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ5dGVzQnVmZmVySW5kZXggPSAtMTtcbiAgfVxuXG4gIC8vIE5vIGJ1ZmZlcmVkIGJ5dGVzIGF2YWlsYWJsZSBvciBpbmRleCBhYm92ZSB0aHJlc2hvbGRcbiAgaWYgKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9PSAtMSB8fCB0aGlzLmJ5dGVzQnVmZmVySW5kZXggPiB0aHJlc2hvbGQpIHtcbiAgICAgXG4gICAgaWYgKCF0aGlzLmlzR2VuZXJhdGluZ0J5dGVzKSB7XG4gICAgICB0aGlzLmlzR2VuZXJhdGluZ0J5dGVzID0gdHJ1ZTtcbiAgICAgIGNyeXB0by5yYW5kb21CeXRlcyhCVUZGRVJfU0laRSwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgICBzZWxmLmJ5dGVzQnVmZmVyID0gYnl0ZXM7XG4gICAgICAgIHNlbGYuYnl0ZXNCdWZmZXJJbmRleCA9IDA7XG4gICAgICAgIHNlbGYuaXNHZW5lcmF0aW5nQnl0ZXMgPSBmYWxzZTtcbiAgICAgIH0pOyBcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIHN5bmMgY2FsbCB3aGVuIG5vIGJ1ZmZlcmVkIGJ5dGVzIGFyZSBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IC0xKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gIH1cbiAgXG4gIHZhciByZXN1bHQgPSB0aGlzLmJ5dGVzQnVmZmVyLnNsaWNlKGJ5dGVzKnRoaXMuYnl0ZXNCdWZmZXJJbmRleCwgYnl0ZXMqKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCsxKSk7IFxuICB0aGlzLmJ5dGVzQnVmZmVySW5kZXgrKzsgXG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGJhc2U2NCBpZFxuICpcbiAqIChPcmlnaW5hbCB2ZXJzaW9uIGZyb20gc29ja2V0LmlvIDxodHRwOi8vc29ja2V0LmlvPilcbiAqL1xuXG5CYXNlNjRJZC5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmQgPSBCdWZmZXIuYWxsb2MoMTUpOyAvLyBtdWx0aXBsZSBvZiAzIGZvciBiYXNlNjRcbiAgaWYgKCFyYW5kLndyaXRlSW50MzJCRSkge1xuICAgIHJldHVybiBNYXRoLmFicyhNYXRoLnJhbmRvbSgpICogTWF0aC5yYW5kb20oKSAqIERhdGUubm93KCkgfCAwKS50b1N0cmluZygpXG4gICAgICArIE1hdGguYWJzKE1hdGgucmFuZG9tKCkgKiBNYXRoLnJhbmRvbSgpICogRGF0ZS5ub3coKSB8IDApLnRvU3RyaW5nKCk7XG4gIH1cbiAgdGhpcy5zZXF1ZW5jZU51bWJlciA9ICh0aGlzLnNlcXVlbmNlTnVtYmVyICsgMSkgfCAwO1xuICByYW5kLndyaXRlSW50MzJCRSh0aGlzLnNlcXVlbmNlTnVtYmVyLCAxMSk7XG4gIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICB0aGlzLmdldFJhbmRvbUJ5dGVzKDEyKS5jb3B5KHJhbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vdCBzZWN1cmUgZm9yIG5vZGUgMC40XG4gICAgWzAsIDQsIDhdLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgcmFuZC53cml0ZUludDMyQkUoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIDMyKSB8IDAsIGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByYW5kLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcbn07XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IEJhc2U2NElkKCk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IHZvaWQgMDtcbmNvbnN0IEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEFMUEhBQkVUX01BUCA9IHt9O1xuZm9yIChsZXQgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICAgIGNvbnN0IHggPSBBTFBIQUJFVC5jaGFyQXQoeik7XG4gICAgQUxQSEFCRVRfTUFQW3hdID0gejtcbn1cbmZ1bmN0aW9uIHBvbHltb2RTdGVwKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgcmV0dXJuICgoKHByZSAmIDB4MWZmZmZmZikgPDwgNSkgXlxuICAgICAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuICAgICAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICAgICAoLSgoYiA+PiAyKSAmIDEpICYgMHgxZWExMTlmYSkgXlxuICAgICAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuICAgICAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMykpO1xufVxuZnVuY3Rpb24gcHJlZml4Q2hrKHByZWZpeCkge1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIHByZWZpeCAoJyArIHByZWZpeCArICcpJztcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeICh2ICYgMHgxZik7XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgaW5CaXRzKSB8IGRhdGFbaV07XG4gICAgICAgIGJpdHMgKz0gaW5CaXRzO1xuICAgICAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IG91dEJpdHM7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFkKSB7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4Vik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaXRzID49IGluQml0cylcbiAgICAgICAgICAgIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnO1xuICAgICAgICBpZiAoKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICAgICAgICAgIHJldHVybiAnTm9uLXplcm8gcGFkZGluZyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1dvcmRzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xufVxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSB7XG4gICAgY29uc3QgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpXG4gICAgICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmcm9tV29yZHMod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbn1cbmZ1bmN0aW9uIGdldExpYnJhcnlGcm9tRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBsZXQgRU5DT0RJTkdfQ09OU1Q7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmVjaDMyJykge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDB4MmJjODMwYTM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0Jyk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjaGspO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4ICsgJzEnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gd29yZHNbaV07XG4gICAgICAgICAgICBpZiAoeCA+PiA1ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIDUtYml0IHdvcmQnKTtcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4O1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcbiAgICAgICAgfVxuICAgICAgICBjaGsgXj0gRU5DT0RJTkdfQ09OU1Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGNoayA+PiAoKDUgLSBpKSAqIDUpKSAmIDB4MWY7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgTElNSVQgPSBMSU1JVCB8fCA5MDtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4KVxuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcgdG9vIHNob3J0JztcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHJldHVybiAnRXhjZWVkcyBsZW5ndGggbGltaXQnO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZClcbiAgICAgICAgICAgIHJldHVybiAnTWl4ZWQtY2FzZSBzdHJpbmcgJyArIHN0cjtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0cjtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0cjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KTtcbiAgICAgICAgY29uc3Qgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSk7XG4gICAgICAgIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHJldHVybiAnRGF0YSB0b28gc2hvcnQnO1xuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBjaGs7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gd29yZENoYXJzLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBBTFBIQUJFVF9NQVBbY107XG4gICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGM7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdjtcbiAgICAgICAgICAgIC8vIG5vdCBpbiB0aGUgY2hlY2tzdW0/XG4gICAgICAgICAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoayAhPT0gRU5DT0RJTkdfQ09OU1QpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHI7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIExJTUlUKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZGVjb2RlKHN0ciwgTElNSVQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2V0TGlicmFyeUZyb21FbmNvZGluZygnYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzJtJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gbG9hZFdlYkFzc2VtYmx5XG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAob3B0cykge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG5cbiAgdmFyIGltcCA9IG9wdHMgJiYgb3B0cy5pbXBvcnRzXG4gIHZhciB3YXNtID0gdG9VaW50OEFycmF5KCdBR0Z6YlFFQUFBQUJFQU5nQW45L0FHQURmMzkvQUdBQmZ3QURCUVFBQVFJQ0JRVUJBUXJvQndkTkJRWnRaVzF2Y25rQ0FBeGliR0ZyWlRKaVgybHVhWFFBQUE1aWJHRnJaVEppWDNWd1pHRjBaUUFCRFdKc1lXdGxNbUpmWm1sdVlXd0FBaEJpYkdGclpUSmlYMk52YlhCeVpYTnpBQU1LMDBBRWxnTUFJQUJDQURjREFDQUFRUWhxUWdBM0F3QWdBRUVRYWtJQU53TUFJQUJCR0dwQ0FEY0RBQ0FBUVNCcVFnQTNBd0FnQUVFb2FrSUFOd01BSUFCQk1HcENBRGNEQUNBQVFUaHFRZ0EzQXdBZ0FFSEFBR3BDQURjREFDQUFRY2dBYWtJQU53TUFJQUJCMEFCcVFnQTNBd0FnQUVIWUFHcENBRGNEQUNBQVFlQUFha0lBTndNQUlBQkI2QUJxUWdBM0F3QWdBRUh3QUdwQ0FEY0RBQ0FBUWZnQWFrSUFOd01BSUFCQmdBRnFRb2lTODUzL3pQbUU2Z0JCQUNrREFJVTNBd0FnQUVHSUFXcEN1ODZxcHRqUTY3TzdmMEVJS1FNQWhUY0RBQ0FBUVpBQmFrS3I4TlAwcis2OHR6eEJFQ2tEQUlVM0F3QWdBRUdZQVdwQzhlMzArS1duL2FlbGYwRVlLUU1BaFRjREFDQUFRYUFCYWtMUmhacnYrcytVaDlFQVFTQXBBd0NGTndNQUlBQkJxQUZxUXAvWStkbkNrZHFDbTM5QktDa0RBSVUzQXdBZ0FFR3dBV3BDNi9xRzJyKzE5c0VmUVRBcEF3Q0ZOd01BSUFCQnVBRnFRdm5DK0p1Um83UHcyd0JCT0NrREFJVTNBd0FnQUVIQUFXcENBRGNEQUNBQVFjZ0Jha0lBTndNQUlBQkIwQUZxUWdBM0F3QUxiUUVEZnlBQVFjQUJhaUVESUFCQnlBRnFJUVFnQkNrREFLY2hCUUpBQTBBZ0FTQUNSZzBCSUFWQmdBRkdCRUFnQXlBREtRTUFJQVd0ZkRjREFFRUFJUVVnQUJBREN5QUFJQVZxSUFFdEFBQTZBQUFnQlVFQmFpRUZJQUZCQVdvaEFRd0FDd3NnQkNBRnJUY0RBQXRrQVFOL0lBQkJ3QUZxSVFFZ0FFSElBV29oQWlBQklBRXBBd0FnQWlrREFIdzNBd0FnQUVIUUFXcENmemNEQUNBQ0tRTUFweUVEQWtBRFFDQURRWUFCUmcwQklBQWdBMnBCQURvQUFDQURRUUZxSVFNTUFBc0xJQUlnQTYwM0F3QWdBQkFEQytVN0FpQitDWDhnQUVHQUFXb2hJU0FBUVlnQmFpRWlJQUJCa0FGcUlTTWdBRUdZQVdvaEpDQUFRYUFCYWlFbElBQkJxQUZxSVNZZ0FFR3dBV29oSnlBQVFiZ0JhaUVvSUNFcEF3QWhBU0FpS1FNQUlRSWdJeWtEQUNFRElDUXBBd0FoQkNBbEtRTUFJUVVnSmlrREFDRUdJQ2NwQXdBaEJ5QW9LUU1BSVFoQ2lKTHpuZi9NK1lUcUFDRUpRcnZPcXFiWTBPdXp1MzhoQ2tLcjhOUDByKzY4dHp3aEMwTHg3ZlQ0cGFmOXA2Vi9JUXhDMFlXYTcvclBsSWZSQUNFTlFwL1krZG5Da2RxQ20zOGhEa0xyK29iYXY3WDJ3UjhoRDBMNXd2aWJrYU96OE5zQUlSQWdBQ2tEQUNFUklBQkJDR29wQXdBaEVpQUFRUkJxS1FNQUlSTWdBRUVZYWlrREFDRVVJQUJCSUdvcEF3QWhGU0FBUVNocUtRTUFJUllnQUVFd2Fpa0RBQ0VYSUFCQk9Hb3BBd0FoR0NBQVFjQUFhaWtEQUNFWklBQkJ5QUJxS1FNQUlSb2dBRUhRQUdvcEF3QWhHeUFBUWRnQWFpa0RBQ0VjSUFCQjRBQnFLUU1BSVIwZ0FFSG9BR29wQXdBaEhpQUFRZkFBYWlrREFDRWZJQUJCK0FCcUtRTUFJU0FnRFNBQVFjQUJhaWtEQUlVaERTQVBJQUJCMEFGcUtRTUFoU0VQSUFFZ0JTQVJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQk44ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFVZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnRlh4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJaOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBWGZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0dIeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCbDhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWFmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHM3g4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FkZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSG54OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI5OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBZ2ZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0gzeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCdDhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVZmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdHWHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQnA4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFnZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnSG54OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJkOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBU2ZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0hYeDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCRjhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QVRmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dISHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmg4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FXZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnRkh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBWmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0hYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCRjhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QVdmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dFM3g4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQ0I4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FlZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRzN4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUI5OGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBVWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCaDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVNmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdHbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlY4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FZZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnR254OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJSOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBU2ZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0hueDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCMThmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQWNmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dIM3g4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQk44ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFYZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRm54OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJ0OGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBVmZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0VYeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklDQjhmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQVpmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdHbng4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQkY4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFXZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnR0h4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUJOOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBVmZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0czeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlDQjhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQWZmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdFbng4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFkZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnRjN4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJsOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBVWZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0hueDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCTjhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWRmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdGM3g4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQnQ4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFSZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnSEh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUJsOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBVWZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0ZYeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCNThmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QVlmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dGbng4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQ0I4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FmZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRW54OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJwOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBZGZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0ZueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCSjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQWdmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dIM3g4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQjU4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FWZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnRzN4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJGOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBWWZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCUjhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQWFmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dFM3g4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQmw4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FjZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnSG54OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBWWZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0gzeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCMThmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVNmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dGSHg4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQnA4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFXZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnRVh4OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUNCOGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBVmZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0dYeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCZDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVRmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdHM3g4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQmQ4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FnZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnSDN4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJwOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBY2ZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0ZIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCRjhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVpmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdIWHg4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQk44ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFlZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnR0h4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJKOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBVmZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0czeDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCWjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQWJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFM3g4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQmw4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFWZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnR0h4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJkOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBU2ZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0ZueDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lDQjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWNmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHbng4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQjk4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FVZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSFh4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI1OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBUmZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0VYeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCSjhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVRmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdGSHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQlY4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFXZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRjN4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJoOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBWmZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0dueDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCdDhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QWNmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dIWHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQjU4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FmZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnSUh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUI5OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBYmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0ZYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCbDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QWFmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dJSHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQjU4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FYZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRW54OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUIxOGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBUmZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0UzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCeDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVlmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdGbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlI4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklDRWdJU2tEQUNBQklBbUZoVGNEQUNBaUlDSXBBd0FnQWlBS2hZVTNBd0FnSXlBaktRTUFJQU1nQzRXRk53TUFJQ1FnSkNrREFDQUVJQXlGaFRjREFDQWxJQ1VwQXdBZ0JTQU5oWVUzQXdBZ0ppQW1LUU1BSUFZZ0RvV0ZOd01BSUNjZ0p5a0RBQ0FISUErRmhUY0RBQ0FvSUNncEF3QWdDQ0FRaFlVM0F3QUwnKVxuICB2YXIgcmVhZHkgPSBudWxsXG5cbiAgdmFyIG1vZCA9IHtcbiAgICBidWZmZXI6IHdhc20sXG4gICAgbWVtb3J5OiBudWxsLFxuICAgIGV4cG9ydHM6IG51bGwsXG4gICAgcmVhbGxvYzogcmVhbGxvYyxcbiAgICBvbmxvYWQ6IG9ubG9hZFxuICB9XG5cbiAgb25sb2FkKGZ1bmN0aW9uICgpIHt9KVxuXG4gIHJldHVybiBtb2RcblxuICBmdW5jdGlvbiByZWFsbG9jIChzaXplKSB7XG4gICAgbW9kLmV4cG9ydHMubWVtb3J5Lmdyb3coTWF0aC5jZWlsKE1hdGguYWJzKHNpemUgLSBtb2QubWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpXG4gICAgbW9kLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxvYWQgKGNiKSB7XG4gICAgaWYgKG1vZC5leHBvcnRzKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZWFkeS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMnKVxuICAgICAgc2V0dXAoe2luc3RhbmNlOiBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh3YXNtKSwgaW1wKX0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWFkeSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc20sIGltcCkudGhlbihzZXR1cClcbiAgICB9XG5cbiAgICBvbmxvYWQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cCAodykge1xuICAgIG1vZC5leHBvcnRzID0gdy5pbnN0YW5jZS5leHBvcnRzXG4gICAgbW9kLm1lbW9yeSA9IG1vZC5leHBvcnRzLm1lbW9yeSAmJiBtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyICYmIG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5IChzKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF0b2Iocykuc3BsaXQoJycpLm1hcChjaGFyQ29kZUF0KSlcbiAgcmV0dXJuIG5ldyAocmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXIpKHMsICdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjaGFyQ29kZUF0IChjKSB7XG4gIHJldHVybiBjLmNoYXJDb2RlQXQoMClcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciB3YXNtID0gcmVxdWlyZSgnLi9ibGFrZTJiJykoKVxuXG52YXIgaGVhZCA9IDY0XG52YXIgZnJlZUxpc3QgPSBbXVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsYWtlMmJcbnZhciBCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NSU4gPSAxNlxudmFyIEJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01BWCA9IDY0XG52YXIgQllURVMgPSBtb2R1bGUuZXhwb3J0cy5CWVRFUyA9IDMyXG52YXIgS0VZQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUlOID0gMTZcbnZhciBLRVlCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NQVggPSA2NFxudmFyIEtFWUJZVEVTID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVMgPSAzMlxudmFyIFNBTFRCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlNBTFRCWVRFUyA9IDE2XG52YXIgUEVSU09OQUxCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlBFUlNPTkFMQllURVMgPSAxNlxuXG5mdW5jdGlvbiBCbGFrZTJiIChkaWdlc3RMZW5ndGgsIGtleSwgc2FsdCwgcGVyc29uYWwsIG5vQXNzZXJ0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbGFrZTJiKSkgcmV0dXJuIG5ldyBCbGFrZTJiKGRpZ2VzdExlbmd0aCwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpXG4gIGlmICghKHdhc20gJiYgd2FzbS5leHBvcnRzKSkgdGhyb3cgbmV3IEVycm9yKCdXQVNNIG5vdCBsb2FkZWQuIFdhaXQgZm9yIEJsYWtlMmIucmVhZHkoY2IpJylcbiAgaWYgKCFkaWdlc3RMZW5ndGgpIGRpZ2VzdExlbmd0aCA9IDMyXG5cbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA+PSBCWVRFU19NSU4sICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBkaWdlc3RMZW5ndGgpXG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA8PSBCWVRFU19NQVgsICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGRpZ2VzdExlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChzYWx0ICE9IG51bGwpIGFzc2VydChzYWx0Lmxlbmd0aCA9PT0gU0FMVEJZVEVTLCAnc2FsdCBtdXN0IGJlIGV4YWN0bHkgJyArIFNBTFRCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgc2FsdC5sZW5ndGgpXG4gICAgaWYgKHBlcnNvbmFsICE9IG51bGwpIGFzc2VydChwZXJzb25hbC5sZW5ndGggPT09IFBFUlNPTkFMQllURVMsICdwZXJzb25hbCBtdXN0IGJlIGV4YWN0bHkgJyArIFBFUlNPTkFMQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHBlcnNvbmFsLmxlbmd0aClcbiAgfVxuXG4gIGlmICghZnJlZUxpc3QubGVuZ3RoKSB7XG4gICAgZnJlZUxpc3QucHVzaChoZWFkKVxuICAgIGhlYWQgKz0gMjE2XG4gIH1cblxuICB0aGlzLmRpZ2VzdExlbmd0aCA9IGRpZ2VzdExlbmd0aFxuICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlXG4gIHRoaXMucG9pbnRlciA9IGZyZWVMaXN0LnBvcCgpXG5cbiAgd2FzbS5tZW1vcnkuZmlsbCgwLCAwLCA2NClcbiAgd2FzbS5tZW1vcnlbMF0gPSB0aGlzLmRpZ2VzdExlbmd0aFxuICB3YXNtLm1lbW9yeVsxXSA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIHdhc20ubWVtb3J5WzJdID0gMSAvLyBmYW5vdXRcbiAgd2FzbS5tZW1vcnlbM10gPSAxIC8vIGRlcHRoXG5cbiAgaWYgKHNhbHQpIHdhc20ubWVtb3J5LnNldChzYWx0LCAzMilcbiAgaWYgKHBlcnNvbmFsKSB3YXNtLm1lbW9yeS5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIGlmICh0aGlzLnBvaW50ZXIgKyAyMTYgPiB3YXNtLm1lbW9yeS5sZW5ndGgpIHdhc20ucmVhbGxvYyh0aGlzLnBvaW50ZXIgKyAyMTYpIC8vIHdlIG5lZWQgMjE2IGJ5dGVzIGZvciB0aGUgc3RhdGVcbiAgd2FzbS5leHBvcnRzLmJsYWtlMmJfaW5pdCh0aGlzLnBvaW50ZXIsIHRoaXMuZGlnZXN0TGVuZ3RoKVxuXG4gIGlmIChrZXkpIHtcbiAgICB0aGlzLnVwZGF0ZShrZXkpXG4gICAgd2FzbS5tZW1vcnkuZmlsbCgwLCBoZWFkLCBoZWFkICsga2V5Lmxlbmd0aCkgLy8gd2hpdGVvdXQga2V5XG4gICAgd2FzbS5tZW1vcnlbdGhpcy5wb2ludGVyICsgMjAwXSA9IDEyOFxuICB9XG59XG5cblxuQmxha2UyYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIGFzc2VydChpbnB1dCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuXG4gIGlmIChoZWFkICsgaW5wdXQubGVuZ3RoID4gd2FzbS5tZW1vcnkubGVuZ3RoKSB3YXNtLnJlYWxsb2MoaGVhZCArIGlucHV0Lmxlbmd0aClcbiAgd2FzbS5tZW1vcnkuc2V0KGlucHV0LCBoZWFkKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl91cGRhdGUodGhpcy5wb2ludGVyLCBoZWFkLCBoZWFkICsgaW5wdXQubGVuZ3RoKVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIHRoaXMuZmluYWxpemVkID0gdHJ1ZVxuXG4gIGZyZWVMaXN0LnB1c2godGhpcy5wb2ludGVyKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl9maW5hbCh0aGlzLnBvaW50ZXIpXG5cbiAgaWYgKCFlbmMgfHwgZW5jID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiB3YXNtLm1lbW9yeS5zbGljZSh0aGlzLnBvaW50ZXIgKyAxMjgsIHRoaXMucG9pbnRlciArIDEyOCArIHRoaXMuZGlnZXN0TGVuZ3RoKVxuICB9XG5cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gaGV4U2xpY2Uod2FzbS5tZW1vcnksIHRoaXMucG9pbnRlciArIDEyOCwgdGhpcy5kaWdlc3RMZW5ndGgpXG4gIH1cblxuICBhc3NlcnQoZW5jLmxlbmd0aCA+PSB0aGlzLmRpZ2VzdExlbmd0aCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlnZXN0TGVuZ3RoOyBpKyspIHtcbiAgICBlbmNbaV0gPSB3YXNtLm1lbW9yeVt0aGlzLnBvaW50ZXIgKyAxMjggKyBpXVxuICB9XG5cbiAgcmV0dXJuIGVuY1xufVxuXG4vLyBsaWJzb2RpdW0gY29tcGF0XG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLldBU00gPSB3YXNtICYmIHdhc20uYnVmZmVyXG5CbGFrZTJiLlNVUFBPUlRFRCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuQmxha2UyYi5yZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKCF3YXNtKSByZXR1cm4gY2IobmV3IEVycm9yKCdXZWJBc3NlbWJseSBub3Qgc3VwcG9ydGVkJykpXG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdCwgY2FuIGJlIHJlbW92ZWQgaW4gYSBuZXcgbWFqb3JcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgd2FzbS5vbmxvYWQoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmVzb2x2ZSgpXG4gICAgICBlbHNlIHJlamVjdCgpXG4gICAgICBjYihlcnIpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcFxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5yZWFkeSA9IEJsYWtlMmIucmVhZHlcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgbGVuKSB7XG4gIHZhciBzdHIgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW3N0YXJ0ICsgaV0pXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIGIyd2FzbSA9IHJlcXVpcmUoJ2JsYWtlMmItd2FzbScpXG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSB2W2IsYisxXVxuLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuZnVuY3Rpb24gQURENjRBQSAodiwgYSwgYikge1xuICB2YXIgbzAgPSB2W2FdICsgdltiXVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gYlxuLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuZnVuY3Rpb24gQURENjRBQyAodiwgYSwgYjAsIGIxKSB7XG4gIHZhciBvMCA9IHZbYV0gKyBiMFxuICBpZiAoYjAgPCAwKSB7XG4gICAgbzAgKz0gMHgxMDAwMDAwMDBcbiAgfVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzXG5mdW5jdGlvbiBCMkJfR0VUMzIgKGFyciwgaSkge1xuICByZXR1cm4gKGFycltpXSBeXG4gIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgKGFycltpICsgM10gPDwgMjQpKVxufVxuXG4vLyBHIE1peGluZyBmdW5jdGlvblxuLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuZnVuY3Rpb24gQjJCX0cgKGEsIGIsIGMsIGQsIGl4LCBpeSkge1xuICB2YXIgeDAgPSBtW2l4XVxuICB2YXIgeDEgPSBtW2l4ICsgMV1cbiAgdmFyIHkwID0gbVtpeV1cbiAgdmFyIHkxID0gbVtpeSArIDFdXG5cbiAgQURENjRBQSh2LCBhLCBiKSAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICBBREQ2NEFDKHYsIGEsIHgwLCB4MSkgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHRvIHRoZSByaWdodCBieSAzMiBiaXRzXG4gIHZhciB4b3IwID0gdltkXSBeIHZbYV1cbiAgdmFyIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSB4b3IxXG4gIHZbZCArIDFdID0geG9yMFxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KVxuICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KVxuXG4gIEFERDY0QUEodiwgYSwgYilcbiAgQURENjRBQyh2LCBhLCB5MCwgeTEpXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpXG4gIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KVxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgNjMgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IxID4+PiAzMSkgXiAoeG9yMCA8PCAxKVxuICB2W2IgKyAxXSA9ICh4b3IwID4+PiAzMSkgXiAoeG9yMSA8PCAxKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweEYzQkNDOTA4LCAweDZBMDlFNjY3LCAweDg0Q0FBNzNCLCAweEJCNjdBRTg1LFxuICAweEZFOTRGODJCLCAweDNDNkVGMzcyLCAweDVGMUQzNkYxLCAweEE1NEZGNTNBLFxuICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAweEZCNDFCRDZCLCAweDFGODNEOUFCLCAweDEzN0UyMTc5LCAweDVCRTBDRDE5XG5dKVxuXG52YXIgU0lHTUE4ID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0LFxuICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5LFxuICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICA2LCAxNSwgMTQsIDksIDExLCAzLCAwLCA4LCAxMiwgMiwgMTMsIDcsIDEsIDQsIDEwLCA1LFxuICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzXG5dXG5cbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqIDIgfSkpXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgzMilcbmZ1bmN0aW9uIGJsYWtlMmJDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuXG4gIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuXG4gIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICB2WzI0XSA9IHZbMjRdIF4gY3R4LnRcbiAgdlsyNV0gPSB2WzI1XSBeIChjdHgudCAvIDB4MTAwMDAwMDAwKVxuICAvLyBoaWdoIDY0IGJpdHMgbm90IHN1cHBvcnRlZCwgb2Zmc2V0IG1heSBub3QgYmUgaGlnaGVyIHRoYW4gMioqNTMtMVxuXG4gIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICBpZiAobGFzdCkge1xuICAgIHZbMjhdID0gfnZbMjhdXG4gICAgdlsyOV0gPSB+dlsyOV1cbiAgfVxuXG4gIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgbVtpXSA9IEIyQl9HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIEIyQl9HKDAsIDgsIDE2LCAyNCwgU0lHTUE4MltpICogMTYgKyAwXSwgU0lHTUE4MltpICogMTYgKyAxXSlcbiAgICBCMkJfRygyLCAxMCwgMTgsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDJdLCBTSUdNQTgyW2kgKiAxNiArIDNdKVxuICAgIEIyQl9HKDQsIDEyLCAyMCwgMjgsIFNJR01BODJbaSAqIDE2ICsgNF0sIFNJR01BODJbaSAqIDE2ICsgNV0pXG4gICAgQjJCX0coNiwgMTQsIDIyLCAzMCwgU0lHTUE4MltpICogMTYgKyA2XSwgU0lHTUE4MltpICogMTYgKyA3XSlcbiAgICBCMkJfRygwLCAxMCwgMjAsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDhdLCBTSUdNQTgyW2kgKiAxNiArIDldKVxuICAgIEIyQl9HKDIsIDEyLCAyMiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMTBdLCBTSUdNQTgyW2kgKiAxNiArIDExXSlcbiAgICBCMkJfRyg0LCAxNCwgMTYsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDEyXSwgU0lHTUE4MltpICogMTYgKyAxM10pXG4gICAgQjJCX0coNiwgOCwgMTgsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDE0XSwgU0lHTUE4MltpICogMTYgKyAxNV0pXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gY3R4LmhbaV0gXiB2W2ldIF4gdltpICsgMTZdXG4gIH1cbn1cblxuLy8gcmV1c2FibGUgcGFyYW1ldGVyX2Jsb2NrXG52YXIgcGFyYW1ldGVyX2Jsb2NrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAwLCAwLCAwLCAwLCAgICAgIC8vICAwOiBvdXRsZW4sIGtleWxlbiwgZmFub3V0LCBkZXB0aFxuICAwLCAwLCAwLCAwLCAgICAgIC8vICA0OiBsZWFmIGxlbmd0aCwgc2VxdWVudGlhbCBtb2RlXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDg6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTI6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTY6IG5vZGUgZGVwdGgsIGlubmVyIGxlbmd0aCwgcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjA6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDI0OiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyODogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMzI6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAzNjogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQwOiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDQ6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0ODogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1MjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1NjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCAgICAgICAvLyA2MDogcGVyc29uYWxcbl0pXG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJiIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDY0IGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gQmxha2UyYiAob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsKSB7XG4gIC8vIHplcm8gb3V0IHBhcmFtZXRlcl9ibG9jayBiZWZvcmUgdXNhZ2VcbiAgcGFyYW1ldGVyX2Jsb2NrLmZpbGwoMClcbiAgLy8gc3RhdGUsICdwYXJhbSBibG9jaydcblxuICB0aGlzLmIgPSBuZXcgVWludDhBcnJheSgxMjgpXG4gIHRoaXMuaCA9IG5ldyBVaW50MzJBcnJheSgxNilcbiAgdGhpcy50ID0gMCAvLyBpbnB1dCBjb3VudFxuICB0aGlzLmMgPSAwIC8vIHBvaW50ZXIgd2l0aGluIGJ1ZmZlclxuICB0aGlzLm91dGxlbiA9IG91dGxlbiAvLyBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzXG5cbiAgcGFyYW1ldGVyX2Jsb2NrWzBdID0gb3V0bGVuXG4gIGlmIChrZXkpIHBhcmFtZXRlcl9ibG9ja1sxXSA9IGtleS5sZW5ndGhcbiAgcGFyYW1ldGVyX2Jsb2NrWzJdID0gMSAvLyBmYW5vdXRcbiAgcGFyYW1ldGVyX2Jsb2NrWzNdID0gMSAvLyBkZXB0aFxuXG4gIGlmIChzYWx0KSBwYXJhbWV0ZXJfYmxvY2suc2V0KHNhbHQsIDMyKVxuICBpZiAocGVyc29uYWwpIHBhcmFtZXRlcl9ibG9jay5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIC8vIGluaXRpYWxpemUgaGFzaCBzdGF0ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0aGlzLmhbaV0gPSBCTEFLRTJCX0lWMzJbaV0gXiBCMkJfR0VUMzIocGFyYW1ldGVyX2Jsb2NrLCBpICogNClcbiAgfVxuXG4gIC8vIGtleSB0aGUgaGFzaCwgaWYgYXBwbGljYWJsZVxuICBpZiAoa2V5KSB7XG4gICAgYmxha2UyYlVwZGF0ZSh0aGlzLCBrZXkpXG4gICAgLy8gYXQgdGhlIGVuZFxuICAgIHRoaXMuYyA9IDEyOFxuICB9XG59XG5cbkJsYWtlMmIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBhc3NlcnQoaW5wdXQgIT0gbnVsbCwgJ2lucHV0IG11c3QgYmUgVWludDhBcnJheSBvciBCdWZmZXInKVxuICBibGFrZTJiVXBkYXRlKHRoaXMsIGlucHV0KVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAob3V0KSB7XG4gIHZhciBidWYgPSAoIW91dCB8fCBvdXQgPT09ICdiaW5hcnknIHx8IG91dCA9PT0gJ2hleCcpID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRsZW4pIDogb3V0XG4gIGFzc2VydChidWYubGVuZ3RoID49IHRoaXMub3V0bGVuLCAnb3V0IG11c3QgaGF2ZSBhdCBsZWFzdCBvdXRsZW4gYnl0ZXMgb2Ygc3BhY2UnKVxuICBibGFrZTJiRmluYWwodGhpcywgYnVmKVxuICBpZiAob3V0ID09PSAnaGV4JykgcmV0dXJuIGhleFNsaWNlKGJ1ZilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgY2IoKSAvLyBpZ25vcmUgdGhlIGVycm9yXG4gIH0pXG59XG5cbi8vIFVwZGF0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJiVXBkYXRlIChjdHgsIGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmMgPT09IDEyOCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2UyYkZpbmFsIChjdHgsIG91dCkge1xuICBjdHgudCArPSBjdHguYyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG5cbiAgd2hpbGUgKGN0eC5jIDwgMTI4KSB7IC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgIGN0eC5iW2N0eC5jKytdID0gMFxuICB9XG4gIGJsYWtlMmJDb21wcmVzcyhjdHgsIHRydWUpIC8vIGZpbmFsIGJsb2NrIGZsYWcgPSAxXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHgub3V0bGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSBjdHguaFtpID4+IDJdID4+ICg4ICogKGkgJiAzKSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW2ldKVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxudmFyIFByb3RvID0gQmxha2UyYlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpIHtcbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KG91dGxlbiA+PSBCWVRFU19NSU4sICdvdXRsZW4gbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBvdXRsZW4pXG4gICAgYXNzZXJ0KG91dGxlbiA8PSBCWVRFU19NQVgsICdvdXRsZW4gbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIG91dGxlbilcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBtb3N0ICcgKyBLRVlCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKHNhbHQgIT0gbnVsbCkgYXNzZXJ0KHNhbHQubGVuZ3RoID09PSBTQUxUQllURVMsICdzYWx0IG11c3QgYmUgZXhhY3RseSAnICsgU0FMVEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBzYWx0Lmxlbmd0aClcbiAgICBpZiAocGVyc29uYWwgIT0gbnVsbCkgYXNzZXJ0KHBlcnNvbmFsLmxlbmd0aCA9PT0gUEVSU09OQUxCWVRFUywgJ3BlcnNvbmFsIG11c3QgYmUgZXhhY3RseSAnICsgUEVSU09OQUxCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgcGVyc29uYWwubGVuZ3RoKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm90byhvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7IC8vIGlnbm9yZSBlcnJvcnNcbiAgICBjYigpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLldBU01fU1VQUE9SVEVEID0gYjJ3YXNtLlNVUFBPUlRFRFxubW9kdWxlLmV4cG9ydHMuV0FTTV9MT0FERUQgPSBmYWxzZVxuXG52YXIgQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUlOID0gMTZcbnZhciBCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NQVggPSA2NFxudmFyIEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuQllURVMgPSAzMlxudmFyIEtFWUJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01JTiA9IDE2XG52YXIgS0VZQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUFYID0gNjRcbnZhciBLRVlCWVRFUyA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTID0gMzJcbnZhciBTQUxUQllURVMgPSBtb2R1bGUuZXhwb3J0cy5TQUxUQllURVMgPSAxNlxudmFyIFBFUlNPTkFMQllURVMgPSBtb2R1bGUuZXhwb3J0cy5QRVJTT05BTEJZVEVTID0gMTZcblxuYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKCFlcnIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5XQVNNX0xPQURFRCA9IHRydWVcbiAgICBQcm90byA9IGIyd2FzbVxuICB9XG59KVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgbWFzayA9IChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59O1xuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVubWFzayA9IChidWZmZXIsIG1hc2spID0+IHtcbiAgLy8gUmVxdWlyZWQgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy85MDA2IGlzIHJlc29sdmVkLlxuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbWFzaywgdW5tYXNrIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKTtcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwiXHJcbi8qKlxyXG4gKiBFeHBvc2UgYEVtaXR0ZXJgLlxyXG4gKi9cclxuXHJcbmlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gIG1vZHVsZS5leHBvcnRzID0gRW1pdHRlcjtcclxufVxyXG5cclxuLyoqXHJcbiAqIEluaXRpYWxpemUgYSBuZXcgYEVtaXR0ZXJgLlxyXG4gKlxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIEVtaXR0ZXIob2JqKSB7XHJcbiAgaWYgKG9iaikgcmV0dXJuIG1peGluKG9iaik7XHJcbn07XHJcblxyXG4vKipcclxuICogTWl4aW4gdGhlIGVtaXR0ZXIgcHJvcGVydGllcy5cclxuICpcclxuICogQHBhcmFtIHtPYmplY3R9IG9ialxyXG4gKiBAcmV0dXJuIHtPYmplY3R9XHJcbiAqIEBhcGkgcHJpdmF0ZVxyXG4gKi9cclxuXHJcbmZ1bmN0aW9uIG1peGluKG9iaikge1xyXG4gIGZvciAodmFyIGtleSBpbiBFbWl0dGVyLnByb3RvdHlwZSkge1xyXG4gICAgb2JqW2tleV0gPSBFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xyXG4gIH1cclxuICByZXR1cm4gb2JqO1xyXG59XHJcblxyXG4vKipcclxuICogTGlzdGVuIG9uIHRoZSBnaXZlbiBgZXZlbnRgIHdpdGggYGZuYC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub24gPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5hZGRFdmVudExpc3RlbmVyID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcbiAgKHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF0gPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdKVxyXG4gICAgLnB1c2goZm4pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEFkZHMgYW4gYGV2ZW50YCBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgaW52b2tlZCBhIHNpbmdsZVxyXG4gKiB0aW1lIHRoZW4gYXV0b21hdGljYWxseSByZW1vdmVkLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24oZXZlbnQsIGZuKXtcclxuICBmdW5jdGlvbiBvbigpIHtcclxuICAgIHRoaXMub2ZmKGV2ZW50LCBvbik7XHJcbiAgICBmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gIH1cclxuXHJcbiAgb24uZm4gPSBmbjtcclxuICB0aGlzLm9uKGV2ZW50LCBvbik7XHJcbiAgcmV0dXJuIHRoaXM7XHJcbn07XHJcblxyXG4vKipcclxuICogUmVtb3ZlIHRoZSBnaXZlbiBjYWxsYmFjayBmb3IgYGV2ZW50YCBvciBhbGxcclxuICogcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9mZiA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cclxuRW1pdHRlci5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICAvLyBhbGxcclxuICBpZiAoMCA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICB0aGlzLl9jYWxsYmFja3MgPSB7fTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gc3BlY2lmaWMgZXZlbnRcclxuICB2YXIgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICBpZiAoIWNhbGxiYWNrcykgcmV0dXJuIHRoaXM7XHJcblxyXG4gIC8vIHJlbW92ZSBhbGwgaGFuZGxlcnNcclxuICBpZiAoMSA9PSBhcmd1bWVudHMubGVuZ3RoKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICAgIHJldHVybiB0aGlzO1xyXG4gIH1cclxuXHJcbiAgLy8gcmVtb3ZlIHNwZWNpZmljIGhhbmRsZXJcclxuICB2YXIgY2I7XHJcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcclxuICAgIGNiID0gY2FsbGJhY2tzW2ldO1xyXG4gICAgaWYgKGNiID09PSBmbiB8fCBjYi5mbiA9PT0gZm4pIHtcclxuICAgICAgY2FsbGJhY2tzLnNwbGljZShpLCAxKTtcclxuICAgICAgYnJlYWs7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvLyBSZW1vdmUgZXZlbnQgc3BlY2lmaWMgYXJyYXlzIGZvciBldmVudCB0eXBlcyB0aGF0IG5vXHJcbiAgLy8gb25lIGlzIHN1YnNjcmliZWQgZm9yIHRvIGF2b2lkIG1lbW9yeSBsZWFrLlxyXG4gIGlmIChjYWxsYmFja3MubGVuZ3RoID09PSAwKSB7XHJcbiAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIEVtaXQgYGV2ZW50YCB3aXRoIHRoZSBnaXZlbiBhcmdzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtNaXhlZH0gLi4uXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XHJcblxyXG4gIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKVxyXG4gICAgLCBjYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdO1xyXG5cclxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XHJcbiAgfVxyXG5cclxuICBpZiAoY2FsbGJhY2tzKSB7XHJcbiAgICBjYWxsYmFja3MgPSBjYWxsYmFja3Muc2xpY2UoMCk7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gY2FsbGJhY2tzLmxlbmd0aDsgaSA8IGxlbjsgKytpKSB7XHJcbiAgICAgIGNhbGxiYWNrc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJldHVybiBhcnJheSBvZiBjYWxsYmFja3MgZm9yIGBldmVudGAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtBcnJheX1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gIHJldHVybiB0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdIHx8IFtdO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIENoZWNrIGlmIHRoaXMgZW1pdHRlciBoYXMgYGV2ZW50YCBoYW5kbGVycy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEByZXR1cm4ge0Jvb2xlYW59XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUuaGFzTGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHJldHVybiAhISB0aGlzLmxpc3RlbmVycyhldmVudCkubGVuZ3RoO1xyXG59O1xyXG4iLCIvKiFcbiAqIGNvb2tpZVxuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBSb21hbiBTaHR5bG1hblxuICogQ29weXJpZ2h0KGMpIDIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLnBhcnNlID0gcGFyc2U7XG5leHBvcnRzLnNlcmlhbGl6ZSA9IHNlcmlhbGl6ZTtcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZGVjb2RlID0gZGVjb2RlVVJJQ29tcG9uZW50O1xudmFyIGVuY29kZSA9IGVuY29kZVVSSUNvbXBvbmVudDtcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggZmllbGQtY29udGVudCBpbiBSRkMgNzIzMCBzZWMgMy4yXG4gKlxuICogZmllbGQtY29udGVudCA9IGZpZWxkLXZjaGFyIFsgMSooIFNQIC8gSFRBQiApIGZpZWxkLXZjaGFyIF1cbiAqIGZpZWxkLXZjaGFyICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKiBvYnMtdGV4dCAgICAgID0gJXg4MC1GRlxuICovXG5cbnZhciBmaWVsZENvbnRlbnRSZWdFeHAgPSAvXltcXHUwMDA5XFx1MDAyMC1cXHUwMDdlXFx1MDA4MC1cXHUwMGZmXSskLztcblxuLyoqXG4gKiBQYXJzZSBhIGNvb2tpZSBoZWFkZXIuXG4gKlxuICogUGFyc2UgdGhlIGdpdmVuIGNvb2tpZSBoZWFkZXIgc3RyaW5nIGludG8gYW4gb2JqZWN0XG4gKiBUaGUgb2JqZWN0IGhhcyB0aGUgdmFyaW91cyBjb29raWVzIGFzIGtleXMobmFtZXMpID0+IHZhbHVlc1xuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7b2JqZWN0fSBbb3B0aW9uc11cbiAqIEByZXR1cm4ge29iamVjdH1cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIsIG9wdGlvbnMpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmcnKTtcbiAgfVxuXG4gIHZhciBvYmogPSB7fVxuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHBhaXJzID0gc3RyLnNwbGl0KCc7JylcbiAgdmFyIGRlYyA9IG9wdC5kZWNvZGUgfHwgZGVjb2RlO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFpcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgcGFpciA9IHBhaXJzW2ldO1xuICAgIHZhciBpbmRleCA9IHBhaXIuaW5kZXhPZignPScpXG5cbiAgICAvLyBza2lwIHRoaW5ncyB0aGF0IGRvbid0IGxvb2sgbGlrZSBrZXk9dmFsdWVcbiAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIga2V5ID0gcGFpci5zdWJzdHJpbmcoMCwgaW5kZXgpLnRyaW0oKVxuXG4gICAgLy8gb25seSBhc3NpZ24gb25jZVxuICAgIGlmICh1bmRlZmluZWQgPT0gb2JqW2tleV0pIHtcbiAgICAgIHZhciB2YWwgPSBwYWlyLnN1YnN0cmluZyhpbmRleCArIDEsIHBhaXIubGVuZ3RoKS50cmltKClcblxuICAgICAgLy8gcXVvdGVkIHZhbHVlc1xuICAgICAgaWYgKHZhbFswXSA9PT0gJ1wiJykge1xuICAgICAgICB2YWwgPSB2YWwuc2xpY2UoMSwgLTEpXG4gICAgICB9XG5cbiAgICAgIG9ialtrZXldID0gdHJ5RGVjb2RlKHZhbCwgZGVjKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcbiAqIFNlcmlhbGl6ZSBkYXRhIGludG8gYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFNlcmlhbGl6ZSB0aGUgYSBuYW1lIHZhbHVlIHBhaXIgaW50byBhIGNvb2tpZSBzdHJpbmcgc3VpdGFibGUgZm9yXG4gKiBodHRwIGhlYWRlcnMuIEFuIG9wdGlvbmFsIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllZCBjb29raWUgcGFyYW1ldGVycy5cbiAqXG4gKiBzZXJpYWxpemUoJ2ZvbycsICdiYXInLCB7IGh0dHBPbmx5OiB0cnVlIH0pXG4gKiAgID0+IFwiZm9vPWJhcjsgaHR0cE9ubHlcIlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gc2VyaWFsaXplKG5hbWUsIHZhbCwgb3B0aW9ucykge1xuICB2YXIgb3B0ID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIGVuYyA9IG9wdC5lbmNvZGUgfHwgZW5jb2RlO1xuXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGVuY29kZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG5hbWUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgbmFtZSBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgdmFsdWUgPSBlbmModmFsKTtcblxuICBpZiAodmFsdWUgJiYgIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KHZhbHVlKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHZhbCBpcyBpbnZhbGlkJyk7XG4gIH1cblxuICB2YXIgc3RyID0gbmFtZSArICc9JyArIHZhbHVlO1xuXG4gIGlmIChudWxsICE9IG9wdC5tYXhBZ2UpIHtcbiAgICB2YXIgbWF4QWdlID0gb3B0Lm1heEFnZSAtIDA7XG5cbiAgICBpZiAoaXNOYU4obWF4QWdlKSB8fCAhaXNGaW5pdGUobWF4QWdlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIG1heEFnZSBpcyBpbnZhbGlkJylcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgTWF4LUFnZT0nICsgTWF0aC5mbG9vcihtYXhBZ2UpO1xuICB9XG5cbiAgaWYgKG9wdC5kb21haW4pIHtcbiAgICBpZiAoIWZpZWxkQ29udGVudFJlZ0V4cC50ZXN0KG9wdC5kb21haW4pKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZG9tYWluIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgRG9tYWluPScgKyBvcHQuZG9tYWluO1xuICB9XG5cbiAgaWYgKG9wdC5wYXRoKSB7XG4gICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQucGF0aCkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBwYXRoIGlzIGludmFsaWQnKTtcbiAgICB9XG5cbiAgICBzdHIgKz0gJzsgUGF0aD0nICsgb3B0LnBhdGg7XG4gIH1cblxuICBpZiAob3B0LmV4cGlyZXMpIHtcbiAgICBpZiAodHlwZW9mIG9wdC5leHBpcmVzLnRvVVRDU3RyaW5nICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gZXhwaXJlcyBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IEV4cGlyZXM9JyArIG9wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCk7XG4gIH1cblxuICBpZiAob3B0Lmh0dHBPbmx5KSB7XG4gICAgc3RyICs9ICc7IEh0dHBPbmx5JztcbiAgfVxuXG4gIGlmIChvcHQuc2VjdXJlKSB7XG4gICAgc3RyICs9ICc7IFNlY3VyZSc7XG4gIH1cblxuICBpZiAob3B0LnNhbWVTaXRlKSB7XG4gICAgdmFyIHNhbWVTaXRlID0gdHlwZW9mIG9wdC5zYW1lU2l0ZSA9PT0gJ3N0cmluZydcbiAgICAgID8gb3B0LnNhbWVTaXRlLnRvTG93ZXJDYXNlKCkgOiBvcHQuc2FtZVNpdGU7XG5cbiAgICBzd2l0Y2ggKHNhbWVTaXRlKSB7XG4gICAgICBjYXNlIHRydWU6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xheCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1MYXgnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ3N0cmljdCc6XG4gICAgICAgIHN0ciArPSAnOyBTYW1lU2l0ZT1TdHJpY3QnO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ25vbmUnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9Tm9uZSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIHNhbWVTaXRlIGlzIGludmFsaWQnKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3RyO1xufVxuXG4vKipcbiAqIFRyeSBkZWNvZGluZyBhIHN0cmluZyB1c2luZyBhIGRlY29kaW5nIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEBwYXJhbSB7ZnVuY3Rpb259IGRlY29kZVxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiB0cnlEZWNvZGUoc3RyLCBkZWNvZGUpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlKHN0cik7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gc3RyO1xuICB9XG59XG4iLCIoZnVuY3Rpb24gKCkge1xuXG4gICd1c2Ugc3RyaWN0JztcblxuICB2YXIgYXNzaWduID0gcmVxdWlyZSgnb2JqZWN0LWFzc2lnbicpO1xuICB2YXIgdmFyeSA9IHJlcXVpcmUoJ3ZhcnknKTtcblxuICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgb3JpZ2luOiAnKicsXG4gICAgbWV0aG9kczogJ0dFVCxIRUFELFBVVCxQQVRDSCxQT1NULERFTEVURScsXG4gICAgcHJlZmxpZ2h0Q29udGludWU6IGZhbHNlLFxuICAgIG9wdGlvbnNTdWNjZXNzU3RhdHVzOiAyMDRcbiAgfTtcblxuICBmdW5jdGlvbiBpc1N0cmluZyhzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzID09PSAnc3RyaW5nJyB8fCBzIGluc3RhbmNlb2YgU3RyaW5nO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNPcmlnaW5BbGxvd2VkKG9yaWdpbiwgYWxsb3dlZE9yaWdpbikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFsbG93ZWRPcmlnaW4pKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFsbG93ZWRPcmlnaW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGlzT3JpZ2luQWxsb3dlZChvcmlnaW4sIGFsbG93ZWRPcmlnaW5baV0pKSB7XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKGFsbG93ZWRPcmlnaW4pKSB7XG4gICAgICByZXR1cm4gb3JpZ2luID09PSBhbGxvd2VkT3JpZ2luO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dlZE9yaWdpbiBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgcmV0dXJuIGFsbG93ZWRPcmlnaW4udGVzdChvcmlnaW4pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gISFhbGxvd2VkT3JpZ2luO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU9yaWdpbihvcHRpb25zLCByZXEpIHtcbiAgICB2YXIgcmVxdWVzdE9yaWdpbiA9IHJlcS5oZWFkZXJzLm9yaWdpbixcbiAgICAgIGhlYWRlcnMgPSBbXSxcbiAgICAgIGlzQWxsb3dlZDtcblxuICAgIGlmICghb3B0aW9ucy5vcmlnaW4gfHwgb3B0aW9ucy5vcmlnaW4gPT09ICcqJykge1xuICAgICAgLy8gYWxsb3cgYW55IG9yaWdpblxuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsXG4gICAgICAgIHZhbHVlOiAnKidcbiAgICAgIH1dKTtcbiAgICB9IGVsc2UgaWYgKGlzU3RyaW5nKG9wdGlvbnMub3JpZ2luKSkge1xuICAgICAgLy8gZml4ZWQgb3JpZ2luXG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyxcbiAgICAgICAgdmFsdWU6IG9wdGlvbnMub3JpZ2luXG4gICAgICB9XSk7XG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnVmFyeScsXG4gICAgICAgIHZhbHVlOiAnT3JpZ2luJ1xuICAgICAgfV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBpc0FsbG93ZWQgPSBpc09yaWdpbkFsbG93ZWQocmVxdWVzdE9yaWdpbiwgb3B0aW9ucy5vcmlnaW4pO1xuICAgICAgLy8gcmVmbGVjdCBvcmlnaW5cbiAgICAgIGhlYWRlcnMucHVzaChbe1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAgICAgICB2YWx1ZTogaXNBbGxvd2VkID8gcmVxdWVzdE9yaWdpbiA6IGZhbHNlXG4gICAgICB9XSk7XG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnVmFyeScsXG4gICAgICAgIHZhbHVlOiAnT3JpZ2luJ1xuICAgICAgfV0pO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlTWV0aG9kcyhvcHRpb25zKSB7XG4gICAgdmFyIG1ldGhvZHMgPSBvcHRpb25zLm1ldGhvZHM7XG4gICAgaWYgKG1ldGhvZHMuam9pbikge1xuICAgICAgbWV0aG9kcyA9IG9wdGlvbnMubWV0aG9kcy5qb2luKCcsJyk7IC8vIC5tZXRob2RzIGlzIGFuIGFycmF5LCBzbyB0dXJuIGl0IGludG8gYSBzdHJpbmdcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LU1ldGhvZHMnLFxuICAgICAgdmFsdWU6IG1ldGhvZHNcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlQ3JlZGVudGlhbHMob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLmNyZWRlbnRpYWxzID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1DcmVkZW50aWFscycsXG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlQWxsb3dlZEhlYWRlcnMob3B0aW9ucywgcmVxKSB7XG4gICAgdmFyIGFsbG93ZWRIZWFkZXJzID0gb3B0aW9ucy5hbGxvd2VkSGVhZGVycyB8fCBvcHRpb25zLmhlYWRlcnM7XG4gICAgdmFyIGhlYWRlcnMgPSBbXTtcblxuICAgIGlmICghYWxsb3dlZEhlYWRlcnMpIHtcbiAgICAgIGFsbG93ZWRIZWFkZXJzID0gcmVxLmhlYWRlcnNbJ2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycyddOyAvLyAuaGVhZGVycyB3YXNuJ3Qgc3BlY2lmaWVkLCBzbyByZWZsZWN0IHRoZSByZXF1ZXN0IGhlYWRlcnNcbiAgICAgIGhlYWRlcnMucHVzaChbe1xuICAgICAgICBrZXk6ICdWYXJ5JyxcbiAgICAgICAgdmFsdWU6ICdBY2Nlc3MtQ29udHJvbC1SZXF1ZXN0LUhlYWRlcnMnXG4gICAgICB9XSk7XG4gICAgfSBlbHNlIGlmIChhbGxvd2VkSGVhZGVycy5qb2luKSB7XG4gICAgICBhbGxvd2VkSGVhZGVycyA9IGFsbG93ZWRIZWFkZXJzLmpvaW4oJywnKTsgLy8gLmhlYWRlcnMgaXMgYW4gYXJyYXksIHNvIHR1cm4gaXQgaW50byBhIHN0cmluZ1xuICAgIH1cbiAgICBpZiAoYWxsb3dlZEhlYWRlcnMgJiYgYWxsb3dlZEhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctSGVhZGVycycsXG4gICAgICAgIHZhbHVlOiBhbGxvd2VkSGVhZGVyc1xuICAgICAgfV0pO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlRXhwb3NlZEhlYWRlcnMob3B0aW9ucykge1xuICAgIHZhciBoZWFkZXJzID0gb3B0aW9ucy5leHBvc2VkSGVhZGVycztcbiAgICBpZiAoIWhlYWRlcnMpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoaGVhZGVycy5qb2luKSB7XG4gICAgICBoZWFkZXJzID0gaGVhZGVycy5qb2luKCcsJyk7IC8vIC5oZWFkZXJzIGlzIGFuIGFycmF5LCBzbyB0dXJuIGl0IGludG8gYSBzdHJpbmdcbiAgICB9XG4gICAgaWYgKGhlYWRlcnMgJiYgaGVhZGVycy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUV4cG9zZS1IZWFkZXJzJyxcbiAgICAgICAgdmFsdWU6IGhlYWRlcnNcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgZnVuY3Rpb24gY29uZmlndXJlTWF4QWdlKG9wdGlvbnMpIHtcbiAgICB2YXIgbWF4QWdlID0gKHR5cGVvZiBvcHRpb25zLm1heEFnZSA9PT0gJ251bWJlcicgfHwgb3B0aW9ucy5tYXhBZ2UpICYmIG9wdGlvbnMubWF4QWdlLnRvU3RyaW5nKClcbiAgICBpZiAobWF4QWdlICYmIG1heEFnZS5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLU1heC1BZ2UnLFxuICAgICAgICB2YWx1ZTogbWF4QWdlXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFwcGx5SGVhZGVycyhoZWFkZXJzLCByZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbiA9IGhlYWRlcnMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICB2YXIgaGVhZGVyID0gaGVhZGVyc1tpXTtcbiAgICAgIGlmIChoZWFkZXIpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaGVhZGVyKSkge1xuICAgICAgICAgIGFwcGx5SGVhZGVycyhoZWFkZXIsIHJlcyk7XG4gICAgICAgIH0gZWxzZSBpZiAoaGVhZGVyLmtleSA9PT0gJ1ZhcnknICYmIGhlYWRlci52YWx1ZSkge1xuICAgICAgICAgIHZhcnkocmVzLCBoZWFkZXIudmFsdWUpO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci52YWx1ZSkge1xuICAgICAgICAgIHJlcy5zZXRIZWFkZXIoaGVhZGVyLmtleSwgaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNvcnMob3B0aW9ucywgcmVxLCByZXMsIG5leHQpIHtcbiAgICB2YXIgaGVhZGVycyA9IFtdLFxuICAgICAgbWV0aG9kID0gcmVxLm1ldGhvZCAmJiByZXEubWV0aG9kLnRvVXBwZXJDYXNlICYmIHJlcS5tZXRob2QudG9VcHBlckNhc2UoKTtcblxuICAgIGlmIChtZXRob2QgPT09ICdPUFRJT05TJykge1xuICAgICAgLy8gcHJlZmxpZ2h0XG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlT3JpZ2luKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUNyZWRlbnRpYWxzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU1ldGhvZHMob3B0aW9ucywgcmVxKSk7XG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlQWxsb3dlZEhlYWRlcnMob3B0aW9ucywgcmVxKSk7XG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlTWF4QWdlKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUV4cG9zZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgYXBwbHlIZWFkZXJzKGhlYWRlcnMsIHJlcyk7XG5cbiAgICAgIGlmIChvcHRpb25zLnByZWZsaWdodENvbnRpbnVlKSB7XG4gICAgICAgIG5leHQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFNhZmFyaSAoYW5kIHBvdGVudGlhbGx5IG90aGVyIGJyb3dzZXJzKSBuZWVkIGNvbnRlbnQtbGVuZ3RoIDAsXG4gICAgICAgIC8vICAgZm9yIDIwNCBvciB0aGV5IGp1c3QgaGFuZyB3YWl0aW5nIGZvciBhIGJvZHlcbiAgICAgICAgcmVzLnN0YXR1c0NvZGUgPSBvcHRpb25zLm9wdGlvbnNTdWNjZXNzU3RhdHVzO1xuICAgICAgICByZXMuc2V0SGVhZGVyKCdDb250ZW50LUxlbmd0aCcsICcwJyk7XG4gICAgICAgIHJlcy5lbmQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYWN0dWFsIHJlc3BvbnNlXG4gICAgICBoZWFkZXJzLnB1c2goY29uZmlndXJlT3JpZ2luKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUNyZWRlbnRpYWxzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUV4cG9zZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgYXBwbHlIZWFkZXJzKGhlYWRlcnMsIHJlcyk7XG4gICAgICBuZXh0KCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbWlkZGxld2FyZVdyYXBwZXIobykge1xuICAgIC8vIGlmIG9wdGlvbnMgYXJlIHN0YXRpYyAoZWl0aGVyIHZpYSBkZWZhdWx0cyBvciBjdXN0b20gb3B0aW9ucyBwYXNzZWQgaW4pLCB3cmFwIGluIGEgZnVuY3Rpb25cbiAgICB2YXIgb3B0aW9uc0NhbGxiYWNrID0gbnVsbDtcbiAgICBpZiAodHlwZW9mIG8gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIG9wdGlvbnNDYWxsYmFjayA9IG87XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdGlvbnNDYWxsYmFjayA9IGZ1bmN0aW9uIChyZXEsIGNiKSB7XG4gICAgICAgIGNiKG51bGwsIG8pO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gY29yc01pZGRsZXdhcmUocmVxLCByZXMsIG5leHQpIHtcbiAgICAgIG9wdGlvbnNDYWxsYmFjayhyZXEsIGZ1bmN0aW9uIChlcnIsIG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgIG5leHQoZXJyKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY29yc09wdGlvbnMgPSBhc3NpZ24oe30sIGRlZmF1bHRzLCBvcHRpb25zKTtcbiAgICAgICAgICB2YXIgb3JpZ2luQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgIGlmIChjb3JzT3B0aW9ucy5vcmlnaW4gJiYgdHlwZW9mIGNvcnNPcHRpb25zLm9yaWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgb3JpZ2luQ2FsbGJhY2sgPSBjb3JzT3B0aW9ucy5vcmlnaW47XG4gICAgICAgICAgfSBlbHNlIGlmIChjb3JzT3B0aW9ucy5vcmlnaW4pIHtcbiAgICAgICAgICAgIG9yaWdpbkNhbGxiYWNrID0gZnVuY3Rpb24gKG9yaWdpbiwgY2IpIHtcbiAgICAgICAgICAgICAgY2IobnVsbCwgY29yc09wdGlvbnMub3JpZ2luKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG9yaWdpbkNhbGxiYWNrKSB7XG4gICAgICAgICAgICBvcmlnaW5DYWxsYmFjayhyZXEuaGVhZGVycy5vcmlnaW4sIGZ1bmN0aW9uIChlcnIyLCBvcmlnaW4pIHtcbiAgICAgICAgICAgICAgaWYgKGVycjIgfHwgIW9yaWdpbikge1xuICAgICAgICAgICAgICAgIG5leHQoZXJyMik7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29yc09wdGlvbnMub3JpZ2luID0gb3JpZ2luO1xuICAgICAgICAgICAgICAgIGNvcnMoY29yc09wdGlvbnMsIHJlcSwgcmVzLCBuZXh0KTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH1cblxuICAvLyBjYW4gcGFzcyBlaXRoZXIgYW4gb3B0aW9ucyBoYXNoLCBhbiBvcHRpb25zIGRlbGVnYXRlLCBvciBub3RoaW5nXG4gIG1vZHVsZS5leHBvcnRzID0gbWlkZGxld2FyZVdyYXBwZXI7XG5cbn0oKSk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyA/IHNlbGYuRm9ybURhdGEgOiB3aW5kb3cuRm9ybURhdGE7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyohXG4gKiBtaW1lLWRiXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1LTIwMjIgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RiLmpzb24nKVxuIiwiLyohXG4gKiBtaW1lLXR5cGVzXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBKb25hdGhhbiBPbmdcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCdcblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgZGIgPSByZXF1aXJlKCdtaW1lLWRiJylcbnZhciBleHRuYW1lID0gcmVxdWlyZSgncGF0aCcpLmV4dG5hbWVcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgRVhUUkFDVF9UWVBFX1JFR0VYUCA9IC9eXFxzKihbXjtcXHNdKikoPzo7fFxcc3wkKS9cbnZhciBURVhUX1RZUEVfUkVHRVhQID0gL150ZXh0XFwvL2lcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5leHBvcnRzLmNoYXJzZXQgPSBjaGFyc2V0XG5leHBvcnRzLmNoYXJzZXRzID0geyBsb29rdXA6IGNoYXJzZXQgfVxuZXhwb3J0cy5jb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlXG5leHBvcnRzLmV4dGVuc2lvbiA9IGV4dGVuc2lvblxuZXhwb3J0cy5leHRlbnNpb25zID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuZXhwb3J0cy5sb29rdXAgPSBsb29rdXBcbmV4cG9ydHMudHlwZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpXG5cbi8vIFBvcHVsYXRlIHRoZSBleHRlbnNpb25zL3R5cGVzIG1hcHNcbnBvcHVsYXRlTWFwcyhleHBvcnRzLmV4dGVuc2lvbnMsIGV4cG9ydHMudHlwZXMpXG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGNoYXJzZXQgZm9yIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBjaGFyc2V0ICh0eXBlKSB7XG4gIGlmICghdHlwZSB8fCB0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIC8vIFRPRE86IHVzZSBtZWRpYS10eXBlclxuICB2YXIgbWF0Y2ggPSBFWFRSQUNUX1RZUEVfUkVHRVhQLmV4ZWModHlwZSlcbiAgdmFyIG1pbWUgPSBtYXRjaCAmJiBkYlttYXRjaFsxXS50b0xvd2VyQ2FzZSgpXVxuXG4gIGlmIChtaW1lICYmIG1pbWUuY2hhcnNldCkge1xuICAgIHJldHVybiBtaW1lLmNoYXJzZXRcbiAgfVxuXG4gIC8vIGRlZmF1bHQgdGV4dC8qIHRvIHV0Zi04XG4gIGlmIChtYXRjaCAmJiBURVhUX1RZUEVfUkVHRVhQLnRlc3QobWF0Y2hbMV0pKSB7XG4gICAgcmV0dXJuICdVVEYtOCdcbiAgfVxuXG4gIHJldHVybiBmYWxzZVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIGZ1bGwgQ29udGVudC1UeXBlIGhlYWRlciBnaXZlbiBhIE1JTUUgdHlwZSBvciBleHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY29udGVudFR5cGUgKHN0cikge1xuICAvLyBUT0RPOiBzaG91bGQgdGhpcyBldmVuIGJlIGluIHRoaXMgbW9kdWxlP1xuICBpZiAoIXN0ciB8fCB0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgdmFyIG1pbWUgPSBzdHIuaW5kZXhPZignLycpID09PSAtMVxuICAgID8gZXhwb3J0cy5sb29rdXAoc3RyKVxuICAgIDogc3RyXG5cbiAgaWYgKCFtaW1lKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgY29udGVudC10eXBlIG9yIG90aGVyIG1vZHVsZVxuICBpZiAobWltZS5pbmRleE9mKCdjaGFyc2V0JykgPT09IC0xKSB7XG4gICAgdmFyIGNoYXJzZXQgPSBleHBvcnRzLmNoYXJzZXQobWltZSlcbiAgICBpZiAoY2hhcnNldCkgbWltZSArPSAnOyBjaGFyc2V0PScgKyBjaGFyc2V0LnRvTG93ZXJDYXNlKClcbiAgfVxuXG4gIHJldHVybiBtaW1lXG59XG5cbi8qKlxuICogR2V0IHRoZSBkZWZhdWx0IGV4dGVuc2lvbiBmb3IgYSBNSU1FIHR5cGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGV4dGVuc2lvbiAodHlwZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgbWVkaWEtdHlwZXJcbiAgdmFyIG1hdGNoID0gRVhUUkFDVF9UWVBFX1JFR0VYUC5leGVjKHR5cGUpXG5cbiAgLy8gZ2V0IGV4dGVuc2lvbnNcbiAgdmFyIGV4dHMgPSBtYXRjaCAmJiBleHBvcnRzLmV4dGVuc2lvbnNbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV1cblxuICBpZiAoIWV4dHMgfHwgIWV4dHMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXh0c1swXVxufVxuXG4vKipcbiAqIExvb2t1cCB0aGUgTUlNRSB0eXBlIGZvciBhIGZpbGUgcGF0aC9leHRlbnNpb24uXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHBhdGhcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGxvb2t1cCAocGF0aCkge1xuICBpZiAoIXBhdGggfHwgdHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBnZXQgdGhlIGV4dGVuc2lvbiAoXCJleHRcIiBvciBcIi5leHRcIiBvciBmdWxsIHBhdGgpXG4gIHZhciBleHRlbnNpb24gPSBleHRuYW1lKCd4LicgKyBwYXRoKVxuICAgIC50b0xvd2VyQ2FzZSgpXG4gICAgLnN1YnN0cigxKVxuXG4gIGlmICghZXh0ZW5zaW9uKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICByZXR1cm4gZXhwb3J0cy50eXBlc1tleHRlbnNpb25dIHx8IGZhbHNlXG59XG5cbi8qKlxuICogUG9wdWxhdGUgdGhlIGV4dGVuc2lvbnMgYW5kIHR5cGVzIG1hcHMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBvcHVsYXRlTWFwcyAoZXh0ZW5zaW9ucywgdHlwZXMpIHtcbiAgLy8gc291cmNlIHByZWZlcmVuY2UgKGxlYXN0IC0+IG1vc3QpXG4gIHZhciBwcmVmZXJlbmNlID0gWyduZ2lueCcsICdhcGFjaGUnLCB1bmRlZmluZWQsICdpYW5hJ11cblxuICBPYmplY3Qua2V5cyhkYikuZm9yRWFjaChmdW5jdGlvbiBmb3JFYWNoTWltZVR5cGUgKHR5cGUpIHtcbiAgICB2YXIgbWltZSA9IGRiW3R5cGVdXG4gICAgdmFyIGV4dHMgPSBtaW1lLmV4dGVuc2lvbnNcblxuICAgIGlmICghZXh0cyB8fCAhZXh0cy5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIG1pbWUgLT4gZXh0ZW5zaW9uc1xuICAgIGV4dGVuc2lvbnNbdHlwZV0gPSBleHRzXG5cbiAgICAvLyBleHRlbnNpb24gLT4gbWltZVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXh0cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGV4dGVuc2lvbiA9IGV4dHNbaV1cblxuICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0pIHtcbiAgICAgICAgdmFyIGZyb20gPSBwcmVmZXJlbmNlLmluZGV4T2YoZGJbdHlwZXNbZXh0ZW5zaW9uXV0uc291cmNlKVxuICAgICAgICB2YXIgdG8gPSBwcmVmZXJlbmNlLmluZGV4T2YobWltZS5zb3VyY2UpXG5cbiAgICAgICAgaWYgKHR5cGVzW2V4dGVuc2lvbl0gIT09ICdhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0nICYmXG4gICAgICAgICAgKGZyb20gPiB0byB8fCAoZnJvbSA9PT0gdG8gJiYgdHlwZXNbZXh0ZW5zaW9uXS5zdWJzdHIoMCwgMTIpID09PSAnYXBwbGljYXRpb24vJykpKSB7XG4gICAgICAgICAgLy8gc2tpcCB0aGUgcmVtYXBwaW5nXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBzZXQgdGhlIGV4dGVuc2lvbiAtPiBtaW1lXG4gICAgICB0eXBlc1tleHRlbnNpb25dID0gdHlwZVxuICAgIH1cbiAgfSlcbn1cbiIsImFzc2VydC5ub3RFcXVhbCA9IG5vdEVxdWFsXG5hc3NlcnQubm90T2sgPSBub3RPa1xuYXNzZXJ0LmVxdWFsID0gZXF1YWxcbmFzc2VydC5vayA9IGFzc2VydFxuXG5tb2R1bGUuZXhwb3J0cyA9IGFzc2VydFxuXG5mdW5jdGlvbiBlcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSA9PSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RFcXVhbCAoYSwgYiwgbSkge1xuICBhc3NlcnQoYSAhPSBiLCBtKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxufVxuXG5mdW5jdGlvbiBub3RPayAodCwgbSkge1xuICBhc3NlcnQoIXQsIG0pXG59XG5cbmZ1bmN0aW9uIGFzc2VydCAodCwgbSkge1xuICBpZiAoIXQpIHRocm93IG5ldyBFcnJvcihtIHx8ICdBc3NlcnRpb25FcnJvcicpXG59XG4iLCIvKiFcbiAqIG5lZ290aWF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyIEZlZGVyaWNvIFJvbWVyb1xuICogQ29weXJpZ2h0KGMpIDIwMTItMjAxNCBJc2FhYyBaLiBTY2hsdWV0ZXJcbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwcmVmZXJyZWRDaGFyc2V0cyA9IHJlcXVpcmUoJy4vbGliL2NoYXJzZXQnKVxudmFyIHByZWZlcnJlZEVuY29kaW5ncyA9IHJlcXVpcmUoJy4vbGliL2VuY29kaW5nJylcbnZhciBwcmVmZXJyZWRMYW5ndWFnZXMgPSByZXF1aXJlKCcuL2xpYi9sYW5ndWFnZScpXG52YXIgcHJlZmVycmVkTWVkaWFUeXBlcyA9IHJlcXVpcmUoJy4vbGliL21lZGlhVHlwZScpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBOZWdvdGlhdG9yO1xubW9kdWxlLmV4cG9ydHMuTmVnb3RpYXRvciA9IE5lZ290aWF0b3I7XG5cbi8qKlxuICogQ3JlYXRlIGEgTmVnb3RpYXRvciBpbnN0YW5jZSBmcm9tIGEgcmVxdWVzdC5cbiAqIEBwYXJhbSB7b2JqZWN0fSByZXF1ZXN0XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gTmVnb3RpYXRvcihyZXF1ZXN0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBOZWdvdGlhdG9yKSkge1xuICAgIHJldHVybiBuZXcgTmVnb3RpYXRvcihyZXF1ZXN0KTtcbiAgfVxuXG4gIHRoaXMucmVxdWVzdCA9IHJlcXVlc3Q7XG59XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmNoYXJzZXQgPSBmdW5jdGlvbiBjaGFyc2V0KGF2YWlsYWJsZSkge1xuICB2YXIgc2V0ID0gdGhpcy5jaGFyc2V0cyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmNoYXJzZXRzID0gZnVuY3Rpb24gY2hhcnNldHMoYXZhaWxhYmxlKSB7XG4gIHJldHVybiBwcmVmZXJyZWRDaGFyc2V0cyh0aGlzLnJlcXVlc3QuaGVhZGVyc1snYWNjZXB0LWNoYXJzZXQnXSwgYXZhaWxhYmxlKTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5nID0gZnVuY3Rpb24gZW5jb2RpbmcoYXZhaWxhYmxlKSB7XG4gIHZhciBzZXQgPSB0aGlzLmVuY29kaW5ncyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5ncyA9IGZ1bmN0aW9uIGVuY29kaW5ncyhhdmFpbGFibGUpIHtcbiAgcmV0dXJuIHByZWZlcnJlZEVuY29kaW5ncyh0aGlzLnJlcXVlc3QuaGVhZGVyc1snYWNjZXB0LWVuY29kaW5nJ10sIGF2YWlsYWJsZSk7XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5sYW5ndWFnZSA9IGZ1bmN0aW9uIGxhbmd1YWdlKGF2YWlsYWJsZSkge1xuICB2YXIgc2V0ID0gdGhpcy5sYW5ndWFnZXMoYXZhaWxhYmxlKTtcbiAgcmV0dXJuIHNldCAmJiBzZXRbMF07XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5sYW5ndWFnZXMgPSBmdW5jdGlvbiBsYW5ndWFnZXMoYXZhaWxhYmxlKSB7XG4gIHJldHVybiBwcmVmZXJyZWRMYW5ndWFnZXModGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ2FjY2VwdC1sYW5ndWFnZSddLCBhdmFpbGFibGUpO1xufTtcblxuTmVnb3RpYXRvci5wcm90b3R5cGUubWVkaWFUeXBlID0gZnVuY3Rpb24gbWVkaWFUeXBlKGF2YWlsYWJsZSkge1xuICB2YXIgc2V0ID0gdGhpcy5tZWRpYVR5cGVzKGF2YWlsYWJsZSk7XG4gIHJldHVybiBzZXQgJiYgc2V0WzBdO1xufTtcblxuTmVnb3RpYXRvci5wcm90b3R5cGUubWVkaWFUeXBlcyA9IGZ1bmN0aW9uIG1lZGlhVHlwZXMoYXZhaWxhYmxlKSB7XG4gIHJldHVybiBwcmVmZXJyZWRNZWRpYVR5cGVzKHRoaXMucmVxdWVzdC5oZWFkZXJzLmFjY2VwdCwgYXZhaWxhYmxlKTtcbn07XG5cbi8vIEJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRDaGFyc2V0ID0gTmVnb3RpYXRvci5wcm90b3R5cGUuY2hhcnNldDtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZENoYXJzZXRzID0gTmVnb3RpYXRvci5wcm90b3R5cGUuY2hhcnNldHM7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRFbmNvZGluZyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5nO1xuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkRW5jb2RpbmdzID0gTmVnb3RpYXRvci5wcm90b3R5cGUuZW5jb2RpbmdzO1xuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkTGFuZ3VhZ2UgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5sYW5ndWFnZTtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZExhbmd1YWdlcyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmxhbmd1YWdlcztcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZE1lZGlhVHlwZSA9IE5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZTtcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZE1lZGlhVHlwZXMgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5tZWRpYVR5cGVzO1xuIiwiLyoqXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBJc2FhYyBaLiBTY2hsdWV0ZXJcbiAqIENvcHlyaWdodChjKSAyMDE0IEZlZGVyaWNvIFJvbWVyb1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZmVycmVkQ2hhcnNldHM7XG5tb2R1bGUuZXhwb3J0cy5wcmVmZXJyZWRDaGFyc2V0cyA9IHByZWZlcnJlZENoYXJzZXRzO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzaW1wbGVDaGFyc2V0UmVnRXhwID0gL15cXHMqKFteXFxzO10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1DaGFyc2V0IGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VBY2NlcHRDaGFyc2V0KGFjY2VwdCkge1xuICB2YXIgYWNjZXB0cyA9IGFjY2VwdC5zcGxpdCgnLCcpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFjY2VwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcnNldCA9IHBhcnNlQ2hhcnNldChhY2NlcHRzW2ldLnRyaW0oKSwgaSk7XG5cbiAgICBpZiAoY2hhcnNldCkge1xuICAgICAgYWNjZXB0c1tqKytdID0gY2hhcnNldDtcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqO1xuXG4gIHJldHVybiBhY2NlcHRzO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgY2hhcnNldCBmcm9tIHRoZSBBY2NlcHQtQ2hhcnNldCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQ2hhcnNldChzdHIsIGkpIHtcbiAgdmFyIG1hdGNoID0gc2ltcGxlQ2hhcnNldFJlZ0V4cC5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciBjaGFyc2V0ID0gbWF0Y2hbMV07XG4gIHZhciBxID0gMTtcbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdmFyIHBhcmFtcyA9IG1hdGNoWzJdLnNwbGl0KCc7JylcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBhcmFtcy5sZW5ndGg7IGorKykge1xuICAgICAgdmFyIHAgPSBwYXJhbXNbal0udHJpbSgpLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAocFswXSA9PT0gJ3EnKSB7XG4gICAgICAgIHEgPSBwYXJzZUZsb2F0KHBbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGNoYXJzZXQ6IGNoYXJzZXQsXG4gICAgcTogcSxcbiAgICBpOiBpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmlvcml0eSBvZiBhIGNoYXJzZXQuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldENoYXJzZXRQcmlvcml0eShjaGFyc2V0LCBhY2NlcHRlZCwgaW5kZXgpIHtcbiAgdmFyIHByaW9yaXR5ID0ge286IC0xLCBxOiAwLCBzOiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwZWMgPSBzcGVjaWZ5KGNoYXJzZXQsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBjaGFyc2V0LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGVjaWZ5KGNoYXJzZXQsIHNwZWMsIGluZGV4KSB7XG4gIHZhciBzID0gMDtcbiAgaWYoc3BlYy5jaGFyc2V0LnRvTG93ZXJDYXNlKCkgPT09IGNoYXJzZXQudG9Mb3dlckNhc2UoKSl7XG4gICAgcyB8PSAxO1xuICB9IGVsc2UgaWYgKHNwZWMuY2hhcnNldCAhPT0gJyonICkge1xuICAgIHJldHVybiBudWxsXG4gIH1cblxuICByZXR1cm4ge1xuICAgIGk6IGluZGV4LFxuICAgIG86IHNwZWMuaSxcbiAgICBxOiBzcGVjLnEsXG4gICAgczogc1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmZXJyZWQgY2hhcnNldHMgZnJvbSBhbiBBY2NlcHQtQ2hhcnNldCBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJlZmVycmVkQ2hhcnNldHMoYWNjZXB0LCBwcm92aWRlZCkge1xuICAvLyBSRkMgMjYxNiBzZWMgMTQuMjogbm8gaGVhZGVyID0gKlxuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0Q2hhcnNldChhY2NlcHQgPT09IHVuZGVmaW5lZCA/ICcqJyA6IGFjY2VwdCB8fCAnJyk7XG5cbiAgaWYgKCFwcm92aWRlZCkge1xuICAgIC8vIHNvcnRlZCBsaXN0IG9mIGFsbCBjaGFyc2V0c1xuICAgIHJldHVybiBhY2NlcHRzXG4gICAgICAuZmlsdGVyKGlzUXVhbGl0eSlcbiAgICAgIC5zb3J0KGNvbXBhcmVTcGVjcylcbiAgICAgIC5tYXAoZ2V0RnVsbENoYXJzZXQpO1xuICB9XG5cbiAgdmFyIHByaW9yaXRpZXMgPSBwcm92aWRlZC5tYXAoZnVuY3Rpb24gZ2V0UHJpb3JpdHkodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0Q2hhcnNldFByaW9yaXR5KHR5cGUsIGFjY2VwdHMsIGluZGV4KTtcbiAgfSk7XG5cbiAgLy8gc29ydGVkIGxpc3Qgb2YgYWNjZXB0ZWQgY2hhcnNldHNcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRDaGFyc2V0KHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHByb3ZpZGVkW3ByaW9yaXRpZXMuaW5kZXhPZihwcmlvcml0eSldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBzcGVjcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZVNwZWNzKGEsIGIpIHtcbiAgcmV0dXJuIChiLnEgLSBhLnEpIHx8IChiLnMgLSBhLnMpIHx8IChhLm8gLSBiLm8pIHx8IChhLmkgLSBiLmkpIHx8IDA7XG59XG5cbi8qKlxuICogR2V0IGZ1bGwgY2hhcnNldCBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEZ1bGxDaGFyc2V0KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuY2hhcnNldDtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNwZWMgaGFzIGFueSBxdWFsaXR5LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1F1YWxpdHkoc3BlYykge1xuICByZXR1cm4gc3BlYy5xID4gMDtcbn1cbiIsIi8qKlxuICogbmVnb3RpYXRvclxuICogQ29weXJpZ2h0KGMpIDIwMTIgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZWZlcnJlZEVuY29kaW5ncztcbm1vZHVsZS5leHBvcnRzLnByZWZlcnJlZEVuY29kaW5ncyA9IHByZWZlcnJlZEVuY29kaW5ncztcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2ltcGxlRW5jb2RpbmdSZWdFeHAgPSAvXlxccyooW15cXHM7XSspXFxzKig/OjsoLiopKT8kLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgQWNjZXB0LUVuY29kaW5nIGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VBY2NlcHRFbmNvZGluZyhhY2NlcHQpIHtcbiAgdmFyIGFjY2VwdHMgPSBhY2NlcHQuc3BsaXQoJywnKTtcbiAgdmFyIGhhc0lkZW50aXR5ID0gZmFsc2U7XG4gIHZhciBtaW5RdWFsaXR5ID0gMTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBhY2NlcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGVuY29kaW5nID0gcGFyc2VFbmNvZGluZyhhY2NlcHRzW2ldLnRyaW0oKSwgaSk7XG5cbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGFjY2VwdHNbaisrXSA9IGVuY29kaW5nO1xuICAgICAgaGFzSWRlbnRpdHkgPSBoYXNJZGVudGl0eSB8fCBzcGVjaWZ5KCdpZGVudGl0eScsIGVuY29kaW5nKTtcbiAgICAgIG1pblF1YWxpdHkgPSBNYXRoLm1pbihtaW5RdWFsaXR5LCBlbmNvZGluZy5xIHx8IDEpO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaGFzSWRlbnRpdHkpIHtcbiAgICAvKlxuICAgICAqIElmIGlkZW50aXR5IGRvZXNuJ3QgZXhwbGljaXRseSBhcHBlYXIgaW4gdGhlIGFjY2VwdC1lbmNvZGluZyBoZWFkZXIsXG4gICAgICogaXQncyBhZGRlZCB0byB0aGUgbGlzdCBvZiBhY2NlcHRhYmxlIGVuY29kaW5nIHdpdGggdGhlIGxvd2VzdCBxXG4gICAgICovXG4gICAgYWNjZXB0c1tqKytdID0ge1xuICAgICAgZW5jb2Rpbmc6ICdpZGVudGl0eScsXG4gICAgICBxOiBtaW5RdWFsaXR5LFxuICAgICAgaTogaVxuICAgIH07XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqO1xuXG4gIHJldHVybiBhY2NlcHRzO1xufVxuXG4vKipcbiAqIFBhcnNlIGFuIGVuY29kaW5nIGZyb20gdGhlIEFjY2VwdC1FbmNvZGluZyBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlRW5jb2Rpbmcoc3RyLCBpKSB7XG4gIHZhciBtYXRjaCA9IHNpbXBsZUVuY29kaW5nUmVnRXhwLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIGVuY29kaW5nID0gbWF0Y2hbMV07XG4gIHZhciBxID0gMTtcbiAgaWYgKG1hdGNoWzJdKSB7XG4gICAgdmFyIHBhcmFtcyA9IG1hdGNoWzJdLnNwbGl0KCc7Jyk7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwID0gcGFyYW1zW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgICAgaWYgKHBbMF0gPT09ICdxJykge1xuICAgICAgICBxID0gcGFyc2VGbG9hdChwWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgcTogcSxcbiAgICBpOiBpXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmlvcml0eSBvZiBhbiBlbmNvZGluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RW5jb2RpbmdQcmlvcml0eShlbmNvZGluZywgYWNjZXB0ZWQsIGluZGV4KSB7XG4gIHZhciBwcmlvcml0eSA9IHtvOiAtMSwgcTogMCwgczogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGVjID0gc3BlY2lmeShlbmNvZGluZywgYWNjZXB0ZWRbaV0sIGluZGV4KTtcblxuICAgIGlmIChzcGVjICYmIChwcmlvcml0eS5zIC0gc3BlYy5zIHx8IHByaW9yaXR5LnEgLSBzcGVjLnEgfHwgcHJpb3JpdHkubyAtIHNwZWMubykgPCAwKSB7XG4gICAgICBwcmlvcml0eSA9IHNwZWM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByaW9yaXR5O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3BlY2lmaWNpdHkgb2YgdGhlIGVuY29kaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGVjaWZ5KGVuY29kaW5nLCBzcGVjLCBpbmRleCkge1xuICB2YXIgcyA9IDA7XG4gIGlmKHNwZWMuZW5jb2RpbmcudG9Mb3dlckNhc2UoKSA9PT0gZW5jb2RpbmcudG9Mb3dlckNhc2UoKSl7XG4gICAgcyB8PSAxO1xuICB9IGVsc2UgaWYgKHNwZWMuZW5jb2RpbmcgIT09ICcqJyApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpOiBpbmRleCxcbiAgICBvOiBzcGVjLmksXG4gICAgcTogc3BlYy5xLFxuICAgIHM6IHNcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHByZWZlcnJlZCBlbmNvZGluZ3MgZnJvbSBhbiBBY2NlcHQtRW5jb2RpbmcgaGVhZGVyLlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHByZWZlcnJlZEVuY29kaW5ncyhhY2NlcHQsIHByb3ZpZGVkKSB7XG4gIHZhciBhY2NlcHRzID0gcGFyc2VBY2NlcHRFbmNvZGluZyhhY2NlcHQgfHwgJycpO1xuXG4gIGlmICghcHJvdmlkZWQpIHtcbiAgICAvLyBzb3J0ZWQgbGlzdCBvZiBhbGwgZW5jb2RpbmdzXG4gICAgcmV0dXJuIGFjY2VwdHNcbiAgICAgIC5maWx0ZXIoaXNRdWFsaXR5KVxuICAgICAgLnNvcnQoY29tcGFyZVNwZWNzKVxuICAgICAgLm1hcChnZXRGdWxsRW5jb2RpbmcpO1xuICB9XG5cbiAgdmFyIHByaW9yaXRpZXMgPSBwcm92aWRlZC5tYXAoZnVuY3Rpb24gZ2V0UHJpb3JpdHkodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0RW5jb2RpbmdQcmlvcml0eSh0eXBlLCBhY2NlcHRzLCBpbmRleCk7XG4gIH0pO1xuXG4gIC8vIHNvcnRlZCBsaXN0IG9mIGFjY2VwdGVkIGVuY29kaW5nc1xuICByZXR1cm4gcHJpb3JpdGllcy5maWx0ZXIoaXNRdWFsaXR5KS5zb3J0KGNvbXBhcmVTcGVjcykubWFwKGZ1bmN0aW9uIGdldEVuY29kaW5nKHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHByb3ZpZGVkW3ByaW9yaXRpZXMuaW5kZXhPZihwcmlvcml0eSldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBzcGVjcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZVNwZWNzKGEsIGIpIHtcbiAgcmV0dXJuIChiLnEgLSBhLnEpIHx8IChiLnMgLSBhLnMpIHx8IChhLm8gLSBiLm8pIHx8IChhLmkgLSBiLmkpIHx8IDA7XG59XG5cbi8qKlxuICogR2V0IGZ1bGwgZW5jb2Rpbmcgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRGdWxsRW5jb2Rpbmcoc3BlYykge1xuICByZXR1cm4gc3BlYy5lbmNvZGluZztcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNwZWMgaGFzIGFueSBxdWFsaXR5LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1F1YWxpdHkoc3BlYykge1xuICByZXR1cm4gc3BlYy5xID4gMDtcbn1cbiIsIi8qKlxuICogbmVnb3RpYXRvclxuICogQ29weXJpZ2h0KGMpIDIwMTIgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZWZlcnJlZExhbmd1YWdlcztcbm1vZHVsZS5leHBvcnRzLnByZWZlcnJlZExhbmd1YWdlcyA9IHByZWZlcnJlZExhbmd1YWdlcztcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2ltcGxlTGFuZ3VhZ2VSZWdFeHAgPSAvXlxccyooW15cXHNcXC07XSspKD86LShbXlxccztdKykpP1xccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0TGFuZ3VhZ2UoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBsYW5ndWFnZSA9IHBhcnNlTGFuZ3VhZ2UoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKGxhbmd1YWdlKSB7XG4gICAgICBhY2NlcHRzW2orK10gPSBsYW5ndWFnZTtcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqO1xuXG4gIHJldHVybiBhY2NlcHRzO1xufVxuXG4vKipcbiAqIFBhcnNlIGEgbGFuZ3VhZ2UgZnJvbSB0aGUgQWNjZXB0LUxhbmd1YWdlIGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VMYW5ndWFnZShzdHIsIGkpIHtcbiAgdmFyIG1hdGNoID0gc2ltcGxlTGFuZ3VhZ2VSZWdFeHAuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcHJlZml4ID0gbWF0Y2hbMV1cbiAgdmFyIHN1ZmZpeCA9IG1hdGNoWzJdXG4gIHZhciBmdWxsID0gcHJlZml4XG5cbiAgaWYgKHN1ZmZpeCkgZnVsbCArPSBcIi1cIiArIHN1ZmZpeDtcblxuICB2YXIgcSA9IDE7XG4gIGlmIChtYXRjaFszXSkge1xuICAgIHZhciBwYXJhbXMgPSBtYXRjaFszXS5zcGxpdCgnOycpXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwID0gcGFyYW1zW2pdLnNwbGl0KCc9Jyk7XG4gICAgICBpZiAocFswXSA9PT0gJ3EnKSBxID0gcGFyc2VGbG9hdChwWzFdKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHByZWZpeDogcHJlZml4LFxuICAgIHN1ZmZpeDogc3VmZml4LFxuICAgIHE6IHEsXG4gICAgaTogaSxcbiAgICBmdWxsOiBmdWxsXG4gIH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBwcmlvcml0eSBvZiBhIGxhbmd1YWdlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRMYW5ndWFnZVByaW9yaXR5KGxhbmd1YWdlLCBhY2NlcHRlZCwgaW5kZXgpIHtcbiAgdmFyIHByaW9yaXR5ID0ge286IC0xLCBxOiAwLCBzOiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwZWMgPSBzcGVjaWZ5KGxhbmd1YWdlLCBhY2NlcHRlZFtpXSwgaW5kZXgpO1xuXG4gICAgaWYgKHNwZWMgJiYgKHByaW9yaXR5LnMgLSBzcGVjLnMgfHwgcHJpb3JpdHkucSAtIHNwZWMucSB8fCBwcmlvcml0eS5vIC0gc3BlYy5vKSA8IDApIHtcbiAgICAgIHByaW9yaXR5ID0gc3BlYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgbGFuZ3VhZ2UuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNwZWNpZnkobGFuZ3VhZ2UsIHNwZWMsIGluZGV4KSB7XG4gIHZhciBwID0gcGFyc2VMYW5ndWFnZShsYW5ndWFnZSlcbiAgaWYgKCFwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHMgPSAwO1xuICBpZihzcGVjLmZ1bGwudG9Mb3dlckNhc2UoKSA9PT0gcC5mdWxsLnRvTG93ZXJDYXNlKCkpe1xuICAgIHMgfD0gNDtcbiAgfSBlbHNlIGlmIChzcGVjLnByZWZpeC50b0xvd2VyQ2FzZSgpID09PSBwLmZ1bGwudG9Mb3dlckNhc2UoKSkge1xuICAgIHMgfD0gMjtcbiAgfSBlbHNlIGlmIChzcGVjLmZ1bGwudG9Mb3dlckNhc2UoKSA9PT0gcC5wcmVmaXgudG9Mb3dlckNhc2UoKSkge1xuICAgIHMgfD0gMTtcbiAgfSBlbHNlIGlmIChzcGVjLmZ1bGwgIT09ICcqJyApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpOiBpbmRleCxcbiAgICBvOiBzcGVjLmksXG4gICAgcTogc3BlYy5xLFxuICAgIHM6IHNcbiAgfVxufTtcblxuLyoqXG4gKiBHZXQgdGhlIHByZWZlcnJlZCBsYW5ndWFnZXMgZnJvbSBhbiBBY2NlcHQtTGFuZ3VhZ2UgaGVhZGVyLlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHByZWZlcnJlZExhbmd1YWdlcyhhY2NlcHQsIHByb3ZpZGVkKSB7XG4gIC8vIFJGQyAyNjE2IHNlYyAxNC40OiBubyBoZWFkZXIgPSAqXG4gIHZhciBhY2NlcHRzID0gcGFyc2VBY2NlcHRMYW5ndWFnZShhY2NlcHQgPT09IHVuZGVmaW5lZCA/ICcqJyA6IGFjY2VwdCB8fCAnJyk7XG5cbiAgaWYgKCFwcm92aWRlZCkge1xuICAgIC8vIHNvcnRlZCBsaXN0IG9mIGFsbCBsYW5ndWFnZXNcbiAgICByZXR1cm4gYWNjZXB0c1xuICAgICAgLmZpbHRlcihpc1F1YWxpdHkpXG4gICAgICAuc29ydChjb21wYXJlU3BlY3MpXG4gICAgICAubWFwKGdldEZ1bGxMYW5ndWFnZSk7XG4gIH1cblxuICB2YXIgcHJpb3JpdGllcyA9IHByb3ZpZGVkLm1hcChmdW5jdGlvbiBnZXRQcmlvcml0eSh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBnZXRMYW5ndWFnZVByaW9yaXR5KHR5cGUsIGFjY2VwdHMsIGluZGV4KTtcbiAgfSk7XG5cbiAgLy8gc29ydGVkIGxpc3Qgb2YgYWNjZXB0ZWQgbGFuZ3VhZ2VzXG4gIHJldHVybiBwcmlvcml0aWVzLmZpbHRlcihpc1F1YWxpdHkpLnNvcnQoY29tcGFyZVNwZWNzKS5tYXAoZnVuY3Rpb24gZ2V0TGFuZ3VhZ2UocHJpb3JpdHkpIHtcbiAgICByZXR1cm4gcHJvdmlkZWRbcHJpb3JpdGllcy5pbmRleE9mKHByaW9yaXR5KV07XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbXBhcmUgdHdvIHNwZWNzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBjb21wYXJlU3BlY3MoYSwgYikge1xuICByZXR1cm4gKGIucSAtIGEucSkgfHwgKGIucyAtIGEucykgfHwgKGEubyAtIGIubykgfHwgKGEuaSAtIGIuaSkgfHwgMDtcbn1cblxuLyoqXG4gKiBHZXQgZnVsbCBsYW5ndWFnZSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEZ1bGxMYW5ndWFnZShzcGVjKSB7XG4gIHJldHVybiBzcGVjLmZ1bGw7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG4iLCIvKipcbiAqIG5lZ290aWF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyIElzYWFjIFouIFNjaGx1ZXRlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRmVkZXJpY28gUm9tZXJvXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVmZXJyZWRNZWRpYVR5cGVzO1xubW9kdWxlLmV4cG9ydHMucHJlZmVycmVkTWVkaWFUeXBlcyA9IHByZWZlcnJlZE1lZGlhVHlwZXM7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNpbXBsZU1lZGlhVHlwZVJlZ0V4cCA9IC9eXFxzKihbXlxcc1xcLztdKylcXC8oW147XFxzXSspXFxzKig/OjsoLiopKT8kLztcblxuLyoqXG4gKiBQYXJzZSB0aGUgQWNjZXB0IGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VBY2NlcHQoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gc3BsaXRNZWRpYVR5cGVzKGFjY2VwdCk7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBtZWRpYVR5cGUgPSBwYXJzZU1lZGlhVHlwZShhY2NlcHRzW2ldLnRyaW0oKSwgaSk7XG5cbiAgICBpZiAobWVkaWFUeXBlKSB7XG4gICAgICBhY2NlcHRzW2orK10gPSBtZWRpYVR5cGU7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gajtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIG1lZGlhIHR5cGUgZnJvbSB0aGUgQWNjZXB0IGhlYWRlci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2VNZWRpYVR5cGUoc3RyLCBpKSB7XG4gIHZhciBtYXRjaCA9IHNpbXBsZU1lZGlhVHlwZVJlZ0V4cC5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICB2YXIgcSA9IDE7XG4gIHZhciBzdWJ0eXBlID0gbWF0Y2hbMl07XG4gIHZhciB0eXBlID0gbWF0Y2hbMV07XG5cbiAgaWYgKG1hdGNoWzNdKSB7XG4gICAgdmFyIGt2cHMgPSBzcGxpdFBhcmFtZXRlcnMobWF0Y2hbM10pLm1hcChzcGxpdEtleVZhbHVlUGFpcik7XG5cbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IGt2cHMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwYWlyID0ga3Zwc1tqXTtcbiAgICAgIHZhciBrZXkgPSBwYWlyWzBdLnRvTG93ZXJDYXNlKCk7XG4gICAgICB2YXIgdmFsID0gcGFpclsxXTtcblxuICAgICAgLy8gZ2V0IHRoZSB2YWx1ZSwgdW53cmFwcGluZyBxdW90ZXNcbiAgICAgIHZhciB2YWx1ZSA9IHZhbCAmJiB2YWxbMF0gPT09ICdcIicgJiYgdmFsW3ZhbC5sZW5ndGggLSAxXSA9PT0gJ1wiJ1xuICAgICAgICA/IHZhbC5zdWJzdHIoMSwgdmFsLmxlbmd0aCAtIDIpXG4gICAgICAgIDogdmFsO1xuXG4gICAgICBpZiAoa2V5ID09PSAncScpIHtcbiAgICAgICAgcSA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gc3RvcmUgcGFyYW1ldGVyXG4gICAgICBwYXJhbXNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICBzdWJ0eXBlOiBzdWJ0eXBlLFxuICAgIHBhcmFtczogcGFyYW1zLFxuICAgIHE6IHEsXG4gICAgaTogaVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJpb3JpdHkgb2YgYSBtZWRpYSB0eXBlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRNZWRpYVR5cGVQcmlvcml0eSh0eXBlLCBhY2NlcHRlZCwgaW5kZXgpIHtcbiAgdmFyIHByaW9yaXR5ID0ge286IC0xLCBxOiAwLCBzOiAwfTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGFjY2VwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHNwZWMgPSBzcGVjaWZ5KHR5cGUsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBtZWRpYSB0eXBlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGVjaWZ5KHR5cGUsIHNwZWMsIGluZGV4KSB7XG4gIHZhciBwID0gcGFyc2VNZWRpYVR5cGUodHlwZSk7XG4gIHZhciBzID0gMDtcblxuICBpZiAoIXApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGlmKHNwZWMudHlwZS50b0xvd2VyQ2FzZSgpID09IHAudHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgcyB8PSA0XG4gIH0gZWxzZSBpZihzcGVjLnR5cGUgIT0gJyonKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZihzcGVjLnN1YnR5cGUudG9Mb3dlckNhc2UoKSA9PSBwLnN1YnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIHMgfD0gMlxuICB9IGVsc2UgaWYoc3BlYy5zdWJ0eXBlICE9ICcqJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzcGVjLnBhcmFtcyk7XG4gIGlmIChrZXlzLmxlbmd0aCA+IDApIHtcbiAgICBpZiAoa2V5cy5ldmVyeShmdW5jdGlvbiAoaykge1xuICAgICAgcmV0dXJuIHNwZWMucGFyYW1zW2tdID09ICcqJyB8fCAoc3BlYy5wYXJhbXNba10gfHwgJycpLnRvTG93ZXJDYXNlKCkgPT0gKHAucGFyYW1zW2tdIHx8ICcnKS50b0xvd2VyQ2FzZSgpO1xuICAgIH0pKSB7XG4gICAgICBzIHw9IDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG51bGxcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGk6IGluZGV4LFxuICAgIG86IHNwZWMuaSxcbiAgICBxOiBzcGVjLnEsXG4gICAgczogcyxcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZmVycmVkIG1lZGlhIHR5cGVzIGZyb20gYW4gQWNjZXB0IGhlYWRlci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwcmVmZXJyZWRNZWRpYVR5cGVzKGFjY2VwdCwgcHJvdmlkZWQpIHtcbiAgLy8gUkZDIDI2MTYgc2VjIDE0LjI6IG5vIGhlYWRlciA9ICovKlxuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0KGFjY2VwdCA9PT0gdW5kZWZpbmVkID8gJyovKicgOiBhY2NlcHQgfHwgJycpO1xuXG4gIGlmICghcHJvdmlkZWQpIHtcbiAgICAvLyBzb3J0ZWQgbGlzdCBvZiBhbGwgdHlwZXNcbiAgICByZXR1cm4gYWNjZXB0c1xuICAgICAgLmZpbHRlcihpc1F1YWxpdHkpXG4gICAgICAuc29ydChjb21wYXJlU3BlY3MpXG4gICAgICAubWFwKGdldEZ1bGxUeXBlKTtcbiAgfVxuXG4gIHZhciBwcmlvcml0aWVzID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIGdldFByaW9yaXR5KHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGdldE1lZGlhVHlwZVByaW9yaXR5KHR5cGUsIGFjY2VwdHMsIGluZGV4KTtcbiAgfSk7XG5cbiAgLy8gc29ydGVkIGxpc3Qgb2YgYWNjZXB0ZWQgdHlwZXNcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRUeXBlKHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHByb3ZpZGVkW3ByaW9yaXRpZXMuaW5kZXhPZihwcmlvcml0eSldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBzcGVjcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZVNwZWNzKGEsIGIpIHtcbiAgcmV0dXJuIChiLnEgLSBhLnEpIHx8IChiLnMgLSBhLnMpIHx8IChhLm8gLSBiLm8pIHx8IChhLmkgLSBiLmkpIHx8IDA7XG59XG5cbi8qKlxuICogR2V0IGZ1bGwgdHlwZSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEZ1bGxUeXBlKHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMudHlwZSArICcvJyArIHNwZWMuc3VidHlwZTtcbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHNwZWMgaGFzIGFueSBxdWFsaXR5LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBpc1F1YWxpdHkoc3BlYykge1xuICByZXR1cm4gc3BlYy5xID4gMDtcbn1cblxuLyoqXG4gKiBDb3VudCB0aGUgbnVtYmVyIG9mIHF1b3RlcyBpbiBhIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcXVvdGVDb3VudChzdHJpbmcpIHtcbiAgdmFyIGNvdW50ID0gMDtcbiAgdmFyIGluZGV4ID0gMDtcblxuICB3aGlsZSAoKGluZGV4ID0gc3RyaW5nLmluZGV4T2YoJ1wiJywgaW5kZXgpKSAhPT0gLTEpIHtcbiAgICBjb3VudCsrO1xuICAgIGluZGV4Kys7XG4gIH1cblxuICByZXR1cm4gY291bnQ7XG59XG5cbi8qKlxuICogU3BsaXQgYSBrZXkgdmFsdWUgcGFpci5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BsaXRLZXlWYWx1ZVBhaXIoc3RyKSB7XG4gIHZhciBpbmRleCA9IHN0ci5pbmRleE9mKCc9Jyk7XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG5cbiAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgIGtleSA9IHN0cjtcbiAgfSBlbHNlIHtcbiAgICBrZXkgPSBzdHIuc3Vic3RyKDAsIGluZGV4KTtcbiAgICB2YWwgPSBzdHIuc3Vic3RyKGluZGV4ICsgMSk7XG4gIH1cblxuICByZXR1cm4gW2tleSwgdmFsXTtcbn1cblxuLyoqXG4gKiBTcGxpdCBhbiBBY2NlcHQgaGVhZGVyIGludG8gbWVkaWEgdHlwZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNwbGl0TWVkaWFUeXBlcyhhY2NlcHQpIHtcbiAgdmFyIGFjY2VwdHMgPSBhY2NlcHQuc3BsaXQoJywnKTtcblxuICBmb3IgKHZhciBpID0gMSwgaiA9IDA7IGkgPCBhY2NlcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKHF1b3RlQ291bnQoYWNjZXB0c1tqXSkgJSAyID09IDApIHtcbiAgICAgIGFjY2VwdHNbKytqXSA9IGFjY2VwdHNbaV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGFjY2VwdHNbal0gKz0gJywnICsgYWNjZXB0c1tpXTtcbiAgICB9XG4gIH1cblxuICAvLyB0cmltIGFjY2VwdHNcbiAgYWNjZXB0cy5sZW5ndGggPSBqICsgMTtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBTcGxpdCBhIHN0cmluZyBvZiBwYXJhbWV0ZXJzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdFBhcmFtZXRlcnMoc3RyKSB7XG4gIHZhciBwYXJhbWV0ZXJzID0gc3RyLnNwbGl0KCc7Jyk7XG5cbiAgZm9yICh2YXIgaSA9IDEsIGogPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChxdW90ZUNvdW50KHBhcmFtZXRlcnNbal0pICUgMiA9PSAwKSB7XG4gICAgICBwYXJhbWV0ZXJzWysral0gPSBwYXJhbWV0ZXJzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbWV0ZXJzW2pdICs9ICc7JyArIHBhcmFtZXRlcnNbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBwYXJhbWV0ZXJzXG4gIHBhcmFtZXRlcnMubGVuZ3RoID0gaiArIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJhbWV0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgcGFyYW1ldGVyc1tpXSA9IHBhcmFtZXRlcnNbaV0udHJpbSgpO1xuICB9XG5cbiAgcmV0dXJuIHBhcmFtZXRlcnM7XG59XG4iLCJ2YXIgZnMgPSByZXF1aXJlKCdmcycpXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKVxudmFyIG9zID0gcmVxdWlyZSgnb3MnKVxuXG4vLyBXb3JrYXJvdW5kIHRvIGZpeCB3ZWJwYWNrJ3MgYnVpbGQgd2FybmluZ3M6ICd0aGUgcmVxdWVzdCBvZiBhIGRlcGVuZGVuY3kgaXMgYW4gZXhwcmVzc2lvbidcbnZhciBydW50aW1lUmVxdWlyZSA9IHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fID09PSAnZnVuY3Rpb24nID8gX19ub25fd2VicGFja19yZXF1aXJlX18gOiByZXF1aXJlIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcblxudmFyIHZhcnMgPSAocHJvY2Vzcy5jb25maWcgJiYgcHJvY2Vzcy5jb25maWcudmFyaWFibGVzKSB8fCB7fVxudmFyIHByZWJ1aWxkc09ubHkgPSAhIXByb2Nlc3MuZW52LlBSRUJVSUxEU19PTkxZXG52YXIgYWJpID0gcHJvY2Vzcy52ZXJzaW9ucy5tb2R1bGVzIC8vIFRPRE86IHN1cHBvcnQgb2xkIG5vZGUgd2hlcmUgdGhpcyBpcyB1bmRlZlxudmFyIHJ1bnRpbWUgPSBpc0VsZWN0cm9uKCkgPyAnZWxlY3Ryb24nIDogJ25vZGUnXG52YXIgYXJjaCA9IG9zLmFyY2goKVxudmFyIHBsYXRmb3JtID0gb3MucGxhdGZvcm0oKVxudmFyIGxpYmMgPSBwcm9jZXNzLmVudi5MSUJDIHx8IChpc0FscGluZShwbGF0Zm9ybSkgPyAnbXVzbCcgOiAnZ2xpYmMnKVxudmFyIGFybXYgPSBwcm9jZXNzLmVudi5BUk1fVkVSU0lPTiB8fCAoYXJjaCA9PT0gJ2FybTY0JyA/ICc4JyA6IHZhcnMuYXJtX3ZlcnNpb24pIHx8ICcnXG52YXIgdXYgPSAocHJvY2Vzcy52ZXJzaW9ucy51diB8fCAnJykuc3BsaXQoJy4nKVswXVxuXG5tb2R1bGUuZXhwb3J0cyA9IGxvYWRcblxuZnVuY3Rpb24gbG9hZCAoZGlyKSB7XG4gIHJldHVybiBydW50aW1lUmVxdWlyZShsb2FkLnBhdGgoZGlyKSlcbn1cblxubG9hZC5wYXRoID0gZnVuY3Rpb24gKGRpcikge1xuICBkaXIgPSBwYXRoLnJlc29sdmUoZGlyIHx8ICcuJylcblxuICB0cnkge1xuICAgIHZhciBuYW1lID0gcnVudGltZVJlcXVpcmUocGF0aC5qb2luKGRpciwgJ3BhY2thZ2UuanNvbicpKS5uYW1lLnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvLS9nLCAnXycpXG4gICAgaWYgKHByb2Nlc3MuZW52W25hbWUgKyAnX1BSRUJVSUxEJ10pIGRpciA9IHByb2Nlc3MuZW52W25hbWUgKyAnX1BSRUJVSUxEJ11cbiAgfSBjYXRjaCAoZXJyKSB7fVxuXG4gIGlmICghcHJlYnVpbGRzT25seSkge1xuICAgIHZhciByZWxlYXNlID0gZ2V0Rmlyc3QocGF0aC5qb2luKGRpciwgJ2J1aWxkL1JlbGVhc2UnKSwgbWF0Y2hCdWlsZClcbiAgICBpZiAocmVsZWFzZSkgcmV0dXJuIHJlbGVhc2VcblxuICAgIHZhciBkZWJ1ZyA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdidWlsZC9EZWJ1ZycpLCBtYXRjaEJ1aWxkKVxuICAgIGlmIChkZWJ1ZykgcmV0dXJuIGRlYnVnXG4gIH1cblxuICB2YXIgcHJlYnVpbGQgPSByZXNvbHZlKGRpcilcbiAgaWYgKHByZWJ1aWxkKSByZXR1cm4gcHJlYnVpbGRcblxuICB2YXIgbmVhcmJ5ID0gcmVzb2x2ZShwYXRoLmRpcm5hbWUocHJvY2Vzcy5leGVjUGF0aCkpXG4gIGlmIChuZWFyYnkpIHJldHVybiBuZWFyYnlcblxuICB2YXIgdGFyZ2V0ID0gW1xuICAgICdwbGF0Zm9ybT0nICsgcGxhdGZvcm0sXG4gICAgJ2FyY2g9JyArIGFyY2gsXG4gICAgJ3J1bnRpbWU9JyArIHJ1bnRpbWUsXG4gICAgJ2FiaT0nICsgYWJpLFxuICAgICd1dj0nICsgdXYsXG4gICAgYXJtdiA/ICdhcm12PScgKyBhcm12IDogJycsXG4gICAgJ2xpYmM9JyArIGxpYmMsXG4gICAgJ25vZGU9JyArIHByb2Nlc3MudmVyc2lvbnMubm9kZSxcbiAgICBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uID8gJ2VsZWN0cm9uPScgKyBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uIDogJycsXG4gICAgdHlwZW9mIF9fd2VicGFja19yZXF1aXJlX18gPT09ICdmdW5jdGlvbicgPyAnd2VicGFjaz10cnVlJyA6ICcnIC8vIGVzbGludC1kaXNhYmxlLWxpbmVcbiAgXS5maWx0ZXIoQm9vbGVhbikuam9pbignICcpXG5cbiAgdGhyb3cgbmV3IEVycm9yKCdObyBuYXRpdmUgYnVpbGQgd2FzIGZvdW5kIGZvciAnICsgdGFyZ2V0ICsgJ1xcbiAgICBsb2FkZWQgZnJvbTogJyArIGRpciArICdcXG4nKVxuXG4gIGZ1bmN0aW9uIHJlc29sdmUgKGRpcikge1xuICAgIC8vIEZpbmQgbWF0Y2hpbmcgXCJwcmVidWlsZHMvPHBsYXRmb3JtPi08YXJjaD5cIiBkaXJlY3RvcnlcbiAgICB2YXIgdHVwbGVzID0gcmVhZGRpclN5bmMocGF0aC5qb2luKGRpciwgJ3ByZWJ1aWxkcycpKS5tYXAocGFyc2VUdXBsZSlcbiAgICB2YXIgdHVwbGUgPSB0dXBsZXMuZmlsdGVyKG1hdGNoVHVwbGUocGxhdGZvcm0sIGFyY2gpKS5zb3J0KGNvbXBhcmVUdXBsZXMpWzBdXG4gICAgaWYgKCF0dXBsZSkgcmV0dXJuXG5cbiAgICAvLyBGaW5kIG1vc3Qgc3BlY2lmaWMgZmxhdm9yIGZpcnN0XG4gICAgdmFyIHByZWJ1aWxkcyA9IHBhdGguam9pbihkaXIsICdwcmVidWlsZHMnLCB0dXBsZS5uYW1lKVxuICAgIHZhciBwYXJzZWQgPSByZWFkZGlyU3luYyhwcmVidWlsZHMpLm1hcChwYXJzZVRhZ3MpXG4gICAgdmFyIGNhbmRpZGF0ZXMgPSBwYXJzZWQuZmlsdGVyKG1hdGNoVGFncyhydW50aW1lLCBhYmkpKVxuICAgIHZhciB3aW5uZXIgPSBjYW5kaWRhdGVzLnNvcnQoY29tcGFyZVRhZ3MocnVudGltZSkpWzBdXG4gICAgaWYgKHdpbm5lcikgcmV0dXJuIHBhdGguam9pbihwcmVidWlsZHMsIHdpbm5lci5maWxlKVxuICB9XG59XG5cbmZ1bmN0aW9uIHJlYWRkaXJTeW5jIChkaXIpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnMucmVhZGRpclN5bmMoZGlyKVxuICB9IGNhdGNoIChlcnIpIHtcbiAgICByZXR1cm4gW11cbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRGaXJzdCAoZGlyLCBmaWx0ZXIpIHtcbiAgdmFyIGZpbGVzID0gcmVhZGRpclN5bmMoZGlyKS5maWx0ZXIoZmlsdGVyKVxuICByZXR1cm4gZmlsZXNbMF0gJiYgcGF0aC5qb2luKGRpciwgZmlsZXNbMF0pXG59XG5cbmZ1bmN0aW9uIG1hdGNoQnVpbGQgKG5hbWUpIHtcbiAgcmV0dXJuIC9cXC5ub2RlJC8udGVzdChuYW1lKVxufVxuXG5mdW5jdGlvbiBwYXJzZVR1cGxlIChuYW1lKSB7XG4gIC8vIEV4YW1wbGU6IGRhcndpbi14NjQrYXJtNjRcbiAgdmFyIGFyciA9IG5hbWUuc3BsaXQoJy0nKVxuICBpZiAoYXJyLmxlbmd0aCAhPT0gMikgcmV0dXJuXG5cbiAgdmFyIHBsYXRmb3JtID0gYXJyWzBdXG4gIHZhciBhcmNoaXRlY3R1cmVzID0gYXJyWzFdLnNwbGl0KCcrJylcblxuICBpZiAoIXBsYXRmb3JtKSByZXR1cm5cbiAgaWYgKCFhcmNoaXRlY3R1cmVzLmxlbmd0aCkgcmV0dXJuXG4gIGlmICghYXJjaGl0ZWN0dXJlcy5ldmVyeShCb29sZWFuKSkgcmV0dXJuXG5cbiAgcmV0dXJuIHsgbmFtZSwgcGxhdGZvcm0sIGFyY2hpdGVjdHVyZXMgfVxufVxuXG5mdW5jdGlvbiBtYXRjaFR1cGxlIChwbGF0Zm9ybSwgYXJjaCkge1xuICByZXR1cm4gZnVuY3Rpb24gKHR1cGxlKSB7XG4gICAgaWYgKHR1cGxlID09IG51bGwpIHJldHVybiBmYWxzZVxuICAgIGlmICh0dXBsZS5wbGF0Zm9ybSAhPT0gcGxhdGZvcm0pIHJldHVybiBmYWxzZVxuICAgIHJldHVybiB0dXBsZS5hcmNoaXRlY3R1cmVzLmluY2x1ZGVzKGFyY2gpXG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZVR1cGxlcyAoYSwgYikge1xuICAvLyBQcmVmZXIgc2luZ2xlLWFyY2ggcHJlYnVpbGRzIG92ZXIgbXVsdGktYXJjaFxuICByZXR1cm4gYS5hcmNoaXRlY3R1cmVzLmxlbmd0aCAtIGIuYXJjaGl0ZWN0dXJlcy5sZW5ndGhcbn1cblxuZnVuY3Rpb24gcGFyc2VUYWdzIChmaWxlKSB7XG4gIHZhciBhcnIgPSBmaWxlLnNwbGl0KCcuJylcbiAgdmFyIGV4dGVuc2lvbiA9IGFyci5wb3AoKVxuICB2YXIgdGFncyA9IHsgZmlsZTogZmlsZSwgc3BlY2lmaWNpdHk6IDAgfVxuXG4gIGlmIChleHRlbnNpb24gIT09ICdub2RlJykgcmV0dXJuXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdGFnID0gYXJyW2ldXG5cbiAgICBpZiAodGFnID09PSAnbm9kZScgfHwgdGFnID09PSAnZWxlY3Ryb24nIHx8IHRhZyA9PT0gJ25vZGUtd2Via2l0Jykge1xuICAgICAgdGFncy5ydW50aW1lID0gdGFnXG4gICAgfSBlbHNlIGlmICh0YWcgPT09ICduYXBpJykge1xuICAgICAgdGFncy5uYXBpID0gdHJ1ZVxuICAgIH0gZWxzZSBpZiAodGFnLnNsaWNlKDAsIDMpID09PSAnYWJpJykge1xuICAgICAgdGFncy5hYmkgPSB0YWcuc2xpY2UoMylcbiAgICB9IGVsc2UgaWYgKHRhZy5zbGljZSgwLCAyKSA9PT0gJ3V2Jykge1xuICAgICAgdGFncy51diA9IHRhZy5zbGljZSgyKVxuICAgIH0gZWxzZSBpZiAodGFnLnNsaWNlKDAsIDQpID09PSAnYXJtdicpIHtcbiAgICAgIHRhZ3MuYXJtdiA9IHRhZy5zbGljZSg0KVxuICAgIH0gZWxzZSBpZiAodGFnID09PSAnZ2xpYmMnIHx8IHRhZyA9PT0gJ211c2wnKSB7XG4gICAgICB0YWdzLmxpYmMgPSB0YWdcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICB0YWdzLnNwZWNpZmljaXR5KytcbiAgfVxuXG4gIHJldHVybiB0YWdzXG59XG5cbmZ1bmN0aW9uIG1hdGNoVGFncyAocnVudGltZSwgYWJpKSB7XG4gIHJldHVybiBmdW5jdGlvbiAodGFncykge1xuICAgIGlmICh0YWdzID09IG51bGwpIHJldHVybiBmYWxzZVxuICAgIGlmICh0YWdzLnJ1bnRpbWUgIT09IHJ1bnRpbWUgJiYgIXJ1bnRpbWVBZ25vc3RpYyh0YWdzKSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRhZ3MuYWJpICE9PSBhYmkgJiYgIXRhZ3MubmFwaSkgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRhZ3MudXYgJiYgdGFncy51diAhPT0gdXYpIHJldHVybiBmYWxzZVxuICAgIGlmICh0YWdzLmFybXYgJiYgdGFncy5hcm12ICE9PSBhcm12KSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGFncy5saWJjICYmIHRhZ3MubGliYyAhPT0gbGliYykgcmV0dXJuIGZhbHNlXG5cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG59XG5cbmZ1bmN0aW9uIHJ1bnRpbWVBZ25vc3RpYyAodGFncykge1xuICByZXR1cm4gdGFncy5ydW50aW1lID09PSAnbm9kZScgJiYgdGFncy5uYXBpXG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUYWdzIChydW50aW1lKSB7XG4gIC8vIFByZWNlZGVuY2U6IG5vbi1hZ25vc3RpYyBydW50aW1lLCBhYmkgb3ZlciBuYXBpLCB0aGVuIGJ5IHNwZWNpZmljaXR5LlxuICByZXR1cm4gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICBpZiAoYS5ydW50aW1lICE9PSBiLnJ1bnRpbWUpIHtcbiAgICAgIHJldHVybiBhLnJ1bnRpbWUgPT09IHJ1bnRpbWUgPyAtMSA6IDFcbiAgICB9IGVsc2UgaWYgKGEuYWJpICE9PSBiLmFiaSkge1xuICAgICAgcmV0dXJuIGEuYWJpID8gLTEgOiAxXG4gICAgfSBlbHNlIGlmIChhLnNwZWNpZmljaXR5ICE9PSBiLnNwZWNpZmljaXR5KSB7XG4gICAgICByZXR1cm4gYS5zcGVjaWZpY2l0eSA+IGIuc3BlY2lmaWNpdHkgPyAtMSA6IDFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIDBcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNFbGVjdHJvbiAoKSB7XG4gIGlmIChwcm9jZXNzLnZlcnNpb25zICYmIHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24pIHJldHVybiB0cnVlXG4gIGlmIChwcm9jZXNzLmVudi5FTEVDVFJPTl9SVU5fQVNfTk9ERSkgcmV0dXJuIHRydWVcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmIHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcidcbn1cblxuZnVuY3Rpb24gaXNBbHBpbmUgKHBsYXRmb3JtKSB7XG4gIHJldHVybiBwbGF0Zm9ybSA9PT0gJ2xpbnV4JyAmJiBmcy5leGlzdHNTeW5jKCcvZXRjL2FscGluZS1yZWxlYXNlJylcbn1cblxuLy8gRXhwb3NlZCBmb3IgdW5pdCB0ZXN0c1xuLy8gVE9ETzogbW92ZSB0byBsaWJcbmxvYWQucGFyc2VUYWdzID0gcGFyc2VUYWdzXG5sb2FkLm1hdGNoVGFncyA9IG1hdGNoVGFnc1xubG9hZC5jb21wYXJlVGFncyA9IGNvbXBhcmVUYWdzXG5sb2FkLnBhcnNlVHVwbGUgPSBwYXJzZVR1cGxlXG5sb2FkLm1hdGNoVHVwbGUgPSBtYXRjaFR1cGxlXG5sb2FkLmNvbXBhcmVUdXBsZXMgPSBjb21wYXJlVHVwbGVzXG4iLCIvKlxub2JqZWN0LWFzc2lnblxuKGMpIFNpbmRyZSBTb3JodXNcbkBsaWNlbnNlIE1JVFxuKi9cblxuJ3VzZSBzdHJpY3QnO1xuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cbnZhciBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcbnZhciBwcm9wSXNFbnVtZXJhYmxlID0gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuZnVuY3Rpb24gdG9PYmplY3QodmFsKSB7XG5cdGlmICh2YWwgPT09IG51bGwgfHwgdmFsID09PSB1bmRlZmluZWQpIHtcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdPYmplY3QuYXNzaWduIGNhbm5vdCBiZSBjYWxsZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZCcpO1xuXHR9XG5cblx0cmV0dXJuIE9iamVjdCh2YWwpO1xufVxuXG5mdW5jdGlvbiBzaG91bGRVc2VOYXRpdmUoKSB7XG5cdHRyeSB7XG5cdFx0aWYgKCFPYmplY3QuYXNzaWduKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZWN0IGJ1Z2d5IHByb3BlcnR5IGVudW1lcmF0aW9uIG9yZGVyIGluIG9sZGVyIFY4IHZlcnNpb25zLlxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9NDExOFxuXHRcdHZhciB0ZXN0MSA9IG5ldyBTdHJpbmcoJ2FiYycpOyAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1uZXctd3JhcHBlcnNcblx0XHR0ZXN0MVs1XSA9ICdkZSc7XG5cdFx0aWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QxKVswXSA9PT0gJzUnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0Ly8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9MzA1NlxuXHRcdHZhciB0ZXN0MiA9IHt9O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMTA7IGkrKykge1xuXHRcdFx0dGVzdDJbJ18nICsgU3RyaW5nLmZyb21DaGFyQ29kZShpKV0gPSBpO1xuXHRcdH1cblx0XHR2YXIgb3JkZXIyID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGVzdDIpLm1hcChmdW5jdGlvbiAobikge1xuXHRcdFx0cmV0dXJuIHRlc3QyW25dO1xuXHRcdH0pO1xuXHRcdGlmIChvcmRlcjIuam9pbignJykgIT09ICcwMTIzNDU2Nzg5Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDMgPSB7fTtcblx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnLnNwbGl0KCcnKS5mb3JFYWNoKGZ1bmN0aW9uIChsZXR0ZXIpIHtcblx0XHRcdHRlc3QzW2xldHRlcl0gPSBsZXR0ZXI7XG5cdFx0fSk7XG5cdFx0aWYgKE9iamVjdC5rZXlzKE9iamVjdC5hc3NpZ24oe30sIHRlc3QzKSkuam9pbignJykgIT09XG5cdFx0XHRcdCdhYmNkZWZnaGlqa2xtbm9wcXJzdCcpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoZXJyKSB7XG5cdFx0Ly8gV2UgZG9uJ3QgZXhwZWN0IGFueSBvZiB0aGUgYWJvdmUgdG8gdGhyb3csIGJ1dCBiZXR0ZXIgdG8gYmUgc2FmZS5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzaG91bGRVc2VOYXRpdmUoKSA/IE9iamVjdC5hc3NpZ24gOiBmdW5jdGlvbiAodGFyZ2V0LCBzb3VyY2UpIHtcblx0dmFyIGZyb207XG5cdHZhciB0byA9IHRvT2JqZWN0KHRhcmdldCk7XG5cdHZhciBzeW1ib2xzO1xuXG5cdGZvciAodmFyIHMgPSAxOyBzIDwgYXJndW1lbnRzLmxlbmd0aDsgcysrKSB7XG5cdFx0ZnJvbSA9IE9iamVjdChhcmd1bWVudHNbc10pO1xuXG5cdFx0Zm9yICh2YXIga2V5IGluIGZyb20pIHtcblx0XHRcdGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGZyb20sIGtleSkpIHtcblx0XHRcdFx0dG9ba2V5XSA9IGZyb21ba2V5XTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG5cdFx0XHRzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKGZyb20pO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzeW1ib2xzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdGlmIChwcm9wSXNFbnVtZXJhYmxlLmNhbGwoZnJvbSwgc3ltYm9sc1tpXSkpIHtcblx0XHRcdFx0XHR0b1tzeW1ib2xzW2ldXSA9IGZyb21bc3ltYm9sc1tpXV07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gdG87XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIHN0cmluZ2lmeVByaW1pdGl2ZSA9IGZ1bmN0aW9uKHYpIHtcbiAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICByZXR1cm4gdjtcblxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxuICAgICAgcmV0dXJuIHYgPyAndHJ1ZScgOiAnZmFsc2UnO1xuXG4gICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgIHJldHVybiBpc0Zpbml0ZSh2KSA/IHYgOiAnJztcblxuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gJyc7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ob2JqLCBzZXAsIGVxLCBuYW1lKSB7XG4gIHNlcCA9IHNlcCB8fCAnJic7XG4gIGVxID0gZXEgfHwgJz0nO1xuICBpZiAob2JqID09PSBudWxsKSB7XG4gICAgb2JqID0gdW5kZWZpbmVkO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubWFwKGZ1bmN0aW9uKGspIHtcbiAgICAgIHZhciBrcyA9IGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUoaykpICsgZXE7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvYmpba10pKSB7XG4gICAgICAgIHJldHVybiBvYmpba10ubWFwKGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBfaW5oZXJpdHNMb29zZShzdWJDbGFzcywgc3VwZXJDbGFzcykgeyBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MucHJvdG90eXBlKTsgc3ViQ2xhc3MucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gc3ViQ2xhc3M7IHN1YkNsYXNzLl9fcHJvdG9fXyA9IHN1cGVyQ2xhc3M7IH1cblxudmFyIGNvZGVzID0ge307XG5cbmZ1bmN0aW9uIGNyZWF0ZUVycm9yVHlwZShjb2RlLCBtZXNzYWdlLCBCYXNlKSB7XG4gIGlmICghQmFzZSkge1xuICAgIEJhc2UgPSBFcnJvcjtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldE1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiBtZXNzYWdlO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9XG4gIH1cblxuICB2YXIgTm9kZUVycm9yID1cbiAgLyojX19QVVJFX18qL1xuICBmdW5jdGlvbiAoX0Jhc2UpIHtcbiAgICBfaW5oZXJpdHNMb29zZShOb2RlRXJyb3IsIF9CYXNlKTtcblxuICAgIGZ1bmN0aW9uIE5vZGVFcnJvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICByZXR1cm4gX0Jhc2UuY2FsbCh0aGlzLCBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpKSB8fCB0aGlzO1xuICAgIH1cblxuICAgIHJldHVybiBOb2RlRXJyb3I7XG4gIH0oQmFzZSk7XG5cbiAgTm9kZUVycm9yLnByb3RvdHlwZS5uYW1lID0gQmFzZS5uYW1lO1xuICBOb2RlRXJyb3IucHJvdG90eXBlLmNvZGUgPSBjb2RlO1xuICBjb2Rlc1tjb2RlXSA9IE5vZGVFcnJvcjtcbn0gLy8gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2Jsb2IvdjEwLjguMC9saWIvaW50ZXJuYWwvZXJyb3JzLmpzXG5cblxuZnVuY3Rpb24gb25lT2YoZXhwZWN0ZWQsIHRoaW5nKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KGV4cGVjdGVkKSkge1xuICAgIHZhciBsZW4gPSBleHBlY3RlZC5sZW5ndGg7XG4gICAgZXhwZWN0ZWQgPSBleHBlY3RlZC5tYXAoZnVuY3Rpb24gKGkpIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaSk7XG4gICAgfSk7XG5cbiAgICBpZiAobGVuID4gMikge1xuICAgICAgcmV0dXJuIFwib25lIG9mIFwiLmNvbmNhdCh0aGluZywgXCIgXCIpLmNvbmNhdChleHBlY3RlZC5zbGljZSgwLCBsZW4gLSAxKS5qb2luKCcsICcpLCBcIiwgb3IgXCIpICsgZXhwZWN0ZWRbbGVuIC0gMV07XG4gICAgfSBlbHNlIGlmIChsZW4gPT09IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0sIFwiIG9yIFwiKS5jb25jYXQoZXhwZWN0ZWRbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWRbMF0pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gXCJvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoU3RyaW5nKGV4cGVjdGVkKSk7XG4gIH1cbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL3N0YXJ0c1dpdGhcblxuXG5mdW5jdGlvbiBzdGFydHNXaXRoKHN0ciwgc2VhcmNoLCBwb3MpIHtcbiAgcmV0dXJuIHN0ci5zdWJzdHIoIXBvcyB8fCBwb3MgPCAwID8gMCA6ICtwb3MsIHNlYXJjaC5sZW5ndGgpID09PSBzZWFyY2g7XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9lbmRzV2l0aFxuXG5cbmZ1bmN0aW9uIGVuZHNXaXRoKHN0ciwgc2VhcmNoLCB0aGlzX2xlbikge1xuICBpZiAodGhpc19sZW4gPT09IHVuZGVmaW5lZCB8fCB0aGlzX2xlbiA+IHN0ci5sZW5ndGgpIHtcbiAgICB0aGlzX2xlbiA9IHN0ci5sZW5ndGg7XG4gIH1cblxuICByZXR1cm4gc3RyLnN1YnN0cmluZyh0aGlzX2xlbiAtIHNlYXJjaC5sZW5ndGgsIHRoaXNfbGVuKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvaW5jbHVkZXNcblxuXG5mdW5jdGlvbiBpbmNsdWRlcyhzdHIsIHNlYXJjaCwgc3RhcnQpIHtcbiAgaWYgKHR5cGVvZiBzdGFydCAhPT0gJ251bWJlcicpIHtcbiAgICBzdGFydCA9IDA7XG4gIH1cblxuICBpZiAoc3RhcnQgKyBzZWFyY2gubGVuZ3RoID4gc3RyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gc3RyLmluZGV4T2Yoc2VhcmNoLCBzdGFydCkgIT09IC0xO1xuICB9XG59XG5cbmNyZWF0ZUVycm9yVHlwZSgnRVJSX0lOVkFMSURfT1BUX1ZBTFVFJywgZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG4gIHJldHVybiAnVGhlIHZhbHVlIFwiJyArIHZhbHVlICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcIicgKyBuYW1lICsgJ1wiJztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX0FSR19UWVBFJywgZnVuY3Rpb24gKG5hbWUsIGV4cGVjdGVkLCBhY3R1YWwpIHtcbiAgLy8gZGV0ZXJtaW5lcjogJ211c3QgYmUnIG9yICdtdXN0IG5vdCBiZSdcbiAgdmFyIGRldGVybWluZXI7XG5cbiAgaWYgKHR5cGVvZiBleHBlY3RlZCA9PT0gJ3N0cmluZycgJiYgc3RhcnRzV2l0aChleHBlY3RlZCwgJ25vdCAnKSkge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBub3QgYmUnO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQucmVwbGFjZSgvXm5vdCAvLCAnJyk7XG4gIH0gZWxzZSB7XG4gICAgZGV0ZXJtaW5lciA9ICdtdXN0IGJlJztcbiAgfVxuXG4gIHZhciBtc2c7XG5cbiAgaWYgKGVuZHNXaXRoKG5hbWUsICcgYXJndW1lbnQnKSkge1xuICAgIC8vIEZvciBjYXNlcyBsaWtlICdmaXJzdCBhcmd1bWVudCdcbiAgICBtc2cgPSBcIlRoZSBcIi5jb25jYXQobmFtZSwgXCIgXCIpLmNvbmNhdChkZXRlcm1pbmVyLCBcIiBcIikuY29uY2F0KG9uZU9mKGV4cGVjdGVkLCAndHlwZScpKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgdHlwZSA9IGluY2x1ZGVzKG5hbWUsICcuJykgPyAncHJvcGVydHknIDogJ2FyZ3VtZW50JztcbiAgICBtc2cgPSBcIlRoZSBcXFwiXCIuY29uY2F0KG5hbWUsIFwiXFxcIiBcIikuY29uY2F0KHR5cGUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH1cblxuICBtc2cgKz0gXCIuIFJlY2VpdmVkIHR5cGUgXCIuY29uY2F0KHR5cGVvZiBhY3R1YWwpO1xuICByZXR1cm4gbXNnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRicsICdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCcsIGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiAnVGhlICcgKyBuYW1lICsgJyBtZXRob2QgaXMgbm90IGltcGxlbWVudGVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScsICdQcmVtYXR1cmUgY2xvc2UnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9ERVNUUk9ZRUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ0Nhbm5vdCBjYWxsICcgKyBuYW1lICsgJyBhZnRlciBhIHN0cmVhbSB3YXMgZGVzdHJveWVkJztcbn0pO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfTVVMVElQTEVfQ0FMTEJBQ0snLCAnQ2FsbGJhY2sgY2FsbGVkIG11bHRpcGxlIHRpbWVzJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fQ0FOTk9UX1BJUEUnLCAnQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCcsICd3cml0ZSBhZnRlciBlbmQnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUycsICdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScsIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9VTktOT1dOX0VOQ09ESU5HJywgZnVuY3Rpb24gKGFyZykge1xuICByZXR1cm4gJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBhcmc7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UJywgJ3N0cmVhbS51bnNoaWZ0KCkgYWZ0ZXIgZW5kIGV2ZW50Jyk7XG5tb2R1bGUuZXhwb3J0cy5jb2RlcyA9IGNvZGVzO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxuLy8gU2luY2UgSlMgZG9lc24ndCBoYXZlIG11bHRpcGxlIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UsIHRoaXMgY2xhc3Ncbi8vIHByb3RvdHlwYWxseSBpbmhlcml0cyBmcm9tIFJlYWRhYmxlLCBhbmQgdGhlbiBwYXJhc2l0aWNhbGx5IGZyb21cbi8vIFdyaXRhYmxlLlxuJ3VzZSBzdHJpY3QnO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG5cbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGtleXMucHVzaChrZXkpO1xuICB9XG5cbiAgcmV0dXJuIGtleXM7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbnZhciBSZWFkYWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV9yZWFkYWJsZScpO1xuXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShEdXBsZXgsIFJlYWRhYmxlKTtcblxue1xuICAvLyBBbGxvdyB0aGUga2V5cyBhcnJheSB0byBiZSBHQydlZC5cbiAgdmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5cbiAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gICAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xuICB9XG59XG5cbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSByZXR1cm4gbmV3IER1cGxleChvcHRpb25zKTtcbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIGlmIChvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHtcbiAgICAgIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuICAgICAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG4gICAgfVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyKCk7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gdGhlIG5vLWhhbGYtb3BlbiBlbmZvcmNlclxuXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gSWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsIHRoZW4gd2UncmUgb2suXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47IC8vIG5vIG1vcmUgZGF0YSBjYW4gYmUgd3JpdHRlbi5cbiAgLy8gQnV0IGFsbG93IG1vcmUgd3JpdGVzIHRvIGhhcHBlbiBpbiB0aGlzIHRpY2suXG5cbiAgcHJvY2Vzcy5uZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcbn1cblxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XG4gIHNlbGYuZW5kKCk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxuLy8gYmFzaWNhbGx5IGp1c3QgdGhlIG1vc3QgbWluaW1hbCBzb3J0IG9mIFRyYW5zZm9ybSBzdHJlYW0uXG4vLyBFdmVyeSB3cml0dGVuIGNodW5rIGdldHMgb3V0cHV0IGFzLWlzLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG4gIFRyYW5zZm9ybS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xufVxuXG5QYXNzVGhyb3VnaC5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG51bGwsIGNodW5rKTtcbn07IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblJlYWRhYmxlLlJlYWRhYmxlU3RhdGUgPSBSZWFkYWJsZVN0YXRlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuXG52YXIgRUVsaXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gRUVsaXN0ZW5lckNvdW50KGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJzKHR5cGUpLmxlbmd0aDtcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcblxudmFyIGRlYnVnO1xuXG5pZiAoZGVidWdVdGlsICYmIGRlYnVnVXRpbC5kZWJ1Z2xvZykge1xuICBkZWJ1ZyA9IGRlYnVnVXRpbC5kZWJ1Z2xvZygnc3RyZWFtJyk7XG59IGVsc2Uge1xuICBkZWJ1ZyA9IGZ1bmN0aW9uIGRlYnVnKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9idWZmZXJfbGlzdCcpO1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RhdGUnKSxcbiAgICBnZXRIaWdoV2F0ZXJNYXJrID0gX3JlcXVpcmUuZ2V0SGlnaFdhdGVyTWFyaztcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX0lOVkFMSURfQVJHX1RZUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfSU5WQUxJRF9BUkdfVFlQRSxcbiAgICBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRixcbiAgICBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVELFxuICAgIEVSUl9TVFJFQU1fVU5TSElGVF9BRlRFUl9FTkRfRVZFTlQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UOyAvLyBMYXp5IGxvYWRlZCB0byBpbXByb3ZlIHRoZSBzdGFydHVwIHBlcmZvcm1hbmNlLlxuXG5cbnZhciBTdHJpbmdEZWNvZGVyO1xudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjtcbnZhciBmcm9tO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHJldHVybiBlbWl0dGVyLnByZXBlbmRMaXN0ZW5lcihldmVudCwgZm4pOyAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXG4gIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKEFycmF5LmlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbS5cbiAgLy8gVGhlc2Ugb3B0aW9ucyBjYW4gYmUgcHJvdmlkZWQgc2VwYXJhdGVseSBhcyByZWFkYWJsZVhYWCBhbmQgd3JpdGFibGVYWFguXG5cbiAgaWYgKHR5cGVvZiBpc0R1cGxleCAhPT0gJ2Jvb2xlYW4nKSBpc0R1cGxleCA9IHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleDsgLy8gb2JqZWN0IHN0cmVhbSBmbGFnLiBVc2VkIHRvIG1ha2UgcmVhZChuKSBpZ25vcmUgbiBhbmQgdG9cbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcblxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcbiAgaWYgKGlzRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTsgLy8gdGhlIHBvaW50IGF0IHdoaWNoIGl0IHN0b3BzIGNhbGxpbmcgX3JlYWQoKSB0byBmaWxsIHRoZSBidWZmZXJcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcImRvbid0IGNhbGwgX3JlYWQgcHJlZW1wdGl2ZWx5IGV2ZXJcIlxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcbiAgdGhpcy5sZW5ndGggPSAwO1xuICB0aGlzLnBpcGVzID0gbnVsbDtcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcbiAgdGhpcy5mbG93aW5nID0gbnVsbDtcbiAgdGhpcy5lbmRlZCA9IGZhbHNlO1xuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgdGhpcy5yZWFkaW5nID0gZmFsc2U7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cblxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICB0aGlzLnJlYWRhYmxlTGlzdGVuaW5nID0gZmFsc2U7XG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHRoaXMucGF1c2VkID0gdHJ1ZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdlbmQnIChhbmQgcG90ZW50aWFsbHkgJ2ZpbmlzaCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gdGhlIG51bWJlciBvZiB3cml0ZXJzIHRoYXQgYXJlIGF3YWl0aW5nIGEgZHJhaW4gZXZlbnQgaW4gLnBpcGUoKXNcblxuICB0aGlzLmF3YWl0RHJhaW4gPSAwOyAvLyBpZiB0cnVlLCBhIG1heWJlUmVhZE1vcmUgaGFzIGJlZW4gc2NoZWR1bGVkXG5cbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuICB0aGlzLmRlY29kZXIgPSBudWxsO1xuICB0aGlzLmVuY29kaW5nID0gbnVsbDtcblxuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUmVhZGFibGUpKSByZXR1cm4gbmV3IFJlYWRhYmxlKG9wdGlvbnMpOyAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBSZWFkYWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeVxuXG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5cblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIGNiKGVycik7XG59OyAvLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBza2lwQ2h1bmtDaGVjaztcblxuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBpZiAodHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuXG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07IC8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIGRlYnVnKCdyZWFkYWJsZUFkZENodW5rJywgY2h1bmspO1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG5cbiAgICBpZiAoZXIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIH0gZWxzZSBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuayAmJiBjaHVuay5sZW5ndGggPiAwKSB7XG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XG4gICAgICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gICAgICB9XG5cbiAgICAgIGlmIChhZGRUb0Zyb250KSB7XG4gICAgICAgIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UKCkpO2Vsc2UgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIHRydWUpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xuICAgICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIG5ldyBFUlJfU1RSRUFNX1BVU0hfQUZURVJfRU9GKCkpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuXG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgICAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG4gIH0gLy8gV2UgY2FuIHB1c2ggbW9yZSBkYXRhIGlmIHdlIGFyZSBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyay5cbiAgLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWUgbW9yZSBieXRlcy5cbiAgLy8gVGhpcyBpcyB0byB3b3JrIGFyb3VuZCBjYXNlcyB3aGVyZSBod209MCwgc3VjaCBhcyB0aGUgcmVwbC5cblxuXG4gIHJldHVybiAhc3RhdGUuZW5kZWQgJiYgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuZnVuY3Rpb24gYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGFkZFRvRnJvbnQpIHtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmICFzdGF0ZS5zeW5jKSB7XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XG4gIH0gZWxzZSB7XG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cbiAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgaWYgKGFkZFRvRnJvbnQpIHN0YXRlLmJ1ZmZlci51bnNoaWZ0KGNodW5rKTtlbHNlIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcbiAgdmFyIGVyO1xuXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJywgJ1VpbnQ4QXJyYXknXSwgY2h1bmspO1xuICB9XG5cbiAgcmV0dXJuIGVyO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTsgLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB2YXIgZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IGRlY29kZXI7IC8vIElmIHNldEVuY29kaW5nKG51bGwpLCBkZWNvZGVyLmVuY29kaW5nIGVxdWFscyB1dGY4XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2Rlci5lbmNvZGluZzsgLy8gSXRlcmF0ZSBvdmVyIGN1cnJlbnQgYnVmZmVyIHRvIGNvbnZlcnQgYWxyZWFkeSBzdG9yZWQgQnVmZmVyczpcblxuICB2YXIgcCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmhlYWQ7XG4gIHZhciBjb250ZW50ID0gJyc7XG5cbiAgd2hpbGUgKHAgIT09IG51bGwpIHtcbiAgICBjb250ZW50ICs9IGRlY29kZXIud3JpdGUocC5kYXRhKTtcbiAgICBwID0gcC5uZXh0O1xuICB9XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXIuY2xlYXIoKTtcblxuICBpZiAoY29udGVudCAhPT0gJycpIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLnB1c2goY29udGVudCk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoID0gY29udGVudC5sZW5ndGg7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDFHQlxuXG5cbnZhciBNQVhfSFdNID0gMHg0MDAwMDAwMDtcblxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xuICBpZiAobiA+PSBNQVhfSFdNKSB7XG4gICAgLy8gVE9ETyhyb25hZyk6IFRocm93IEVSUl9WQUxVRV9PVVRfT0ZfUkFOR0UuXG4gICAgbiA9IE1BWF9IV007XG4gIH0gZWxzZSB7XG4gICAgLy8gR2V0IHRoZSBuZXh0IGhpZ2hlc3QgcG93ZXIgb2YgMiB0byBwcmV2ZW50IGluY3JlYXNpbmcgaHdtIGV4Y2Vzc2l2ZWx5IGluXG4gICAgLy8gdGlueSBhbW91bnRzXG4gICAgbi0tO1xuICAgIG4gfD0gbiA+Pj4gMTtcbiAgICBuIHw9IG4gPj4+IDI7XG4gICAgbiB8PSBuID4+PiA0O1xuICAgIG4gfD0gbiA+Pj4gODtcbiAgICBuIHw9IG4gPj4+IDE2O1xuICAgIG4rKztcbiAgfVxuXG4gIHJldHVybiBuO1xufSAvLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuXG5mdW5jdGlvbiBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKSB7XG4gIGlmIChuIDw9IDAgfHwgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSByZXR1cm4gMDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xuXG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9IC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuXG5cbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XG4gIGlmIChuIDw9IHN0YXRlLmxlbmd0aCkgcmV0dXJuIG47IC8vIERvbid0IGhhdmUgZW5vdWdoXG5cbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cblxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufSAvLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcbiAgaWYgKG4gIT09IDApIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlOyAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUubmVlZFJlYWRhYmxlICYmICgoc3RhdGUuaGlnaFdhdGVyTWFyayAhPT0gMCA/IHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIDogc3RhdGUubGVuZ3RoID4gMCkgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpOyAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfSAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuICAvLyBpZiB3ZSBuZWVkIGEgcmVhZGFibGUgZXZlbnQsIHRoZW4gd2UgbmVlZCB0byBkbyBzb21lIHJlYWRpbmcuXG5cblxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7IC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH0gLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuXG5cbiAgaWYgKHN0YXRlLmVuZGVkIHx8IHN0YXRlLnJlYWRpbmcpIHtcbiAgICBkb1JlYWQgPSBmYWxzZTtcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XG4gIH0gZWxzZSBpZiAoZG9SZWFkKSB7XG4gICAgZGVidWcoJ2RvIHJlYWQnKTtcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcbiAgICBzdGF0ZS5zeW5jID0gdHJ1ZTsgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cblxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcblxuICAgIHRoaXMuX3JlYWQoc3RhdGUuaGlnaFdhdGVyTWFyayk7XG5cbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7IC8vIElmIF9yZWFkIHB1c2hlZCBkYXRhIHN5bmNocm9ub3VzbHksIHRoZW4gYHJlYWRpbmdgIHdpbGwgYmUgZmFsc2UsXG4gICAgLy8gYW5kIHdlIG5lZWQgdG8gcmUtZXZhbHVhdGUgaG93IG11Y2ggZGF0YSB3ZSBjYW4gcmV0dXJuIHRvIHRoZSB1c2VyLlxuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBzdGF0ZS5sZW5ndGggPD0gc3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgICBuID0gMDtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5sZW5ndGggLT0gbjtcbiAgICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgfVxuXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICAvLyBJZiB3ZSBoYXZlIG5vdGhpbmcgaW4gdGhlIGJ1ZmZlciwgdGhlbiB3ZSB3YW50IHRvIGtub3dcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXG4gICAgaWYgKCFzdGF0ZS5lbmRlZCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ29uRW9mQ2h1bmsnKTtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuXG4gICAgaWYgKGNodW5rICYmIGNodW5rLmxlbmd0aCkge1xuICAgICAgc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUuc3luYykge1xuICAgIC8vIGlmIHdlIGFyZSBzeW5jLCB3YWl0IHVudGlsIG5leHQgdGljayB0byBlbWl0IHRoZSBkYXRhLlxuICAgIC8vIE90aGVyd2lzZSB3ZSByaXNrIGVtaXR0aW5nIGRhdGEgaW4gdGhlIGZsb3coKVxuICAgIC8vIHRoZSByZWFkYWJsZSBjb2RlIHRyaWdnZXJzIGR1cmluZyBhIHJlYWQoKSBjYWxsXG4gICAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gZW1pdCAncmVhZGFibGUnIG5vdyB0byBtYWtlIHN1cmUgaXQgZ2V0cyBwaWNrZWQgdXAuXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcbiAgICB9XG4gIH1cbn0gLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cblxuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLm5lZWRSZWFkYWJsZSwgc3RhdGUuZW1pdHRlZFJlYWRhYmxlKTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZW1pdFJlYWRhYmxlXycsIHN0YXRlLmRlc3Ryb3llZCwgc3RhdGUubGVuZ3RoLCBzdGF0ZS5lbmRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5kZXN0cm95ZWQgJiYgKHN0YXRlLmxlbmd0aCB8fCBzdGF0ZS5lbmRlZCkpIHtcbiAgICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcbiAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgfSAvLyBUaGUgc3RyZWFtIG5lZWRzIGFub3RoZXIgcmVhZGFibGUgZXZlbnQgaWZcbiAgLy8gMS4gSXQgaXMgbm90IGZsb3dpbmcsIGFzIHRoZSBmbG93IG1lY2hhbmlzbSB3aWxsIHRha2VcbiAgLy8gICAgY2FyZSBvZiBpdC5cbiAgLy8gMi4gSXQgaXMgbm90IGVuZGVkLlxuICAvLyAzLiBJdCBpcyBiZWxvdyB0aGUgaGlnaFdhdGVyTWFyaywgc28gd2UgY2FuIHNjaGVkdWxlXG4gIC8vICAgIGFub3RoZXIgcmVhZGFibGUgbGF0ZXIuXG5cblxuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIGZsb3coc3RyZWFtKTtcbn0gLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhtYXliZVJlYWRNb3JlXywgc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZV8oc3RyZWFtLCBzdGF0ZSkge1xuICAvLyBBdHRlbXB0IHRvIHJlYWQgbW9yZSBkYXRhIGlmIHdlIHNob3VsZC5cbiAgLy9cbiAgLy8gVGhlIGNvbmRpdGlvbnMgZm9yIHJlYWRpbmcgbW9yZSBkYXRhIGFyZSAob25lIG9mKTpcbiAgLy8gLSBOb3QgZW5vdWdoIGRhdGEgYnVmZmVyZWQgKHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmspLiBUaGUgbG9vcFxuICAvLyAgIGlzIHJlc3BvbnNpYmxlIGZvciBmaWxsaW5nIHRoZSBidWZmZXIgd2l0aCBlbm91Z2ggZGF0YSBpZiBzdWNoIGRhdGFcbiAgLy8gICBpcyBhdmFpbGFibGUuIElmIGhpZ2hXYXRlck1hcmsgaXMgMCBhbmQgd2UgYXJlIG5vdCBpbiB0aGUgZmxvd2luZyBtb2RlXG4gIC8vICAgd2Ugc2hvdWxkIF9ub3RfIGF0dGVtcHQgdG8gYnVmZmVyIGFueSBleHRyYSBkYXRhLiBXZSdsbCBnZXQgbW9yZSBkYXRhXG4gIC8vICAgd2hlbiB0aGUgc3RyZWFtIGNvbnN1bWVyIGNhbGxzIHJlYWQoKSBpbnN0ZWFkLlxuICAvLyAtIE5vIGRhdGEgaW4gdGhlIGJ1ZmZlciwgYW5kIHRoZSBzdHJlYW0gaXMgaW4gZmxvd2luZyBtb2RlLiBJbiB0aGlzIG1vZGVcbiAgLy8gICB0aGUgbG9vcCBiZWxvdyBpcyByZXNwb25zaWJsZSBmb3IgZW5zdXJpbmcgcmVhZCgpIGlzIGNhbGxlZC4gRmFpbGluZyB0b1xuICAvLyAgIGNhbGwgcmVhZCBoZXJlIHdvdWxkIGFib3J0IHRoZSBmbG93IGFuZCB0aGVyZSdzIG5vIG90aGVyIG1lY2hhbmlzbSBmb3JcbiAgLy8gICBjb250aW51aW5nIHRoZSBmbG93IGlmIHRoZSBzdHJlYW0gY29uc3VtZXIgaGFzIGp1c3Qgc3Vic2NyaWJlZCB0byB0aGVcbiAgLy8gICAnZGF0YScgZXZlbnQuXG4gIC8vXG4gIC8vIEluIGFkZGl0aW9uIHRvIHRoZSBhYm92ZSBjb25kaXRpb25zIHRvIGtlZXAgcmVhZGluZyBkYXRhLCB0aGUgZm9sbG93aW5nXG4gIC8vIGNvbmRpdGlvbnMgcHJldmVudCB0aGUgZGF0YSBmcm9tIGJlaW5nIHJlYWQ6XG4gIC8vIC0gVGhlIHN0cmVhbSBoYXMgZW5kZWQgKHN0YXRlLmVuZGVkKS5cbiAgLy8gLSBUaGVyZSBpcyBhbHJlYWR5IGEgcGVuZGluZyAncmVhZCcgb3BlcmF0aW9uIChzdGF0ZS5yZWFkaW5nKS4gVGhpcyBpcyBhXG4gIC8vICAgY2FzZSB3aGVyZSB0aGUgdGhlIHN0cmVhbSBoYXMgY2FsbGVkIHRoZSBpbXBsZW1lbnRhdGlvbiBkZWZpbmVkIF9yZWFkKClcbiAgLy8gICBtZXRob2QsIGJ1dCB0aGV5IGFyZSBwcm9jZXNzaW5nIHRoZSBjYWxsIGFzeW5jaHJvbm91c2x5IGFuZCBoYXZlIF9ub3RfXG4gIC8vICAgY2FsbGVkIHB1c2goKSB3aXRoIG5ldyBkYXRhLiBJbiB0aGlzIGNhc2Ugd2Ugc2tpcCBwZXJmb3JtaW5nIG1vcmVcbiAgLy8gICByZWFkKClzLiBUaGUgZXhlY3V0aW9uIGVuZHMgaW4gdGhpcyBtZXRob2QgYWdhaW4gYWZ0ZXIgdGhlIF9yZWFkKCkgZW5kc1xuICAvLyAgIHVwIGNhbGxpbmcgcHVzaCgpIHdpdGggbW9yZSBkYXRhLlxuICB3aGlsZSAoIXN0YXRlLnJlYWRpbmcgJiYgIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwKSkge1xuICAgIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKSAvLyBkaWRuJ3QgZ2V0IGFueSBkYXRhLCBzdG9wIHNwaW5uaW5nLlxuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufSAvLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ19yZWFkKCknKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgMTpcbiAgICAgIHN0YXRlLnBpcGVzID0gW3N0YXRlLnBpcGVzLCBkZXN0XTtcbiAgICAgIGJyZWFrO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcbiAgdmFyIGVuZEZuID0gZG9FbmQgPyBvbmVuZCA6IHVucGlwZTtcbiAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHByb2Nlc3MubmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuXG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG5cbiAgICBpZiAocmVhZGFibGUgPT09IHNyYykge1xuICAgICAgaWYgKHVucGlwZUluZm8gJiYgdW5waXBlSW5mby5oYXNVbnBpcGVkID09PSBmYWxzZSkge1xuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xuICAgICAgICBjbGVhbnVwKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgZGVidWcoJ29uZW5kJyk7XG4gICAgZGVzdC5lbmQoKTtcbiAgfSAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cblxuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTsgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBjbGVhbmVkVXAgPSB0cnVlOyAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcblxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgdmFyIHJldCA9IGRlc3Qud3JpdGUoY2h1bmspO1xuICAgIGRlYnVnKCdkZXN0LndyaXRlJywgcmV0KTtcblxuICAgIGlmIChyZXQgPT09IGZhbHNlKSB7XG4gICAgICAvLyBJZiB0aGUgdXNlciB1bnBpcGVkIGR1cmluZyBgZGVzdC53cml0ZSgpYCwgaXQgaXMgcG9zc2libGVcbiAgICAgIC8vIHRvIGdldCBzdHVjayBpbiBhIHBlcm1hbmVudGx5IHBhdXNlZCBzdGF0ZSBpZiB0aGF0IHdyaXRlXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxuICAgICAgLy8gPT4gQ2hlY2sgd2hldGhlciBgZGVzdGAgaXMgc3RpbGwgYSBwaXBpbmcgZGVzdGluYXRpb24uXG4gICAgICBpZiAoKHN0YXRlLnBpcGVzQ291bnQgPT09IDEgJiYgc3RhdGUucGlwZXMgPT09IGRlc3QgfHwgc3RhdGUucGlwZXNDb3VudCA+IDEgJiYgaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCkgIT09IC0xKSAmJiAhY2xlYW5lZFVwKSB7XG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgfVxuXG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH0gLy8gaWYgdGhlIGRlc3QgaGFzIGFuIGVycm9yLCB0aGVuIHN0b3AgcGlwaW5nIGludG8gaXQuXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cblxuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGVycm9yT3JEZXN0cm95KGRlc3QsIGVyKTtcbiAgfSAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG5cblxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7IC8vIEJvdGggY2xvc2UgYW5kIGZpbmlzaCBzaG91bGQgdHJpZ2dlciB1bnBpcGUsIGJ1dCBvbmx5IG9uY2UuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgZGVidWcoJ29uZmluaXNoJyk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuXG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfSAvLyB0ZWxsIHRoZSBkZXN0IHRoYXQgaXQncyBiZWluZyBwaXBlZCB0b1xuXG5cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTsgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiBwaXBlT25EcmFpbkZ1bmN0aW9uUmVzdWx0KCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7XG4gICAgaGFzVW5waXBlZDogZmFsc2VcbiAgfTsgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAwKSByZXR1cm4gdGhpczsgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuXG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSB7XG4gICAgLy8gcGFzc2VkIGluIG9uZSwgYnV0IGl0J3Mgbm90IHRoZSByaWdodCBvbmUuXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzOyAvLyBnb3QgYSBtYXRjaC5cblxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cblxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHtcbiAgICAgICAgaGFzVW5waXBlZDogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG5cblxuICB2YXIgaW5kZXggPSBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KTtcbiAgaWYgKGluZGV4ID09PSAtMSkgcmV0dXJuIHRoaXM7XG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gIHJldHVybiB0aGlzO1xufTsgLy8gc2V0IHVwIGRhdGEgZXZlbnRzIGlmIHRoZXkgYXJlIGFza2VkIGZvclxuLy8gRW5zdXJlIHJlYWRhYmxlIGxpc3RlbmVycyBldmVudHVhbGx5IGdldCBzb21ldGhpbmdcblxuXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIHVwZGF0ZSByZWFkYWJsZUxpc3RlbmluZyBzbyB0aGF0IHJlc3VtZSgpIG1heSBiZSBhIG5vLW9wXG4gICAgLy8gYSBmZXcgbGluZXMgZG93bi4gVGhpcyBpcyBuZWVkZWQgdG8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScpLlxuICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gdGhpcy5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDsgLy8gVHJ5IHN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBkZWJ1Zygnb24gcmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLnJlYWRpbmcpO1xuXG4gICAgICBpZiAoc3RhdGUubGVuZ3RoKSB7XG4gICAgICAgIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICAgIH0gZWxzZSBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIChldikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICBpZiAoZXYgPT09ICdyZWFkYWJsZScgfHwgZXYgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIFdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlcmUgaXMgc29tZW9uZSBzdGlsbCBsaXN0ZW5pbmcgdG9cbiAgICAvLyByZWFkYWJsZSBhbmQgcmVzZXQgdGhlIHN0YXRlLiBIb3dldmVyIHRoaXMgbmVlZHMgdG8gaGFwcGVuXG4gICAgLy8gYWZ0ZXIgcmVhZGFibGUgaGFzIGJlZW4gZW1pdHRlZCBidXQgYmVmb3JlIEkvTyAobmV4dFRpY2spIHRvXG4gICAgLy8gc3VwcG9ydCBvbmNlKCdyZWFkYWJsZScsIGZuKSBjeWNsZXMuIFRoaXMgbWVhbnMgdGhhdCBjYWxsaW5nXG4gICAgLy8gcmVzdW1lIHdpdGhpbiB0aGUgc2FtZSB0aWNrIHdpbGwgaGF2ZSBub1xuICAgIC8vIGVmZmVjdC5cbiAgICBwcm9jZXNzLm5leHRUaWNrKHVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nLCB0aGlzKTtcbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuXG5mdW5jdGlvbiB1cGRhdGVSZWFkYWJsZUxpc3RlbmluZyhzZWxmKSB7XG4gIHZhciBzdGF0ZSA9IHNlbGYuX3JlYWRhYmxlU3RhdGU7XG4gIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc2VsZi5saXN0ZW5lckNvdW50KCdyZWFkYWJsZScpID4gMDtcblxuICBpZiAoc3RhdGUucmVzdW1lU2NoZWR1bGVkICYmICFzdGF0ZS5wYXVzZWQpIHtcbiAgICAvLyBmbG93aW5nIG5lZWRzIHRvIGJlIHNldCB0byB0cnVlIG5vdywgb3RoZXJ3aXNlXG4gICAgLy8gdGhlIHVwY29taW5nIHJlc3VtZSB3aWxsIG5vdCBmbG93LlxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlOyAvLyBjcnVkZSB3YXkgdG8gY2hlY2sgaWYgd2Ugc2hvdWxkIHJlc3VtZVxuICB9IGVsc2UgaWYgKHNlbGYubGlzdGVuZXJDb3VudCgnZGF0YScpID4gMCkge1xuICAgIHNlbGYucmVzdW1lKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gblJlYWRpbmdOZXh0VGljayhzZWxmKSB7XG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcbiAgc2VsZi5yZWFkKDApO1xufSAvLyBwYXVzZSgpIGFuZCByZXN1bWUoKSBhcmUgcmVtbmFudHMgb2YgdGhlIGxlZ2FjeSByZWFkYWJsZSBzdHJlYW0gQVBJXG4vLyBJZiB0aGUgdXNlciB1c2VzIHRoZW0sIHRoZW4gc3dpdGNoIGludG8gb2xkIG1vZGUuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lJyk7IC8vIHdlIGZsb3cgb25seSBpZiB0aGVyZSBpcyBubyBvbmUgbGlzdGVuaW5nXG4gICAgLy8gZm9yIHJlYWRhYmxlLCBidXQgd2Ugc3RpbGwgaGF2ZSB0byBjYWxsXG4gICAgLy8gcmVzdW1lKClcblxuICAgIHN0YXRlLmZsb3dpbmcgPSAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmc7XG4gICAgcmVzdW1lKHRoaXMsIHN0YXRlKTtcbiAgfVxuXG4gIHN0YXRlLnBhdXNlZCA9IGZhbHNlO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVzdW1lU2NoZWR1bGVkKSB7XG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBkZWJ1ZygncmVzdW1lJywgc3RhdGUucmVhZGluZyk7XG5cbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gIH1cblxuICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUucGF1c2VkID0gdHJ1ZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG5cbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge1xuICAgIDtcbiAgfVxufSAvLyB3cmFwIGFuIG9sZC1zdHlsZSBzdHJlYW0gYXMgdGhlIGFzeW5jIGRhdGEgc291cmNlLlxuLy8gVGhpcyBpcyAqbm90KiBwYXJ0IG9mIHRoZSByZWFkYWJsZSBzdHJlYW0gaW50ZXJmYWNlLlxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIF90aGlzLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIF90aGlzLnB1c2gobnVsbCk7XG4gIH0pO1xuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7IC8vIGRvbid0IHNraXAgb3ZlciBmYWxzeSB2YWx1ZXMgaW4gb2JqZWN0TW9kZVxuXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IF90aGlzLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pOyAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXG4gIC8vIGltcG9ydGFudCB3aGVuIHdyYXBwaW5nIGZpbHRlcnMgYW5kIGR1cGxleGVzLlxuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gbWV0aG9kV3JhcChtZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIG1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbigpIHtcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgICAgfShpKTtcbiAgICB9XG4gIH0gLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuXG5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCB0aGlzLmVtaXQuYmluZCh0aGlzLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfSAvLyB3aGVuIHdlIHRyeSB0byBjb25zdW1lIHNvbWUgbW9yZSBieXRlcywgc2ltcGx5IHVucGF1c2UgdGhlXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxuXG5cbiAgdGhpcy5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcblxuICAgIGlmIChwYXVzZWQpIHtcbiAgICAgIHBhdXNlZCA9IGZhbHNlO1xuICAgICAgc3RyZWFtLnJlc3VtZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLnByb3RvdHlwZVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3InKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yKHRoaXMpO1xuICB9O1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVIaWdoV2F0ZXJNYXJrJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5idWZmZXI7XG4gIH1cbn0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlRmxvd2luZycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZztcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiBzZXQoc3RhdGUpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID0gc3RhdGU7XG4gICAgfVxuICB9XG59KTsgLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTsgLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuXG5mdW5jdGlvbiBmcm9tTGlzdChuLCBzdGF0ZSkge1xuICAvLyBub3RoaW5nIGJ1ZmZlcmVkXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5maXJzdCgpO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbnN1bWUobiwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VuZFJlYWRhYmxlJywgc3RhdGUuZW5kRW1pdHRlZCk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2soZW5kUmVhZGFibGVOVCwgc3RhdGUsIHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZU5UJywgc3RhdGUuZW5kRW1pdHRlZCwgc3RhdGUubGVuZ3RoKTsgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcblxuICAgIGlmIChzdGF0ZS5hdXRvRGVzdHJveSkge1xuICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgLy8gaWYgdGhlIHdyaXRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG5cbiAgICAgIGlmICghd1N0YXRlIHx8IHdTdGF0ZS5hdXRvRGVzdHJveSAmJiB3U3RhdGUuZmluaXNoZWQpIHtcbiAgICAgICAgc3RyZWFtLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicpIHtcbiAgUmVhZGFibGUuZnJvbSA9IGZ1bmN0aW9uIChpdGVyYWJsZSwgb3B0cykge1xuICAgIGlmIChmcm9tID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGZyb20gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZnJvbScpO1xuICAgIH1cblxuICAgIHJldHVybiBmcm9tKFJlYWRhYmxlLCBpdGVyYWJsZSwgb3B0cyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG5cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFRyYW5zZm9ybTtcblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcsXG4gICAgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wID0gX3JlcXVpcmUkY29kZXMuRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFRyYW5zZm9ybSwgRHVwbGV4KTtcblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oZXIsIGRhdGEpIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmIChjYiA9PT0gbnVsbCkge1xuICAgIHJldHVybiB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgdGhpcy5wdXNoKGRhdGEpO1xuICBjYihlcik7XG4gIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcblxuICBpZiAocnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHtcbiAgICB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlID0ge1xuICAgIGFmdGVyVHJhbnNmb3JtOiBhZnRlclRyYW5zZm9ybS5iaW5kKHRoaXMpLFxuICAgIG5lZWRUcmFuc2Zvcm06IGZhbHNlLFxuICAgIHRyYW5zZm9ybWluZzogZmFsc2UsXG4gICAgd3JpdGVjYjogbnVsbCxcbiAgICB3cml0ZWNodW5rOiBudWxsLFxuICAgIHdyaXRlZW5jb2Rpbmc6IG51bGxcbiAgfTsgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfSAvLyBXaGVuIHRoZSB3cml0YWJsZSBzaWRlIGZpbmlzaGVzLCB0aGVuIGZsdXNoIG91dCBhbnl0aGluZyByZW1haW5pbmcuXG5cblxuICB0aGlzLm9uKCdwcmVmaW5pc2gnLCBwcmVmaW5pc2gpO1xufVxuXG5mdW5jdGlvbiBwcmVmaW5pc2goKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJyAmJiAhdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoX3RoaXMsIGVyLCBkYXRhKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBkb25lKHRoaXMsIG51bGwsIG51bGwpO1xuICB9XG59XG5cblRyYW5zZm9ybS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcbn07IC8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxuLy8gb3ZlcnJpZGUgdGhpcyBmdW5jdGlvbiBpbiBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gJ2NodW5rJyBpcyBhbiBpbnB1dCBjaHVuay5cbi8vXG4vLyBDYWxsIGBwdXNoKG5ld0NodW5rKWAgdG8gcGFzcyBhbG9uZyB0cmFuc2Zvcm1lZCBvdXRwdXRcbi8vIHRvIHRoZSByZWFkYWJsZSBzaWRlLiAgWW91IG1heSBjYWxsICdwdXNoJyB6ZXJvIG9yIG1vcmUgdGltZXMuXG4vL1xuLy8gQ2FsbCBgY2IoZXJyKWAgd2hlbiB5b3UgYXJlIGRvbmUgd2l0aCB0aGlzIGNodW5rLiAgSWYgeW91IHBhc3Ncbi8vIGFuIGVycm9yLCB0aGVuIHRoYXQnbGwgcHV0IHRoZSBodXJ0IG9uIHRoZSB3aG9sZSBvcGVyYXRpb24uICBJZiB5b3Vcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXG5cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfdHJhbnNmb3JtKCknKSk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuXG4gIGlmICghdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdmFyIHJzID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufTsgLy8gRG9lc24ndCBtYXR0ZXIgd2hhdCB0aGUgYXJncyBhcmUgaGVyZS5cbi8vIF90cmFuc2Zvcm0gZG9lcyBhbGwgdGhlIHdvcmsuXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcblxuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgfSk7XG59O1xuXG5mdW5jdGlvbiBkb25lKHN0cmVhbSwgZXIsIGRhdGEpIHtcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBpZiAoZGF0YSAhPSBudWxsKSAvLyBzaW5nbGUgZXF1YWxzIGNoZWNrIGZvciBib3RoIGBudWxsYCBhbmQgYHVuZGVmaW5lZGBcbiAgICBzdHJlYW0ucHVzaChkYXRhKTsgLy8gVE9ETyhCcmlkZ2VBUik6IFdyaXRlIGEgdGVzdCBmb3IgdGhlc2UgdHdvIGVycm9yIGNhc2VzXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG5cbiAgaWYgKHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5sZW5ndGgpIHRocm93IG5ldyBFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAoKTtcbiAgaWYgKHN0cmVhbS5fdHJhbnNmb3JtU3RhdGUudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORygpO1xuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBBIGJpdCBzaW1wbGVyIHRoYW4gcmVhZGFibGUgc3RyZWFtcy5cbi8vIEltcGxlbWVudCBhbiBhc3luYyAuX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpLCBhbmQgaXQnbGwgaGFuZGxlIGFsbFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn0gLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cblxuXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG5cbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBpbnRlcm5hbFV0aWwgPSB7XG4gIGRlcHJlY2F0ZTogcmVxdWlyZSgndXRpbC1kZXByZWNhdGUnKVxufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpLkJ1ZmZlcjtcblxudmFyIE91clVpbnQ4QXJyYXkgPSBnbG9iYWwuVWludDhBcnJheSB8fCBmdW5jdGlvbiAoKSB7fTtcblxuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuXG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfTVVMVElQTEVfQ0FMTEJBQ0sgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTVVMVElQTEVfQ0FMTEJBQ0ssXG4gICAgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRCxcbiAgICBFUlJfU1RSRUFNX05VTExfVkFMVUVTID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyxcbiAgICBFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5ELFxuICAgIEVSUl9VTktOT1dOX0VOQ09ESU5HID0gX3JlcXVpcmUkY29kZXMuRVJSX1VOS05PV05fRU5DT0RJTkc7XG5cbnZhciBlcnJvck9yRGVzdHJveSA9IGRlc3Ryb3lJbXBsLmVycm9yT3JEZXN0cm95O1xuXG5yZXF1aXJlKCdpbmhlcml0cycpKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSwgaXNEdXBsZXgpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307IC8vIER1cGxleCBzdHJlYW1zIGFyZSBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZSwgYnV0IHNoYXJlXG4gIC8vIHRoZSBzYW1lIG9wdGlvbnMgb2JqZWN0LlxuICAvLyBIb3dldmVyLCBzb21lIGNhc2VzIHJlcXVpcmUgc2V0dGluZyBvcHRpb25zIHRvIGRpZmZlcmVudFxuICAvLyB2YWx1ZXMgZm9yIHRoZSByZWFkYWJsZSBhbmQgdGhlIHdyaXRhYmxlIHNpZGVzIG9mIHRoZSBkdXBsZXggc3RyZWFtLFxuICAvLyBlLmcuIG9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlIHZzLiBvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZSwgZXRjLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGdldEhpZ2hXYXRlck1hcmsodGhpcywgb3B0aW9ucywgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIGlzRHVwbGV4KTsgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTsgLy8gZHJhaW4gZXZlbnQgZmxhZy5cblxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlOyAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuXG4gIHRoaXMuZW5kaW5nID0gZmFsc2U7IC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcblxuICB0aGlzLmVuZGVkID0gZmFsc2U7IC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTsgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG5cbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTsgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTsgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cblxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JzsgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cblxuICB0aGlzLmxlbmd0aCA9IDA7IC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7IC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcblxuICB0aGlzLmNvcmtlZCA9IDA7IC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuXG4gIHRoaXMuc3luYyA9IHRydWU7IC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7IC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcblxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9OyAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcblxuXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7IC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cblxuICB0aGlzLndyaXRlbGVuID0gMDtcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsOyAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcblxuICB0aGlzLnBlbmRpbmdjYiA9IDA7IC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcblxuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7IC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTsgLy8gU2hvdWxkIGNsb3NlIGJlIGVtaXR0ZWQgb24gZGVzdHJveS4gRGVmYXVsdHMgdG8gdHJ1ZS5cblxuICB0aGlzLmVtaXRDbG9zZSA9IG9wdGlvbnMuZW1pdENsb3NlICE9PSBmYWxzZTsgLy8gU2hvdWxkIC5kZXN0cm95KCkgYmUgY2FsbGVkIGFmdGVyICdmaW5pc2gnIChhbmQgcG90ZW50aWFsbHkgJ2VuZCcpXG5cbiAgdGhpcy5hdXRvRGVzdHJveSA9ICEhb3B0aW9ucy5hdXRvRGVzdHJveTsgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcblxuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDsgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG5cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG5cbiAgd2hpbGUgKGN1cnJlbnQpIHtcbiAgICBvdXQucHVzaChjdXJyZW50KTtcbiAgICBjdXJyZW50ID0gY3VycmVudC5uZXh0O1xuICB9XG5cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uIHdyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEJ1ZmZlcigpO1xuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXG4gICAgfSk7XG4gIH0gY2F0Y2ggKF8pIHt9XG59KSgpOyAvLyBUZXN0IF93cml0YWJsZVN0YXRlIGZvciBpbmhlcml0YW5jZSB0byBhY2NvdW50IGZvciBEdXBsZXggc3RyZWFtcyxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cblxuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaGFzSW5zdGFuY2UgJiYgdHlwZW9mIEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdID09PSAnZnVuY3Rpb24nKSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUsIFN5bWJvbC5oYXNJbnN0YW5jZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcbiAgICAgIGlmICh0aGlzICE9PSBXcml0YWJsZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiByZWFsSGFzSW5zdGFuY2Uob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTsgLy8gV3JpdGFibGUgY3RvciBpcyBhcHBsaWVkIHRvIER1cGxleGVzLCB0b28uXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxuICAvLyB3b3VsZCByZXR1cm4gZmFsc2UsIGFzIG5vIGBfd3JpdGFibGVTdGF0ZWAgcHJvcGVydHkgaXMgYXR0YWNoZWQuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICAvLyBDaGVja2luZyBmb3IgYSBTdHJlYW0uRHVwbGV4IGluc3RhbmNlIGlzIGZhc3RlciBoZXJlIGluc3RlYWQgb2YgaW5zaWRlXG4gIC8vIHRoZSBXcml0YWJsZVN0YXRlIGNvbnN0cnVjdG9yLCBhdCBsZWFzdCB3aXRoIFY4IDYuNVxuXG4gIHZhciBpc0R1cGxleCA9IHRoaXMgaW5zdGFuY2VvZiBEdXBsZXg7XG4gIGlmICghaXNEdXBsZXggJiYgIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSkgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZSA9IG5ldyBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMsIGlzRHVwbGV4KTsgLy8gbGVnYWN5LlxuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn0gLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuXG5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICBlcnJvck9yRGVzdHJveSh0aGlzLCBuZXcgRVJSX1NUUkVBTV9DQU5OT1RfUElQRSgpKTtcbn07XG5cbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xuICB2YXIgZXIgPSBuZXcgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQoKTsgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcblxuICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXIpO1xufSAvLyBDaGVja3MgdGhhdCBhIHVzZXItc3VwcGxpZWQgY2h1bmsgaXMgdmFsaWQsIGVzcGVjaWFsbHkgZm9yIHRoZSBwYXJ0aWN1bGFyXG4vLyBtb2RlIHRoZSBzdHJlYW0gaXMgaW4uIEN1cnJlbnRseSB0aGlzIG1lYW5zIHRoYXQgYG51bGxgIGlzIG5ldmVyIGFjY2VwdGVkXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXG5cblxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIGVyO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IEVSUl9TVFJFQU1fTlVMTF9WQUxVRVMoKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgRVJSX0lOVkFMSURfQVJHX1RZUEUoJ2NodW5rJywgWydzdHJpbmcnLCAnQnVmZmVyJ10sIGNodW5rKTtcbiAgfVxuXG4gIGlmIChlcikge1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuXG4gIHZhciBpc0J1ZiA9ICFzdGF0ZS5vYmplY3RNb2RlICYmIF9pc1VpbnQ4QXJyYXkoY2h1bmspO1xuXG4gIGlmIChpc0J1ZiAmJiAhQnVmZmVyLmlzQnVmZmVyKGNodW5rKSkge1xuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XG4gIH1cblxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoaXNCdWYpIGVuY29kaW5nID0gJ2J1ZmZlcic7ZWxzZSBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG4gIGlmIChzdGF0ZS5lbmRpbmcpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICByZXQgPSB3cml0ZU9yQnVmZmVyKHRoaXMsIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBFUlJfVU5LTk9XTl9FTkNPRElORyhlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuXG4gIHJldHVybiBjaHVuaztcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7IC8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5cbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgaWYgKCFpc0J1Zikge1xuICAgIHZhciBuZXdDaHVuayA9IGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpO1xuXG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG5cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuICB2YXIgcmV0ID0gc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyazsgLy8gd2UgbXVzdCBlbnN1cmUgdGhhdCBwcmV2aW91cyBuZWVkRHJhaW4gd2lsbCBub3QgYmUgcmVzZXQgdG8gZmFsc2UuXG5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcblxuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ICs9IDE7XG4gIH0gZWxzZSB7XG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgc3RhdGUud3JpdGVsZW4gPSBsZW47XG4gIHN0YXRlLndyaXRlY2IgPSBjYjtcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XG4gIHN0YXRlLnN5bmMgPSB0cnVlO1xuICBpZiAoc3RhdGUuZGVzdHJveWVkKSBzdGF0ZS5vbndyaXRlKG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgnd3JpdGUnKSk7ZWxzZSBpZiAod3JpdGV2KSBzdHJlYW0uX3dyaXRldihjaHVuaywgc3RhdGUub253cml0ZSk7ZWxzZSBzdHJlYW0uX3dyaXRlKGNodW5rLCBlbmNvZGluZywgc3RhdGUub253cml0ZSk7XG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xuICAtLXN0YXRlLnBlbmRpbmdjYjtcblxuICBpZiAoc3luYykge1xuICAgIC8vIGRlZmVyIHRoZSBjYWxsYmFjayBpZiB3ZSBhcmUgYmVpbmcgY2FsbGVkIHN5bmNocm9ub3VzbHlcbiAgICAvLyB0byBhdm9pZCBwaWxpbmcgdXAgdGhpbmdzIG9uIHRoZSBzdGFja1xuICAgIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTsgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG5cbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcbiAgc3RhdGUud3JpdGluZyA9IGZhbHNlO1xuICBzdGF0ZS53cml0ZWNiID0gbnVsbDtcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xuICBzdGF0ZS53cml0ZWxlbiA9IDA7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGUoc3RyZWFtLCBlcikge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcbiAgdmFyIGNiID0gc3RhdGUud3JpdGVjYjtcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgdGhyb3cgbmV3IEVSUl9NVUxUSVBMRV9DQUxMQkFDSygpO1xuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSkgfHwgc3RyZWFtLmRlc3Ryb3llZDtcblxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcbiAgICAgIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpO1xuICAgIH1cblxuICAgIGlmIChzeW5jKSB7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpIHtcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xuICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgY2IoKTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG59IC8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XG4vLyBlbWl0ICdkcmFpbicgYmVmb3JlIHRoZSB3cml0ZSgpIGNvbnN1bWVyIGdldHMgdGhlICdmYWxzZScgcmV0dXJuXG4vLyB2YWx1ZSwgYW5kIGhhcyBhIGNoYW5jZSB0byBhdHRhY2ggYSAnZHJhaW4nIGxpc3RlbmVyLlxuXG5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn0gLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcblxuXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG4gICAgdmFyIGNvdW50ID0gMDtcbiAgICB2YXIgYWxsQnVmZmVycyA9IHRydWU7XG5cbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuXG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTsgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcblxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cblxuICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQtLTsgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cbiAgICAgIC8vIGl0IG1lYW5zIHRoYXQgd2UgbmVlZCB0byB3YWl0IHVudGlsIGl0IGRvZXMuXG4gICAgICAvLyBhbHNvLCB0aGF0IG1lYW5zIHRoYXQgdGhlIGNodW5rIGFuZCBjYiBhcmUgY3VycmVudGx5XG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cblxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9IGVudHJ5O1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihuZXcgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQoJ193cml0ZSgpJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTsgLy8gLmVuZCgpIGZ1bGx5IHVuY29ya3NcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9IC8vIGlnbm9yZSB1bm5lY2Vzc2FyeSBlbmQoKSBjYWxscy5cblxuXG4gIGlmICghc3RhdGUuZW5kaW5nKSBlbmRXcml0YWJsZSh0aGlzLCBzdGF0ZSwgY2IpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUxlbmd0aCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUubGVuZ3RoO1xuICB9XG59KTtcblxuZnVuY3Rpb24gbmVlZEZpbmlzaChzdGF0ZSkge1xuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xufVxuXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcblxuICAgIGlmIChlcnIpIHtcbiAgICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicgJiYgIXN0YXRlLmRlc3Ryb3llZCkge1xuICAgICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgICBzdGF0ZS5maW5hbENhbGxlZCA9IHRydWU7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gIGlmIChuZWVkKSB7XG4gICAgcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpO1xuXG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuXG4gICAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgICAgLy8gSW4gY2FzZSBvZiBkdXBsZXggc3RyZWFtcyB3ZSBuZWVkIGEgd2F5IHRvIGRldGVjdFxuICAgICAgICAvLyBpZiB0aGUgcmVhZGFibGUgc2lkZSBpcyByZWFkeSBmb3IgYXV0b0Rlc3Ryb3kgYXMgd2VsbFxuICAgICAgICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gICAgICAgIGlmICghclN0YXRlIHx8IHJTdGF0ZS5hdXRvRGVzdHJveSAmJiByU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG5cbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzLm5leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuXG4gIHdoaWxlIChlbnRyeSkge1xuICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGNiKGVycik7XG4gICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICB9IC8vIHJldXNlIHRoZSBmcmVlIGNvcmtSZXEuXG5cblxuICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUubmV4dCA9IGNvcmtSZXE7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciBfT2JqZWN0JHNldFByb3RvdHlwZU87XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHsgaWYgKGtleSBpbiBvYmopIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7IHZhbHVlOiB2YWx1ZSwgZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlLCB3cml0YWJsZTogdHJ1ZSB9KTsgfSBlbHNlIHsgb2JqW2tleV0gPSB2YWx1ZTsgfSByZXR1cm4gb2JqOyB9XG5cbnZhciBmaW5pc2hlZCA9IHJlcXVpcmUoJy4vZW5kLW9mLXN0cmVhbScpO1xuXG52YXIga0xhc3RSZXNvbHZlID0gU3ltYm9sKCdsYXN0UmVzb2x2ZScpO1xudmFyIGtMYXN0UmVqZWN0ID0gU3ltYm9sKCdsYXN0UmVqZWN0Jyk7XG52YXIga0Vycm9yID0gU3ltYm9sKCdlcnJvcicpO1xudmFyIGtFbmRlZCA9IFN5bWJvbCgnZW5kZWQnKTtcbnZhciBrTGFzdFByb21pc2UgPSBTeW1ib2woJ2xhc3RQcm9taXNlJyk7XG52YXIga0hhbmRsZVByb21pc2UgPSBTeW1ib2woJ2hhbmRsZVByb21pc2UnKTtcbnZhciBrU3RyZWFtID0gU3ltYm9sKCdzdHJlYW0nKTtcblxuZnVuY3Rpb24gY3JlYXRlSXRlclJlc3VsdCh2YWx1ZSwgZG9uZSkge1xuICByZXR1cm4ge1xuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBkb25lOiBkb25lXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlYWRBbmRSZXNvbHZlKGl0ZXIpIHtcbiAgdmFyIHJlc29sdmUgPSBpdGVyW2tMYXN0UmVzb2x2ZV07XG5cbiAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICB2YXIgZGF0YSA9IGl0ZXJba1N0cmVhbV0ucmVhZCgpOyAvLyB3ZSBkZWZlciBpZiBkYXRhIGlzIG51bGxcbiAgICAvLyB3ZSBjYW4gYmUgZXhwZWN0aW5nIGVpdGhlciAnZW5kJyBvclxuICAgIC8vICdlcnJvcidcblxuICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICBpdGVyW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBvblJlYWRhYmxlKGl0ZXIpIHtcbiAgLy8gd2Ugd2FpdCBmb3IgdGhlIG5leHQgdGljaywgYmVjYXVzZSBpdCBtaWdodFxuICAvLyBlbWl0IGFuIGVycm9yIHdpdGggcHJvY2Vzcy5uZXh0VGlja1xuICBwcm9jZXNzLm5leHRUaWNrKHJlYWRBbmRSZXNvbHZlLCBpdGVyKTtcbn1cblxuZnVuY3Rpb24gd3JhcEZvck5leHQobGFzdFByb21pc2UsIGl0ZXIpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBsYXN0UHJvbWlzZS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmIChpdGVyW2tFbmRlZF0pIHtcbiAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGl0ZXJba0hhbmRsZVByb21pc2VdKHJlc29sdmUsIHJlamVjdCk7XG4gICAgfSwgcmVqZWN0KTtcbiAgfTtcbn1cblxudmFyIEFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YoZnVuY3Rpb24gKCkge30pO1xudmFyIFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSA9IE9iamVjdC5zZXRQcm90b3R5cGVPZigoX09iamVjdCRzZXRQcm90b3R5cGVPID0ge1xuICBnZXQgc3RyZWFtKCkge1xuICAgIHJldHVybiB0aGlzW2tTdHJlYW1dO1xuICB9LFxuXG4gIG5leHQ6IGZ1bmN0aW9uIG5leHQoKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIC8vIGlmIHdlIGhhdmUgZGV0ZWN0ZWQgYW4gZXJyb3IgaW4gdGhlIG1lYW53aGlsZVxuICAgIC8vIHJlamVjdCBzdHJhaWdodCBhd2F5XG4gICAgdmFyIGVycm9yID0gdGhpc1trRXJyb3JdO1xuXG4gICAgaWYgKGVycm9yICE9PSBudWxsKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgIH1cblxuICAgIGlmICh0aGlzW2tFbmRlZF0pIHtcbiAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trU3RyZWFtXS5kZXN0cm95ZWQpIHtcbiAgICAgIC8vIFdlIG5lZWQgdG8gZGVmZXIgdmlhIG5leHRUaWNrIGJlY2F1c2UgaWYgLmRlc3Ryb3koZXJyKSBpc1xuICAgICAgLy8gY2FsbGVkLCB0aGUgZXJyb3Igd2lsbCBiZSBlbWl0dGVkIHZpYSBuZXh0VGljaywgYW5kXG4gICAgICAvLyB3ZSBjYW5ub3QgZ3VhcmFudGVlIHRoYXQgdGhlcmUgaXMgbm8gZXJyb3IgbGluZ2VyaW5nIGFyb3VuZFxuICAgICAgLy8gd2FpdGluZyB0byBiZSBlbWl0dGVkLlxuICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKF90aGlzW2tFcnJvcl0pIHtcbiAgICAgICAgICAgIHJlamVjdChfdGhpc1trRXJyb3JdKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9IC8vIGlmIHdlIGhhdmUgbXVsdGlwbGUgbmV4dCgpIGNhbGxzXG4gICAgLy8gd2Ugd2lsbCB3YWl0IGZvciB0aGUgcHJldmlvdXMgUHJvbWlzZSB0byBmaW5pc2hcbiAgICAvLyB0aGlzIGxvZ2ljIGlzIG9wdGltaXplZCB0byBzdXBwb3J0IGZvciBhd2FpdCBsb29wcyxcbiAgICAvLyB3aGVyZSBuZXh0KCkgaXMgb25seSBjYWxsZWQgb25jZSBhdCBhIHRpbWVcblxuXG4gICAgdmFyIGxhc3RQcm9taXNlID0gdGhpc1trTGFzdFByb21pc2VdO1xuICAgIHZhciBwcm9taXNlO1xuXG4gICAgaWYgKGxhc3RQcm9taXNlKSB7XG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2Uod3JhcEZvck5leHQobGFzdFByb21pc2UsIHRoaXMpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZmFzdCBwYXRoIG5lZWRlZCB0byBzdXBwb3J0IG11bHRpcGxlIHRoaXMucHVzaCgpXG4gICAgICAvLyB3aXRob3V0IHRyaWdnZXJpbmcgdGhlIG5leHQoKSBxdWV1ZVxuICAgICAgdmFyIGRhdGEgPSB0aGlzW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEgIT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KGRhdGEsIGZhbHNlKSk7XG4gICAgICB9XG5cbiAgICAgIHByb21pc2UgPSBuZXcgUHJvbWlzZSh0aGlzW2tIYW5kbGVQcm9taXNlXSk7XG4gICAgfVxuXG4gICAgdGhpc1trTGFzdFByb21pc2VdID0gcHJvbWlzZTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxufSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgU3ltYm9sLmFzeW5jSXRlcmF0b3IsIGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIHRoaXM7XG59KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3Qkc2V0UHJvdG90eXBlTywgXCJyZXR1cm5cIiwgZnVuY3Rpb24gX3JldHVybigpIHtcbiAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgLy8gZGVzdHJveShlcnIsIGNiKSBpcyBhIHByaXZhdGUgQVBJXG4gIC8vIHdlIGNhbiBndWFyYW50ZWUgd2UgaGF2ZSB0aGF0IGhlcmUsIGJlY2F1c2Ugd2UgY29udHJvbCB0aGVcbiAgLy8gUmVhZGFibGUgY2xhc3MgdGhpcyBpcyBhdHRhY2hlZCB0b1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIF90aGlzMltrU3RyZWFtXS5kZXN0cm95KG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH0pO1xuICB9KTtcbn0pLCBfT2JqZWN0JHNldFByb3RvdHlwZU8pLCBBc3luY0l0ZXJhdG9yUHJvdG90eXBlKTtcblxudmFyIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvciA9IGZ1bmN0aW9uIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcihzdHJlYW0pIHtcbiAgdmFyIF9PYmplY3QkY3JlYXRlO1xuXG4gIHZhciBpdGVyYXRvciA9IE9iamVjdC5jcmVhdGUoUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlLCAoX09iamVjdCRjcmVhdGUgPSB7fSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrU3RyZWFtLCB7XG4gICAgdmFsdWU6IHN0cmVhbSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlc29sdmUsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrTGFzdFJlamVjdCwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFcnJvciwge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfZGVmaW5lUHJvcGVydHkoX09iamVjdCRjcmVhdGUsIGtFbmRlZCwge1xuICAgIHZhbHVlOiBzdHJlYW0uX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrSGFuZGxlUHJvbWlzZSwge1xuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgIHZhciBkYXRhID0gaXRlcmF0b3Jba1N0cmVhbV0ucmVhZCgpO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IHJlc29sdmU7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IHJlamVjdDtcbiAgICAgIH1cbiAgICB9LFxuICAgIHdyaXRhYmxlOiB0cnVlXG4gIH0pLCBfT2JqZWN0JGNyZWF0ZSkpO1xuICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgZmluaXNoZWQoc3RyZWFtLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVyciAmJiBlcnIuY29kZSAhPT0gJ0VSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFJykge1xuICAgICAgdmFyIHJlamVjdCA9IGl0ZXJhdG9yW2tMYXN0UmVqZWN0XTsgLy8gcmVqZWN0IGlmIHdlIGFyZSB3YWl0aW5nIGZvciBkYXRhIGluIHRoZSBQcm9taXNlXG4gICAgICAvLyByZXR1cm5lZCBieSBuZXh0KCkgYW5kIHN0b3JlIHRoZSBlcnJvclxuXG4gICAgICBpZiAocmVqZWN0ICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlc29sdmVdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICB9XG5cbiAgICAgIGl0ZXJhdG9yW2tFcnJvcl0gPSBlcnI7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHJlc29sdmUgPSBpdGVyYXRvcltrTGFzdFJlc29sdmVdO1xuXG4gICAgaWYgKHJlc29sdmUgIT09IG51bGwpIHtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UHJvbWlzZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgcmVzb2x2ZShjcmVhdGVJdGVyUmVzdWx0KHVuZGVmaW5lZCwgdHJ1ZSkpO1xuICAgIH1cblxuICAgIGl0ZXJhdG9yW2tFbmRlZF0gPSB0cnVlO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdyZWFkYWJsZScsIG9uUmVhZGFibGUuYmluZChudWxsLCBpdGVyYXRvcikpO1xuICByZXR1cm4gaXRlcmF0b3I7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcjsiLCIndXNlIHN0cmljdCc7XG5cbmZ1bmN0aW9uIG93bktleXMob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7IGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHsgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTsgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlOyBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7IGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTsgfSB9XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHsgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7IGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTsgcmV0dXJuIENvbnN0cnVjdG9yOyB9XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJ2J1ZmZlcicpLFxuICAgIEJ1ZmZlciA9IF9yZXF1aXJlLkJ1ZmZlcjtcblxudmFyIF9yZXF1aXJlMiA9IHJlcXVpcmUoJ3V0aWwnKSxcbiAgICBpbnNwZWN0ID0gX3JlcXVpcmUyLmluc3BlY3Q7XG5cbnZhciBjdXN0b20gPSBpbnNwZWN0ICYmIGluc3BlY3QuY3VzdG9tIHx8ICdpbnNwZWN0JztcblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIEJ1ZmZlci5wcm90b3R5cGUuY29weS5jYWxsKHNyYywgdGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9XG4vKiNfX1BVUkVfXyovXG5mdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIF9jcmVhdGVDbGFzcyhCdWZmZXJMaXN0LCBbe1xuICAgIGtleTogXCJwdXNoXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHB1c2godikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiBudWxsXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID4gMCkgdGhpcy50YWlsLm5leHQgPSBlbnRyeTtlbHNlIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJ1bnNoaWZ0XCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHVuc2hpZnQodikge1xuICAgICAgdmFyIGVudHJ5ID0ge1xuICAgICAgICBkYXRhOiB2LFxuICAgICAgICBuZXh0OiB0aGlzLmhlYWRcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgICArK3RoaXMubGVuZ3RoO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJzaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgICAtLXRoaXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiY2xlYXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJqb2luXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNvbmNhdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBjb25jYXQobikge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGkgPSAwO1xuXG4gICAgICB3aGlsZSAocCkge1xuICAgICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcbiAgICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIG9yIGNoYXJhY3RlcnMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcImNvbnN1bWVcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uc3VtZShuLCBoYXNTdHJpbmdzKSB7XG4gICAgICB2YXIgcmV0O1xuXG4gICAgICBpZiAobiA8IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBgc2xpY2VgIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzLlxuICAgICAgICByZXQgPSB0aGlzLmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICAgICAgdGhpcy5oZWFkLmRhdGEgPSB0aGlzLmhlYWQuZGF0YS5zbGljZShuKTtcbiAgICAgIH0gZWxzZSBpZiAobiA9PT0gdGhpcy5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgICAgIC8vIEZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaC5cbiAgICAgICAgcmV0ID0gdGhpcy5zaGlmdCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVzdWx0IHNwYW5zIG1vcmUgdGhhbiBvbmUgYnVmZmVyLlxuICAgICAgICByZXQgPSBoYXNTdHJpbmdzID8gdGhpcy5fZ2V0U3RyaW5nKG4pIDogdGhpcy5fZ2V0QnVmZmVyKG4pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJmaXJzdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBmaXJzdCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0U3RyaW5nXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRTdHJpbmcobikge1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICB2YXIgcmV0ID0gcC5kYXRhO1xuICAgICAgbiAtPSByZXQubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgc3RyID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgICAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cblxuICB9LCB7XG4gICAga2V5OiBcIl9nZXRCdWZmZXJcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gX2dldEJ1ZmZlcihuKSB7XG4gICAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgYyA9IDE7XG4gICAgICBwLmRhdGEuY29weShyZXQpO1xuICAgICAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgICB2YXIgYnVmID0gcC5kYXRhO1xuICAgICAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgICAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgICAgIG4gLT0gbmI7XG5cbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgICAgICsrYztcbiAgICAgICAgICAgIGlmIChwLm5leHQpIHRoaXMuaGVhZCA9IHAubmV4dDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZCA9IHA7XG4gICAgICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgKytjO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCAtPSBjO1xuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIE1ha2Ugc3VyZSB0aGUgbGlua2VkIGxpc3Qgb25seSBzaG93cyB0aGUgbWluaW1hbCBuZWNlc3NhcnkgaW5mb3JtYXRpb24uXG5cbiAgfSwge1xuICAgIGtleTogY3VzdG9tLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZShfLCBvcHRpb25zKSB7XG4gICAgICByZXR1cm4gaW5zcGVjdCh0aGlzLCBfb2JqZWN0U3ByZWFkKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIC8vIE9ubHkgaW5zcGVjdCBvbmUgbGV2ZWwuXG4gICAgICAgIGRlcHRoOiAwLFxuICAgICAgICAvLyBJdCBzaG91bGQgbm90IHJlY3Vyc2UuXG4gICAgICAgIGN1c3RvbUluc3BlY3Q6IGZhbHNlXG4gICAgICB9KSk7XG4gICAgfVxuICB9XSk7XG5cbiAgcmV0dXJuIEJ1ZmZlckxpc3Q7XG59KCk7IiwiJ3VzZSBzdHJpY3QnOyAvLyB1bmRvY3VtZW50ZWQgY2IoKSBBUEksIG5lZWRlZCBmb3IgY29yZSwgbm90IGZvciBwdWJsaWMgQVBJXG5cbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyKSB7XG4gICAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcbiAgLy8gdG8gbWFrZSBpdCByZS1lbnRyYW5jZSBzYWZlIGluIGNhc2UgZGVzdHJveSgpIGlzIGNhbGxlZCB3aXRoaW4gY2FsbGJhY2tzXG5cblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfSAvLyBpZiB0aGlzIGlzIGEgZHVwbGV4IHN0cmVhbSBtYXJrIHRoZSB3cml0YWJsZSBwYXJ0IGFzIGRlc3Ryb3llZCBhcyB3ZWxsXG5cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgaWYgKCFfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSB7XG4gICAgICAgIF90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yQW5kQ2xvc2VOVCwgX3RoaXMsIGVycik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZU5ULCBfdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChjYikge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHRoaXM7XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvckFuZENsb3NlTlQoc2VsZiwgZXJyKSB7XG4gIGVtaXRFcnJvck5UKHNlbGYsIGVycik7XG4gIGVtaXRDbG9zZU5UKHNlbGYpO1xufVxuXG5mdW5jdGlvbiBlbWl0Q2xvc2VOVChzZWxmKSB7XG4gIGlmIChzZWxmLl93cml0YWJsZVN0YXRlICYmICFzZWxmLl93cml0YWJsZVN0YXRlLmVtaXRDbG9zZSkgcmV0dXJuO1xuICBpZiAoc2VsZi5fcmVhZGFibGVTdGF0ZSAmJiAhc2VsZi5fcmVhZGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgc2VsZi5lbWl0KCdjbG9zZScpO1xufVxuXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIH1cblxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5hbENhbGxlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUucHJlZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbmZ1bmN0aW9uIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXJyKSB7XG4gIC8vIFdlIGhhdmUgdGVzdHMgdGhhdCByZWx5IG9uIGVycm9ycyBiZWluZyBlbWl0dGVkXG4gIC8vIGluIHRoZSBzYW1lIHRpY2ssIHNvIGNoYW5naW5nIHRoaXMgaXMgc2VtdmVyIG1ham9yLlxuICAvLyBGb3Igbm93IHdoZW4geW91IG9wdC1pbiB0byBhdXRvRGVzdHJveSB3ZSBhbGxvd1xuICAvLyB0aGUgZXJyb3IgdG8gYmUgZW1pdHRlZCBuZXh0VGljay4gSW4gYSBmdXR1cmVcbiAgLy8gc2VtdmVyIG1ham9yIHVwZGF0ZSB3ZSBzaG91bGQgY2hhbmdlIHRoZSBkZWZhdWx0IHRvIHRoaXMuXG4gIHZhciByU3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB3U3RhdGUgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIGlmIChyU3RhdGUgJiYgclN0YXRlLmF1dG9EZXN0cm95IHx8IHdTdGF0ZSAmJiB3U3RhdGUuYXV0b0Rlc3Ryb3kpIHN0cmVhbS5kZXN0cm95KGVycik7ZWxzZSBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVzdHJveTogZGVzdHJveSxcbiAgdW5kZXN0cm95OiB1bmRlc3Ryb3ksXG4gIGVycm9yT3JEZXN0cm95OiBlcnJvck9yRGVzdHJveVxufTsiLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL2VuZC1vZi1zdHJlYW0gd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzUmVxdWVzdChzdHJlYW0pIHtcbiAgcmV0dXJuIHN0cmVhbS5zZXRIZWFkZXIgJiYgdHlwZW9mIHN0cmVhbS5hYm9ydCA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gZW9zKHN0cmVhbSwgb3B0cywgY2FsbGJhY2spIHtcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW9zKHN0cmVhbSwgbnVsbCwgb3B0cyk7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2sgfHwgbm9vcCk7XG4gIHZhciByZWFkYWJsZSA9IG9wdHMucmVhZGFibGUgfHwgb3B0cy5yZWFkYWJsZSAhPT0gZmFsc2UgJiYgc3RyZWFtLnJlYWRhYmxlO1xuICB2YXIgd3JpdGFibGUgPSBvcHRzLndyaXRhYmxlIHx8IG9wdHMud3JpdGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS53cml0YWJsZTtcblxuICB2YXIgb25sZWdhY3lmaW5pc2ggPSBmdW5jdGlvbiBvbmxlZ2FjeWZpbmlzaCgpIHtcbiAgICBpZiAoIXN0cmVhbS53cml0YWJsZSkgb25maW5pc2goKTtcbiAgfTtcblxuICB2YXIgd3JpdGFibGVFbmRlZCA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQ7XG5cbiAgdmFyIG9uZmluaXNoID0gZnVuY3Rpb24gb25maW5pc2goKSB7XG4gICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICB3cml0YWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXJlYWRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIHJlYWRhYmxlRW5kZWQgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGUgJiYgc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQ7XG5cbiAgdmFyIG9uZW5kID0gZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgcmVhZGFibGUgPSBmYWxzZTtcbiAgICByZWFkYWJsZUVuZGVkID0gdHJ1ZTtcbiAgICBpZiAoIXdyaXRhYmxlKSBjYWxsYmFjay5jYWxsKHN0cmVhbSk7XG4gIH07XG5cbiAgdmFyIG9uZXJyb3IgPSBmdW5jdGlvbiBvbmVycm9yKGVycikge1xuICAgIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICB9O1xuXG4gIHZhciBvbmNsb3NlID0gZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICB2YXIgZXJyO1xuXG4gICAgaWYgKHJlYWRhYmxlICYmICFyZWFkYWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fcmVhZGFibGVTdGF0ZSB8fCAhc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG5cbiAgICBpZiAod3JpdGFibGUgJiYgIXdyaXRhYmxlRW5kZWQpIHtcbiAgICAgIGlmICghc3RyZWFtLl93cml0YWJsZVN0YXRlIHx8ICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZW5kZWQpIGVyciA9IG5ldyBFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRSgpO1xuICAgICAgcmV0dXJuIGNhbGxiYWNrLmNhbGwoc3RyZWFtLCBlcnIpO1xuICAgIH1cbiAgfTtcblxuICB2YXIgb25yZXF1ZXN0ID0gZnVuY3Rpb24gb25yZXF1ZXN0KCkge1xuICAgIHN0cmVhbS5yZXEub24oJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgfTtcblxuICBpZiAoaXNSZXF1ZXN0KHN0cmVhbSkpIHtcbiAgICBzdHJlYW0ub24oJ2NvbXBsZXRlJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5vbignYWJvcnQnLCBvbmNsb3NlKTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgb25yZXF1ZXN0KCk7ZWxzZSBzdHJlYW0ub24oJ3JlcXVlc3QnLCBvbnJlcXVlc3QpO1xuICB9IGVsc2UgaWYgKHdyaXRhYmxlICYmICFzdHJlYW0uX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAvLyBsZWdhY3kgc3RyZWFtc1xuICAgIHN0cmVhbS5vbignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5vbignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gIH1cblxuICBzdHJlYW0ub24oJ2VuZCcsIG9uZW5kKTtcbiAgc3RyZWFtLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIGlmIChvcHRzLmVycm9yICE9PSBmYWxzZSkgc3RyZWFtLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBzdHJlYW0ub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgICBpZiAoc3RyZWFtLnJlcSkgc3RyZWFtLnJlcS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmxlZ2FjeWZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBlb3M7IiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIHRocm93IG5ldyBFcnJvcignUmVhZGFibGUuZnJvbSBpcyBub3QgYXZhaWxhYmxlIGluIHRoZSBicm93c2VyJylcbn07XG4iLCIvLyBQb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vbWFmaW50b3NoL3B1bXAgd2l0aFxuLy8gcGVybWlzc2lvbiBmcm9tIHRoZSBhdXRob3IsIE1hdGhpYXMgQnV1cyAoQG1hZmludG9zaCkuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlb3M7XG5cbmZ1bmN0aW9uIG9uY2UoY2FsbGJhY2spIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYWxsZWQpIHJldHVybjtcbiAgICBjYWxsZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrLmFwcGx5KHZvaWQgMCwgYXJndW1lbnRzKTtcbiAgfTtcbn1cblxudmFyIF9yZXF1aXJlJGNvZGVzID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMsXG4gICAgRVJSX01JU1NJTkdfQVJHUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9NSVNTSU5HX0FSR1MsXG4gICAgRVJSX1NUUkVBTV9ERVNUUk9ZRUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0RFU1RST1lFRDtcblxuZnVuY3Rpb24gbm9vcChlcnIpIHtcbiAgLy8gUmV0aHJvdyB0aGUgZXJyb3IgaWYgaXQgZXhpc3RzIHRvIGF2b2lkIHN3YWxsb3dpbmcgaXRcbiAgaWYgKGVycikgdGhyb3cgZXJyO1xufVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGNhbGxiYWNrKSB7XG4gIGNhbGxiYWNrID0gb25jZShjYWxsYmFjayk7XG4gIHZhciBjbG9zZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICB9KTtcbiAgaWYgKGVvcyA9PT0gdW5kZWZpbmVkKSBlb3MgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcbiAgZW9zKHN0cmVhbSwge1xuICAgIHJlYWRhYmxlOiByZWFkaW5nLFxuICAgIHdyaXRhYmxlOiB3cml0aW5nXG4gIH0sIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoZXJyKSByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICBjbG9zZWQgPSB0cnVlO1xuICAgIGNhbGxiYWNrKCk7XG4gIH0pO1xuICB2YXIgZGVzdHJveWVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGNsb3NlZCkgcmV0dXJuO1xuICAgIGlmIChkZXN0cm95ZWQpIHJldHVybjtcbiAgICBkZXN0cm95ZWQgPSB0cnVlOyAvLyByZXF1ZXN0LmRlc3Ryb3kganVzdCBkbyAuZW5kIC0gLmFib3J0IGlzIHdoYXQgd2Ugd2FudFxuXG4gICAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSByZXR1cm4gc3RyZWFtLmFib3J0KCk7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgY2FsbGJhY2soZXJyIHx8IG5ldyBFUlJfU1RSRUFNX0RFU1RST1lFRCgncGlwZScpKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gY2FsbChmbikge1xuICBmbigpO1xufVxuXG5mdW5jdGlvbiBwaXBlKGZyb20sIHRvKSB7XG4gIHJldHVybiBmcm9tLnBpcGUodG8pO1xufVxuXG5mdW5jdGlvbiBwb3BDYWxsYmFjayhzdHJlYW1zKSB7XG4gIGlmICghc3RyZWFtcy5sZW5ndGgpIHJldHVybiBub29wO1xuICBpZiAodHlwZW9mIHN0cmVhbXNbc3RyZWFtcy5sZW5ndGggLSAxXSAhPT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5vb3A7XG4gIHJldHVybiBzdHJlYW1zLnBvcCgpO1xufVxuXG5mdW5jdGlvbiBwaXBlbGluZSgpIHtcbiAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIHN0cmVhbXMgPSBuZXcgQXJyYXkoX2xlbiksIF9rZXkgPSAwOyBfa2V5IDwgX2xlbjsgX2tleSsrKSB7XG4gICAgc3RyZWFtc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgfVxuXG4gIHZhciBjYWxsYmFjayA9IHBvcENhbGxiYWNrKHN0cmVhbXMpO1xuICBpZiAoQXJyYXkuaXNBcnJheShzdHJlYW1zWzBdKSkgc3RyZWFtcyA9IHN0cmVhbXNbMF07XG5cbiAgaWYgKHN0cmVhbXMubGVuZ3RoIDwgMikge1xuICAgIHRocm93IG5ldyBFUlJfTUlTU0lOR19BUkdTKCdzdHJlYW1zJyk7XG4gIH1cblxuICB2YXIgZXJyb3I7XG4gIHZhciBkZXN0cm95cyA9IHN0cmVhbXMubWFwKGZ1bmN0aW9uIChzdHJlYW0sIGkpIHtcbiAgICB2YXIgcmVhZGluZyA9IGkgPCBzdHJlYW1zLmxlbmd0aCAtIDE7XG4gICAgdmFyIHdyaXRpbmcgPSBpID4gMDtcbiAgICByZXR1cm4gZGVzdHJveWVyKHN0cmVhbSwgcmVhZGluZywgd3JpdGluZywgZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gICAgICBpZiAoZXJyKSBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgaWYgKHJlYWRpbmcpIHJldHVybjtcbiAgICAgIGRlc3Ryb3lzLmZvckVhY2goY2FsbCk7XG4gICAgICBjYWxsYmFjayhlcnJvcik7XG4gICAgfSk7XG4gIH0pO1xuICByZXR1cm4gc3RyZWFtcy5yZWR1Y2UocGlwZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcGlwZWxpbmU7IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX0lOVkFMSURfT1BUX1ZBTFVFID0gcmVxdWlyZSgnLi4vLi4vLi4vZXJyb3JzJykuY29kZXMuRVJSX0lOVkFMSURfT1BUX1ZBTFVFO1xuXG5mdW5jdGlvbiBoaWdoV2F0ZXJNYXJrRnJvbShvcHRpb25zLCBpc0R1cGxleCwgZHVwbGV4S2V5KSB7XG4gIHJldHVybiBvcHRpb25zLmhpZ2hXYXRlck1hcmsgIT0gbnVsbCA/IG9wdGlvbnMuaGlnaFdhdGVyTWFyayA6IGlzRHVwbGV4ID8gb3B0aW9uc1tkdXBsZXhLZXldIDogbnVsbDtcbn1cblxuZnVuY3Rpb24gZ2V0SGlnaFdhdGVyTWFyayhzdGF0ZSwgb3B0aW9ucywgZHVwbGV4S2V5LCBpc0R1cGxleCkge1xuICB2YXIgaHdtID0gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSk7XG5cbiAgaWYgKGh3bSAhPSBudWxsKSB7XG4gICAgaWYgKCEoaXNGaW5pdGUoaHdtKSAmJiBNYXRoLmZsb29yKGh3bSkgPT09IGh3bSkgfHwgaHdtIDwgMCkge1xuICAgICAgdmFyIG5hbWUgPSBpc0R1cGxleCA/IGR1cGxleEtleSA6ICdoaWdoV2F0ZXJNYXJrJztcbiAgICAgIHRocm93IG5ldyBFUlJfSU5WQUxJRF9PUFRfVkFMVUUobmFtZSwgaHdtKTtcbiAgICB9XG5cbiAgICByZXR1cm4gTWF0aC5mbG9vcihod20pO1xuICB9IC8vIERlZmF1bHQgdmFsdWVcblxuXG4gIHJldHVybiBzdGF0ZS5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBnZXRIaWdoV2F0ZXJNYXJrOiBnZXRIaWdoV2F0ZXJNYXJrXG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcycpO1xuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xuZXhwb3J0cy5SZWFkYWJsZSA9IGV4cG9ydHM7XG5leHBvcnRzLldyaXRhYmxlID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuZXhwb3J0cy5UcmFuc2Zvcm0gPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcycpO1xuZXhwb3J0cy5QYXNzVGhyb3VnaCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMnKTtcbmV4cG9ydHMuZmluaXNoZWQgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2VuZC1vZi1zdHJlYW0uanMnKTtcbmV4cG9ydHMucGlwZWxpbmUgPSByZXF1aXJlKCcuL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzJyk7XG4iLCIvKiEgc2FmZS1idWZmZXIuIE1JVCBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cbnZhciBidWZmZXIgPSByZXF1aXJlKCdidWZmZXInKVxudmFyIEJ1ZmZlciA9IGJ1ZmZlci5CdWZmZXJcblxuLy8gYWx0ZXJuYXRpdmUgdG8gdXNpbmcgT2JqZWN0LmtleXMgZm9yIG9sZCBicm93c2Vyc1xuZnVuY3Rpb24gY29weVByb3BzIChzcmMsIGRzdCkge1xuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XG4gICAgZHN0W2tleV0gPSBzcmNba2V5XVxuICB9XG59XG5pZiAoQnVmZmVyLmZyb20gJiYgQnVmZmVyLmFsbG9jICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZSAmJiBCdWZmZXIuYWxsb2NVbnNhZmVTbG93KSB7XG4gIG1vZHVsZS5leHBvcnRzID0gYnVmZmVyXG59IGVsc2Uge1xuICAvLyBDb3B5IHByb3BlcnRpZXMgZnJvbSByZXF1aXJlKCdidWZmZXInKVxuICBjb3B5UHJvcHMoYnVmZmVyLCBleHBvcnRzKVxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcbn1cblxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKEJ1ZmZlci5wcm90b3R5cGUpXG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkFkYXB0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jbGFzcyBBZGFwdGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbi1tZW1vcnkgYWRhcHRlciBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihuc3ApIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMucm9vbXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2lkcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gbnNwLnNlcnZlci5lbmNvZGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuXG4gICAgICovXG4gICAgaW5pdCgpIHsgfVxuICAgIC8qKlxuICAgICAqIFRvIGJlIG92ZXJyaWRkZW5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHsgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBzb2NrZXQgdG8gYSBsaXN0IG9mIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSAgaWQgICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgYSBzZXQgb2Ygcm9vbXNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWRkQWxsKGlkLCByb29tcykge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuc2V0KGlkLCBuZXcgU2V0KCkpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuYWRkKHJvb20pO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmhhcyhyb29tKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuc2V0KHJvb20sIG5ldyBTZXQoKSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY3JlYXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuZ2V0KHJvb20pLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLmdldChyb29tKS5hZGQoaWQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImpvaW4tcm9vbVwiLCByb29tLCBpZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgICB0aGUgc29ja2V0IGlkXG4gICAgICogQHBhcmFtIHtSb29tfSAgICAgcm9vbSAgIHRoZSByb29tIG5hbWVcbiAgICAgKi9cbiAgICBkZWwoaWQsIHJvb20pIHtcbiAgICAgICAgaWYgKHRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNpZHMuZ2V0KGlkKS5kZWxldGUocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGVsKHJvb20sIGlkKTtcbiAgICB9XG4gICAgX2RlbChyb29tLCBpZCkge1xuICAgICAgICBjb25zdCBfcm9vbSA9IHRoaXMucm9vbXMuZ2V0KHJvb20pO1xuICAgICAgICBpZiAoX3Jvb20gIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgZGVsZXRlZCA9IF9yb29tLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImxlYXZlLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9yb29tLnNpemUgPT09IDAgJiYgdGhpcy5yb29tcy5kZWxldGUocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWxldGUtcm9vbVwiLCByb29tKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0IGZyb20gYWxsIHJvb21zIGl0J3Mgam9pbmVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gaWQgICB0aGUgc29ja2V0IGlkXG4gICAgICovXG4gICAgZGVsQWxsKGlkKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWRzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgdGhpcy5zaWRzLmdldChpZCkpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWRzLmRlbGV0ZShpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJyb2FkY2FzdHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBPcHRpb25zOlxuICAgICAqICAtIGBmbGFnc2Age09iamVjdH0gZmxhZ3MgZm9yIHRoaXMgcGFja2V0XG4gICAgICogIC0gYGV4Y2VwdGAge0FycmF5fSBzaWRzIHRoYXQgc2hvdWxkIGJlIGV4Y2x1ZGVkXG4gICAgICogIC0gYHJvb21zYCB7QXJyYXl9IGxpc3Qgb2Ygcm9vbXMgdG8gYnJvYWRjYXN0IHRvXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0ICAgdGhlIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAgICAgdGhlIG9wdGlvbnNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYnJvYWRjYXN0KHBhY2tldCwgb3B0cykge1xuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IHBhY2tldE9wdHMgPSB7XG4gICAgICAgICAgICBwcmVFbmNvZGVkOiB0cnVlLFxuICAgICAgICAgICAgdm9sYXRpbGU6IGZsYWdzLnZvbGF0aWxlLFxuICAgICAgICAgICAgY29tcHJlc3M6IGZsYWdzLmNvbXByZXNzXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmNsaWVudC53cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBwYWNrZXRPcHRzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHNvY2tldHMgYnkgc2lkLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTZXQ8Um9vbT59IHJvb21zICAgdGhlIGV4cGxpY2l0IHNldCBvZiByb29tcyB0byBjaGVjay5cbiAgICAgKi9cbiAgICBzb2NrZXRzKHJvb21zKSB7XG4gICAgICAgIGNvbnN0IHNpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIHRoaXMuYXBwbHkoeyByb29tcyB9LCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc2lkcy5hZGQoc29ja2V0LmlkKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoc2lkcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxpc3Qgb2Ygcm9vbXMgYSBnaXZlbiBzb2NrZXQgaGFzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgdGhlIHNvY2tldCBpZFxuICAgICAqL1xuICAgIHNvY2tldFJvb21zKGlkKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNpZHMuZ2V0KGlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqL1xuICAgIGZldGNoU29ja2V0cyhvcHRzKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldHMgPSBbXTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0cy5wdXNoKHNvY2tldCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNvY2tldHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcm9vbXMgLSB0aGUgcm9vbXMgdG8gam9pblxuICAgICAqL1xuICAgIGFkZFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmpvaW4ocm9vbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSByb29tcyAtIHRoZSByb29tcyB0byBsZWF2ZVxuICAgICAqL1xuICAgIGRlbFNvY2tldHMob3B0cywgcm9vbXMpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgcm9vbXMuZm9yRWFjaChyb29tID0+IHNvY2tldC5sZWF2ZShyb29tKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBkaXNjb25uZWN0XG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICovXG4gICAgZGlzY29ubmVjdFNvY2tldHMob3B0cywgY2xvc2UpIHtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCBzb2NrZXQgPT4ge1xuICAgICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoY2xvc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXBwbHkob3B0cywgY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3Qgcm9vbXMgPSBvcHRzLnJvb21zO1xuICAgICAgICBjb25zdCBleGNlcHQgPSB0aGlzLmNvbXB1dGVFeGNlcHRTaWRzKG9wdHMuZXhjZXB0KTtcbiAgICAgICAgaWYgKHJvb21zLnNpemUpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgcm9vbSBvZiByb29tcykge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaWQgb2YgdGhpcy5yb29tcy5nZXQocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlkcy5oYXMoaWQpIHx8IGV4Y2VwdC5oYXMoaWQpKVxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlkcy5hZGQoaWQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBbaWRdIG9mIHRoaXMuc2lkcykge1xuICAgICAgICAgICAgICAgIGlmIChleGNlcHQuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29tcHV0ZUV4Y2VwdFNpZHMoZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgY29uc3QgZXhjZXB0U2lkcyA9IG5ldyBTZXQoKTtcbiAgICAgICAgaWYgKGV4Y2VwdFJvb21zICYmIGV4Y2VwdFJvb21zLnNpemUgPiAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2YgZXhjZXB0Um9vbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuZm9yRWFjaChzaWQgPT4gZXhjZXB0U2lkcy5hZGQoc2lkKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBleGNlcHRTaWRzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kIGEgcGFja2V0IHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycyBpbiB0aGUgY2x1c3RlclxuICAgICAqIEBwYXJhbSBwYWNrZXQgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQocGFja2V0KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRoaXMgYWRhcHRlciBkb2VzIG5vdCBzdXBwb3J0IHRoZSBzZXJ2ZXJTaWRlRW1pdCgpIGZ1bmN0aW9uYWxpdHlcIik7XG4gICAgfVxufVxuZXhwb3J0cy5BZGFwdGVyID0gQWRhcHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IGV4cG9ydHMuZGVjb25zdHJ1Y3RQYWNrZXQgPSB2b2lkIDA7XG5jb25zdCBpc19iaW5hcnlfMSA9IHJlcXVpcmUoXCIuL2lzLWJpbmFyeVwiKTtcbi8qKlxuICogUmVwbGFjZXMgZXZlcnkgQnVmZmVyIHwgQXJyYXlCdWZmZXIgfCBCbG9iIHwgRmlsZSBpbiBwYWNrZXQgd2l0aCBhIG51bWJlcmVkIHBsYWNlaG9sZGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBzb2NrZXQuaW8gZXZlbnQgcGFja2V0XG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggZGVjb25zdHJ1Y3RlZCBwYWNrZXQgYW5kIGxpc3Qgb2YgYnVmZmVyc1xuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvbnN0cnVjdFBhY2tldChwYWNrZXQpIHtcbiAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgY29uc3QgcGFja2V0RGF0YSA9IHBhY2tldC5kYXRhO1xuICAgIGNvbnN0IHBhY2sgPSBwYWNrZXQ7XG4gICAgcGFjay5kYXRhID0gX2RlY29uc3RydWN0UGFja2V0KHBhY2tldERhdGEsIGJ1ZmZlcnMpO1xuICAgIHBhY2suYXR0YWNobWVudHMgPSBidWZmZXJzLmxlbmd0aDsgLy8gbnVtYmVyIG9mIGJpbmFyeSAnYXR0YWNobWVudHMnXG4gICAgcmV0dXJuIHsgcGFja2V0OiBwYWNrLCBidWZmZXJzOiBidWZmZXJzIH07XG59XG5leHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gZGVjb25zdHJ1Y3RQYWNrZXQ7XG5mdW5jdGlvbiBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YSwgYnVmZmVycykge1xuICAgIGlmICghZGF0YSlcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgaWYgKGlzX2JpbmFyeV8xLmlzQmluYXJ5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IHBsYWNlaG9sZGVyID0geyBfcGxhY2Vob2xkZXI6IHRydWUsIG51bTogYnVmZmVycy5sZW5ndGggfTtcbiAgICAgICAgYnVmZmVycy5wdXNoKGRhdGEpO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IG5ldyBBcnJheShkYXRhLmxlbmd0aCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3RGF0YVtpXSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3RGF0YTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIGRhdGEgPT09IFwib2JqZWN0XCIgJiYgIShkYXRhIGluc3RhbmNlb2YgRGF0ZSkpIHtcbiAgICAgICAgY29uc3QgbmV3RGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgbmV3RGF0YVtrZXldID0gX2RlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBSZWNvbnN0cnVjdHMgYSBiaW5hcnkgcGFja2V0IGZyb20gaXRzIHBsYWNlaG9sZGVyIHBhY2tldCBhbmQgYnVmZmVyc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgLSBldmVudCBwYWNrZXQgd2l0aCBwbGFjZWhvbGRlcnNcbiAqIEBwYXJhbSB7QXJyYXl9IGJ1ZmZlcnMgLSBiaW5hcnkgYnVmZmVycyB0byBwdXQgaW4gcGxhY2Vob2xkZXIgcG9zaXRpb25zXG4gKiBAcmV0dXJuIHtPYmplY3R9IHJlY29uc3RydWN0ZWQgcGFja2V0XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHJlY29uc3RydWN0UGFja2V0KHBhY2tldCwgYnVmZmVycykge1xuICAgIHBhY2tldC5kYXRhID0gX3JlY29uc3RydWN0UGFja2V0KHBhY2tldC5kYXRhLCBidWZmZXJzKTtcbiAgICBwYWNrZXQuYXR0YWNobWVudHMgPSB1bmRlZmluZWQ7IC8vIG5vIGxvbmdlciB1c2VmdWxcbiAgICByZXR1cm4gcGFja2V0O1xufVxuZXhwb3J0cy5yZWNvbnN0cnVjdFBhY2tldCA9IHJlY29uc3RydWN0UGFja2V0O1xuZnVuY3Rpb24gX3JlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmIChkYXRhICYmIGRhdGEuX3BsYWNlaG9sZGVyKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJzW2RhdGEubnVtXTsgLy8gYXBwcm9wcmlhdGUgYnVmZmVyIChzaG91bGQgYmUgbmF0dXJhbCBvcmRlciBhbnl3YXkpXG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBkYXRhW2ldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFbaV0sIGJ1ZmZlcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICBkYXRhW2tleV0gPSBfcmVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtrZXldLCBidWZmZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5EZWNvZGVyID0gZXhwb3J0cy5FbmNvZGVyID0gZXhwb3J0cy5QYWNrZXRUeXBlID0gZXhwb3J0cy5wcm90b2NvbCA9IHZvaWQgMDtcbmNvbnN0IEVtaXR0ZXIgPSByZXF1aXJlKFwiY29tcG9uZW50LWVtaXR0ZXJcIik7XG5jb25zdCBiaW5hcnlfMSA9IHJlcXVpcmUoXCIuL2JpbmFyeVwiKTtcbmNvbnN0IGlzX2JpbmFyeV8xID0gcmVxdWlyZShcIi4vaXMtYmluYXJ5XCIpO1xuY29uc3QgZGVidWcgPSByZXF1aXJlKFwiZGVidWdcIikoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuLyoqXG4gKiBQcm90b2NvbCB2ZXJzaW9uLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZXhwb3J0cy5wcm90b2NvbCA9IDU7XG52YXIgUGFja2V0VHlwZTtcbihmdW5jdGlvbiAoUGFja2V0VHlwZSkge1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkNPTk5FQ1RcIl0gPSAwXSA9IFwiQ09OTkVDVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkRJU0NPTk5FQ1RcIl0gPSAxXSA9IFwiRElTQ09OTkVDVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkVWRU5UXCJdID0gMl0gPSBcIkVWRU5UXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQUNLXCJdID0gM10gPSBcIkFDS1wiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkNPTk5FQ1RfRVJST1JcIl0gPSA0XSA9IFwiQ09OTkVDVF9FUlJPUlwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkJJTkFSWV9FVkVOVFwiXSA9IDVdID0gXCJCSU5BUllfRVZFTlRcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJCSU5BUllfQUNLXCJdID0gNl0gPSBcIkJJTkFSWV9BQ0tcIjtcbn0pKFBhY2tldFR5cGUgPSBleHBvcnRzLlBhY2tldFR5cGUgfHwgKGV4cG9ydHMuUGFja2V0VHlwZSA9IHt9KSk7XG4vKipcbiAqIEEgc29ja2V0LmlvIEVuY29kZXIgaW5zdGFuY2VcbiAqL1xuY2xhc3MgRW5jb2RlciB7XG4gICAgLyoqXG4gICAgICogRW5jb2RlIGEgcGFja2V0IGFzIGEgc2luZ2xlIHN0cmluZyBpZiBub24tYmluYXJ5LCBvciBhcyBhXG4gICAgICogYnVmZmVyIHNlcXVlbmNlLCBkZXBlbmRpbmcgb24gcGFja2V0IHR5cGUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqIC0gcGFja2V0IG9iamVjdFxuICAgICAqL1xuICAgIGVuY29kZShvYmopIHtcbiAgICAgICAgZGVidWcoXCJlbmNvZGluZyBwYWNrZXQgJWpcIiwgb2JqKTtcbiAgICAgICAgaWYgKG9iai50eXBlID09PSBQYWNrZXRUeXBlLkVWRU5UIHx8IG9iai50eXBlID09PSBQYWNrZXRUeXBlLkFDSykge1xuICAgICAgICAgICAgaWYgKGlzX2JpbmFyeV8xLmhhc0JpbmFyeShvYmopKSB7XG4gICAgICAgICAgICAgICAgb2JqLnR5cGUgPVxuICAgICAgICAgICAgICAgICAgICBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5FVkVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgPyBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVFxuICAgICAgICAgICAgICAgICAgICAgICAgOiBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlQXNCaW5hcnkob2JqKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gW3RoaXMuZW5jb2RlQXNTdHJpbmcob2JqKV07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBwYWNrZXQgYXMgc3RyaW5nLlxuICAgICAqL1xuICAgIGVuY29kZUFzU3RyaW5nKG9iaikge1xuICAgICAgICAvLyBmaXJzdCBpcyB0eXBlXG4gICAgICAgIGxldCBzdHIgPSBcIlwiICsgb2JqLnR5cGU7XG4gICAgICAgIC8vIGF0dGFjaG1lbnRzIGlmIHdlIGhhdmUgdGhlbVxuICAgICAgICBpZiAob2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5CSU5BUllfQUNLKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLmF0dGFjaG1lbnRzICsgXCItXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaWYgd2UgaGF2ZSBhIG5hbWVzcGFjZSBvdGhlciB0aGFuIGAvYFxuICAgICAgICAvLyB3ZSBhcHBlbmQgaXQgZm9sbG93ZWQgYnkgYSBjb21tYSBgLGBcbiAgICAgICAgaWYgKG9iai5uc3AgJiYgXCIvXCIgIT09IG9iai5uc3ApIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmoubnNwICsgXCIsXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgdGhlIGlkXG4gICAgICAgIGlmIChudWxsICE9IG9iai5pZCkge1xuICAgICAgICAgICAgc3RyICs9IG9iai5pZDtcbiAgICAgICAgfVxuICAgICAgICAvLyBqc29uIGRhdGFcbiAgICAgICAgaWYgKG51bGwgIT0gb2JqLmRhdGEpIHtcbiAgICAgICAgICAgIHN0ciArPSBKU09OLnN0cmluZ2lmeShvYmouZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJlbmNvZGVkICVqIGFzICVzXCIsIG9iaiwgc3RyKTtcbiAgICAgICAgcmV0dXJuIHN0cjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW5jb2RlIHBhY2tldCBhcyAnYnVmZmVyIHNlcXVlbmNlJyBieSByZW1vdmluZyBibG9icywgYW5kXG4gICAgICogZGVjb25zdHJ1Y3RpbmcgcGFja2V0IGludG8gb2JqZWN0IHdpdGggcGxhY2Vob2xkZXJzIGFuZFxuICAgICAqIGEgbGlzdCBvZiBidWZmZXJzLlxuICAgICAqL1xuICAgIGVuY29kZUFzQmluYXJ5KG9iaikge1xuICAgICAgICBjb25zdCBkZWNvbnN0cnVjdGlvbiA9IGJpbmFyeV8xLmRlY29uc3RydWN0UGFja2V0KG9iaik7XG4gICAgICAgIGNvbnN0IHBhY2sgPSB0aGlzLmVuY29kZUFzU3RyaW5nKGRlY29uc3RydWN0aW9uLnBhY2tldCk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBkZWNvbnN0cnVjdGlvbi5idWZmZXJzO1xuICAgICAgICBidWZmZXJzLnVuc2hpZnQocGFjayk7IC8vIGFkZCBwYWNrZXQgaW5mbyB0byBiZWdpbm5pbmcgb2YgZGF0YSBsaXN0XG4gICAgICAgIHJldHVybiBidWZmZXJzOyAvLyB3cml0ZSBhbGwgdGhlIGJ1ZmZlcnNcbiAgICB9XG59XG5leHBvcnRzLkVuY29kZXIgPSBFbmNvZGVyO1xuLyoqXG4gKiBBIHNvY2tldC5pbyBEZWNvZGVyIGluc3RhbmNlXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSBkZWNvZGVyXG4gKi9cbmNsYXNzIERlY29kZXIgZXh0ZW5kcyBFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVjb2RlcyBhbiBlbmNvZGVkIHBhY2tldCBzdHJpbmcgaW50byBwYWNrZXQgSlNPTi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBvYmogLSBlbmNvZGVkIHBhY2tldFxuICAgICAqL1xuICAgIGFkZChvYmopIHtcbiAgICAgICAgbGV0IHBhY2tldDtcbiAgICAgICAgaWYgKHR5cGVvZiBvYmogPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHBhY2tldCA9IHRoaXMuZGVjb2RlU3RyaW5nKG9iaik7XG4gICAgICAgICAgICBpZiAocGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICAgICAgcGFja2V0LnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgICAgIC8vIGJpbmFyeSBwYWNrZXQncyBqc29uXG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbmV3IEJpbmFyeVJlY29uc3RydWN0b3IocGFja2V0KTtcbiAgICAgICAgICAgICAgICAvLyBubyBhdHRhY2htZW50cywgbGFiZWxlZCBiaW5hcnkgYnV0IG5vIGJpbmFyeSBkYXRhIHRvIGZvbGxvd1xuICAgICAgICAgICAgICAgIGlmIChwYWNrZXQuYXR0YWNobWVudHMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBub24tYmluYXJ5IGZ1bGwgcGFja2V0XG4gICAgICAgICAgICAgICAgc3VwZXIuZW1pdChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc19iaW5hcnlfMS5pc0JpbmFyeShvYmopIHx8IG9iai5iYXNlNjQpIHtcbiAgICAgICAgICAgIC8vIHJhdyBiaW5hcnkgZGF0YVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJnb3QgYmluYXJ5IGRhdGEgd2hlbiBub3QgcmVjb25zdHJ1Y3RpbmcgYSBwYWNrZXRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBwYWNrZXQgPSB0aGlzLnJlY29uc3RydWN0b3IudGFrZUJpbmFyeURhdGEob2JqKTtcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHJlY2VpdmVkIGZpbmFsIGJ1ZmZlclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0KFwiZGVjb2RlZFwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gdHlwZTogXCIgKyBvYmopO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZSBhIHBhY2tldCBTdHJpbmcgKEpTT04gZGF0YSlcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAgICAgKiBAcmV0dXJuIHtPYmplY3R9IHBhY2tldFxuICAgICAqL1xuICAgIGRlY29kZVN0cmluZyhzdHIpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAvLyBsb29rIHVwIHR5cGVcbiAgICAgICAgY29uc3QgcCA9IHtcbiAgICAgICAgICAgIHR5cGU6IE51bWJlcihzdHIuY2hhckF0KDApKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFBhY2tldFR5cGVbcC50eXBlXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHBhY2tldCB0eXBlIFwiICsgcC50eXBlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGF0dGFjaG1lbnRzIGlmIHR5cGUgYmluYXJ5XG4gICAgICAgIGlmIChwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0VWRU5UIHx8XG4gICAgICAgICAgICBwLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgY29uc3Qgc3RhcnQgPSBpICsgMTtcbiAgICAgICAgICAgIHdoaWxlIChzdHIuY2hhckF0KCsraSkgIT09IFwiLVwiICYmIGkgIT0gc3RyLmxlbmd0aCkgeyB9XG4gICAgICAgICAgICBjb25zdCBidWYgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgICAgIGlmIChidWYgIT0gTnVtYmVyKGJ1ZikgfHwgc3RyLmNoYXJBdChpKSAhPT0gXCItXCIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbGxlZ2FsIGF0dGFjaG1lbnRzXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5hdHRhY2htZW50cyA9IE51bWJlcihidWYpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAgbmFtZXNwYWNlIChpZiBhbnkpXG4gICAgICAgIGlmIChcIi9cIiA9PT0gc3RyLmNoYXJBdChpICsgMSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKFwiLFwiID09PSBjKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLm5zcCA9IHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcC5uc3AgPSBcIi9cIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIGlkXG4gICAgICAgIGNvbnN0IG5leHQgPSBzdHIuY2hhckF0KGkgKyAxKTtcbiAgICAgICAgaWYgKFwiXCIgIT09IG5leHQgJiYgTnVtYmVyKG5leHQpID09IG5leHQpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYyA9IHN0ci5jaGFyQXQoaSk7XG4gICAgICAgICAgICAgICAgaWYgKG51bGwgPT0gYyB8fCBOdW1iZXIoYykgIT0gYykge1xuICAgICAgICAgICAgICAgICAgICAtLWk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoaSA9PT0gc3RyLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwLmlkID0gTnVtYmVyKHN0ci5zdWJzdHJpbmcoc3RhcnQsIGkgKyAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBqc29uIGRhdGFcbiAgICAgICAgaWYgKHN0ci5jaGFyQXQoKytpKSkge1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IHRyeVBhcnNlKHN0ci5zdWJzdHIoaSkpO1xuICAgICAgICAgICAgaWYgKERlY29kZXIuaXNQYXlsb2FkVmFsaWQocC50eXBlLCBwYXlsb2FkKSkge1xuICAgICAgICAgICAgICAgIHAuZGF0YSA9IHBheWxvYWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBheWxvYWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJkZWNvZGVkICVzIGFzICVqXCIsIHN0ciwgcCk7XG4gICAgICAgIHJldHVybiBwO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQYXlsb2FkVmFsaWQodHlwZSwgcGF5bG9hZCkge1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5DT05ORUNUOlxuICAgICAgICAgICAgICAgIHJldHVybiB0eXBlb2YgcGF5bG9hZCA9PT0gXCJvYmplY3RcIjtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHJldHVybiBwYXlsb2FkID09PSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgPT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCI7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRVZFTlQ6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0VWRU5UOlxuICAgICAgICAgICAgICAgIHJldHVybiBBcnJheS5pc0FycmF5KHBheWxvYWQpICYmIHBheWxvYWQubGVuZ3RoID4gMDtcbiAgICAgICAgICAgIGNhc2UgUGFja2V0VHlwZS5BQ0s6XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWFsbG9jYXRlcyBhIHBhcnNlcidzIHJlc291cmNlc1xuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY29uc3RydWN0b3IpIHtcbiAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3Rvci5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkRlY29kZXIgPSBEZWNvZGVyO1xuZnVuY3Rpb24gdHJ5UGFyc2Uoc3RyKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2Uoc3RyKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICogQSBtYW5hZ2VyIG9mIGEgYmluYXJ5IGV2ZW50J3MgJ2J1ZmZlciBzZXF1ZW5jZScuIFNob3VsZFxuICogYmUgY29uc3RydWN0ZWQgd2hlbmV2ZXIgYSBwYWNrZXQgb2YgdHlwZSBCSU5BUllfRVZFTlQgaXNcbiAqIGRlY29kZWQuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICogQHJldHVybiB7QmluYXJ5UmVjb25zdHJ1Y3Rvcn0gaW5pdGlhbGl6ZWQgcmVjb25zdHJ1Y3RvclxuICovXG5jbGFzcyBCaW5hcnlSZWNvbnN0cnVjdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihwYWNrZXQpIHtcbiAgICAgICAgdGhpcy5wYWNrZXQgPSBwYWNrZXQ7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IHBhY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGJlIGNhbGxlZCB3aGVuIGJpbmFyeSBkYXRhIHJlY2VpdmVkIGZyb20gY29ubmVjdGlvblxuICAgICAqIGFmdGVyIGEgQklOQVJZX0VWRU5UIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QnVmZmVyIHwgQXJyYXlCdWZmZXJ9IGJpbkRhdGEgLSB0aGUgcmF3IGJpbmFyeSBkYXRhIHJlY2VpdmVkXG4gICAgICogQHJldHVybiB7bnVsbCB8IE9iamVjdH0gcmV0dXJucyBudWxsIGlmIG1vcmUgYmluYXJ5IGRhdGEgaXMgZXhwZWN0ZWQgb3JcbiAgICAgKiAgIGEgcmVjb25zdHJ1Y3RlZCBwYWNrZXQgb2JqZWN0IGlmIGFsbCBidWZmZXJzIGhhdmUgYmVlbiByZWNlaXZlZC5cbiAgICAgKi9cbiAgICB0YWtlQmluYXJ5RGF0YShiaW5EYXRhKSB7XG4gICAgICAgIHRoaXMuYnVmZmVycy5wdXNoKGJpbkRhdGEpO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJzLmxlbmd0aCA9PT0gdGhpcy5yZWNvblBhY2suYXR0YWNobWVudHMpIHtcbiAgICAgICAgICAgIC8vIGRvbmUgd2l0aCBidWZmZXIgbGlzdFxuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0gYmluYXJ5XzEucmVjb25zdHJ1Y3RQYWNrZXQodGhpcy5yZWNvblBhY2ssIHRoaXMuYnVmZmVycyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24oKTtcbiAgICAgICAgICAgIHJldHVybiBwYWNrZXQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFucyB1cCBiaW5hcnkgcGFja2V0IHJlY29uc3RydWN0aW9uIHZhcmlhYmxlcy5cbiAgICAgKi9cbiAgICBmaW5pc2hlZFJlY29uc3RydWN0aW9uKCkge1xuICAgICAgICB0aGlzLnJlY29uUGFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuYnVmZmVycyA9IFtdO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5oYXNCaW5hcnkgPSBleHBvcnRzLmlzQmluYXJ5ID0gdm9pZCAwO1xuY29uc3Qgd2l0aE5hdGl2ZUFycmF5QnVmZmVyID0gdHlwZW9mIEFycmF5QnVmZmVyID09PSBcImZ1bmN0aW9uXCI7XG5jb25zdCBpc1ZpZXcgPSAob2JqKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICA/IEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG4gICAgICAgIDogb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmNvbnN0IHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcbmNvbnN0IHdpdGhOYXRpdmVCbG9iID0gdHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiKTtcbmNvbnN0IHdpdGhOYXRpdmVGaWxlID0gdHlwZW9mIEZpbGUgPT09IFwiZnVuY3Rpb25cIiB8fFxuICAgICh0eXBlb2YgRmlsZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgICB0b1N0cmluZy5jYWxsKEZpbGUpID09PSBcIltvYmplY3QgRmlsZUNvbnN0cnVjdG9yXVwiKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG9iaiBpcyBhIEJ1ZmZlciwgYW4gQXJyYXlCdWZmZXIsIGEgQmxvYiBvciBhIEZpbGUuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCaW5hcnkob2JqKSB7XG4gICAgcmV0dXJuICgod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmIChvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcob2JqKSkpIHx8XG4gICAgICAgICh3aXRoTmF0aXZlQmxvYiAmJiBvYmogaW5zdGFuY2VvZiBCbG9iKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUZpbGUgJiYgb2JqIGluc3RhbmNlb2YgRmlsZSkpO1xufVxuZXhwb3J0cy5pc0JpbmFyeSA9IGlzQmluYXJ5O1xuZnVuY3Rpb24gaGFzQmluYXJ5KG9iaiwgdG9KU09OKSB7XG4gICAgaWYgKCFvYmogfHwgdHlwZW9mIG9iaiAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaGFzQmluYXJ5KG9ialtpXSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpc0JpbmFyeShvYmopKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAob2JqLnRvSlNPTiAmJlxuICAgICAgICB0eXBlb2Ygb2JqLnRvSlNPTiA9PT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIGhhc0JpbmFyeShvYmoudG9KU09OKCksIHRydWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkgJiYgaGFzQmluYXJ5KG9ialtrZXldKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5oYXNCaW5hcnkgPSBoYXNCaW5hcnk7XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBkZWJ1ZyBpbnN0YW5jZSB0byBiZSBjb2xvcmVkXG5cdCogQHJldHVybiB7TnVtYmVyfFN0cmluZ30gQW4gQU5TSSBjb2xvciBjb2RlIGZvciB0aGUgZ2l2ZW4gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHNlbGVjdENvbG9yKG5hbWVzcGFjZSkge1xuXHRcdGxldCBoYXNoID0gMDtcblxuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXNwYWNlLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcblx0XHRcdGhhc2ggfD0gMDsgLy8gQ29udmVydCB0byAzMmJpdCBpbnRlZ2VyXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNyZWF0ZURlYnVnLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGNyZWF0ZURlYnVnLmNvbG9ycy5sZW5ndGhdO1xuXHR9XG5cdGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yID0gc2VsZWN0Q29sb3I7XG5cblx0LyoqXG5cdCogQ3JlYXRlIGEgZGVidWdnZXIgd2l0aCB0aGUgZ2l2ZW4gYG5hbWVzcGFjZWAuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQHJldHVybiB7RnVuY3Rpb259XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XG5cdFx0bGV0IHByZXZUaW1lO1xuXHRcdGxldCBlbmFibGVPdmVycmlkZSA9IG51bGw7XG5cdFx0bGV0IG5hbWVzcGFjZXNDYWNoZTtcblx0XHRsZXQgZW5hYmxlZENhY2hlO1xuXG5cdFx0ZnVuY3Rpb24gZGVidWcoLi4uYXJncykge1xuXHRcdFx0Ly8gRGlzYWJsZWQ/XG5cdFx0XHRpZiAoIWRlYnVnLmVuYWJsZWQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCBzZWxmID0gZGVidWc7XG5cblx0XHRcdC8vIFNldCBgZGlmZmAgdGltZXN0YW1wXG5cdFx0XHRjb25zdCBjdXJyID0gTnVtYmVyKG5ldyBEYXRlKCkpO1xuXHRcdFx0Y29uc3QgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xuXHRcdFx0c2VsZi5kaWZmID0gbXM7XG5cdFx0XHRzZWxmLnByZXYgPSBwcmV2VGltZTtcblx0XHRcdHNlbGYuY3VyciA9IGN1cnI7XG5cdFx0XHRwcmV2VGltZSA9IGN1cnI7XG5cblx0XHRcdGFyZ3NbMF0gPSBjcmVhdGVEZWJ1Zy5jb2VyY2UoYXJnc1swXSk7XG5cblx0XHRcdGlmICh0eXBlb2YgYXJnc1swXSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdFx0Ly8gQW55dGhpbmcgZWxzZSBsZXQncyBpbnNwZWN0IHdpdGggJU9cblx0XHRcdFx0YXJncy51bnNoaWZ0KCclTycpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xuXHRcdFx0bGV0IGluZGV4ID0gMDtcblx0XHRcdGFyZ3NbMF0gPSBhcmdzWzBdLnJlcGxhY2UoLyUoW2EtekEtWiVdKS9nLCAobWF0Y2gsIGZvcm1hdCkgPT4ge1xuXHRcdFx0XHQvLyBJZiB3ZSBlbmNvdW50ZXIgYW4gZXNjYXBlZCAlIHRoZW4gZG9uJ3QgaW5jcmVhc2UgdGhlIGFycmF5IGluZGV4XG5cdFx0XHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0XHRcdHJldHVybiAnJSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aW5kZXgrKztcblx0XHRcdFx0Y29uc3QgZm9ybWF0dGVyID0gY3JlYXRlRGVidWcuZm9ybWF0dGVyc1tmb3JtYXRdO1xuXHRcdFx0XHRpZiAodHlwZW9mIGZvcm1hdHRlciA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGFyZ3NbaW5kZXhdO1xuXHRcdFx0XHRcdG1hdGNoID0gZm9ybWF0dGVyLmNhbGwoc2VsZiwgdmFsKTtcblxuXHRcdFx0XHRcdC8vIE5vdyB3ZSBuZWVkIHRvIHJlbW92ZSBgYXJnc1tpbmRleF1gIHNpbmNlIGl0J3MgaW5saW5lZCBpbiB0aGUgYGZvcm1hdGBcblx0XHRcdFx0XHRhcmdzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0XHR9KTtcblxuXHRcdFx0Ly8gQXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcblx0XHRcdGNyZWF0ZURlYnVnLmZvcm1hdEFyZ3MuY2FsbChzZWxmLCBhcmdzKTtcblxuXHRcdFx0Y29uc3QgbG9nRm4gPSBzZWxmLmxvZyB8fCBjcmVhdGVEZWJ1Zy5sb2c7XG5cdFx0XHRsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcblx0XHR9XG5cblx0XHRkZWJ1Zy5uYW1lc3BhY2UgPSBuYW1lc3BhY2U7XG5cdFx0ZGVidWcudXNlQ29sb3JzID0gY3JlYXRlRGVidWcudXNlQ29sb3JzKCk7XG5cdFx0ZGVidWcuY29sb3IgPSBjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvcihuYW1lc3BhY2UpO1xuXHRcdGRlYnVnLmV4dGVuZCA9IGV4dGVuZDtcblx0XHRkZWJ1Zy5kZXN0cm95ID0gY3JlYXRlRGVidWcuZGVzdHJveTsgLy8gWFhYIFRlbXBvcmFyeS4gV2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZGVidWcsICdlbmFibGVkJywge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG5cdFx0XHRnZXQ6ICgpID0+IHtcblx0XHRcdFx0aWYgKGVuYWJsZU92ZXJyaWRlICE9PSBudWxsKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVuYWJsZU92ZXJyaWRlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChuYW1lc3BhY2VzQ2FjaGUgIT09IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMpIHtcblx0XHRcdFx0XHRuYW1lc3BhY2VzQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzO1xuXHRcdFx0XHRcdGVuYWJsZWRDYWNoZSA9IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbmFibGVkQ2FjaGU7XG5cdFx0XHR9LFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXHRcdGNyZWF0ZURlYnVnLm5hbWVzcGFjZXMgPSBuYW1lc3BhY2VzO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc2xpY2UoMSkgKyAnJCcpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLm5hbWVzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzICsgJyQnKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0LyoqXG5cdCogRGlzYWJsZSBkZWJ1ZyBvdXRwdXQuXG5cdCpcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBkaXNhYmxlKCkge1xuXHRcdGNvbnN0IG5hbWVzcGFjZXMgPSBbXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5uYW1lcy5tYXAodG9OYW1lc3BhY2UpLFxuXHRcdFx0Li4uY3JlYXRlRGVidWcuc2tpcHMubWFwKHRvTmFtZXNwYWNlKS5tYXAobmFtZXNwYWNlID0+ICctJyArIG5hbWVzcGFjZSlcblx0XHRdLmpvaW4oJywnKTtcblx0XHRjcmVhdGVEZWJ1Zy5lbmFibGUoJycpO1xuXHRcdHJldHVybiBuYW1lc3BhY2VzO1xuXHR9XG5cblx0LyoqXG5cdCogUmV0dXJucyB0cnVlIGlmIHRoZSBnaXZlbiBtb2RlIG5hbWUgaXMgZW5hYmxlZCwgZmFsc2Ugb3RoZXJ3aXNlLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVcblx0KiBAcmV0dXJuIHtCb29sZWFufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZWQobmFtZSkge1xuXHRcdGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0bGV0IGk7XG5cdFx0bGV0IGxlbjtcblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcuc2tpcHNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5uYW1lc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8qKlxuXHQqIENvbnZlcnQgcmVnZXhwIHRvIG5hbWVzcGFjZVxuXHQqXG5cdCogQHBhcmFtIHtSZWdFeHB9IHJlZ3hlcFxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlXG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIHRvTmFtZXNwYWNlKHJlZ2V4cCkge1xuXHRcdHJldHVybiByZWdleHAudG9TdHJpbmcoKVxuXHRcdFx0LnN1YnN0cmluZygyLCByZWdleHAudG9TdHJpbmcoKS5sZW5ndGggLSAyKVxuXHRcdFx0LnJlcGxhY2UoL1xcLlxcKlxcPyQvLCAnKicpO1xuXHR9XG5cblx0LyoqXG5cdCogQ29lcmNlIGB2YWxgLlxuXHQqXG5cdCogQHBhcmFtIHtNaXhlZH0gdmFsXG5cdCogQHJldHVybiB7TWl4ZWR9XG5cdCogQGFwaSBwcml2YXRlXG5cdCovXG5cdGZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcblx0XHRpZiAodmFsIGluc3RhbmNlb2YgRXJyb3IpIHtcblx0XHRcdHJldHVybiB2YWwuc3RhY2sgfHwgdmFsLm1lc3NhZ2U7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cblxuXHQvKipcblx0KiBYWFggRE8gTk9UIFVTRS4gVGhpcyBpcyBhIHRlbXBvcmFyeSBzdHViIGZ1bmN0aW9uLlxuXHQqIFhYWCBJdCBXSUxMIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblx0Ki9cblx0ZnVuY3Rpb24gZGVzdHJveSgpIHtcblx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0fVxuXG5cdGNyZWF0ZURlYnVnLmVuYWJsZShjcmVhdGVEZWJ1Zy5sb2FkKCkpO1xuXG5cdHJldHVybiBjcmVhdGVEZWJ1Zztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzZXR1cDtcbiIsIi8qKlxuICogSGVscGVycy5cbiAqL1xuXG52YXIgcyA9IDEwMDA7XG52YXIgbSA9IHMgKiA2MDtcbnZhciBoID0gbSAqIDYwO1xudmFyIGQgPSBoICogMjQ7XG52YXIgdyA9IGQgKiA3O1xudmFyIHkgPSBkICogMzY1LjI1O1xuXG4vKipcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXG4gKlxuICogT3B0aW9uczpcbiAqXG4gKiAgLSBgbG9uZ2AgdmVyYm9zZSBmb3JtYXR0aW5nIFtmYWxzZV1cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIHZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgbnVtYmVyXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKHZhbCwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xuICBpZiAodHlwZSA9PT0gJ3N0cmluZycgJiYgdmFsLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcGFyc2UodmFsKTtcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc0Zpbml0ZSh2YWwpKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMubG9uZyA/IGZtdExvbmcodmFsKSA6IGZtdFNob3J0KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFxuICAgICd2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIHZhbGlkIG51bWJlci4gdmFsPScgK1xuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxuICApO1xufTtcblxuLyoqXG4gKiBQYXJzZSB0aGUgZ2l2ZW4gYHN0cmAgYW5kIHJldHVybiBtaWxsaXNlY29uZHMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0clxuICogQHJldHVybiB7TnVtYmVyfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XG4gIHN0ciA9IFN0cmluZyhzdHIpO1xuICBpZiAoc3RyLmxlbmd0aCA+IDEwMCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbWF0Y2ggPSAvXigtPyg/OlxcZCspP1xcLj9cXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8d2Vla3M/fHd8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXG4gICAgc3RyXG4gICk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAneWVhcnMnOlxuICAgIGNhc2UgJ3llYXInOlxuICAgIGNhc2UgJ3lycyc6XG4gICAgY2FzZSAneXInOlxuICAgIGNhc2UgJ3knOlxuICAgICAgcmV0dXJuIG4gKiB5O1xuICAgIGNhc2UgJ3dlZWtzJzpcbiAgICBjYXNlICd3ZWVrJzpcbiAgICBjYXNlICd3JzpcbiAgICAgIHJldHVybiBuICogdztcbiAgICBjYXNlICdkYXlzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2QnOlxuICAgICAgcmV0dXJuIG4gKiBkO1xuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdob3VyJzpcbiAgICBjYXNlICdocnMnOlxuICAgIGNhc2UgJ2hyJzpcbiAgICBjYXNlICdoJzpcbiAgICAgIHJldHVybiBuICogaDtcbiAgICBjYXNlICdtaW51dGVzJzpcbiAgICBjYXNlICdtaW51dGUnOlxuICAgIGNhc2UgJ21pbnMnOlxuICAgIGNhc2UgJ21pbic6XG4gICAgY2FzZSAnbSc6XG4gICAgICByZXR1cm4gbiAqIG07XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnc2Vjb25kJzpcbiAgICBjYXNlICdzZWNzJzpcbiAgICBjYXNlICdzZWMnOlxuICAgIGNhc2UgJ3MnOlxuICAgICAgcmV0dXJuIG4gKiBzO1xuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XG4gICAgY2FzZSAnbWlsbGlzZWNvbmQnOlxuICAgIGNhc2UgJ21zZWNzJzpcbiAgICBjYXNlICdtc2VjJzpcbiAgICBjYXNlICdtcyc6XG4gICAgICByZXR1cm4gbjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufVxuXG4vKipcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdFNob3J0KG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGQpICsgJ2QnO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBoKSArICdoJztcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbSkgKyAnbSc7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIHMpICsgJ3MnO1xuICB9XG4gIHJldHVybiBtcyArICdtcyc7XG59XG5cbi8qKlxuICogTG9uZyBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRMb25nKG1zKSB7XG4gIHZhciBtc0FicyA9IE1hdGguYWJzKG1zKTtcbiAgaWYgKG1zQWJzID49IGQpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgZCwgJ2RheScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBoKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGgsICdob3VyJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgbSwgJ21pbnV0ZScpO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIHMsICdzZWNvbmQnKTtcbiAgfVxuICByZXR1cm4gbXMgKyAnIG1zJztcbn1cblxuLyoqXG4gKiBQbHVyYWxpemF0aW9uIGhlbHBlci5cbiAqL1xuXG5mdW5jdGlvbiBwbHVyYWwobXMsIG1zQWJzLCBuLCBuYW1lKSB7XG4gIHZhciBpc1BsdXJhbCA9IG1zQWJzID49IG4gKiAxLjU7XG4gIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gbikgKyAnICcgKyBuYW1lICsgKGlzUGx1cmFsID8gJ3MnIDogJycpO1xufVxuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9yZXNwb25zZScpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQ2xpZW50UmVxdWVzdCA9IENsaWVudFJlcXVlc3Rcbmh0dHAuSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5nbG9iYWxBZ2VudCA9IG5ldyBodHRwLkFnZW50KClcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZVN0cmVhbSlcblxuZXhwb3J0cy53cml0YWJsZVN0cmVhbSA9IGlzRnVuY3Rpb24oZ2xvYmFsLldyaXRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLmFib3J0Q29udHJvbGxlciA9IGlzRnVuY3Rpb24oZ2xvYmFsLkFib3J0Q29udHJvbGxlcilcblxuLy8gVGhlIHhociByZXF1ZXN0IHRvIGV4YW1wbGUuY29tIG1heSB2aW9sYXRlIHNvbWUgcmVzdHJpY3RpdmUgQ1NQIGNvbmZpZ3VyYXRpb25zLFxuLy8gc28gaWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBgZmV0Y2hgLCBhdm9pZCBjYWxsaW5nIGdldFhIUigpXG4vLyBhbmQgYXNzdW1lIHN1cHBvcnQgZm9yIGNlcnRhaW4gZmVhdHVyZXMgYmVsb3cuXG52YXIgeGhyXG5mdW5jdGlvbiBnZXRYSFIgKCkge1xuXHQvLyBDYWNoZSB0aGUgeGhyIHZhbHVlXG5cdGlmICh4aHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHhoclxuXG5cdGlmIChnbG9iYWwuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHR4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHQvLyBJZiBYRG9tYWluUmVxdWVzdCBpcyBhdmFpbGFibGUgKGllIG9ubHksIHdoZXJlIHhociBtaWdodCBub3Qgd29ya1xuXHRcdC8vIGNyb3NzIGRvbWFpbiksIHVzZSB0aGUgcGFnZSBsb2NhdGlvbi4gT3RoZXJ3aXNlIHVzZSBleGFtcGxlLmNvbVxuXHRcdC8vIE5vdGU6IHRoaXMgZG9lc24ndCBhY3R1YWxseSBtYWtlIGFuIGh0dHAgcmVxdWVzdC5cblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5YRG9tYWluUmVxdWVzdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHhociA9IG51bGxcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VydmljZSB3b3JrZXJzIGRvbid0IGhhdmUgWEhSXG5cdFx0eGhyID0gbnVsbFxuXHR9XG5cdHJldHVybiB4aHJcbn1cblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR2YXIgeGhyID0gZ2V0WEhSKClcblx0aWYgKCF4aHIpIHJldHVybiBmYWxzZVxuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIElmIGZldGNoIGlzIHN1cHBvcnRlZCwgdGhlbiBhcnJheWJ1ZmZlciB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gY2hlY2tUeXBlU3VwcG9ydCgpLCBzaW5jZSB0aGF0IGNhbGxzIGdldFhIUigpLlxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGV4cG9ydHMuZmV0Y2ggfHwgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gb3ZlcnJpZGVNaW1lVHlwZSB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gZ2V0WEhSKCkuXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBleHBvcnRzLmZldGNoIHx8IChnZXRYSFIoKSA/IGlzRnVuY3Rpb24oZ2V0WEhSKCkub3ZlcnJpZGVNaW1lVHlwZSkgOiBmYWxzZSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRzZWxmLl9vbkZpbmlzaCgpXG5cdH0pXG59XG5cbmluaGVyaXRzKENsaWVudFJlcXVlc3QsIHN0cmVhbS5Xcml0YWJsZSlcblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHR2YXIgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cdC8vIFRoaXMgY2hlY2sgaXMgbm90IG5lY2Vzc2FyeSwgYnV0IGl0IHByZXZlbnRzIHdhcm5pbmdzIGZyb20gYnJvd3NlcnMgYWJvdXQgc2V0dGluZyB1bnNhZmVcblx0Ly8gaGVhZGVycy4gVG8gYmUgaG9uZXN0IEknbSBub3QgZW50aXJlbHkgc3VyZSBoaWRpbmcgdGhlc2Ugd2FybmluZ3MgaXMgYSBnb29kIHRoaW5nLCBidXRcblx0Ly8gaHR0cC1icm93c2VyaWZ5IGRpZCBpdCwgc28gSSB3aWxsIHRvby5cblx0aWYgKHVuc2FmZUhlYWRlcnMuaW5kZXhPZihsb3dlck5hbWUpICE9PSAtMSlcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9oZWFkZXJzW2xvd2VyTmFtZV0gPSB7XG5cdFx0bmFtZTogbmFtZSxcblx0XHR2YWx1ZTogdmFsdWVcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgaGVhZGVyID0gdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG5cdGlmIChoZWFkZXIpXG5cdFx0cmV0dXJuIGhlYWRlci52YWx1ZVxuXHRyZXR1cm4gbnVsbFxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0ZGVsZXRlIHNlbGYuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cdHZhciBvcHRzID0gc2VsZi5fb3B0c1xuXG5cdGlmICgndGltZW91dCcgaW4gb3B0cyAmJiBvcHRzLnRpbWVvdXQgIT09IDApIHtcblx0XHRzZWxmLnNldFRpbWVvdXQob3B0cy50aW1lb3V0KVxuXHR9XG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCbG9iKHNlbGYuX2JvZHksIHtcbiAgICAgICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cdC8vIGNyZWF0ZSBmbGF0dGVuZWQgbGlzdCBvZiBoZWFkZXJzXG5cdHZhciBoZWFkZXJzTGlzdCA9IFtdXG5cdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKGtleU5hbWUpIHtcblx0XHR2YXIgbmFtZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0ubmFtZVxuXHRcdHZhciB2YWx1ZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0udmFsdWVcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdl0pXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2YWx1ZV0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIHNpZ25hbCA9IG51bGxcblx0XHRpZiAoY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpIHtcblx0XHRcdHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cdFx0XHRzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuXHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIgPSBjb250cm9sbGVyXG5cblx0XHRcdGlmICgncmVxdWVzdFRpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy5yZXF1ZXN0VGltZW91dCAhPT0gMCkge1xuXHRcdFx0XHRzZWxmLl9mZXRjaFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0XHRcdGlmIChzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlcilcblx0XHRcdFx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblx0XHRcdFx0fSwgb3B0cy5yZXF1ZXN0VGltZW91dClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzTGlzdCxcblx0XHRcdGJvZHk6IGJvZHkgfHwgdW5kZWZpbmVkLFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHNpZ25hbDogc2lnbmFsXG5cdFx0fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXHRcdFx0c2VsZi5fcmVzZXRUaW1lcnMoZmFsc2UpXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9yZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzKSB7XG5cdFx0XHR4aHIudGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXRcblx0XHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlYWRlcnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuX3Jlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcyhzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlLCBzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxuXHRzZWxmLl9yZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcblx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHR9KVxuXG5cdHNlbGYuZW1pdCgncmVzcG9uc2UnLCBzZWxmLl9yZXNwb25zZSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0c2VsZi5fYm9keS5wdXNoKGNodW5rKVxuXHRjYigpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9yZXNldFRpbWVycyA9IGZ1bmN0aW9uIChkb25lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fc29ja2V0VGltZXIpXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdGlmIChkb25lKSB7XG5cdFx0Z2xvYmFsLmNsZWFyVGltZW91dChzZWxmLl9mZXRjaFRpbWVyKVxuXHRcdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdH0gZWxzZSBpZiAoc2VsZi5fc29ja2V0VGltZW91dCkge1xuXHRcdHNlbGYuX3NvY2tldFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCd0aW1lb3V0Jylcblx0XHR9LCBzZWxmLl9zb2NrZXRUaW1lb3V0KVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX2Rlc3Ryb3llZCA9IHRydWVcblx0c2VsZi5fcmVzZXRUaW1lcnModHJ1ZSlcblx0aWYgKHNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX3Jlc3BvbnNlLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl94aHIpXG5cdFx0c2VsZi5feGhyLmFib3J0KClcblx0ZWxzZSBpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuXG5cdGlmIChlcnIpXG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCwgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKGNiKVxuXHRcdHNlbGYub25jZSgndGltZW91dCcsIGNiKVxuXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSB0aW1lb3V0XG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRTb2NrZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtc2V0cmVxdWVzdGhlYWRlciUyOCUyOS1tZXRob2RcbnZhciB1bnNhZmVIZWFkZXJzID0gW1xuXHQnYWNjZXB0LWNoYXJzZXQnLFxuXHQnYWNjZXB0LWVuY29kaW5nJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsXG5cdCdjb25uZWN0aW9uJyxcblx0J2NvbnRlbnQtbGVuZ3RoJyxcblx0J2Nvb2tpZScsXG5cdCdjb29raWUyJyxcblx0J2RhdGUnLFxuXHQnZG50Jyxcblx0J2V4cGVjdCcsXG5cdCdob3N0Jyxcblx0J2tlZXAtYWxpdmUnLFxuXHQnb3JpZ2luJyxcblx0J3JlZmVyZXInLFxuXHQndGUnLFxuXHQndHJhaWxlcicsXG5cdCd0cmFuc2Zlci1lbmNvZGluZycsXG5cdCd1cGdyYWRlJyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlLCByZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHRcblx0XHRyZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlciwga2V5KXtcblx0XHRcdHNlbGYuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJcblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGtleSwgaGVhZGVyKVxuXHRcdH0pXG5cblx0XHRpZiAoY2FwYWJpbGl0eS53cml0YWJsZVN0cmVhbSkge1xuXHRcdFx0dmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKGZhbHNlKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdCgpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoc2VsZi5wdXNoKEJ1ZmZlci5mcm9tKGNodW5rKSkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWxmLl9yZXN1bWVGZXRjaCA9IHJlc29sdmVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0fSxcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzcG9uc2UuYm9keS5waXBlVG8od3JpdGFibGUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGNhdGNoIChlKSB7fSAvLyBwaXBlVG8gbWV0aG9kIGlzbid0IGRlZmluZWQuIENhbid0IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGZlYXR1cmUgdGVzdCB0aGlzXG5cdFx0fVxuXHRcdC8vIGZhbGxiYWNrIGZvciB3aGVuIHdyaXRhYmxlU3RyZWFtIG9yIHBpcGVUbyBhcmVuJ3QgYXZhaWxhYmxlXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdHJlc2V0VGltZXJzKHJlc3VsdC5kb25lKVxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20ocmVzdWx0LnZhbHVlKSlcblx0XHRcdFx0cmVhZCgpXG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRyZWFkKClcblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgcmVzb2x2ZSA9IHNlbGYuX3Jlc3VtZUZldGNoXG5cdGlmIChyZXNvbHZlKSB7XG5cdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSBudWxsXG5cdFx0cmVzb2x2ZSgpXG5cdH1cbn1cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uIChyZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgeGhyID0gc2VsZi5feGhyXG5cblx0dmFyIHJlc3BvbnNlID0gbnVsbFxuXHRzd2l0Y2ggKHNlbGYuX21vZGUpIHtcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSB8fCAheGhyLnJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQuc2xpY2Uoc2VsZi5fcG9zKSkpKVxuXHRcdFx0XHRcdHNlbGYuX3BvcyA9IHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdH1cblx0XHRcdC8vIHJlYWRlci5vbmVycm9yID0gPz8/IC8vIFRPRE86IHRoaXNcblx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihyZXNwb25zZSlcblx0XHRcdGJyZWFrXG5cdH1cblxuXHQvLyBUaGUgbXMtc3RyZWFtIGNhc2UgaGFuZGxlcyBlbmQgc2VwYXJhdGVseSBpbiByZWFkZXIub25sb2FkKClcblx0aWYgKHNlbGYuX3hoci5yZWFkeVN0YXRlID09PSByU3RhdGVzLkRPTkUgJiYgc2VsZi5fbW9kZSAhPT0gJ21zLXN0cmVhbScpIHtcblx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDB4MDApIHsgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHsgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgIC8vIG92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHsgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODAgfHwgIC8vIG92ZXJsb25nXG4gICAgICAgIGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwICAvLyBzdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkgeyAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwIHx8ICAvLyBvdmVybG9uZ1xuICAgICAgICBidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYgfHwgYnVmW2ldID4gMHhmNCAgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNWYWxpZFVURjg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKTtcbn1cbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiIsIi8qIVxuICogdmFyeVxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB2YXJ5XG5tb2R1bGUuZXhwb3J0cy5hcHBlbmQgPSBhcHBlbmRcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggZmllbGQtbmFtZSBpbiBSRkMgNzIzMCBzZWMgMy4yXG4gKlxuICogZmllbGQtbmFtZSAgICA9IHRva2VuXG4gKiB0b2tlbiAgICAgICAgID0gMSp0Y2hhclxuICogdGNoYXIgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiXG4gKiAgICAgICAgICAgICAgIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIlxuICogICAgICAgICAgICAgICAvIERJR0lUIC8gQUxQSEFcbiAqICAgICAgICAgICAgICAgOyBhbnkgVkNIQVIsIGV4Y2VwdCBkZWxpbWl0ZXJzXG4gKi9cblxudmFyIEZJRUxEX05BTUVfUkVHRVhQID0gL15bISMkJSYnKitcXC0uXl9gfH4wLTlBLVphLXpdKyQvXG5cbi8qKlxuICogQXBwZW5kIGEgZmllbGQgdG8gYSB2YXJ5IGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmQgKGhlYWRlciwgZmllbGQpIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGVhZGVyIGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghZmllbGQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZCBhcmd1bWVudCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBnZXQgZmllbGRzIGFycmF5XG4gIHZhciBmaWVsZHMgPSAhQXJyYXkuaXNBcnJheShmaWVsZClcbiAgICA/IHBhcnNlKFN0cmluZyhmaWVsZCkpXG4gICAgOiBmaWVsZFxuXG4gIC8vIGFzc2VydCBvbiBpbnZhbGlkIGZpZWxkIG5hbWVzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKCFGSUVMRF9OQU1FX1JFR0VYUC50ZXN0KGZpZWxkc1tqXSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkIGFyZ3VtZW50IGNvbnRhaW5zIGFuIGludmFsaWQgaGVhZGVyIG5hbWUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIGV4aXN0aW5nLCB1bnNwZWNpZmllZCB2YXJ5XG4gIGlmIChoZWFkZXIgPT09ICcqJykge1xuICAgIHJldHVybiBoZWFkZXJcbiAgfVxuXG4gIC8vIGVudW1lcmF0ZSBjdXJyZW50IHZhbHVlc1xuICB2YXIgdmFsID0gaGVhZGVyXG4gIHZhciB2YWxzID0gcGFyc2UoaGVhZGVyLnRvTG93ZXJDYXNlKCkpXG5cbiAgLy8gdW5zcGVjaWZpZWQgdmFyeVxuICBpZiAoZmllbGRzLmluZGV4T2YoJyonKSAhPT0gLTEgfHwgdmFscy5pbmRleE9mKCcqJykgIT09IC0xKSB7XG4gICAgcmV0dXJuICcqJ1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmxkID0gZmllbGRzW2ldLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIGFwcGVuZCB2YWx1ZSAoY2FzZS1wcmVzZXJ2aW5nKVxuICAgIGlmICh2YWxzLmluZGV4T2YoZmxkKSA9PT0gLTEpIHtcbiAgICAgIHZhbHMucHVzaChmbGQpXG4gICAgICB2YWwgPSB2YWxcbiAgICAgICAgPyB2YWwgKyAnLCAnICsgZmllbGRzW2ldXG4gICAgICAgIDogZmllbGRzW2ldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIFBhcnNlIGEgdmFyeSBoZWFkZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UgKGhlYWRlcikge1xuICB2YXIgZW5kID0gMFxuICB2YXIgbGlzdCA9IFtdXG4gIHZhciBzdGFydCA9IDBcblxuICAvLyBnYXRoZXIgdG9rZW5zXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoZWFkZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzd2l0Y2ggKGhlYWRlci5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIDB4MjA6IC8qICAgKi9cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICBzdGFydCA9IGVuZCA9IGkgKyAxXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMHgyYzogLyogLCAqL1xuICAgICAgICBsaXN0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcbiAgICAgICAgc3RhcnQgPSBlbmQgPSBpICsgMVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZW5kID0gaSArIDFcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBmaW5hbCB0b2tlblxuICBsaXN0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcblxuICByZXR1cm4gbGlzdFxufVxuXG4vKipcbiAqIE1hcmsgdGhhdCBhIHJlcXVlc3QgaXMgdmFyaWVkIG9uIGEgaGVhZGVyIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBmaWVsZFxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHZhcnkgKHJlcywgZmllbGQpIHtcbiAgaWYgKCFyZXMgfHwgIXJlcy5nZXRIZWFkZXIgfHwgIXJlcy5zZXRIZWFkZXIpIHtcbiAgICAvLyBxdWFjayBxdWFja1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcyBhcmd1bWVudCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBnZXQgZXhpc3RpbmcgaGVhZGVyXG4gIHZhciB2YWwgPSByZXMuZ2V0SGVhZGVyKCdWYXJ5JykgfHwgJydcbiAgdmFyIGhlYWRlciA9IEFycmF5LmlzQXJyYXkodmFsKVxuICAgID8gdmFsLmpvaW4oJywgJylcbiAgICA6IFN0cmluZyh2YWwpXG5cbiAgLy8gc2V0IG5ldyBoZWFkZXJcbiAgaWYgKCh2YWwgPSBhcHBlbmQoaGVhZGVyLCBmaWVsZCkpKSB7XG4gICAgcmVzLnNldEhlYWRlcignVmFyeScsIHZhbClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb246IG1lc3NhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcbiAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBsaXN0ZW5lcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGNiKGVycik7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiIsIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgbWFzayA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7QnVmZmVyW119IFRoZSBmcmFtZWQgZGF0YSBhcyBhIGxpc3Qgb2YgYEJ1ZmZlcmAgaW5zdGFuY2VzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seTtcbiAgICBsZXQgb2Zmc2V0ID0gb3B0aW9ucy5tYXNrID8gNiA6IDI7XG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhLmxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGEubGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoMCwgMik7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRShkYXRhLmxlbmd0aCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvQ2xvc2UoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHk6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9QaW5nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGluZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwaW5nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG5cbiAgICBpZiAoYnVmLmxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb1BvbmcsIGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9Qb25nKGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBvbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9Qb25nKGRhdGEsIG1hc2ssIHJlYWRPbmx5LCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBidWYubGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgcnN2MSxcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIHJlYWRPbmx5OiB0b0J1ZmZlci5yZWFkT25seVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGJ1ZiwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShidWYsIHtcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgcmVhZE9ubHk6IHRvQnVmZmVyLnJlYWRPbmx5XG4gICAgICAgIH0pLFxuICAgICAgICBjYlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZVtpXVs0XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzFdLmxlbmd0aDtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgICBpZiAocmVzdW1lT25SZWNlaXZlckRyYWluKSB3cy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHdzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RyYWluJyk7XG4gICAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgIHdzLl9yZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICB9XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHtcbiAgICAgIHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IGZhbHNlO1xuICAgICAgd3MuX3NvY2tldC5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4gJiYgIXJlc3VtZU9uUmVjZWl2ZXJEcmFpbikge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcbiAgICAgIGlmICghd3MuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjgoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDE1MCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9LFxuICAgIHRva2VuQ2hhcnNcbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzfGh0dHBzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPVxuICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fFxuICAgICAgcmVxLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0JyB8fFxuICAgICAgIWtleSB8fFxuICAgICAgIWtleVJlZ2V4LnRlc3Qoa2V5KSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRQcm90b2NvbCA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRQcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KG51bGwpO1xuXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XG4gICAgICAvL1xuICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuICAgICAgLy9cbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29sc1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmVtYXR1cmUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH07XG5cbiAgICBzb2NrZXQud3JpdGUoXG4gICAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIiwiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeUmVhZGFibGUkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAqIHJlcXVpcmVkIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCJcbiAgICogdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzVW5peFNvY2tldCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgb3IgXCJ3cyt1bml4OlwiJ1xuICAgICk7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0ICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIik7XG4gIH1cblxuICBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJyk7XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IGdldCA9IGlzU2VjdXJlID8gaHR0cHMuZ2V0IDogaHR0cC5nZXQ7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID0gaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdDtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0JyxcbiAgICAuLi5vcHRzLmhlYWRlcnNcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8XG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xuICAgIH1cblxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgY29uc3QgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgdXBncmFkZWBcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gZXh0ZW5kXG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG5cbmZ1bmN0aW9uIGV4dGVuZCgpIHtcbiAgICB2YXIgdGFyZ2V0ID0ge31cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV1cblxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRVJST1JfUEFDS0VUID0gZXhwb3J0cy5QQUNLRVRfVFlQRVNfUkVWRVJTRSA9IGV4cG9ydHMuUEFDS0VUX1RZUEVTID0gdm9pZCAwO1xuY29uc3QgUEFDS0VUX1RZUEVTID0gT2JqZWN0LmNyZWF0ZShudWxsKTsgLy8gbm8gTWFwID0gbm8gcG9seWZpbGxcbmV4cG9ydHMuUEFDS0VUX1RZUEVTID0gUEFDS0VUX1RZUEVTO1xuUEFDS0VUX1RZUEVTW1wib3BlblwiXSA9IFwiMFwiO1xuUEFDS0VUX1RZUEVTW1wiY2xvc2VcIl0gPSBcIjFcIjtcblBBQ0tFVF9UWVBFU1tcInBpbmdcIl0gPSBcIjJcIjtcblBBQ0tFVF9UWVBFU1tcInBvbmdcIl0gPSBcIjNcIjtcblBBQ0tFVF9UWVBFU1tcIm1lc3NhZ2VcIl0gPSBcIjRcIjtcblBBQ0tFVF9UWVBFU1tcInVwZ3JhZGVcIl0gPSBcIjVcIjtcblBBQ0tFVF9UWVBFU1tcIm5vb3BcIl0gPSBcIjZcIjtcbmNvbnN0IFBBQ0tFVF9UWVBFU19SRVZFUlNFID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmV4cG9ydHMuUEFDS0VUX1RZUEVTX1JFVkVSU0UgPSBQQUNLRVRfVFlQRVNfUkVWRVJTRTtcbk9iamVjdC5rZXlzKFBBQ0tFVF9UWVBFUykuZm9yRWFjaChrZXkgPT4ge1xuICAgIFBBQ0tFVF9UWVBFU19SRVZFUlNFW1BBQ0tFVF9UWVBFU1trZXldXSA9IGtleTtcbn0pO1xuY29uc3QgRVJST1JfUEFDS0VUID0geyB0eXBlOiBcImVycm9yXCIsIGRhdGE6IFwicGFyc2VyIGVycm9yXCIgfTtcbmV4cG9ydHMuRVJST1JfUEFDS0VUID0gRVJST1JfUEFDS0VUO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tb25zX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb25zLmpzXCIpO1xuY29uc3QgYmFzZTY0X2FycmF5YnVmZmVyXzEgPSByZXF1aXJlKFwiQHNvY2tldC5pby9iYXNlNjQtYXJyYXlidWZmZXJcIik7XG5jb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbmNvbnN0IGRlY29kZVBhY2tldCA9IChlbmNvZGVkUGFja2V0LCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGVkUGFja2V0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIGRhdGE6IG1hcEJpbmFyeShlbmNvZGVkUGFja2V0LCBiaW5hcnlUeXBlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0eXBlID0gZW5jb2RlZFBhY2tldC5jaGFyQXQoMCk7XG4gICAgaWYgKHR5cGUgPT09IFwiYlwiKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcIm1lc3NhZ2VcIixcbiAgICAgICAgICAgIGRhdGE6IGRlY29kZUJhc2U2NFBhY2tldChlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKSwgYmluYXJ5VHlwZSlcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFja2V0VHlwZSA9IGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXTtcbiAgICBpZiAoIXBhY2tldFR5cGUpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1vbnNfanNfMS5FUlJPUl9QQUNLRVQ7XG4gICAgfVxuICAgIHJldHVybiBlbmNvZGVkUGFja2V0Lmxlbmd0aCA+IDFcbiAgICAgICAgPyB7XG4gICAgICAgICAgICB0eXBlOiBjb21tb25zX2pzXzEuUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV0sXG4gICAgICAgICAgICBkYXRhOiBlbmNvZGVkUGFja2V0LnN1YnN0cmluZygxKVxuICAgICAgICB9XG4gICAgICAgIDoge1xuICAgICAgICAgICAgdHlwZTogY29tbW9uc19qc18xLlBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdXG4gICAgICAgIH07XG59O1xuY29uc3QgZGVjb2RlQmFzZTY0UGFja2V0ID0gKGRhdGEsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWQgPSAoMCwgYmFzZTY0X2FycmF5YnVmZmVyXzEuZGVjb2RlKShkYXRhKTtcbiAgICAgICAgcmV0dXJuIG1hcEJpbmFyeShkZWNvZGVkLCBiaW5hcnlUeXBlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IGJhc2U2NDogdHJ1ZSwgZGF0YSB9OyAvLyBmYWxsYmFjayBmb3Igb2xkIGJyb3dzZXJzXG4gICAgfVxufTtcbmNvbnN0IG1hcEJpbmFyeSA9IChkYXRhLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgc3dpdGNoIChiaW5hcnlUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJibG9iXCI6XG4gICAgICAgICAgICByZXR1cm4gZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyID8gbmV3IEJsb2IoW2RhdGFdKSA6IGRhdGE7XG4gICAgICAgIGNhc2UgXCJhcnJheWJ1ZmZlclwiOlxuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7IC8vIGFzc3VtaW5nIHRoZSBkYXRhIGlzIGFscmVhZHkgYW4gQXJyYXlCdWZmZXJcbiAgICB9XG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gZGVjb2RlUGFja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tb25zX2pzXzEgPSByZXF1aXJlKFwiLi9jb21tb25zLmpzXCIpO1xuY29uc3Qgd2l0aE5hdGl2ZUJsb2IgPSB0eXBlb2YgQmxvYiA9PT0gXCJmdW5jdGlvblwiIHx8XG4gICAgKHR5cGVvZiBCbG9iICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlQXJyYXlCdWZmZXIgPSB0eXBlb2YgQXJyYXlCdWZmZXIgPT09IFwiZnVuY3Rpb25cIjtcbi8vIEFycmF5QnVmZmVyLmlzVmlldyBtZXRob2QgaXMgbm90IGRlZmluZWQgaW4gSUUxMFxuY29uc3QgaXNWaWV3ID0gb2JqID0+IHtcbiAgICByZXR1cm4gdHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gXCJmdW5jdGlvblwiXG4gICAgICAgID8gQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbiAgICAgICAgOiBvYmogJiYgb2JqLmJ1ZmZlciBpbnN0YW5jZW9mIEFycmF5QnVmZmVyO1xufTtcbmNvbnN0IGVuY29kZVBhY2tldCA9ICh7IHR5cGUsIGRhdGEgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSA9PiB7XG4gICAgaWYgKHdpdGhOYXRpdmVCbG9iICYmIGRhdGEgaW5zdGFuY2VvZiBCbG9iKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAod2l0aE5hdGl2ZUFycmF5QnVmZmVyICYmXG4gICAgICAgIChkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KGRhdGEpKSkge1xuICAgICAgICBpZiAoc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBlbmNvZGVCbG9iQXNCYXNlNjQobmV3IEJsb2IoW2RhdGFdKSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHBsYWluIHN0cmluZ1xuICAgIHJldHVybiBjYWxsYmFjayhjb21tb25zX2pzXzEuUEFDS0VUX1RZUEVTW3R5cGVdICsgKGRhdGEgfHwgXCJcIikpO1xufTtcbmNvbnN0IGVuY29kZUJsb2JBc0Jhc2U2NCA9IChkYXRhLCBjYWxsYmFjaykgPT4ge1xuICAgIGNvbnN0IGZpbGVSZWFkZXIgPSBuZXcgRmlsZVJlYWRlcigpO1xuICAgIGZpbGVSZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBjb250ZW50ID0gZmlsZVJlYWRlci5yZXN1bHQuc3BsaXQoXCIsXCIpWzFdO1xuICAgICAgICBjYWxsYmFjayhcImJcIiArIGNvbnRlbnQpO1xuICAgIH07XG4gICAgcmV0dXJuIGZpbGVSZWFkZXIucmVhZEFzRGF0YVVSTChkYXRhKTtcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBlbmNvZGVQYWNrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuY29uc3QgZW5jb2RlUGFja2V0X2pzXzEgPSByZXF1aXJlKFwiLi9lbmNvZGVQYWNrZXQuanNcIik7XG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGVuY29kZVBhY2tldF9qc18xLmRlZmF1bHQ7XG5jb25zdCBkZWNvZGVQYWNrZXRfanNfMSA9IHJlcXVpcmUoXCIuL2RlY29kZVBhY2tldC5qc1wiKTtcbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZGVjb2RlUGFja2V0X2pzXzEuZGVmYXVsdDtcbmNvbnN0IFNFUEFSQVRPUiA9IFN0cmluZy5mcm9tQ2hhckNvZGUoMzApOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5jb25zdCBlbmNvZGVQYXlsb2FkID0gKHBhY2tldHMsIGNhbGxiYWNrKSA9PiB7XG4gICAgLy8gc29tZSBwYWNrZXRzIG1heSBiZSBhZGRlZCB0byB0aGUgYXJyYXkgd2hpbGUgZW5jb2RpbmcsIHNvIHRoZSBpbml0aWFsIGxlbmd0aCBtdXN0IGJlIHNhdmVkXG4gICAgY29uc3QgbGVuZ3RoID0gcGFja2V0cy5sZW5ndGg7XG4gICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBuZXcgQXJyYXkobGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIHBhY2tldHMuZm9yRWFjaCgocGFja2V0LCBpKSA9PiB7XG4gICAgICAgIC8vIGZvcmNlIGJhc2U2NCBlbmNvZGluZyBmb3IgYmluYXJ5IHBhY2tldHNcbiAgICAgICAgKDAsIGVuY29kZVBhY2tldF9qc18xLmRlZmF1bHQpKHBhY2tldCwgZmFsc2UsIGVuY29kZWRQYWNrZXQgPT4ge1xuICAgICAgICAgICAgZW5jb2RlZFBhY2tldHNbaV0gPSBlbmNvZGVkUGFja2V0O1xuICAgICAgICAgICAgaWYgKCsrY291bnQgPT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVuY29kZWRQYWNrZXRzLmpvaW4oU0VQQVJBVE9SKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGVuY29kZVBheWxvYWQ7XG5jb25zdCBkZWNvZGVQYXlsb2FkID0gKGVuY29kZWRQYXlsb2FkLCBiaW5hcnlUeXBlKSA9PiB7XG4gICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSBlbmNvZGVkUGF5bG9hZC5zcGxpdChTRVBBUkFUT1IpO1xuICAgIGNvbnN0IHBhY2tldHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVuY29kZWRQYWNrZXRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGRlY29kZWRQYWNrZXQgPSAoMCwgZGVjb2RlUGFja2V0X2pzXzEuZGVmYXVsdCkoZW5jb2RlZFBhY2tldHNbaV0sIGJpbmFyeVR5cGUpO1xuICAgICAgICBwYWNrZXRzLnB1c2goZGVjb2RlZFBhY2tldCk7XG4gICAgICAgIGlmIChkZWNvZGVkUGFja2V0LnR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhY2tldHM7XG59O1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZGVjb2RlUGF5bG9hZDtcbmV4cG9ydHMucHJvdG9jb2wgPSA0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnByb3RvY29sID0gZXhwb3J0cy5UcmFuc3BvcnQgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMudVNlcnZlciA9IGV4cG9ydHMucGFyc2VyID0gZXhwb3J0cy5hdHRhY2ggPSBleHBvcnRzLmxpc3RlbiA9IGV4cG9ydHMudHJhbnNwb3J0cyA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cF8xID0gcmVxdWlyZShcImh0dHBcIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNlcnZlclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VydmVyXzEuU2VydmVyOyB9IH0pO1xuY29uc3QgaW5kZXhfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMvaW5kZXhcIik7XG5leHBvcnRzLnRyYW5zcG9ydHMgPSBpbmRleF8xLmRlZmF1bHQ7XG5jb25zdCBwYXJzZXIgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmV4cG9ydHMucGFyc2VyID0gcGFyc2VyO1xudmFyIHVzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3VzZXJ2ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ1U2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB1c2VydmVyXzEudVNlcnZlcjsgfSB9KTtcbnZhciBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNvY2tldFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc29ja2V0XzEuU29ja2V0OyB9IH0pO1xudmFyIHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVHJhbnNwb3J0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiB0cmFuc3BvcnRfMS5UcmFuc3BvcnQ7IH0gfSk7XG5leHBvcnRzLnByb3RvY29sID0gcGFyc2VyLnByb3RvY29sO1xuLyoqXG4gKiBDcmVhdGVzIGFuIGh0dHAuU2VydmVyIGV4Y2x1c2l2ZWx5IHVzZWQgZm9yIFdTIHVwZ3JhZGVzLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBwb3J0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gd2Vic29ja2V0LmlvIHNlcnZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbGlzdGVuKHBvcnQsIG9wdGlvbnMsIGZuKSB7XG4gICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgZm4gPSBvcHRpb25zO1xuICAgICAgICBvcHRpb25zID0ge307XG4gICAgfVxuICAgIGNvbnN0IHNlcnZlciA9ICgwLCBodHRwXzEuY3JlYXRlU2VydmVyKShmdW5jdGlvbiAocmVxLCByZXMpIHtcbiAgICAgICAgcmVzLndyaXRlSGVhZCg1MDEpO1xuICAgICAgICByZXMuZW5kKFwiTm90IEltcGxlbWVudGVkXCIpO1xuICAgIH0pO1xuICAgIC8vIGNyZWF0ZSBlbmdpbmUgc2VydmVyXG4gICAgY29uc3QgZW5naW5lID0gYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gICAgZW5naW5lLmh0dHBTZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgc2VydmVyLmxpc3Rlbihwb3J0LCBmbik7XG4gICAgcmV0dXJuIGVuZ2luZTtcbn1cbmV4cG9ydHMubGlzdGVuID0gbGlzdGVuO1xuLyoqXG4gKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICpcbiAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAqIEByZXR1cm4ge1NlcnZlcn0gZW5naW5lIHNlcnZlclxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gYXR0YWNoKHNlcnZlciwgb3B0aW9ucykge1xuICAgIGNvbnN0IGVuZ2luZSA9IG5ldyBzZXJ2ZXJfMS5TZXJ2ZXIob3B0aW9ucyk7XG4gICAgZW5naW5lLmF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiBlbmdpbmU7XG59XG5leHBvcnRzLmF0dGFjaCA9IGF0dGFjaDtcbiIsIlwidXNlIHN0cmljdFwiO1xuLy8gaW1wb3J0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXBhcnNlci90cmVlLzIuMi54XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGV4cG9ydHMuZW5jb2RlUGF5bG9hZEFzQmluYXJ5ID0gZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBleHBvcnRzLmRlY29kZVBhY2tldCA9IGV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZXhwb3J0cy5lbmNvZGVQYWNrZXQgPSBleHBvcnRzLnBhY2tldHMgPSBleHBvcnRzLnByb3RvY29sID0gdm9pZCAwO1xuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxuICovXG52YXIgdXRmOCA9IHJlcXVpcmUoJy4vdXRmOCcpO1xuLyoqXG4gKiBDdXJyZW50IHByb3RvY29sIHZlcnNpb24uXG4gKi9cbmV4cG9ydHMucHJvdG9jb2wgPSAzO1xuY29uc3QgaGFzQmluYXJ5ID0gKHBhY2tldHMpID0+IHtcbiAgICBmb3IgKGNvbnN0IHBhY2tldCBvZiBwYWNrZXRzKSB7XG4gICAgICAgIGlmIChwYWNrZXQuZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyIHx8IEFycmF5QnVmZmVyLmlzVmlldyhwYWNrZXQuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4vKipcbiAqIFBhY2tldCB0eXBlcy5cbiAqL1xuZXhwb3J0cy5wYWNrZXRzID0ge1xuICAgIG9wZW46IDAgLy8gbm9uLXdzXG4gICAgLFxuICAgIGNsb3NlOiAxIC8vIG5vbi13c1xuICAgICxcbiAgICBwaW5nOiAyLFxuICAgIHBvbmc6IDMsXG4gICAgbWVzc2FnZTogNCxcbiAgICB1cGdyYWRlOiA1LFxuICAgIG5vb3A6IDZcbn07XG52YXIgcGFja2V0c2xpc3QgPSBPYmplY3Qua2V5cyhleHBvcnRzLnBhY2tldHMpO1xuLyoqXG4gKiBQcmVtYWRlIGVycm9yIHBhY2tldC5cbiAqL1xudmFyIGVyciA9IHsgdHlwZTogJ2Vycm9yJywgZGF0YTogJ3BhcnNlciBlcnJvcicgfTtcbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5jb25jYXQoW10pO1xuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0LlxuICpcbiAqICAgICA8cGFja2V0IHR5cGUgaWQ+IFsgPGRhdGE+IF1cbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICA1aGVsbG8gd29ybGRcbiAqICAgICAzXG4gKiAgICAgNFxuICpcbiAqIEJpbmFyeSBpcyBlbmNvZGVkIGluIGFuIGlkZW50aWNhbCBwcmluY2lwbGVcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIHV0ZjhlbmNvZGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgICAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdXRmOGVuY29kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHV0ZjhlbmNvZGU7XG4gICAgICAgIHV0ZjhlbmNvZGUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoQnVmZmVyLmlzQnVmZmVyKHBhY2tldC5kYXRhKSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocGFja2V0LmRhdGEgJiYgKHBhY2tldC5kYXRhLmJ1ZmZlciB8fCBwYWNrZXQuZGF0YSkgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gZW5jb2RlQnVmZmVyKHsgdHlwZTogcGFja2V0LnR5cGUsIGRhdGE6IGFycmF5QnVmZmVyVG9CdWZmZXIocGFja2V0LmRhdGEpIH0sIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8vIFNlbmRpbmcgZGF0YSBhcyBhIHV0Zi04IHN0cmluZ1xuICAgIHZhciBlbmNvZGVkID0gZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICAvLyBkYXRhIGZyYWdtZW50IGlzIG9wdGlvbmFsXG4gICAgaWYgKHVuZGVmaW5lZCAhPT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgZW5jb2RlZCArPSB1dGY4ZW5jb2RlID8gdXRmOC5lbmNvZGUoU3RyaW5nKHBhY2tldC5kYXRhKSwgeyBzdHJpY3Q6IGZhbHNlIH0pIDogU3RyaW5nKHBhY2tldC5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbGxiYWNrKCcnICsgZW5jb2RlZCk7XG59XG5leHBvcnRzLmVuY29kZVBhY2tldCA9IGVuY29kZVBhY2tldDtcbjtcbi8qKlxuICogRW5jb2RlIEJ1ZmZlciBkYXRhXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJ1ZmZlcihwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICghc3VwcG9ydHNCaW5hcnkpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgdmFyIGRhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICB2YXIgdHlwZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgxKTtcbiAgICB0eXBlQnVmZmVyWzBdID0gZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChbdHlwZUJ1ZmZlciwgZGF0YV0pKTtcbn1cbi8qKlxuICogRW5jb2RlcyBhIHBhY2tldCB3aXRoIGJpbmFyeSBkYXRhIGluIGEgYmFzZTY0IHN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQsIGhhcyBgdHlwZWAgYW5kIGBkYXRhYFxuICogQHJldHVybiB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZUJhc2U2NFBhY2tldChwYWNrZXQsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpID8gcGFja2V0LmRhdGEgOiBhcnJheUJ1ZmZlclRvQnVmZmVyKHBhY2tldC5kYXRhKTtcbiAgICB2YXIgbWVzc2FnZSA9ICdiJyArIGV4cG9ydHMucGFja2V0c1twYWNrZXQudHlwZV07XG4gICAgbWVzc2FnZSArPSBkYXRhLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICByZXR1cm4gY2FsbGJhY2sobWVzc2FnZSk7XG59XG5leHBvcnRzLmVuY29kZUJhc2U2NFBhY2tldCA9IGVuY29kZUJhc2U2NFBhY2tldDtcbjtcbi8qKlxuICogRGVjb2RlcyBhIHBhY2tldC4gRGF0YSBhbHNvIGF2YWlsYWJsZSBhcyBhbiBBcnJheUJ1ZmZlciBpZiByZXF1ZXN0ZWQuXG4gKlxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGB0eXBlYCBhbmQgYGRhdGFgIChpZiBhbnkpXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGFja2V0KGRhdGEsIGJpbmFyeVR5cGUsIHV0ZjhkZWNvZGUpIHtcbiAgICBpZiAoZGF0YSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiBlcnI7XG4gICAgfVxuICAgIHZhciB0eXBlO1xuICAgIC8vIFN0cmluZyBkYXRhXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICB0eXBlID0gZGF0YS5jaGFyQXQoMCk7XG4gICAgICAgIGlmICh0eXBlID09PSAnYicpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWNvZGVCYXNlNjRQYWNrZXQoZGF0YS5zdWJzdHIoMSksIGJpbmFyeVR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh1dGY4ZGVjb2RlKSB7XG4gICAgICAgICAgICBkYXRhID0gdHJ5RGVjb2RlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoTnVtYmVyKHR5cGUpICE9IHR5cGUgfHwgIXBhY2tldHNsaXN0W3R5cGVdKSB7XG4gICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBkYXRhLnN1YnN0cmluZygxKSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0gfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBCaW5hcnkgZGF0YVxuICAgIGlmIChiaW5hcnlUeXBlID09PSAnYXJyYXlidWZmZXInKSB7XG4gICAgICAgIC8vIHdyYXAgQnVmZmVyL0FycmF5QnVmZmVyIGRhdGEgaW50byBhbiBVaW50OEFycmF5XG4gICAgICAgIHZhciBpbnRBcnJheSA9IG5ldyBVaW50OEFycmF5KGRhdGEpO1xuICAgICAgICB0eXBlID0gaW50QXJyYXlbMF07XG4gICAgICAgIHJldHVybiB7IHR5cGU6IHBhY2tldHNsaXN0W3R5cGVdLCBkYXRhOiBpbnRBcnJheS5idWZmZXIuc2xpY2UoMSkgfTtcbiAgICB9XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICBkYXRhID0gYXJyYXlCdWZmZXJUb0J1ZmZlcihkYXRhKTtcbiAgICB9XG4gICAgdHlwZSA9IGRhdGFbMF07XG4gICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc2xpY2UoMSkgfTtcbn1cbmV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZGVjb2RlUGFja2V0O1xuO1xuZnVuY3Rpb24gdHJ5RGVjb2RlKGRhdGEpIHtcbiAgICB0cnkge1xuICAgICAgICBkYXRhID0gdXRmOC5kZWNvZGUoZGF0YSwgeyBzdHJpY3Q6IGZhbHNlIH0pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xufVxuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0IGVuY29kZWQgaW4gYSBiYXNlNjQgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBiYXNlNjQgZW5jb2RlZCBtZXNzYWdlXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqL1xuZnVuY3Rpb24gZGVjb2RlQmFzZTY0UGFja2V0KG1zZywgYmluYXJ5VHlwZSkge1xuICAgIHZhciB0eXBlID0gcGFja2V0c2xpc3RbbXNnLmNoYXJBdCgwKV07XG4gICAgdmFyIGRhdGEgPSBCdWZmZXIuZnJvbShtc2cuc3Vic3RyKDEpLCAnYmFzZTY0Jyk7XG4gICAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgdmFyIGFidiA9IG5ldyBVaW50OEFycmF5KGRhdGEubGVuZ3RoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhYnYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFidltpXSA9IGRhdGFbaV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBkYXRhID0gYWJ2LmJ1ZmZlcjtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogdHlwZSwgZGF0YTogZGF0YSB9O1xufVxuZXhwb3J0cy5kZWNvZGVCYXNlNjRQYWNrZXQgPSBkZWNvZGVCYXNlNjRQYWNrZXQ7XG47XG4vKipcbiAqIEVuY29kZXMgbXVsdGlwbGUgbWVzc2FnZXMgKHBheWxvYWQpLlxuICpcbiAqICAgICA8bGVuZ3RoPjpkYXRhXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiAgICAgMTE6aGVsbG8gd29ybGQyOmhpXG4gKlxuICogSWYgYW55IGNvbnRlbnRzIGFyZSBiaW5hcnksIHRoZXkgd2lsbCBiZSBlbmNvZGVkIGFzIGJhc2U2NCBzdHJpbmdzLiBCYXNlNjRcbiAqIGVuY29kZWQgc3RyaW5ncyBhcmUgbWFya2VkIHdpdGggYSBiIGJlZm9yZSB0aGUgbGVuZ3RoIHNwZWNpZmllclxuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYXlsb2FkKHBhY2tldHMsIHN1cHBvcnRzQmluYXJ5LCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2Ygc3VwcG9ydHNCaW5hcnkgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBzdXBwb3J0c0JpbmFyeTtcbiAgICAgICAgc3VwcG9ydHNCaW5hcnkgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoc3VwcG9ydHNCaW5hcnkgJiYgaGFzQmluYXJ5KHBhY2tldHMpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVQYXlsb2FkQXNCaW5hcnkocGFja2V0cywgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAoIXBhY2tldHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjaygnMDonKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlT25lKHBhY2tldCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgIGVuY29kZVBhY2tldChwYWNrZXQsIHN1cHBvcnRzQmluYXJ5LCBmYWxzZSwgZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZSwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2socmVzdWx0cy5qb2luKCcnKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmVuY29kZVBheWxvYWQgPSBlbmNvZGVQYXlsb2FkO1xuO1xuZnVuY3Rpb24gc2V0TGVuZ3RoSGVhZGVyKG1lc3NhZ2UpIHtcbiAgICByZXR1cm4gbWVzc2FnZS5sZW5ndGggKyAnOicgKyBtZXNzYWdlO1xufVxuLyoqXG4gKiBBc3luYyBhcnJheSBtYXAgdXNpbmcgYWZ0ZXJcbiAqL1xuZnVuY3Rpb24gbWFwKGFyeSwgZWFjaCwgZG9uZSkge1xuICAgIGNvbnN0IHJlc3VsdHMgPSBuZXcgQXJyYXkoYXJ5Lmxlbmd0aCk7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFyeS5sZW5ndGg7IGkrKykge1xuICAgICAgICBlYWNoKGFyeVtpXSwgKGVycm9yLCBtc2cpID0+IHtcbiAgICAgICAgICAgIHJlc3VsdHNbaV0gPSBtc2c7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gYXJ5Lmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGRvbmUobnVsbCwgcmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qXG4gKiBEZWNvZGVzIGRhdGEgd2hlbiBhIHBheWxvYWQgaXMgbWF5YmUgZXhwZWN0ZWQuIFBvc3NpYmxlIGJpbmFyeSBjb250ZW50cyBhcmVcbiAqIGRlY29kZWQgZnJvbSB0aGVpciBiYXNlNjQgcmVwcmVzZW50YXRpb25cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gZGF0YSwgY2FsbGJhY2sgbWV0aG9kXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBkZWNvZGVQYXlsb2FkKGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhICE9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICAgICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChkYXRhID09PSAnJykge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cbiAgICB2YXIgbGVuZ3RoID0gJycsIG4sIG1zZywgcGFja2V0O1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gZGF0YS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdmFyIGNociA9IGRhdGEuY2hhckF0KGkpO1xuICAgICAgICBpZiAoY2hyICE9PSAnOicpIHtcbiAgICAgICAgICAgIGxlbmd0aCArPSBjaHI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGlmIChsZW5ndGggPT09ICcnIHx8IChsZW5ndGggIT0gKG4gPSBOdW1iZXIobGVuZ3RoKSkpKSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBtc2cgPSBkYXRhLnN1YnN0cihpICsgMSwgbik7XG4gICAgICAgIGlmIChsZW5ndGggIT0gbXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1zZy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHBhY2tldCA9IGRlY29kZVBhY2tldChtc2csIGJpbmFyeVR5cGUsIGZhbHNlKTtcbiAgICAgICAgICAgIGlmIChlcnIudHlwZSA9PT0gcGFja2V0LnR5cGUgJiYgZXJyLmRhdGEgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gcGFyc2VyIGVycm9yIGluIGluZGl2aWR1YWwgcGFja2V0IC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG1vcmUgPSBjYWxsYmFjayhwYWNrZXQsIGkgKyBuLCBsKTtcbiAgICAgICAgICAgIGlmIChmYWxzZSA9PT0gbW9yZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWR2YW5jZSBjdXJzb3JcbiAgICAgICAgaSArPSBuO1xuICAgICAgICBsZW5ndGggPSAnJztcbiAgICB9XG4gICAgaWYgKGxlbmd0aCAhPT0gJycpIHtcbiAgICAgICAgLy8gcGFyc2VyIGVycm9yIC0gaWdub3JpbmcgcGF5bG9hZFxuICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBkZWNvZGVQYXlsb2FkO1xuO1xuLyoqXG4gKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvU3RyaW5nKGJ1ZmZlcikge1xuICAgIHZhciBzdHIgPSAnJztcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IGJ1ZmZlci5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgc3RyICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmZmVyW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cjtcbn1cbi8qKlxuICpcbiAqIENvbnZlcnRzIGEgdXRmOC5qcyBlbmNvZGVkIHN0cmluZyB0byBhIGJ1ZmZlclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzdHJpbmdUb0J1ZmZlcihzdHJpbmcpIHtcbiAgICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKHN0cmluZy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBidWYud3JpdGVVSW50OChzdHJpbmcuY2hhckNvZGVBdChpKSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBidWY7XG59XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhbiBBcnJheUJ1ZmZlciB0byBhIEJ1ZmZlclxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpIHtcbiAgICAvLyBkYXRhIGlzIGVpdGhlciBhbiBBcnJheUJ1ZmZlciBvciBBcnJheUJ1ZmZlclZpZXcuXG4gICAgdmFyIGxlbmd0aCA9IGRhdGEuYnl0ZUxlbmd0aCB8fCBkYXRhLmxlbmd0aDtcbiAgICB2YXIgb2Zmc2V0ID0gZGF0YS5ieXRlT2Zmc2V0IHx8IDA7XG4gICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyIHx8IGRhdGEsIG9mZnNldCwgbGVuZ3RoKTtcbn1cbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkgYXMgYmluYXJ5LlxuICpcbiAqIDwxID0gYmluYXJ5LCAwID0gc3RyaW5nPjxudW1iZXIgZnJvbSAwLTk+PG51bWJlciBmcm9tIDAtOT5bLi4uXTxudW1iZXJcbiAqIDI1NT48ZGF0YT5cbiAqXG4gKiBFeGFtcGxlOlxuICogMSAzIDI1NSAxIDIgMywgaWYgdGhlIGJpbmFyeSBjb250ZW50cyBhcmUgaW50ZXJwcmV0ZWQgYXMgOCBiaXQgaW50ZWdlcnNcbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gKiBAcmV0dXJuIHtCdWZmZXJ9IGVuY29kZWQgcGF5bG9hZFxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBheWxvYWRBc0JpbmFyeShwYWNrZXRzLCBjYWxsYmFjaykge1xuICAgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEVNUFRZX0JVRkZFUik7XG4gICAgfVxuICAgIG1hcChwYWNrZXRzLCBlbmNvZGVPbmVCaW5hcnlQYWNrZXQsIGZ1bmN0aW9uIChlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKEJ1ZmZlci5jb25jYXQocmVzdWx0cykpO1xuICAgIH0pO1xufVxuZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCaW5hcnkgPSBlbmNvZGVQYXlsb2FkQXNCaW5hcnk7XG47XG5mdW5jdGlvbiBlbmNvZGVPbmVCaW5hcnlQYWNrZXQocCwgZG9uZUNhbGxiYWNrKSB7XG4gICAgZnVuY3Rpb24gb25CaW5hcnlQYWNrZXRFbmNvZGUocGFja2V0KSB7XG4gICAgICAgIHZhciBlbmNvZGluZ0xlbmd0aCA9ICcnICsgcGFja2V0Lmxlbmd0aDtcbiAgICAgICAgdmFyIHNpemVCdWZmZXI7XG4gICAgICAgIGlmICh0eXBlb2YgcGFja2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgICAgIHNpemVCdWZmZXJbMF0gPSAwOyAvLyBpcyBhIHN0cmluZyAobm90IHRydWUgYmluYXJ5ID0gMClcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzaXplQnVmZmVyW3NpemVCdWZmZXIubGVuZ3RoIC0gMV0gPSAyNTU7XG4gICAgICAgICAgICByZXR1cm4gZG9uZUNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoW3NpemVCdWZmZXIsIHN0cmluZ1RvQnVmZmVyKHBhY2tldCldKSk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShlbmNvZGluZ0xlbmd0aC5sZW5ndGggKyAyKTtcbiAgICAgICAgc2l6ZUJ1ZmZlclswXSA9IDE7IC8vIGlzIGJpbmFyeSAodHJ1ZSBiaW5hcnkgPSAxKVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY29kaW5nTGVuZ3RoLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzaXplQnVmZmVyW2kgKyAxXSA9IHBhcnNlSW50KGVuY29kaW5nTGVuZ3RoW2ldLCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgc2l6ZUJ1ZmZlcltzaXplQnVmZmVyLmxlbmd0aCAtIDFdID0gMjU1O1xuICAgICAgICBkb25lQ2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChbc2l6ZUJ1ZmZlciwgcGFja2V0XSkpO1xuICAgIH1cbiAgICBlbmNvZGVQYWNrZXQocCwgdHJ1ZSwgdHJ1ZSwgb25CaW5hcnlQYWNrZXRFbmNvZGUpO1xufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gU3RyaW5ncyBhcmUgZGVjb2RlZCBieVxuICogaW50ZXJwcmV0aW5nIGVhY2ggYnl0ZSBhcyBhIGtleSBjb2RlIGZvciBlbnRyaWVzIG1hcmtlZCB0byBzdGFydCB3aXRoIDAuIFNlZVxuICogZGVzY3JpcHRpb24gb2YgZW5jb2RlUGF5bG9hZEFzQmluYXJ5XG5cbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWRBc0JpbmFyeShkYXRhLCBiaW5hcnlUeXBlLCBjYWxsYmFjaykge1xuICAgIGlmICh0eXBlb2YgYmluYXJ5VHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IGJpbmFyeVR5cGU7XG4gICAgICAgIGJpbmFyeVR5cGUgPSBudWxsO1xuICAgIH1cbiAgICB2YXIgYnVmZmVyVGFpbCA9IGRhdGE7XG4gICAgdmFyIGJ1ZmZlcnMgPSBbXTtcbiAgICB2YXIgaTtcbiAgICB3aGlsZSAoYnVmZmVyVGFpbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzdHJMZW4gPSAnJztcbiAgICAgICAgdmFyIGlzU3RyaW5nID0gYnVmZmVyVGFpbFswXSA9PT0gMDtcbiAgICAgICAgZm9yIChpID0gMTs7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1ZmZlclRhaWxbaV0gPT09IDI1NSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIDMxMCA9IGNoYXIgbGVuZ3RoIG9mIE51bWJlci5NQVhfVkFMVUVcbiAgICAgICAgICAgIGlmIChzdHJMZW4ubGVuZ3RoID4gMzEwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdHJMZW4gKz0gJycgKyBidWZmZXJUYWlsW2ldO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKHN0ckxlbi5sZW5ndGggKyAxKTtcbiAgICAgICAgdmFyIG1zZ0xlbmd0aCA9IHBhcnNlSW50KHN0ckxlbiwgMTApO1xuICAgICAgICB2YXIgbXNnID0gYnVmZmVyVGFpbC5zbGljZSgxLCBtc2dMZW5ndGggKyAxKTtcbiAgICAgICAgaWYgKGlzU3RyaW5nKVxuICAgICAgICAgICAgbXNnID0gYnVmZmVyVG9TdHJpbmcobXNnKTtcbiAgICAgICAgYnVmZmVycy5wdXNoKG1zZyk7XG4gICAgICAgIGJ1ZmZlclRhaWwgPSBidWZmZXJUYWlsLnNsaWNlKG1zZ0xlbmd0aCArIDEpO1xuICAgIH1cbiAgICB2YXIgdG90YWwgPSBidWZmZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWw7IGkrKykge1xuICAgICAgICB2YXIgYnVmZmVyID0gYnVmZmVyc1tpXTtcbiAgICAgICAgY2FsbGJhY2soZGVjb2RlUGFja2V0KGJ1ZmZlciwgYmluYXJ5VHlwZSwgdHJ1ZSksIGksIHRvdGFsKTtcbiAgICB9XG59XG5leHBvcnRzLmRlY29kZVBheWxvYWRBc0JpbmFyeSA9IGRlY29kZVBheWxvYWRBc0JpbmFyeTtcbjtcbiIsIi8qISBodHRwczovL210aHMuYmUvdXRmOGpzIHYyLjEuMiBieSBAbWF0aGlhcyAqL1xudmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgdmFyIGNvdW50ZXIgPSAwO1xuICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgZXh0cmE7XG4gICAgd2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICBpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcbiAgICAgICAgICAgIGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcbiAgICAgICAgICAgIGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG4gICAgICAgICAgICAgICAgLy8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICAgICAgICAgIGNvdW50ZXItLTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIG91dHB1dC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuLy8gVGFrZW4gZnJvbSBodHRwczovL210aHMuYmUvcHVueWNvZGVcbmZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciB2YWx1ZTtcbiAgICB2YXIgb3V0cHV0ID0gJyc7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSA+IDB4RkZGRikge1xuICAgICAgICAgICAgdmFsdWUgLT0gMHgxMDAwMDtcbiAgICAgICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuICAgICAgICAgICAgdmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuICAgICAgICB9XG4gICAgICAgIG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xufVxuZnVuY3Rpb24gY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmIChjb2RlUG9pbnQgPj0gMHhEODAwICYmIGNvZGVQb2ludCA8PSAweERGRkYpIHtcbiAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0xvbmUgc3Vycm9nYXRlIFUrJyArIGNvZGVQb2ludC50b1N0cmluZygxNikudG9VcHBlckNhc2UoKSArXG4gICAgICAgICAgICAgICAgJyBpcyBub3QgYSBzY2FsYXIgdmFsdWUnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5mdW5jdGlvbiBjcmVhdGVCeXRlKGNvZGVQb2ludCwgc2hpZnQpIHtcbiAgICByZXR1cm4gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IHNoaWZ0KSAmIDB4M0YpIHwgMHg4MCk7XG59XG5mdW5jdGlvbiBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpIHtcbiAgICBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRkZGODApID09IDApIHsgLy8gMS1ieXRlIHNlcXVlbmNlXG4gICAgICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICB9XG4gICAgdmFyIHN5bWJvbCA9ICcnO1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRjgwMCkgPT0gMCkgeyAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDYpICYgMHgxRikgfCAweEMwKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZGRjAwMDApID09IDApIHsgLy8gMy1ieXRlIHNlcXVlbmNlXG4gICAgICAgIGlmICghY2hlY2tTY2FsYXJWYWx1ZShjb2RlUG9pbnQsIHN0cmljdCkpIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IDB4RkZGRDtcbiAgICAgICAgfVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gMTIpICYgMHgwRikgfCAweEUwKTtcbiAgICAgICAgc3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoKGNvZGVQb2ludCAmIDB4RkZFMDAwMDApID09IDApIHsgLy8gNC1ieXRlIHNlcXVlbmNlXG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxOCkgJiAweDA3KSB8IDB4RjApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDEyKTtcbiAgICAgICAgc3ltYm9sICs9IGNyZWF0ZUJ5dGUoY29kZVBvaW50LCA2KTtcbiAgICB9XG4gICAgc3ltYm9sICs9IHN0cmluZ0Zyb21DaGFyQ29kZSgoY29kZVBvaW50ICYgMHgzRikgfCAweDgwKTtcbiAgICByZXR1cm4gc3ltYm9sO1xufVxuZnVuY3Rpb24gdXRmOGVuY29kZShzdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIHZhciBjb2RlUG9pbnRzID0gdWNzMmRlY29kZShzdHJpbmcpO1xuICAgIHZhciBsZW5ndGggPSBjb2RlUG9pbnRzLmxlbmd0aDtcbiAgICB2YXIgaW5kZXggPSAtMTtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIHZhciBieXRlU3RyaW5nID0gJyc7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29kZVBvaW50ID0gY29kZVBvaW50c1tpbmRleF07XG4gICAgICAgIGJ5dGVTdHJpbmcgKz0gZW5jb2RlQ29kZVBvaW50KGNvZGVQb2ludCwgc3RyaWN0KTtcbiAgICB9XG4gICAgcmV0dXJuIGJ5dGVTdHJpbmc7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIHJlYWRDb250aW51YXRpb25CeXRlKCkge1xuICAgIGlmIChieXRlSW5kZXggPj0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGJ5dGUgaW5kZXgnKTtcbiAgICB9XG4gICAgdmFyIGNvbnRpbnVhdGlvbkJ5dGUgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgaWYgKChjb250aW51YXRpb25CeXRlICYgMHhDMCkgPT0gMHg4MCkge1xuICAgICAgICByZXR1cm4gY29udGludWF0aW9uQnl0ZSAmIDB4M0Y7XG4gICAgfVxuICAgIC8vIElmIHdlIGVuZCB1cCBoZXJlLCBpdOKAmXMgbm90IGEgY29udGludWF0aW9uIGJ5dGVcbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xufVxuZnVuY3Rpb24gZGVjb2RlU3ltYm9sKHN0cmljdCkge1xuICAgIHZhciBieXRlMTtcbiAgICB2YXIgYnl0ZTI7XG4gICAgdmFyIGJ5dGUzO1xuICAgIHZhciBieXRlNDtcbiAgICB2YXIgY29kZVBvaW50O1xuICAgIGlmIChieXRlSW5kZXggPiBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICBpZiAoYnl0ZUluZGV4ID09IGJ5dGVDb3VudCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIFJlYWQgZmlyc3QgYnl0ZVxuICAgIGJ5dGUxID0gYnl0ZUFycmF5W2J5dGVJbmRleF0gJiAweEZGO1xuICAgIGJ5dGVJbmRleCsrO1xuICAgIC8vIDEtYnl0ZSBzZXF1ZW5jZSAobm8gY29udGludWF0aW9uIGJ5dGVzKVxuICAgIGlmICgoYnl0ZTEgJiAweDgwKSA9PSAwKSB7XG4gICAgICAgIHJldHVybiBieXRlMTtcbiAgICB9XG4gICAgLy8gMi1ieXRlIHNlcXVlbmNlXG4gICAgaWYgKChieXRlMSAmIDB4RTApID09IDB4QzApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgxRikgPDwgNikgfCBieXRlMjtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDgwKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyAzLWJ5dGUgc2VxdWVuY2UgKG1heSBpbmNsdWRlIHVucGFpcmVkIHN1cnJvZ2F0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4RjApID09IDB4RTApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDBGKSA8PCAxMikgfCAoYnl0ZTIgPDwgNikgfCBieXRlMztcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAweDA4MDApIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSA/IGNvZGVQb2ludCA6IDB4RkZGRDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gNC1ieXRlIHNlcXVlbmNlXG4gICAgaWYgKChieXRlMSAmIDB4RjgpID09IDB4RjApIHtcbiAgICAgICAgYnl0ZTIgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBieXRlMyA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGU0ID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MDcpIDw8IDB4MTIpIHwgKGJ5dGUyIDw8IDB4MEMpIHxcbiAgICAgICAgICAgIChieXRlMyA8PCAweDA2KSB8IGJ5dGU0O1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDEwMDAwICYmIGNvZGVQb2ludCA8PSAweDEwRkZGRikge1xuICAgICAgICAgICAgcmV0dXJuIGNvZGVQb2ludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBFcnJvcignSW52YWxpZCBVVEYtOCBkZXRlY3RlZCcpO1xufVxudmFyIGJ5dGVBcnJheTtcbnZhciBieXRlQ291bnQ7XG52YXIgYnl0ZUluZGV4O1xuZnVuY3Rpb24gdXRmOGRlY29kZShieXRlU3RyaW5nLCBvcHRzKSB7XG4gICAgb3B0cyA9IG9wdHMgfHwge307XG4gICAgdmFyIHN0cmljdCA9IGZhbHNlICE9PSBvcHRzLnN0cmljdDtcbiAgICBieXRlQXJyYXkgPSB1Y3MyZGVjb2RlKGJ5dGVTdHJpbmcpO1xuICAgIGJ5dGVDb3VudCA9IGJ5dGVBcnJheS5sZW5ndGg7XG4gICAgYnl0ZUluZGV4ID0gMDtcbiAgICB2YXIgY29kZVBvaW50cyA9IFtdO1xuICAgIHZhciB0bXA7XG4gICAgd2hpbGUgKCh0bXAgPSBkZWNvZGVTeW1ib2woc3RyaWN0KSkgIT09IGZhbHNlKSB7XG4gICAgICAgIGNvZGVQb2ludHMucHVzaCh0bXApO1xuICAgIH1cbiAgICByZXR1cm4gdWNzMmVuY29kZShjb2RlUG9pbnRzKTtcbn1cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHZlcnNpb246ICcyLjEuMicsXG4gICAgZW5jb2RlOiB1dGY4ZW5jb2RlLFxuICAgIGRlY29kZTogdXRmOGRlY29kZVxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZXJ2ZXIgPSBleHBvcnRzLkJhc2VTZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBxcyA9IHJlcXVpcmUoXCJxdWVyeXN0cmluZ1wiKTtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGJhc2U2NGlkID0gcmVxdWlyZShcImJhc2U2NGlkXCIpO1xuY29uc3QgdHJhbnNwb3J0c18xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0c1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGNvb2tpZV8xID0gcmVxdWlyZShcImNvb2tpZVwiKTtcbmNvbnN0IHdzXzEgPSByZXF1aXJlKFwid3NcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lXCIpO1xuY2xhc3MgQmFzZVNlcnZlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogU2VydmVyIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgLSBvcHRpb25zXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5jbGllbnRzID0ge307XG4gICAgICAgIHRoaXMuY2xpZW50c0NvdW50ID0gMDtcbiAgICAgICAgdGhpcy5vcHRzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICB3c0VuZ2luZTogd3NfMS5TZXJ2ZXIsXG4gICAgICAgICAgICBwaW5nVGltZW91dDogMjAwMDAsXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IDI1MDAwLFxuICAgICAgICAgICAgdXBncmFkZVRpbWVvdXQ6IDEwMDAwLFxuICAgICAgICAgICAgbWF4SHR0cEJ1ZmZlclNpemU6IDFlNixcbiAgICAgICAgICAgIHRyYW5zcG9ydHM6IE9iamVjdC5rZXlzKHRyYW5zcG9ydHNfMS5kZWZhdWx0KSxcbiAgICAgICAgICAgIGFsbG93VXBncmFkZXM6IHRydWUsXG4gICAgICAgICAgICBodHRwQ29tcHJlc3Npb246IHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMjRcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb3JzOiBmYWxzZSxcbiAgICAgICAgICAgIGFsbG93RUlPMzogZmFsc2VcbiAgICAgICAgfSwgb3B0cyk7XG4gICAgICAgIGlmIChvcHRzLmNvb2tpZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRzLmNvb2tpZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG5hbWU6IFwiaW9cIixcbiAgICAgICAgICAgICAgICBwYXRoOiBcIi9cIixcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgaHR0cE9ubHk6IG9wdHMuY29va2llLnBhdGggIT09IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNhbWVTaXRlOiBcImxheFwiXG4gICAgICAgICAgICB9LCBvcHRzLmNvb2tpZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0cy5jb3JzKSB7XG4gICAgICAgICAgICB0aGlzLmNvcnNNaWRkbGV3YXJlID0gcmVxdWlyZShcImNvcnNcIikodGhpcy5vcHRzLmNvcnMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGUgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgICAgICB0aHJlc2hvbGQ6IDEwMjRcbiAgICAgICAgICAgIH0sIG9wdHMucGVyTWVzc2FnZURlZmxhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaW5pdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGEgbGlzdCBvZiBhdmFpbGFibGUgdHJhbnNwb3J0cyBmb3IgdXBncmFkZSBnaXZlbiBhIGNlcnRhaW4gdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHJldHVybiB7QXJyYXl9XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICB1cGdyYWRlcyh0cmFuc3BvcnQpIHtcbiAgICAgICAgaWYgKCF0aGlzLm9wdHMuYWxsb3dVcGdyYWRlcylcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydHNfMS5kZWZhdWx0W3RyYW5zcG9ydF0udXBncmFkZXNUbyB8fCBbXTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVmVyaWZpZXMgYSByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX1cbiAgICAgKiBAcmV0dXJuIHtCb29sZWFufSB3aGV0aGVyIHRoZSByZXF1ZXN0IGlzIHZhbGlkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgdmVyaWZ5KHJlcSwgdXBncmFkZSwgZm4pIHtcbiAgICAgICAgLy8gdHJhbnNwb3J0IGNoZWNrXG4gICAgICAgIGNvbnN0IHRyYW5zcG9ydCA9IHJlcS5fcXVlcnkudHJhbnNwb3J0O1xuICAgICAgICBpZiAoIX50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKHRyYW5zcG9ydCkpIHtcbiAgICAgICAgICAgIGRlYnVnKCd1bmtub3duIHRyYW5zcG9ydCBcIiVzXCInLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuVU5LTk9XTl9UUkFOU1BPUlQsIHsgdHJhbnNwb3J0IH0pO1xuICAgICAgICB9XG4gICAgICAgIC8vICdPcmlnaW4nIGhlYWRlciBjaGVja1xuICAgICAgICBjb25zdCBpc09yaWdpbkludmFsaWQgPSBjaGVja0ludmFsaWRIZWFkZXJDaGFyKHJlcS5oZWFkZXJzLm9yaWdpbik7XG4gICAgICAgIGlmIChpc09yaWdpbkludmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9yaWdpbiA9IHJlcS5oZWFkZXJzLm9yaWdpbjtcbiAgICAgICAgICAgIHJlcS5oZWFkZXJzLm9yaWdpbiA9IG51bGw7XG4gICAgICAgICAgICBkZWJ1ZyhcIm9yaWdpbiBoZWFkZXIgaW52YWxpZFwiKTtcbiAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJJTlZBTElEX09SSUdJTlwiLFxuICAgICAgICAgICAgICAgIG9yaWdpblxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2lkIGNoZWNrXG4gICAgICAgIGNvbnN0IHNpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICBpZiAoc2lkKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50cy5oYXNPd25Qcm9wZXJ0eShzaWQpKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3Vua25vd24gc2lkIFwiJXNcIicsIHNpZCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuVU5LTk9XTl9TSUQsIHtcbiAgICAgICAgICAgICAgICAgICAgc2lkXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcmV2aW91c1RyYW5zcG9ydCA9IHRoaXMuY2xpZW50c1tzaWRdLnRyYW5zcG9ydC5uYW1lO1xuICAgICAgICAgICAgaWYgKCF1cGdyYWRlICYmIHByZXZpb3VzVHJhbnNwb3J0ICE9PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImJhZCByZXF1ZXN0OiB1bmV4cGVjdGVkIHRyYW5zcG9ydCB3aXRob3V0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfTUlTTUFUQ0hcIixcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c1RyYW5zcG9ydFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaGFuZHNoYWtlIGlzIEdFVCBvbmx5XG4gICAgICAgICAgICBpZiAoXCJHRVRcIiAhPT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9IQU5EU0hBS0VfTUVUSE9ELCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogcmVxLm1ldGhvZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyYW5zcG9ydCA9PT0gXCJ3ZWJzb2NrZXRcIiAmJiAhdXBncmFkZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiaW52YWxpZCB0cmFuc3BvcnQgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRSQU5TUE9SVF9IQU5EU0hBS0VfRVJST1JcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLm9wdHMuYWxsb3dSZXF1ZXN0KVxuICAgICAgICAgICAgICAgIHJldHVybiBmbigpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub3B0cy5hbGxvd1JlcXVlc3QocmVxLCAobWVzc2FnZSwgc3VjY2VzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5GT1JCSURERU4sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBmbigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmcgYWxsIG9wZW4gY2xpZW50c1wiKTtcbiAgICAgICAgZm9yIChsZXQgaSBpbiB0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudHMuaGFzT3duUHJvcGVydHkoaSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbaV0uY2xvc2UodHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBnZW5lcmF0ZSBhIHNvY2tldCBpZC5cbiAgICAgKiBPdmVyd3JpdGUgdGhpcyBtZXRob2QgdG8gZ2VuZXJhdGUgeW91ciBjdXN0b20gc29ja2V0IGlkXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBvYmplY3RcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdlbmVyYXRlSWQocmVxKSB7XG4gICAgICAgIHJldHVybiBiYXNlNjRpZC5nZW5lcmF0ZUlkKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRzaGFrZXMgYSBuZXcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHRyYW5zcG9ydCBuYW1lXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlcXVlc3Qgb2JqZWN0XG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2xvc2VDb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIGFzeW5jIGhhbmRzaGFrZSh0cmFuc3BvcnROYW1lLCByZXEsIGNsb3NlQ29ubmVjdGlvbikge1xuICAgICAgICBjb25zdCBwcm90b2NvbCA9IHJlcS5fcXVlcnkuRUlPID09PSBcIjRcIiA/IDQgOiAzOyAvLyAzcmQgcmV2aXNpb24gYnkgZGVmYXVsdFxuICAgICAgICBpZiAocHJvdG9jb2wgPT09IDMgJiYgIXRoaXMub3B0cy5hbGxvd0VJTzMpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvblwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04sXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5VTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaWQ7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZCA9IGF3YWl0IHRoaXMuZ2VuZXJhdGVJZChyZXEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHdoaWxlIGdlbmVyYXRpbmcgYW4gaWRcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgY29kZTogU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiSURfR0VORVJBVElPTl9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKCdoYW5kc2hha2luZyBjbGllbnQgXCIlc1wiJywgaWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUsIHJlcSk7XG4gICAgICAgICAgICBpZiAoXCJwb2xsaW5nXCIgPT09IHRyYW5zcG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQubWF4SHR0cEJ1ZmZlclNpemUgPSB0aGlzLm9wdHMubWF4SHR0cEJ1ZmZlclNpemU7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0Lmh0dHBDb21wcmVzc2lvbiA9IHRoaXMub3B0cy5odHRwQ29tcHJlc3Npb247XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcIndlYnNvY2tldFwiID09PSB0cmFuc3BvcnROYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcS5fcXVlcnkgJiYgcmVxLl9xdWVyeS5iNjQpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdlcnJvciBoYW5kc2hha2luZyB0byB0cmFuc3BvcnQgXCIlc1wiJywgdHJhbnNwb3J0TmFtZSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgY29kZTogU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCxcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNUXSxcbiAgICAgICAgICAgICAgICBjb250ZXh0OiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX0hBTkRTSEFLRV9FUlJPUlwiLFxuICAgICAgICAgICAgICAgICAgICBlcnJvcjogZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2xvc2VDb25uZWN0aW9uKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBzb2NrZXRfMS5Tb2NrZXQoaWQsIHRoaXMsIHRyYW5zcG9ydCwgcmVxLCBwcm90b2NvbCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbihcImhlYWRlcnNcIiwgKGhlYWRlcnMsIHJlcSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsUmVxdWVzdCA9ICFyZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgICAgIGlmIChpc0luaXRpYWxSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0cy5jb29raWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc1tcIlNldC1Db29raWVcIl0gPSBbXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgICAgICAoMCwgY29va2llXzEuc2VyaWFsaXplKSh0aGlzLm9wdHMuY29va2llLm5hbWUsIGlkLCB0aGlzLm9wdHMuY29va2llKVxuICAgICAgICAgICAgICAgICAgICBdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJpbml0aWFsX2hlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgdGhpcy5jbGllbnRzW2lkXSA9IHNvY2tldDtcbiAgICAgICAgdGhpcy5jbGllbnRzQ291bnQrKztcbiAgICAgICAgc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgIHRoaXMuY2xpZW50c0NvdW50LS07XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5CYXNlU2VydmVyID0gQmFzZVNlcnZlcjtcbi8qKlxuICogUHJvdG9jb2wgZXJyb3JzIG1hcHBpbmdzLlxuICovXG5CYXNlU2VydmVyLmVycm9ycyA9IHtcbiAgICBVTktOT1dOX1RSQU5TUE9SVDogMCxcbiAgICBVTktOT1dOX1NJRDogMSxcbiAgICBCQURfSEFORFNIQUtFX01FVEhPRDogMixcbiAgICBCQURfUkVRVUVTVDogMyxcbiAgICBGT1JCSURERU46IDQsXG4gICAgVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTjogNVxufTtcbkJhc2VTZXJ2ZXIuZXJyb3JNZXNzYWdlcyA9IHtcbiAgICAwOiBcIlRyYW5zcG9ydCB1bmtub3duXCIsXG4gICAgMTogXCJTZXNzaW9uIElEIHVua25vd25cIixcbiAgICAyOiBcIkJhZCBoYW5kc2hha2UgbWV0aG9kXCIsXG4gICAgMzogXCJCYWQgcmVxdWVzdFwiLFxuICAgIDQ6IFwiRm9yYmlkZGVuXCIsXG4gICAgNTogXCJVbnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uXCJcbn07XG5jbGFzcyBTZXJ2ZXIgZXh0ZW5kcyBCYXNlU2VydmVyIHtcbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHdlYnNvY2tldCBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCF+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMud3MpXG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMud3MgPSBuZXcgdGhpcy5vcHRzLndzRW5naW5lKHtcbiAgICAgICAgICAgIG5vU2VydmVyOiB0cnVlLFxuICAgICAgICAgICAgY2xpZW50VHJhY2tpbmc6IGZhbHNlLFxuICAgICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSxcbiAgICAgICAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZVxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLndzLm9uID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3Mub24oXCJoZWFkZXJzXCIsIChoZWFkZXJzQXJyYXksIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIG5vdGU6ICd3cycgdXNlcyBhbiBhcnJheSBvZiBoZWFkZXJzLCB3aGlsZSBFbmdpbmUuSU8gdXNlcyBhbiBvYmplY3QgKHJlc3BvbnNlLndyaXRlSGVhZCgpIGFjY2VwdHMgYm90aCBmb3JtYXRzKVxuICAgICAgICAgICAgICAgIC8vIHdlIGNvdWxkIGFsc28gdHJ5IHRvIHBhcnNlIHRoZSBhcnJheSBhbmQgdGhlbiBzeW5jIHRoZSB2YWx1ZXMsIGJ1dCB0aGF0IHdpbGwgYmUgZXJyb3ItcHJvbmVcbiAgICAgICAgICAgICAgICBjb25zdCBhZGRpdGlvbmFsSGVhZGVycyA9IHt9O1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzSW5pdGlhbFJlcXVlc3QgPSAhcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaW5pdGlhbF9oZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGFkZGl0aW9uYWxIZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGFkZGl0aW9uYWxIZWFkZXJzKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNBcnJheS5wdXNoKGAke2tleX06ICR7YWRkaXRpb25hbEhlYWRlcnNba2V5XX1gKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIGlmICh0aGlzLndzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgd2ViU29ja2V0U2VydmVyXCIpO1xuICAgICAgICAgICAgdGhpcy53cy5jbG9zZSgpO1xuICAgICAgICAgICAgLy8gZG9uJ3QgZGVsZXRlIHRoaXMud3MgYmVjYXVzZSBpdCBjYW4gYmUgdXNlZCBhZ2FpbiBpZiB0aGUgaHR0cCBzZXJ2ZXIgc3RhcnRzIGxpc3RlbmluZyBhZ2FpblxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByZXBhcmVzIGEgcmVxdWVzdCBieSBwcm9jZXNzaW5nIHRoZSBxdWVyeSBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBwcmVwYXJlKHJlcSkge1xuICAgICAgICAvLyB0cnkgdG8gbGV2ZXJhZ2UgcHJlLWV4aXN0aW5nIGByZXEuX3F1ZXJ5YCAoZS5nOiBmcm9tIGNvbm5lY3QpXG4gICAgICAgIGlmICghcmVxLl9xdWVyeSkge1xuICAgICAgICAgICAgcmVxLl9xdWVyeSA9IH5yZXEudXJsLmluZGV4T2YoXCI/XCIpID8gcXMucGFyc2UoKDAsIHVybF8xLnBhcnNlKShyZXEudXJsKS5xdWVyeSkgOiB7fTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSwgcmVxKSB7XG4gICAgICAgIHJldHVybiBuZXcgdHJhbnNwb3J0c18xLmRlZmF1bHRbdHJhbnNwb3J0TmFtZV0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJSZXNwb25zZXxodHRwLk91dGdvaW5nTWVzc2FnZX0gcmVzcG9uc2VcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGhhbmRsZVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgZGVidWcoJ2hhbmRsaW5nIFwiJXNcIiBodHRwIHJlcXVlc3QgXCIlc1wiJywgcmVxLm1ldGhvZCwgcmVxLnVybCk7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEpO1xuICAgICAgICByZXEucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlcS5fcXVlcnkuc2lkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXR0aW5nIG5ldyByZXF1ZXN0IGZvciBleGlzdGluZyBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGllbnRzW3JlcS5fcXVlcnkuc2lkXS50cmFuc3BvcnQub25SZXF1ZXN0KHJlcSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb3JzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgdGhpcy5jb3JzTWlkZGxld2FyZS5jYWxsKG51bGwsIHJlcSwgcmVzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBFbmdpbmUuSU8gSFRUUCBVcGdyYWRlLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBoYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCB1cGdyYWRlSGVhZCkge1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxKTtcbiAgICAgICAgdGhpcy52ZXJpZnkocmVxLCB0cnVlLCAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZWFkID0gQnVmZmVyLmZyb20odXBncmFkZUhlYWQpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGlcbiAgICAgICAgICAgIHVwZ3JhZGVIZWFkID0gbnVsbDtcbiAgICAgICAgICAgIC8vIGRlbGVnYXRlIHRvIHdzXG4gICAgICAgICAgICB0aGlzLndzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIHdlYnNvY2tldCA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbldlYlNvY2tldChyZXEsIHNvY2tldCwgd2Vic29ja2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gYSB3cy5pbyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHt3cy5Tb2NrZXR9IHdlYnNvY2tldFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uV2ViU29ja2V0KHJlcSwgc29ja2V0LCB3ZWJzb2NrZXQpIHtcbiAgICAgICAgd2Vic29ja2V0Lm9uKFwiZXJyb3JcIiwgb25VcGdyYWRlRXJyb3IpO1xuICAgICAgICBpZiAodHJhbnNwb3J0c18xLmRlZmF1bHRbcmVxLl9xdWVyeS50cmFuc3BvcnRdICE9PSB1bmRlZmluZWQgJiZcbiAgICAgICAgICAgICF0cmFuc3BvcnRzXzEuZGVmYXVsdFtyZXEuX3F1ZXJ5LnRyYW5zcG9ydF0ucHJvdG90eXBlLmhhbmRsZXNVcGdyYWRlcykge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZG9lc250IGhhbmRsZSB1cGdyYWRlZCByZXF1ZXN0c1wiKTtcbiAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIGdldCBjbGllbnQgaWRcbiAgICAgICAgY29uc3QgaWQgPSByZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgLy8ga2VlcCBhIHJlZmVyZW5jZSB0byB0aGUgd3MuU29ja2V0XG4gICAgICAgIHJlcS53ZWJzb2NrZXQgPSB3ZWJzb2NrZXQ7XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhZCBhbHJlYWR5IGJlZW4gdXBncmFkZWRcIik7XG4gICAgICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgLy8gdHJhbnNwb3J0IGVycm9yIGhhbmRsaW5nIHRha2VzIG92ZXJcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvblVwZ3JhZGVFcnJvcik7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcS5fcXVlcnkgJiYgcmVxLl9xdWVyeS5iNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgICAgICAgICAgY2xpZW50Lm1heWJlVXBncmFkZSh0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiBhYm9ydFVwZ3JhZGUoc29ja2V0LCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIGZ1bmN0aW9uIG9uVXBncmFkZUVycm9yKCkge1xuICAgICAgICAgICAgZGVidWcoXCJ3ZWJzb2NrZXQgZXJyb3IgYmVmb3JlIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAvLyB3ZWJzb2NrZXQuY2xvc2UoKSBub3QgbmVlZGVkXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FwdHVyZXMgdXBncmFkZSByZXF1ZXN0cyBmb3IgYSBodHRwLlNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5TZXJ2ZXJ9IHNlcnZlclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBhdHRhY2goc2VydmVyLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgbGV0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8IFwiL2VuZ2luZS5pb1wiKS5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGRlc3Ryb3lVcGdyYWRlVGltZW91dCA9IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGVUaW1lb3V0IHx8IDEwMDA7XG4gICAgICAgIC8vIG5vcm1hbGl6ZSBwYXRoXG4gICAgICAgIHBhdGggKz0gXCIvXCI7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKHJlcSkge1xuICAgICAgICAgICAgcmV0dXJuIHBhdGggPT09IHJlcS51cmwuc3Vic3RyKDAsIHBhdGgubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBjYWNoZSBhbmQgY2xlYW4gdXAgbGlzdGVuZXJzXG4gICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHNlcnZlci5saXN0ZW5lcnMoXCJyZXF1ZXN0XCIpLnNsaWNlKDApO1xuICAgICAgICBzZXJ2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVxdWVzdFwiKTtcbiAgICAgICAgc2VydmVyLm9uKFwiY2xvc2VcIiwgdGhpcy5jbG9zZS5iaW5kKHRoaXMpKTtcbiAgICAgICAgc2VydmVyLm9uKFwibGlzdGVuaW5nXCIsIHRoaXMuaW5pdC5iaW5kKHRoaXMpKTtcbiAgICAgICAgLy8gYWRkIHJlcXVlc3QgaGFuZGxlclxuICAgICAgICBzZXJ2ZXIub24oXCJyZXF1ZXN0XCIsIChyZXEsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGNoZWNrKHJlcSkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygnaW50ZXJjZXB0aW5nIHJlcXVlc3QgZm9yIHBhdGggXCIlc1wiJywgcGF0aCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICBjb25zdCBsID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZXJ2ZXIsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAofnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YoXCJ3ZWJzb2NrZXRcIikpIHtcbiAgICAgICAgICAgIHNlcnZlci5vbihcInVwZ3JhZGVcIiwgKHJlcSwgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNoZWNrKHJlcSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5oYW5kbGVVcGdyYWRlKHJlcSwgc29ja2V0LCBoZWFkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoZmFsc2UgIT09IG9wdGlvbnMuZGVzdHJveVVwZ3JhZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVmYXVsdCBub2RlIGJlaGF2aW9yIGlzIHRvIGRpc2Nvbm5lY3Qgd2hlbiBubyBoYW5kbGVyc1xuICAgICAgICAgICAgICAgICAgICAvLyBidXQgYnkgYWRkaW5nIGEgaGFuZGxlciwgd2UgcHJldmVudCB0aGF0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFuZCBpZiBubyBlaW8gdGhpbmcgaGFuZGxlcyB0aGUgdXBncmFkZVxuICAgICAgICAgICAgICAgICAgICAvLyB0aGVuIHRoZSBzb2NrZXQgbmVlZHMgdG8gZGllIVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQud3JpdGFibGUgJiYgc29ja2V0LmJ5dGVzV3JpdHRlbiA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSwgZGVzdHJveVVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuLyoqXG4gKiBDbG9zZSB0aGUgSFRUUCBsb25nLXBvbGxpbmcgcmVxdWVzdFxuICpcbiAqIEBwYXJhbSByZXMgLSB0aGUgcmVzcG9uc2Ugb2JqZWN0XG4gKiBAcGFyYW0gZXJyb3JDb2RlIC0gdGhlIGVycm9yIGNvZGVcbiAqIEBwYXJhbSBlcnJvckNvbnRleHQgLSBhZGRpdGlvbmFsIGVycm9yIGNvbnRleHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpIHtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyb3JDb2RlID09PSBTZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTiA/IDQwMyA6IDQwMDtcbiAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JDb250ZXh0ICYmIGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgID8gZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgIHJlcy53cml0ZUhlYWQoc3RhdHVzQ29kZSwgeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiB9KTtcbiAgICByZXMuZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICBtZXNzYWdlXG4gICAgfSkpO1xufVxuLyoqXG4gKiBDbG9zZSB0aGUgV2ViU29ja2V0IGNvbm5lY3Rpb25cbiAqXG4gKiBAcGFyYW0ge25ldC5Tb2NrZXR9IHNvY2tldFxuICogQHBhcmFtIHtzdHJpbmd9IGVycm9yQ29kZSAtIHRoZSBlcnJvciBjb2RlXG4gKiBAcGFyYW0ge29iamVjdH0gZXJyb3JDb250ZXh0IC0gYWRkaXRpb25hbCBlcnJvciBjb250ZXh0XG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0ID0ge30pIHtcbiAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoKSA9PiB7XG4gICAgICAgIGRlYnVnKFwiaWdub3JpbmcgZXJyb3IgZnJvbSBjbG9zZWQgY29ubmVjdGlvblwiKTtcbiAgICB9KTtcbiAgICBpZiAoc29ja2V0LndyaXRhYmxlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckNvbnRleHQubWVzc2FnZSB8fCBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKTtcbiAgICAgICAgc29ja2V0LndyaXRlKFwiSFRUUC8xLjEgNDAwIEJhZCBSZXF1ZXN0XFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb25uZWN0aW9uOiBjbG9zZVxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGVudC10eXBlOiB0ZXh0L2h0bWxcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoOiBcIiArXG4gICAgICAgICAgICBsZW5ndGggK1xuICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIG1lc3NhZ2UpO1xuICAgIH1cbiAgICBzb2NrZXQuZGVzdHJveSgpO1xufVxuLyogZXNsaW50LWRpc2FibGUgKi9cbi8qKlxuICogRnJvbSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvYmxvYi92OC40LjAvbGliL19odHRwX2NvbW1vbi5qcyNMMzAzLUwzNTRcbiAqXG4gKiBUcnVlIGlmIHZhbCBjb250YWlucyBhbiBpbnZhbGlkIGZpZWxkLXZjaGFyXG4gKiAgZmllbGQtdmFsdWUgICAgPSAqKCBmaWVsZC1jb250ZW50IC8gb2JzLWZvbGQgKVxuICogIGZpZWxkLWNvbnRlbnQgID0gZmllbGQtdmNoYXIgWyAxKiggU1AgLyBIVEFCICkgZmllbGQtdmNoYXIgXVxuICogIGZpZWxkLXZjaGFyICAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICpcbiAqIGNoZWNrSW52YWxpZEhlYWRlckNoYXIoKSBpcyBjdXJyZW50bHkgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlIGJ5IHY4LFxuICogc28gdGFrZSBjYXJlIHdoZW4gbWFraW5nIGNoYW5nZXMgdG8gdGhlIGltcGxlbWVudGF0aW9uIHNvIHRoYXQgdGhlIHNvdXJjZVxuICogY29kZSBzaXplIGRvZXMgbm90IGV4Y2VlZCB2OCdzIGRlZmF1bHQgbWF4X2lubGluZWRfc291cmNlX3NpemUgc2V0dGluZy5cbiAqKi9cbi8vIHByZXR0aWVyLWlnbm9yZVxuY29uc3QgdmFsaWRIZHJDaGFycyA9IFtcbiAgICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAxLCAwLCAwLCAwLCAwLCAwLCAwLFxuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxIC8vIC4uLiAyNTVcbl07XG5mdW5jdGlvbiBjaGVja0ludmFsaWRIZWFkZXJDaGFyKHZhbCkge1xuICAgIHZhbCArPSBcIlwiO1xuICAgIGlmICh2YWwubGVuZ3RoIDwgMSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgwKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAwLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDApKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgMilcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgxKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAxLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDEpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgMylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgyKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAyLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDIpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoIDwgNClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdCgzKV0pIHtcbiAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCAzLCBjaGFyIFwiJXNcIicsIHZhbC5jaGFyQ29kZUF0KDMpKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSA0OyBpIDwgdmFsLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmICghdmFsaWRIZHJDaGFyc1t2YWwuY2hhckNvZGVBdChpKV0pIHtcbiAgICAgICAgICAgIGRlYnVnKCdpbnZhbGlkIGhlYWRlciwgaW5kZXggXCIlaVwiLCBjaGFyIFwiJXNcIicsIGksIHZhbC5jaGFyQ29kZUF0KGkpKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgdGltZXJzXzEgPSByZXF1aXJlKFwidGltZXJzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpzb2NrZXRcIik7XG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBjbGFzcyAoYWJzdHJhY3QpLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoaWQsIHNlcnZlciwgdHJhbnNwb3J0LCByZXEsIHByb3RvY29sKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMudXBncmFkZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuaW5nXCI7XG4gICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbiA9IFtdO1xuICAgICAgICB0aGlzLmNsZWFudXBGbiA9IFtdO1xuICAgICAgICB0aGlzLnJlcXVlc3QgPSByZXE7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgICAgLy8gQ2FjaGUgSVAgc2luY2UgaXQgbWlnaHQgbm90IGJlIGluIHRoZSByZXEgbGF0ZXJcbiAgICAgICAgaWYgKHJlcS53ZWJzb2NrZXQgJiYgcmVxLndlYnNvY2tldC5fc29ja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnJlbW90ZUFkZHJlc3MgPSByZXEud2Vic29ja2V0Ll9zb2NrZXQucmVtb3RlQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlcS5jb25uZWN0aW9uLnJlbW90ZUFkZHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jaGVja0ludGVydmFsVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5vbk9wZW4oKTtcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBzZXQgcmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgdXBkYXRlZCBmcm9tICVzIHRvICVzXCIsIHRoaXMuX3JlYWR5U3RhdGUsIHN0YXRlKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY29uc2lkZXJlZCBvcGVuLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25PcGVuKCkge1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5cIjtcbiAgICAgICAgLy8gc2VuZHMgYW4gYG9wZW5gIHBhY2tldFxuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zaWQgPSB0aGlzLmlkO1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJvcGVuXCIsIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgIHNpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIHVwZ3JhZGVzOiB0aGlzLmdldEF2YWlsYWJsZVVwZ3JhZGVzKCksXG4gICAgICAgICAgICBwaW5nSW50ZXJ2YWw6IHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsLFxuICAgICAgICAgICAgcGluZ1RpbWVvdXQ6IHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXRcbiAgICAgICAgfSkpO1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIub3B0cy5pbml0aWFsUGFja2V0KSB7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIHRoaXMuc2VydmVyLm9wdHMuaW5pdGlhbFBhY2tldCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwib3BlblwiKTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIGluIHByb3RvY29sIHYzLCB0aGUgY2xpZW50IHNlbmRzIGEgcGluZywgYW5kIHRoZSBzZXJ2ZXIgYW5zd2VycyB3aXRoIGEgcG9uZ1xuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsICsgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpbiBwcm90b2NvbCB2NCwgdGhlIHNlcnZlciBzZW5kcyBhIHBpbmcsIGFuZCB0aGUgY2xpZW50IGFuc3dlcnMgd2l0aCBhIHBvbmdcbiAgICAgICAgICAgIHRoaXMuc2NoZWR1bGVQaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgaWYgKFwib3BlblwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWJ1ZyhcInBhY2tldCByZWNlaXZlZCB3aXRoIGNsb3NlZCBzb2NrZXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXhwb3J0IHBhY2tldCBldmVudFxuICAgICAgICBkZWJ1ZyhgcmVjZWl2ZWQgcGFja2V0ICR7cGFja2V0LnR5cGV9YCk7XG4gICAgICAgIHRoaXMuZW1pdChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgICAgICAvLyBSZXNldCBwaW5nIHRpbWVvdXQgb24gYW55IHBhY2tldCwgaW5jb21pbmcgZGF0YSBpcyBhIGdvb2Qgc2lnbiBvZlxuICAgICAgICAvLyBvdGhlciBzaWRlJ3MgbGl2ZW5lc3NcbiAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KHRoaXMuc2VydmVyLm9wdHMucGluZ0ludGVydmFsICsgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJwaW5nXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJhbnNwb3J0LnByb3RvY29sICE9PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub25FcnJvcihcImludmFsaWQgaGVhcnRiZWF0IGRpcmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwaW5nXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcInBvbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBvbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiaW52YWxpZCBoZWFydGJlYXQgZGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHBvbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5waW5nSW50ZXJ2YWxUaW1lci5yZWZyZXNoKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhcnRiZWF0XCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGFyc2UgZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWVzc2FnZVwiOlxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRhdGFcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RXJyb3J9IGVycm9yIG9iamVjdFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRXJyb3IoZXJyKSB7XG4gICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGVycm9yXCIpO1xuICAgICAgICB0aGlzLm9uQ2xvc2UoXCJ0cmFuc3BvcnQgZXJyb3JcIiwgZXJyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGluZ3MgY2xpZW50IGV2ZXJ5IGB0aGlzLnBpbmdJbnRlcnZhbGAgYW5kIGV4cGVjdHMgcmVzcG9uc2VcbiAgICAgKiB3aXRoaW4gYHRoaXMucGluZ1RpbWVvdXRgIG9yIGNsb3NlcyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2NoZWR1bGVQaW5nKCkge1xuICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBwaW5nIHBhY2tldCAtIGV4cGVjdGluZyBwb25nIHdpdGhpbiAlc21zXCIsIHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwicGluZ1wiKTtcbiAgICAgICAgICAgIHRoaXMucmVzZXRQaW5nVGltZW91dCh0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICAgICAgfSwgdGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldHMgcGluZyB0aW1lb3V0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcmVzZXRQaW5nVGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9ICgwLCB0aW1lcnNfMS5zZXRUaW1lb3V0KSgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NlZFwiKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMub25DbG9zZShcInBpbmcgdGltZW91dFwiKTtcbiAgICAgICAgfSwgdGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIGhhbmRsZXJzIGZvciB0aGUgZ2l2ZW4gdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtUcmFuc3BvcnR9IHRyYW5zcG9ydFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldFRyYW5zcG9ydCh0cmFuc3BvcnQpIHtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IHRoaXMub25FcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBvblBhY2tldCA9IHRoaXMub25QYWNrZXQuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgZmx1c2ggPSB0aGlzLmZsdXNoLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzLCBcInRyYW5zcG9ydCBjbG9zZVwiKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uY2UoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcImRyYWluXCIsIGZsdXNoKTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAvLyB0aGlzIGZ1bmN0aW9uIHdpbGwgbWFuYWdlIHBhY2tldCBldmVudHMgKGFsc28gbWVzc2FnZSBjYWxsYmFja3MpXG4gICAgICAgIHRoaXMuc2V0dXBTZW5kQ2FsbGJhY2soKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwRm4ucHVzaChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJkcmFpblwiLCBmbHVzaCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVwZ3JhZGVzIHNvY2tldCB0byB0aGUgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgbWF5YmVVcGdyYWRlKHRyYW5zcG9ydCkge1xuICAgICAgICBkZWJ1ZygnbWlnaHQgdXBncmFkZSBzb2NrZXQgdHJhbnNwb3J0IGZyb20gXCIlc1wiIHRvIFwiJXNcIicsIHRoaXMudHJhbnNwb3J0Lm5hbWUsIHRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgdGhpcy51cGdyYWRpbmcgPSB0cnVlO1xuICAgICAgICAvLyBzZXQgdHJhbnNwb3J0IHVwZ3JhZGUgdGltZXJcbiAgICAgICAgdGhpcy51cGdyYWRlVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xpZW50IGRpZCBub3QgY29tcGxldGUgdXBncmFkZSAtIGNsb3NpbmcgdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgaWYgKFwib3BlblwiID09PSB0cmFuc3BvcnQucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5vcHRzLnVwZ3JhZGVUaW1lb3V0KTtcbiAgICAgICAgY29uc3Qgb25QYWNrZXQgPSBwYWNrZXQgPT4ge1xuICAgICAgICAgICAgaWYgKFwicGluZ1wiID09PSBwYWNrZXQudHlwZSAmJiBcInByb2JlXCIgPT09IHBhY2tldC5kYXRhKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcHJvYmUgcGluZyBwYWNrZXQsIHNlbmRpbmcgcG9uZ1wiKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcInBvbmdcIiwgZGF0YTogXCJwcm9iZVwiIH1dKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGdyYWRpbmdcIiwgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWxUaW1lciA9IHNldEludGVydmFsKGNoZWNrLCAxMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoXCJ1cGdyYWRlXCIgPT09IHBhY2tldC50eXBlICYmIHRoaXMucmVhZHlTdGF0ZSAhPT0gXCJjbG9zZWRcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHVwZ3JhZGUgcGFja2V0IC0gdXBncmFkaW5nXCIpO1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gICAgICAgICAgICAgICAgdGhpcy51cGdyYWRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRyYW5zcG9ydCgpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwidXBncmFkZVwiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBcImNsb3NpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwiZm9yY2VkIGNsb3NlXCIpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIHdlIGZvcmNlIGEgcG9sbGluZyBjeWNsZSB0byBlbnN1cmUgYSBmYXN0IHVwZ3JhZGVcbiAgICAgICAgY29uc3QgY2hlY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwb2xsaW5nXCIgPT09IHRoaXMudHJhbnNwb3J0Lm5hbWUgJiYgdGhpcy50cmFuc3BvcnQud3JpdGFibGUpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIndyaXRpbmcgYSBub29wIHBhY2tldCB0byBwb2xsaW5nIGZvciBmYXN0IHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IGZhbHNlO1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLmNoZWNrSW50ZXJ2YWxUaW1lcik7XG4gICAgICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIpO1xuICAgICAgICAgICAgdGhpcy51cGdyYWRlVGltZW91dFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvblRyYW5zcG9ydENsb3NlKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVycm9yID0gZXJyID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xpZW50IGRpZCBub3QgY29tcGxldGUgdXBncmFkZSAtICVzXCIsIGVycik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydCA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uVHJhbnNwb3J0Q2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBvbkVycm9yKFwidHJhbnNwb3J0IGNsb3NlZFwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3IoXCJzb2NrZXQgY2xvc2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgICB0cmFuc3BvcnQub24oXCJwYWNrZXRcIiwgb25QYWNrZXQpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICB0cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLm9uY2UoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYXJzIGxpc3RlbmVycyBhbmQgdGltZXJzIGFzc29jaWF0ZWQgd2l0aCBjdXJyZW50IHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsZWFyVHJhbnNwb3J0KCkge1xuICAgICAgICBsZXQgY2xlYW51cDtcbiAgICAgICAgY29uc3QgdG9DbGVhblVwID0gdGhpcy5jbGVhbnVwRm4ubGVuZ3RoO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRvQ2xlYW5VcDsgaSsrKSB7XG4gICAgICAgICAgICBjbGVhbnVwID0gdGhpcy5jbGVhbnVwRm4uc2hpZnQoKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWxlbmNlIGZ1cnRoZXIgdHJhbnNwb3J0IGVycm9ycyBhbmQgcHJldmVudCB1bmNhdWdodCBleGNlcHRpb25zXG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZGVidWcoXCJlcnJvciB0cmlnZ2VyZWQgYnkgZGlzY2FyZGVkIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGVuc3VyZSB0cmFuc3BvcnQgd29uJ3Qgc3RheSBvcGVuXG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjb25zaWRlcmVkIGNsb3NlZC5cbiAgICAgKiBQb3NzaWJsZSByZWFzb25zOiBgcGluZyB0aW1lb3V0YCwgYGNsaWVudCBlcnJvcmAsIGBwYXJzZSBlcnJvcmAsXG4gICAgICogYHRyYW5zcG9ydCBlcnJvcmAsIGBzZXJ2ZXIgY2xvc2VgLCBgdHJhbnNwb3J0IGNsb3NlYFxuICAgICAqL1xuICAgIG9uQ2xvc2UocmVhc29uLCBkZXNjcmlwdGlvbikge1xuICAgICAgICBpZiAoXCJjbG9zZWRcIiAhPT0gdGhpcy5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NlZFwiO1xuICAgICAgICAgICAgLy8gY2xlYXIgdGltZXJzXG4gICAgICAgICAgICAoMCwgdGltZXJzXzEuY2xlYXJUaW1lb3V0KSh0aGlzLnBpbmdJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ1RpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMudXBncmFkZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICAvLyBjbGVhbiB3cml0ZUJ1ZmZlciBpbiBuZXh0IHRpY2ssIHNvIGRldmVsb3BlcnMgY2FuIHN0aWxsXG4gICAgICAgICAgICAvLyBncmFiIHRoZSB3cml0ZUJ1ZmZlciBvbiAnY2xvc2UnIGV2ZW50XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyID0gW107XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJjbG9zZVwiLCByZWFzb24sIGRlc2NyaXB0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXR1cCBhbmQgbWFuYWdlIHNlbmQgY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldHVwU2VuZENhbGxiYWNrKCkge1xuICAgICAgICAvLyB0aGUgbWVzc2FnZSB3YXMgc2VudCBzdWNjZXNzZnVsbHksIGV4ZWN1dGUgdGhlIGNhbGxiYWNrXG4gICAgICAgIGNvbnN0IG9uRHJhaW4gPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5zZW50Q2FsbGJhY2tGbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VxRm4gPSB0aGlzLnNlbnRDYWxsYmFja0ZuLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2VxRm4pIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJleGVjdXRpbmcgc2VuZCBjYWxsYmFja1wiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VxRm4odGhpcy50cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHNlcUZuKSkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImV4ZWN1dGluZyBiYXRjaCBzZW5kIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBsID0gc2VxRm4ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgICBsZXQgaSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygc2VxRm5baV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXFGbltpXSh0aGlzLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZHJhaW5cIiwgb25EcmFpbik7XG4gICAgICAgIHRoaXMuY2xlYW51cEZuLnB1c2goKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQucmVtb3ZlTGlzdGVuZXIoXCJkcmFpblwiLCBvbkRyYWluKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgbWVzc2FnZSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IGZvciBjaGFpbmluZ1xuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgc2VuZChkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJtZXNzYWdlXCIsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSAtIHBhY2tldCB0eXBlXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kUGFja2V0KHR5cGUsIGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBvcHRpb25zKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XG4gICAgICAgICAgICBvcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICAgICAgb3B0aW9ucy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRpb25zLmNvbXByZXNzO1xuICAgICAgICBpZiAoXCJjbG9zaW5nXCIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJiBcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGRlYnVnKCdzZW5kaW5nIHBhY2tldCBcIiVzXCIgKCVzKScsIHR5cGUsIGRhdGEpO1xuICAgICAgICAgICAgY29uc3QgcGFja2V0ID0ge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChkYXRhKVxuICAgICAgICAgICAgICAgIHBhY2tldC5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgIC8vIGV4cG9ydHMgcGFja2V0Q3JlYXRlIGV2ZW50XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRDcmVhdGVcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIucHVzaChwYWNrZXQpO1xuICAgICAgICAgICAgLy8gYWRkIHNlbmQgY2FsbGJhY2sgdG8gb2JqZWN0LCBpZiBkZWZpbmVkXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgdGhpcy5wYWNrZXRzRm4ucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICB0aGlzLmZsdXNoKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdHMgdG8gZmx1c2ggdGhlIHBhY2tldHMgYnVmZmVyLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZmx1c2goKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUgJiZcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LndyaXRhYmxlICYmXG4gICAgICAgICAgICB0aGlzLndyaXRlQnVmZmVyLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoXCJmbHVzaGluZyBidWZmZXIgdG8gdHJhbnNwb3J0XCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZmx1c2hcIiwgdGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5lbWl0KFwiZmx1c2hcIiwgdGhpcywgdGhpcy53cml0ZUJ1ZmZlcik7XG4gICAgICAgICAgICBjb25zdCB3YnVmID0gdGhpcy53cml0ZUJ1ZmZlcjtcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIGlmICghdGhpcy50cmFuc3BvcnQuc3VwcG9ydHNGcmFtaW5nKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoKHRoaXMucGFja2V0c0ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4ucHVzaC5hcHBseSh0aGlzLnNlbnRDYWxsYmFja0ZuLCB0aGlzLnBhY2tldHNGbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuc2VuZCh3YnVmKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAgICAgdGhpcy5zZXJ2ZXIuZW1pdChcImRyYWluXCIsIHRoaXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhdmFpbGFibGUgdXBncmFkZXMgZm9yIHRoaXMgc29ja2V0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZ2V0QXZhaWxhYmxlVXBncmFkZXMoKSB7XG4gICAgICAgIGNvbnN0IGF2YWlsYWJsZVVwZ3JhZGVzID0gW107XG4gICAgICAgIGNvbnN0IGFsbFVwZ3JhZGVzID0gdGhpcy5zZXJ2ZXIudXBncmFkZXModGhpcy50cmFuc3BvcnQubmFtZSk7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgY29uc3QgbCA9IGFsbFVwZ3JhZGVzLmxlbmd0aDtcbiAgICAgICAgZm9yICg7IGkgPCBsOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZyA9IGFsbFVwZ3JhZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHRoaXMuc2VydmVyLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKHVwZykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVXBncmFkZXMucHVzaCh1cGcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdmFpbGFibGVVcGdyYWRlcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSBzb2NrZXQgYW5kIHVuZGVybHlpbmcgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBkaXNjYXJkIC0gb3B0aW9uYWwsIGRpc2NhcmQgdGhlIHRyYW5zcG9ydFxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjbG9zZShkaXNjYXJkKSB7XG4gICAgICAgIGlmIChcIm9wZW5cIiAhPT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgaWYgKHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UoXCJkcmFpblwiLCB0aGlzLmNsb3NlVHJhbnNwb3J0LmJpbmQodGhpcywgZGlzY2FyZCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xvc2VUcmFuc3BvcnQoZGlzY2FyZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBjbG9zZVRyYW5zcG9ydChkaXNjYXJkKSB7XG4gICAgICAgIGlmIChkaXNjYXJkKVxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQuZGlzY2FyZCgpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5jbG9zZSh0aGlzLm9uQ2xvc2UuYmluZCh0aGlzLCBcImZvcmNlZCBjbG9zZVwiKSk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgcGFyc2VyX3Y0ID0gcmVxdWlyZShcImVuZ2luZS5pby1wYXJzZXJcIik7XG5jb25zdCBwYXJzZXJfdjMgPSByZXF1aXJlKFwiLi9wYXJzZXItdjMvaW5kZXhcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp0cmFuc3BvcnRcIik7XG4vKipcbiAqIE5vb3AgZnVuY3Rpb24uXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxdWVzdFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICB0aGlzLmRpc2NhcmRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnByb3RvY29sID0gcmVxLl9xdWVyeS5FSU8gPT09IFwiNFwiID8gNCA6IDM7IC8vIDNyZCByZXZpc2lvbiBieSBkZWZhdWx0XG4gICAgICAgIHRoaXMucGFyc2VyID0gdGhpcy5wcm90b2NvbCA9PT0gNCA/IHBhcnNlcl92NCA6IHBhcnNlcl92MztcbiAgICB9XG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkeVN0YXRlO1xuICAgIH1cbiAgICBzZXQgcmVhZHlTdGF0ZShzdGF0ZSkge1xuICAgICAgICBkZWJ1ZyhcInJlYWR5U3RhdGUgdXBkYXRlZCBmcm9tICVzIHRvICVzICglcylcIiwgdGhpcy5fcmVhZHlTdGF0ZSwgc3RhdGUsIHRoaXMubmFtZSk7XG4gICAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBzdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRmxhZ3MgdGhlIHRyYW5zcG9ydCBhcyBkaXNjYXJkZWQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkaXNjYXJkKCkge1xuICAgICAgICB0aGlzLmRpc2NhcmRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGFuIGluY29taW5nIEhUVFAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3RcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgZGVidWcoXCJzZXR0aW5nIHJlcXVlc3RcIik7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlKGZuKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiID09PSB0aGlzLnJlYWR5U3RhdGUgfHwgXCJjbG9zaW5nXCIgPT09IHRoaXMucmVhZHlTdGF0ZSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zaW5nXCI7XG4gICAgICAgIHRoaXMuZG9DbG9zZShmbiB8fCBub29wKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggYSB0cmFuc3BvcnQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSBlcnJvclxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnJvciBkZXNjcmlwdGlvblxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25FcnJvcihtc2csIGRlc2MpIHtcbiAgICAgICAgaWYgKHRoaXMubGlzdGVuZXJzKFwiZXJyb3JcIikubGVuZ3RoKSB7XG4gICAgICAgICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGVyci50eXBlID0gXCJUcmFuc3BvcnRFcnJvclwiO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyLmRlc2NyaXB0aW9uID0gZGVzYztcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yZWQgdHJhbnNwb3J0IGVycm9yICVzICglcylcIiwgbXNnLCBkZXNjKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBwYXJzZWQgb3V0IGEgcGFja2V0cyBmcm9tIHRoZSBkYXRhIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICB0aGlzLmVtaXQoXCJwYWNrZXRcIiwgcGFja2V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggdGhlIGVuY29kZWQgcGFja2V0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgdGhpcy5vblBhY2tldCh0aGlzLnBhcnNlci5kZWNvZGVQYWNrZXQoZGF0YSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByb3RlY3RlZFxuICAgICAqL1xuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuVHJhbnNwb3J0ID0gVHJhbnNwb3J0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3Qgd2Vic29ja2V0XzEgPSByZXF1aXJlKFwiLi93ZWJzb2NrZXRcIik7XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgcG9sbGluZzogcG9sbGluZ18xLlBvbGxpbmcsXG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMS5XZWJTb2NrZXRcbn07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUG9sbGluZyA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6cG9sbGluZ1wiKTtcbmNvbnN0IGNvbXByZXNzaW9uTWV0aG9kcyA9IHtcbiAgICBnemlwOiB6bGliXzEuY3JlYXRlR3ppcCxcbiAgICBkZWZsYXRlOiB6bGliXzEuY3JlYXRlRGVmbGF0ZVxufTtcbmNsYXNzIFBvbGxpbmcgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIEhUVFAgcG9sbGluZyBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljLlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLmNsb3NlVGltZW91dCA9IDMwICogMTAwMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IG5hbWVcbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBcInBvbGxpbmdcIjtcbiAgICB9XG4gICAgZ2V0IHN1cHBvcnRzRnJhbWluZygpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVycmlkZXMgb25SZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkge1xuICAgICAgICBjb25zdCByZXMgPSByZXEucmVzO1xuICAgICAgICBpZiAocmVxLmdldE1ldGhvZCgpID09PSBcImdldFwiKSB7XG4gICAgICAgICAgICB0aGlzLm9uUG9sbFJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlcS5nZXRNZXRob2QoKSA9PT0gXCJwb3N0XCIpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IGF3YWl0aW5nIGZvciB1cyB0byBzZW5kIGRhdGEuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvblBvbGxSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLnJlcSkge1xuICAgICAgICAgICAgZGVidWcoXCJyZXF1ZXN0IG92ZXJsYXBcIik7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMucmVzLCAnLnJlcSBhbmQgLnJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcIm92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI1MDAgSW50ZXJuYWwgU2VydmVyIEVycm9yXCIpO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2V0dGluZyByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwb2xsIGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEgPSB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5jbGVhbnVwID0gY2xlYW51cDtcbiAgICAgICAgcmVzLm9uQWJvcnRlZChvbkNsb3NlKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBzdGlsbCB3cml0YWJsZSBidXQgaGFkIGEgcGVuZGluZyBjbG9zZSwgdHJpZ2dlciBhbiBlbXB0eSBzZW5kXG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlICYmIHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJpZ2dlcmluZyBlbXB0eSBzZW5kIHRvIGFwcGVuZCBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXhwZWN0ZWRDb250ZW50TGVuZ3RoID0gTnVtYmVyKHJlcS5oZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0pO1xuICAgICAgICBpZiAoIWV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggaGVhZGVyIHJlcXVpcmVkXCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDExIExlbmd0aCBSZXF1aXJlZFwiKS5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZWN0ZWRDb250ZW50TGVuZ3RoID4gdGhpcy5tYXhIdHRwQnVmZmVyU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicGF5bG9hZCB0b28gbGFyZ2VcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MTMgUGF5bG9hZCBUb28gTGFyZ2VcIikuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCaW5hcnkgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiID09PSByZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgaWYgKGlzQmluYXJ5ICYmIHRoaXMucHJvdG9jb2wgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUmVxID0gcmVxO1xuICAgICAgICB0aGlzLmRhdGFSZXMgPSByZXM7XG4gICAgICAgIGxldCBidWZmZXI7XG4gICAgICAgIGxldCBvZmZzZXQgPSAwO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgLy8gdW53YW50ZWQgZG93bmxvYWQgZGlhbG9nIG9uIGNlcnRhaW4gdXNlci1hZ2VudHMgKEdILTQzKVxuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIlxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmhlYWRlcnMocmVxLCBoZWFkZXJzKTtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihrZXksIFN0cmluZyhoZWFkZXJzW2tleV0pKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkVuZCA9IGJ1ZmZlciA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YShidWZmZXIudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICByZXMuZW5kKFwib2tcIik7XG4gICAgICAgIH07XG4gICAgICAgIHJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVzLm9uRGF0YSgoYXJyYXlCdWZmZXIsIGlzTGFzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdG90YWxMZW5ndGggPSBvZmZzZXQgKyBhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoID4gZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7IC8vIGNhbGxzIG9uQWJvcnRlZFxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghYnVmZmVyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVuZChCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShleHBlY3RlZENvbnRlbnRMZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICAgICAgICAgICAgaWYgKGlzTGFzdCkge1xuICAgICAgICAgICAgICAgIGlmICh0b3RhbExlbmd0aCAhPSBleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiY29udGVudC1sZW5ndGggbWlzbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQwMCBDb250ZW50LUxlbmd0aCBNaXNtYXRjaFwiKS5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0Q2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9uRW5kKGJ1ZmZlcik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb2Zmc2V0ID0gdG90YWxMZW5ndGg7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnVwIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGFSZXF1ZXN0Q2xlYW51cCgpIHtcbiAgICAgICAgdGhpcy5kYXRhUmVxID0gdGhpcy5kYXRhUmVzID0gbnVsbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBpbmNvbWluZyBkYXRhIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlZCBwYXlsb2FkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhY2tldCA9PiB7XG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHhociBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvbkNsb3NlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHBlbmRpbmcgcG9sbCByZXF1ZXN0XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXBwZW5kaW5nIGNsb3NlIHBhY2tldCB0byBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgcGFja2V0cy5wdXNoKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9Xcml0ZSA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUocGFja2V0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0Lm9wdGlvbnMgJiYgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YSwgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGFzIHJlc3BvbnNlIHRvIHBvbGwgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICB3cml0ZShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEuY2xlYW51cCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBleHBsaWNpdCBVVEYtOCBpcyByZXF1aXJlZCBmb3IgcGFnZXMgbm90IHNlcnZlZCB1bmRlciB1dGZcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBpc1N0cmluZ1xuICAgICAgICAgICAgPyBcInRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLThcIlxuICAgICAgICAgICAgOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uZCA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzKHRoaXMucmVxLCBoZWFkZXJzKTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWRlcihrZXksIFN0cmluZyhoZWFkZXJzW2tleV0pKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmh0dHBDb21wcmVzc2lvbiB8fCAhb3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBpc1N0cmluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCB0aGlzLmh0dHBDb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoW1wiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZyhcImNvbXByZXNzaW5nXCIpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGxldCBucmVhZCA9IDA7XG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGxldCBjbG9zZVRpbWVvdXRUaW1lcjtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCB3cml0YWJsZSAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzY2FyZGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkaXNjYXJkZWQgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgd3JpdGFibGUgLSBidWZmZXJpbmcgb3JkZXJseSBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBvbkNsb3NlO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KG9uQ2xvc2UsIHRoaXMuY2xvc2VUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlYWRlcnMgZm9yIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxIC0gcmVxdWVzdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBleHRyYSBoZWFkZXJzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgaGVhZGVycyhyZXEsIGhlYWRlcnMpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIC8vIHByZXZlbnQgWFNTIHdhcm5pbmdzIG9uIElFXG4gICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9wdWxsLzEzMzNcbiAgICAgICAgY29uc3QgdWEgPSByZXEuaGVhZGVyc1tcInVzZXItYWdlbnRcIl07XG4gICAgICAgIGlmICh1YSAmJiAofnVhLmluZGV4T2YoXCI7TVNJRVwiKSB8fCB+dWEuaW5kZXhPZihcIlRyaWRlbnQvXCIpKSkge1xuICAgICAgICAgICAgaGVhZGVyc1tcIlgtWFNTLVByb3RlY3Rpb25cIl0gPSBcIjBcIjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJoZWFkZXJzXCIsIGhlYWRlcnMsIHJlcSk7XG4gICAgICAgIHJldHVybiBoZWFkZXJzO1xuICAgIH1cbn1cbmV4cG9ydHMuUG9sbGluZyA9IFBvbGxpbmc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuV2ViU29ja2V0ID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6d3NcIik7XG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyB0cmFuc3BvcnRfMS5UcmFuc3BvcnQge1xuICAgIC8qKlxuICAgICAqIFdlYlNvY2tldCB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSB1cGdyYWRlIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBoYW5kbGVzVXBncmFkZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZlcnRpc2UgZnJhbWluZyBzdXBwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgc3VwcG9ydHNGcmFtaW5nKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWNrZXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHNpbmNlIHdzIG1vZGlmaWVzIGl0XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgaXNCaW5hcnkgPSB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIjtcbiAgICAgICAgICAgIGNvbnN0IGNvbXByZXNzID0gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpID4gdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQ7XG4gICAgICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSwgaXNCaW5hcnksIGNvbXByZXNzKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChwYWNrZXRzKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zICYmIHR5cGVvZiBwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHNlbmQocGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIHNlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgICAgIC8vIGNhbGwgZm4gZmlyc3Qgc2luY2Ugc29ja2V0LmNsb3NlKCkgaW1tZWRpYXRlbHkgZW1pdHMgYSBcImNsb3NlXCIgZXZlbnRcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlNvY2tldCA9IFdlYlNvY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgcG9sbGluZ18xID0gcmVxdWlyZShcIi4vcG9sbGluZ1wiKTtcbmNvbnN0IHBvbGxpbmdfanNvbnBfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmctanNvbnBcIik7XG5jb25zdCB3ZWJzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwb2xsaW5nOiBwb2xsaW5nLFxuICAgIHdlYnNvY2tldDogd2Vic29ja2V0XzEuV2ViU29ja2V0XG59O1xuLyoqXG4gKiBQb2xsaW5nIHBvbHltb3JwaGljIGNvbnN0cnVjdG9yLlxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwb2xsaW5nKHJlcSkge1xuICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgcmVxLl9xdWVyeS5qKSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9sbGluZ19qc29ucF8xLkpTT05QKHJlcSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gbmV3IHBvbGxpbmdfMS5Qb2xsaW5nKHJlcSk7XG4gICAgfVxufVxucG9sbGluZy51cGdyYWRlc1RvID0gW1wid2Vic29ja2V0XCJdO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkpTT05QID0gdm9pZCAwO1xuY29uc3QgcG9sbGluZ18xID0gcmVxdWlyZShcIi4vcG9sbGluZ1wiKTtcbmNvbnN0IHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgckRvdWJsZVNsYXNoZXMgPSAvXFxcXFxcXFxuL2c7XG5jb25zdCByU2xhc2hlcyA9IC8oXFxcXCk/XFxcXG4vZztcbmNsYXNzIEpTT05QIGV4dGVuZHMgcG9sbGluZ18xLlBvbGxpbmcge1xuICAgIC8qKlxuICAgICAqIEpTT04tUCBwb2xsaW5nIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuaGVhZCA9IFwiX19fZWlvW1wiICsgKHJlcS5fcXVlcnkuaiB8fCBcIlwiKS5yZXBsYWNlKC9bXjAtOV0vZywgXCJcIikgKyBcIl0oXCI7XG4gICAgICAgIHRoaXMuZm9vdCA9IFwiKTtcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBpbmNvbWluZyBkYXRhLlxuICAgICAqIER1ZSB0byBhIGJ1ZyBpbiBcXG4gaGFuZGxpbmcgYnkgYnJvd3NlcnMsIHdlIGV4cGVjdCBhIGVzY2FwZWQgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgLy8gd2UgbGV2ZXJhZ2UgdGhlIHFzIG1vZHVsZSBzbyB0aGF0IHdlIGdldCBidWlsdC1pbiBEb1MgcHJvdGVjdGlvblxuICAgICAgICAvLyBhbmQgdGhlIGZhc3QgYWx0ZXJuYXRpdmUgdG8gZGVjb2RlVVJJQ29tcG9uZW50XG4gICAgICAgIGRhdGEgPSBxcy5wYXJzZShkYXRhKS5kO1xuICAgICAgICBpZiAoXCJzdHJpbmdcIiA9PT0gdHlwZW9mIGRhdGEpIHtcbiAgICAgICAgICAgIC8vIGNsaWVudCB3aWxsIHNlbmQgYWxyZWFkeSBlc2NhcGVkIG5ld2xpbmVzIGFzIFxcXFxcXFxcbiBhbmQgbmV3bGluZXMgYXMgXFxcXG5cbiAgICAgICAgICAgIC8vIFxcXFxuIG11c3QgYmUgcmVwbGFjZWQgd2l0aCBcXG4gYW5kIFxcXFxcXFxcbiB3aXRoIFxcXFxuXG4gICAgICAgICAgICBkYXRhID0gZGF0YS5yZXBsYWNlKHJTbGFzaGVzLCBmdW5jdGlvbiAobWF0Y2gsIHNsYXNoZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2xhc2hlcyA/IG1hdGNoIDogXCJcXG5cIjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3VwZXIub25EYXRhKGRhdGEucmVwbGFjZShyRG91YmxlU2xhc2hlcywgXCJcXFxcblwiKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyB3ZSBtdXN0IG91dHB1dCB2YWxpZCBqYXZhc2NyaXB0LCBub3QgdmFsaWQganNvblxuICAgICAgICAvLyBzZWU6IGh0dHA6Ly90aW1lbGVzc3JlcG8uY29tL2pzb24taXNudC1hLWphdmFzY3JpcHQtc3Vic2V0XG4gICAgICAgIGNvbnN0IGpzID0gSlNPTi5zdHJpbmdpZnkoZGF0YSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI4L2csIFwiXFxcXHUyMDI4XCIpXG4gICAgICAgICAgICAucmVwbGFjZSgvXFx1MjAyOS9nLCBcIlxcXFx1MjAyOVwiKTtcbiAgICAgICAgLy8gcHJlcGFyZSByZXNwb25zZVxuICAgICAgICBkYXRhID0gdGhpcy5oZWFkICsganMgKyB0aGlzLmZvb3Q7XG4gICAgICAgIHN1cGVyLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgIH1cbn1cbmV4cG9ydHMuSlNPTlAgPSBKU09OUDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpwb2xsaW5nXCIpO1xuY29uc3QgY29tcHJlc3Npb25NZXRob2RzID0ge1xuICAgIGd6aXA6IHpsaWJfMS5jcmVhdGVHemlwLFxuICAgIGRlZmxhdGU6IHpsaWJfMS5jcmVhdGVEZWZsYXRlXG59O1xuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogSFRUUCBwb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICBnZXQgc3VwcG9ydHNGcmFtaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfVxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUmVxdWVzdChyZXEpIHtcbiAgICAgICAgY29uc3QgcmVzID0gcmVxLnJlcztcbiAgICAgICAgaWYgKFwiR0VUXCIgPT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMub25Qb2xsUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoXCJQT1NUXCIgPT09IHJlcS5tZXRob2QpIHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDUwMCk7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3QgYXdhaXRpbmcgZm9yIHVzIHRvIHNlbmQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUG9sbFJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcXVlc3Qgb3ZlcmxhcFwiKTtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwib3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwicG9sbCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5yZXEgPSB0aGlzLnJlcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5jbGVhbnVwID0gY2xlYW51cDtcbiAgICAgICAgcmVxLm9uKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgLy8gaWYgd2UncmUgc3RpbGwgd3JpdGFibGUgYnV0IGhhZCBhIHBlbmRpbmcgY2xvc2UsIHRyaWdnZXIgYW4gZW1wdHkgc2VuZFxuICAgICAgICBpZiAodGhpcy53cml0YWJsZSAmJiB0aGlzLnNob3VsZENsb3NlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyaWdnZXJpbmcgZW1wdHkgc2VuZCB0byBhcHBlbmQgY2xvc2UgcGFja2V0XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCB3aXRoIGRhdGEuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFSZXEpIHtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5kYXRhUmVzLCAnLmRhdGFSZXEgYW5kIC5kYXRhUmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiZGF0YSByZXF1ZXN0IG92ZXJsYXAgZnJvbSBjbGllbnRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDUwMCk7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXNCaW5hcnkgPSBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiID09PSByZXEuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXTtcbiAgICAgICAgaWYgKGlzQmluYXJ5ICYmIHRoaXMucHJvdG9jb2wgPT09IDQpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGNvbnRlbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kYXRhUmVxID0gcmVxO1xuICAgICAgICB0aGlzLmRhdGFSZXMgPSByZXM7XG4gICAgICAgIGxldCBjaHVua3MgPSBpc0JpbmFyeSA/IEJ1ZmZlci5jb25jYXQoW10pIDogXCJcIjtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgb25EYXRhKTtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImVuZFwiLCBvbkVuZCk7XG4gICAgICAgICAgICByZXEucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlcSA9IHRoaXMuZGF0YVJlcyA9IGNodW5rcyA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3QgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRGF0YSA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgbGV0IGNvbnRlbnRMZW5ndGg7XG4gICAgICAgICAgICBpZiAoaXNCaW5hcnkpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBCdWZmZXIuY29uY2F0KFtjaHVua3MsIGRhdGFdKTtcbiAgICAgICAgICAgICAgICBjb250ZW50TGVuZ3RoID0gY2h1bmtzLmxlbmd0aDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNodW5rcyArPSBkYXRhO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChjaHVua3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbnRlbnRMZW5ndGggPiB0aGlzLm1heEh0dHBCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzID0gaXNCaW5hcnkgPyBCdWZmZXIuY29uY2F0KFtdKSA6IFwiXCI7XG4gICAgICAgICAgICAgICAgcmVxLmNvbm5lY3Rpb24uZGVzdHJveSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkVuZCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGNodW5rcyk7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgICAgIC8vIHRleHQvaHRtbCBpcyByZXF1aXJlZCBpbnN0ZWFkIG9mIHRleHQvcGxhaW4gdG8gYXZvaWQgYW5cbiAgICAgICAgICAgICAgICAvLyB1bndhbnRlZCBkb3dubG9hZCBkaWFsb2cgb24gY2VydGFpbiB1c2VyLWFnZW50cyAoR0gtNDMpXG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L2h0bWxcIixcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtTGVuZ3RoXCI6IDJcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgdGhpcy5oZWFkZXJzKHJlcSwgaGVhZGVycykpO1xuICAgICAgICAgICAgcmVzLmVuZChcIm9rXCIpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9O1xuICAgICAgICByZXEub24oXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgaWYgKCFpc0JpbmFyeSlcbiAgICAgICAgICAgIHJlcS5zZXRFbmNvZGluZyhcInV0ZjhcIik7XG4gICAgICAgIHJlcS5vbihcImRhdGFcIiwgb25EYXRhKTtcbiAgICAgICAgcmVxLm9uKFwiZW5kXCIsIG9uRW5kKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJvY2Vzc2VzIHRoZSBpbmNvbWluZyBkYXRhIHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZW5jb2RlZCBwYXlsb2FkXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhKGRhdGEpIHtcbiAgICAgICAgZGVidWcoJ3JlY2VpdmVkIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICBjb25zdCBjYWxsYmFjayA9IHBhY2tldCA9PiB7XG4gICAgICAgICAgICBpZiAoXCJjbG9zZVwiID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHhociBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vblBhY2tldChwYWNrZXQpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZGVjb2RlUGF5bG9hZChkYXRhLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEpLmZvckVhY2goY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvbkNsb3NlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIC8vIGNsb3NlIHBlbmRpbmcgcG9sbCByZXF1ZXN0XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgICAgIHN1cGVyLm9uQ2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXBwZW5kaW5nIGNsb3NlIHBhY2tldCB0byBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgcGFja2V0cy5wdXNoKHsgdHlwZTogXCJjbG9zZVwiIH0pO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZG9Xcml0ZSA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSBwYWNrZXRzLnNvbWUocGFja2V0ID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFja2V0Lm9wdGlvbnMgJiYgcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMud3JpdGUoZGF0YSwgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgdGhpcy5zdXBwb3J0c0JpbmFyeSwgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5lbmNvZGVQYXlsb2FkKHBhY2tldHMsIGRvV3JpdGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBkYXRhIGFzIHJlc3BvbnNlIHRvIHBvbGwgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICB3cml0ZShkYXRhLCBvcHRpb25zKSB7XG4gICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICB0aGlzLmRvV3JpdGUoZGF0YSwgb3B0aW9ucywgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXEuY2xlYW51cCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgdGhlIHdyaXRlLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICAvLyBleHBsaWNpdCBVVEYtOCBpcyByZXF1aXJlZCBmb3IgcGFnZXMgbm90IHNlcnZlZCB1bmRlciB1dGZcbiAgICAgICAgY29uc3QgaXNTdHJpbmcgPSB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIjtcbiAgICAgICAgY29uc3QgY29udGVudFR5cGUgPSBpc1N0cmluZ1xuICAgICAgICAgICAgPyBcInRleHQvcGxhaW47IGNoYXJzZXQ9VVRGLThcIlxuICAgICAgICAgICAgOiBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0ge1xuICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogY29udGVudFR5cGVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVzcG9uZCA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgaGVhZGVyc1tcIkNvbnRlbnQtTGVuZ3RoXCJdID1cbiAgICAgICAgICAgICAgICBcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWQoMjAwLCB0aGlzLmhlYWRlcnModGhpcy5yZXEsIGhlYWRlcnMpKTtcbiAgICAgICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICghdGhpcy5odHRwQ29tcHJlc3Npb24gfHwgIW9wdGlvbnMuY29tcHJlc3MpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuID0gaXNTdHJpbmcgPyBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICBpZiAobGVuIDwgdGhpcy5odHRwQ29tcHJlc3Npb24udGhyZXNob2xkKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gYWNjZXB0cyh0aGlzLnJlcSkuZW5jb2RpbmdzKFtcImd6aXBcIiwgXCJkZWZsYXRlXCJdKTtcbiAgICAgICAgaWYgKCFlbmNvZGluZykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCAoZXJyLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkKDUwMCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1FbmNvZGluZ1wiXSA9IGVuY29kaW5nO1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbXByZXNzZXMgZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNvbXByZXNzKGRhdGEsIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgICBkZWJ1ZyhcImNvbXByZXNzaW5nXCIpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gW107XG4gICAgICAgIGxldCBucmVhZCA9IDA7XG4gICAgICAgIGNvbXByZXNzaW9uTWV0aG9kc1tlbmNvZGluZ10odGhpcy5odHRwQ29tcHJlc3Npb24pXG4gICAgICAgICAgICAub24oXCJlcnJvclwiLCBjYWxsYmFjaylcbiAgICAgICAgICAgIC5vbihcImRhdGFcIiwgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICBidWZmZXJzLnB1c2goY2h1bmspO1xuICAgICAgICAgICAgbnJlYWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLm9uKFwiZW5kXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIEJ1ZmZlci5jb25jYXQoYnVmZmVycywgbnJlYWQpKTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5lbmQoZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIGxldCBjbG9zZVRpbWVvdXRUaW1lcjtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgZGVidWcoXCJhYm9ydGluZyBvbmdvaW5nIGRhdGEgcmVxdWVzdFwiKTtcbiAgICAgICAgICAgIHRoaXMuZGF0YVJlcS5kZXN0cm95KCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dChjbG9zZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCB3cml0YWJsZSAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcImNsb3NlXCIgfV0pO1xuICAgICAgICAgICAgb25DbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuZGlzY2FyZGVkKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkaXNjYXJkZWQgLSBjbG9zaW5nIHJpZ2h0IGF3YXlcIik7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBub3Qgd3JpdGFibGUgLSBidWZmZXJpbmcgb3JkZXJseSBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuc2hvdWxkQ2xvc2UgPSBvbkNsb3NlO1xuICAgICAgICAgICAgY2xvc2VUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KG9uQ2xvc2UsIHRoaXMuY2xvc2VUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGhlYWRlcnMgZm9yIGEgcmVzcG9uc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIGhlYWRlcnNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBoZWFkZXJzKHJlcSwgaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgLy8gcHJldmVudCBYU1Mgd2FybmluZ3Mgb24gSUVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYXJuQm9vc3Qvc29ja2V0LmlvL3B1bGwvMTMzM1xuICAgICAgICBjb25zdCB1YSA9IHJlcS5oZWFkZXJzW1widXNlci1hZ2VudFwiXTtcbiAgICAgICAgaWYgKHVhICYmICh+dWEuaW5kZXhPZihcIjtNU0lFXCIpIHx8IH51YS5pbmRleE9mKFwiVHJpZGVudC9cIikpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1YU1MtUHJvdGVjdGlvblwiXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp3c1wiKTtcbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IHRyYW5zcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX1cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHJlcSkge1xuICAgICAgICBzdXBlcihyZXEpO1xuICAgICAgICB0aGlzLnNvY2tldCA9IHJlcS53ZWJzb2NrZXQ7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwibWVzc2FnZVwiLCAoZGF0YSwgaXNCaW5hcnkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBpc0JpbmFyeSA/IGRhdGEgOiBkYXRhLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgbWVzc2FnZSk7XG4gICAgICAgICAgICBzdXBlci5vbkRhdGEobWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnNvY2tldC5vbmNlKFwiY2xvc2VcIiwgdGhpcy5vbkNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLnNvY2tldC5vbihcImVycm9yXCIsIHRoaXMub25FcnJvci5iaW5kKHRoaXMpKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMucGVyTWVzc2FnZURlZmxhdGUgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwid2Vic29ja2V0XCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSB1cGdyYWRlIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBoYW5kbGVzVXBncmFkZXMoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZHZlcnRpc2UgZnJhbWluZyBzdXBwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgc3VwcG9ydHNGcmFtaW5nKCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0IHBheWxvYWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBwYWNrZXRzXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2VuZChwYWNrZXRzKSB7XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHBhY2tldHMuc2hpZnQoKTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWNrZXQgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gYWx3YXlzIGNyZWF0ZXMgYSBuZXcgb2JqZWN0IHNpbmNlIHdzIG1vZGlmaWVzIGl0XG4gICAgICAgIGNvbnN0IG9wdHMgPSB7fTtcbiAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRzLmNvbXByZXNzID0gcGFja2V0Lm9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZCA9IGRhdGEgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW4gPSBcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgaWYgKGxlbiA8IHRoaXMucGVyTWVzc2FnZURlZmxhdGUudGhyZXNob2xkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1Zygnd3JpdGluZyBcIiVzXCInLCBkYXRhKTtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoZGF0YSwgb3B0cywgZXJyID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5vbkVycm9yKFwid3JpdGUgZXJyb3JcIiwgZXJyLnN0YWNrKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmQocGFja2V0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHBhY2tldC5vcHRpb25zICYmIHR5cGVvZiBwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHNlbmQocGFja2V0Lm9wdGlvbnMud3NQcmVFbmNvZGVkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBhY2tldChwYWNrZXQsIHRoaXMuc3VwcG9ydHNCaW5hcnksIHNlbmQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgZG9DbG9zZShmbikge1xuICAgICAgICBkZWJ1ZyhcImNsb3NpbmdcIik7XG4gICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKCk7XG4gICAgICAgIGZuICYmIGZuKCk7XG4gICAgfVxufVxuZXhwb3J0cy5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudVNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBzZXJ2ZXJfMSA9IHJlcXVpcmUoXCIuL3NlcnZlclwiKTtcbmNvbnN0IHRyYW5zcG9ydHNfdXdzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzLXV3c1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmU6dXdzXCIpO1xuY2xhc3MgdVNlcnZlciBleHRlbmRzIHNlcnZlcl8xLkJhc2VTZXJ2ZXIge1xuICAgIGluaXQoKSB7IH1cbiAgICBjbGVhbnVwKCkgeyB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmUocmVxLCByZXMpIHtcbiAgICAgICAgcmVxLm1ldGhvZCA9IHJlcS5nZXRNZXRob2QoKS50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBjb25zdCBwYXJhbXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHJlcS5nZXRRdWVyeSgpKTtcbiAgICAgICAgcmVxLl9xdWVyeSA9IE9iamVjdC5mcm9tRW50cmllcyhwYXJhbXMuZW50cmllcygpKTtcbiAgICAgICAgcmVxLmhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmVxLmZvckVhY2goKGtleSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgIHJlcS5oZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcS5jb25uZWN0aW9uID0ge1xuICAgICAgICAgICAgcmVtb3RlQWRkcmVzczogQnVmZmVyLmZyb20ocmVzLmdldFJlbW90ZUFkZHJlc3NBc1RleHQoKSkudG9TdHJpbmcoKVxuICAgICAgICB9O1xuICAgICAgICByZXMub25BYm9ydGVkKCgpID0+IHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVzcG9uc2UgaGFzIGJlZW4gYWJvcnRlZFwiKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzX3V3c18xLmRlZmF1bHRbdHJhbnNwb3J0TmFtZV0ocmVxKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoIHRoZSBlbmdpbmUgdG8gYSDCtVdlYlNvY2tldHMuanMgc2VydmVyXG4gICAgICogQHBhcmFtIGFwcFxuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICovXG4gICAgYXR0YWNoKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLywgb3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHBhdGggPSAob3B0aW9ucy5wYXRoIHx8IFwiL2VuZ2luZS5pb1wiKS5yZXBsYWNlKC9cXC8kLywgXCJcIikgKyBcIi9cIjtcbiAgICAgICAgYXBwXG4gICAgICAgICAgICAuYW55KHBhdGgsIHRoaXMuaGFuZGxlUmVxdWVzdC5iaW5kKHRoaXMpKVxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIC53cyhwYXRoLCB7XG4gICAgICAgICAgICBjb21wcmVzc2lvbjogb3B0aW9ucy5jb21wcmVzc2lvbixcbiAgICAgICAgICAgIGlkbGVUaW1lb3V0OiBvcHRpb25zLmlkbGVUaW1lb3V0LFxuICAgICAgICAgICAgbWF4QmFja3ByZXNzdXJlOiBvcHRpb25zLm1heEJhY2twcmVzc3VyZSxcbiAgICAgICAgICAgIG1heFBheWxvYWRMZW5ndGg6IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZSxcbiAgICAgICAgICAgIHVwZ3JhZGU6IHRoaXMuaGFuZGxlVXBncmFkZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgb3Blbjogd3MgPT4ge1xuICAgICAgICAgICAgICAgIHdzLnRyYW5zcG9ydC5zb2NrZXQgPSB3cztcbiAgICAgICAgICAgICAgICB3cy50cmFuc3BvcnQud3JpdGFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHdzLnRyYW5zcG9ydC5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVzc2FnZTogKHdzLCBtZXNzYWdlLCBpc0JpbmFyeSkgPT4ge1xuICAgICAgICAgICAgICAgIHdzLnRyYW5zcG9ydC5vbkRhdGEoaXNCaW5hcnkgPyBtZXNzYWdlIDogQnVmZmVyLmZyb20obWVzc2FnZSkudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2U6ICh3cywgY29kZSwgbWVzc2FnZSkgPT4ge1xuICAgICAgICAgICAgICAgIHdzLnRyYW5zcG9ydC5vbkNsb3NlKGNvZGUsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaGFuZGxlUmVxdWVzdChyZXMsIHJlcSkge1xuICAgICAgICBkZWJ1ZygnaGFuZGxpbmcgXCIlc1wiIGh0dHAgcmVxdWVzdCBcIiVzXCInLCByZXEuZ2V0TWV0aG9kKCksIHJlcS5nZXRVcmwoKSk7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEsIHJlcyk7XG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcS5yZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNldHRpbmcgbmV3IHJlcXVlc3QgZm9yIGV4aXN0aW5nIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbcmVxLl9xdWVyeS5zaWRdLnRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gdGhpcy5hYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgY2xvc2VDb25uZWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuY29yc01pZGRsZXdhcmUpIHtcbiAgICAgICAgICAgIC8vIG5lZWRlZCB0byBidWZmZXIgaGVhZGVycyB1bnRpbCB0aGUgc3RhdHVzIGlzIGNvbXB1dGVkXG4gICAgICAgICAgICByZXEucmVzID0gbmV3IFJlc3BvbnNlV3JhcHBlcihyZXMpO1xuICAgICAgICAgICAgdGhpcy5jb3JzTWlkZGxld2FyZS5jYWxsKG51bGwsIHJlcSwgcmVxLnJlcywgKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVVwZ3JhZGUocmVzLCByZXEsIGNvbnRleHQpIHtcbiAgICAgICAgZGVidWcoXCJvbiB1cGdyYWRlXCIpO1xuICAgICAgICB0aGlzLnByZXBhcmUocmVxLCByZXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgdHJ1ZSwgYXN5bmMgKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdLFxuICAgICAgICAgICAgICAgICAgICBjb250ZXh0OiBlcnJvckNvbnRleHRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAgICAgbGV0IHRyYW5zcG9ydDtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IHRoaXMuY2xpZW50c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ1cGdyYWRlIGF0dGVtcHQgZm9yIGNsb3NlZCBjbGllbnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkaW5nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGhhcyBhbHJlYWR5IGJlZW4gdHJ5aW5nIHRvIHVwZ3JhZGVcIik7XG4gICAgICAgICAgICAgICAgICAgIHJlcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjbGllbnQudXBncmFkZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGluZyBleGlzdGluZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydCA9IHRoaXMuY3JlYXRlVHJhbnNwb3J0KHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEpO1xuICAgICAgICAgICAgICAgICAgICBjbGllbnQubWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gYXdhaXQgdGhpcy5oYW5kc2hha2UocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSwgKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSk7XG4gICAgICAgICAgICAgICAgaWYgKCF0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlcy51cGdyYWRlKHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRcbiAgICAgICAgICAgIH0sIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LWtleVwiKSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQtcHJvdG9jb2xcIiksIHJlcS5nZXRIZWFkZXIoXCJzZWMtd2Vic29ja2V0LWV4dGVuc2lvbnNcIiksIGNvbnRleHQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IGVycm9yQ29kZSA9PT0gc2VydmVyXzEuU2VydmVyLmVycm9ycy5GT1JCSURERU5cbiAgICAgICAgICAgID8gXCI0MDMgRm9yYmlkZGVuXCJcbiAgICAgICAgICAgIDogXCI0MDAgQmFkIFJlcXVlc3RcIjtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dCAmJiBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgPyBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICAgICAgOiBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JNZXNzYWdlc1tlcnJvckNvZGVdO1xuICAgICAgICByZXMud3JpdGVTdGF0dXMoc3RhdHVzQ29kZSk7XG4gICAgICAgIHJlcy53cml0ZUhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG4gICAgICAgIHJlcy5lbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgY29kZTogZXJyb3JDb2RlLFxuICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICB9KSk7XG4gICAgfVxufVxuZXhwb3J0cy51U2VydmVyID0gdVNlcnZlcjtcbmNsYXNzIFJlc3BvbnNlV3JhcHBlciB7XG4gICAgY29uc3RydWN0b3IocmVzKSB7XG4gICAgICAgIHRoaXMucmVzID0gcmVzO1xuICAgICAgICB0aGlzLnN0YXR1c1dyaXR0ZW4gPSBmYWxzZTtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gW107XG4gICAgfVxuICAgIHNldCBzdGF0dXNDb2RlKHN0YXR1cykge1xuICAgICAgICB0aGlzLndyaXRlU3RhdHVzKHN0YXR1cyA9PT0gMjAwID8gXCIyMDAgT0tcIiA6IFwiMjA0IE5vIENvbnRlbnRcIik7XG4gICAgfVxuICAgIHNldEhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIG5lZWRlZCBieSB2YXJ5OiBodHRwczovL2dpdGh1Yi5jb20vanNodHRwL3ZhcnkvYmxvYi81ZDcyNWQwNTliMzg3MTAyNWNmNzUzZTlkZmEwODkyNGQwYmNmYThmL2luZGV4LmpzI0wxMzRcbiAgICBnZXRIZWFkZXIoKSB7IH1cbiAgICB3cml0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgdGhpcy5yZXMud3JpdGVTdGF0dXMoc3RhdHVzKTtcbiAgICAgICAgdGhpcy5zdGF0dXNXcml0dGVuID0gdHJ1ZTtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcmVkSGVhZGVycygpO1xuICAgIH1cbiAgICB3cml0ZUhlYWRlcihrZXksIHZhbHVlKSB7XG4gICAgICAgIGlmIChrZXkgPT09IFwiQ29udGVudC1MZW5ndGhcIikge1xuICAgICAgICAgICAgLy8gdGhlIGNvbnRlbnQgbGVuZ3RoIGlzIGF1dG9tYXRpY2FsbHkgYWRkZWQgYnkgdVdlYlNvY2tldHMuanNcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXNXcml0dGVuKSB7XG4gICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWRlcihrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaGVhZGVycy5wdXNoKFtrZXksIHZhbHVlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgd3JpdGVCdWZmZXJlZEhlYWRlcnMoKSB7XG4gICAgICAgIHRoaXMuaGVhZGVycy5mb3JFYWNoKChba2V5LCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5kKGRhdGEpIHtcbiAgICAgICAgaWYgKCF0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIC8vIHN0YXR1cyB3aWxsIGJlIGluZmVycmVkIGFzIFwiMjAwIE9LXCJcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXJlZEhlYWRlcnMoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgfVxuICAgIG9uRGF0YShmbikge1xuICAgICAgICB0aGlzLnJlcy5vbkRhdGEoZm4pO1xuICAgIH1cbiAgICBvbkFib3J0ZWQoZm4pIHtcbiAgICAgICAgdGhpcy5yZXMub25BYm9ydGVkKGZuKTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gZXhwb3J0cy5Ccm9hZGNhc3RPcGVyYXRvciA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jbGFzcyBCcm9hZGNhc3RPcGVyYXRvciB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vbXMgPSBuZXcgU2V0KCksIGV4Y2VwdFJvb21zID0gbmV3IFNldCgpLCBmbGFncyA9IHt9KSB7XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IGFkYXB0ZXI7XG4gICAgICAgIHRoaXMucm9vbXMgPSByb29tcztcbiAgICAgICAgdGhpcy5leGNlcHRSb29tcyA9IGV4Y2VwdFJvb21zO1xuICAgICAgICB0aGlzLmZsYWdzID0gZmxhZ3M7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gYSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IgaW5zdGFuY2VcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICBjb25zdCByb29tcyA9IG5ldyBTZXQodGhpcy5yb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IHJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICBjb25zdCBleGNlcHRSb29tcyA9IG5ldyBTZXQodGhpcy5leGNlcHRSb29tcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJvb20pKSB7XG4gICAgICAgICAgICByb29tLmZvckVhY2goKHIpID0+IGV4Y2VwdFJvb21zLmFkZChyKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBleGNlcHRSb29tcy5hZGQocm9vbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIGV4Y2VwdFJvb21zLCB0aGlzLmZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb21wcmVzcyAtIGlmIGB0cnVlYCwgY29tcHJlc3NlcyB0aGUgc2VuZGluZyBkYXRhXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgY29tcHJlc3MgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyB2b2xhdGlsZTogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IGxvY2FsOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHRydWVcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoc29ja2V0XzEuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2V2fVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNldCB1cCBwYWNrZXQgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbZXYsIC4uLmFyZ3NdO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGRhdGFbZGF0YS5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FsbGJhY2tzIGFyZSBub3Qgc3VwcG9ydGVkIHdoZW4gYnJvYWRjYXN0aW5nXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCB7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgICAgIGZsYWdzOiB0aGlzLmZsYWdzLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmFkYXB0ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGFkYXB0ZXIgZm9yIHRoaXMgbmFtZXNwYWNlLCBhcmUgeW91IHRyeWluZyB0byBnZXQgdGhlIGxpc3Qgb2YgY2xpZW50cyBvZiBhIGR5bmFtaWMgbmFtZXNwYWNlP1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLnNvY2tldHModGhpcy5yb29tcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXJcbiAgICAgICAgICAgIC5mZXRjaFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgIH0pXG4gICAgICAgICAgICAudGhlbigoc29ja2V0cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHNvY2tldHMubWFwKChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0IGluc3RhbmNlb2Ygc29ja2V0XzEuU29ja2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZJWE1FIHRoZSBUeXBlU2NyaXB0IGNvbXBpbGVyIGNvbXBsYWlucyBhYm91dCBtaXNzaW5nIHByaXZhdGUgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBSZW1vdGVTb2NrZXQodGhpcy5hZGFwdGVyLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5hZGRTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kZWxTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICB9LCBBcnJheS5pc0FycmF5KHJvb20pID8gcm9vbSA6IFtyb29tXSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlci5kaXNjb25uZWN0U29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgfSwgY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuQnJvYWRjYXN0T3BlcmF0b3IgPSBCcm9hZGNhc3RPcGVyYXRvcjtcbi8qKlxuICogRXhwb3NlIG9mIHN1YnNldCBvZiB0aGUgYXR0cmlidXRlcyBhbmQgbWV0aG9kcyBvZiB0aGUgU29ja2V0IGNsYXNzXG4gKi9cbmNsYXNzIFJlbW90ZVNvY2tldCB7XG4gICAgY29uc3RydWN0b3IoYWRhcHRlciwgZGV0YWlscykge1xuICAgICAgICB0aGlzLmlkID0gZGV0YWlscy5pZDtcbiAgICAgICAgdGhpcy5oYW5kc2hha2UgPSBkZXRhaWxzLmhhbmRzaGFrZTtcbiAgICAgICAgdGhpcy5yb29tcyA9IG5ldyBTZXQoZGV0YWlscy5yb29tcyk7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRldGFpbHMuZGF0YTtcbiAgICAgICAgdGhpcy5vcGVyYXRvciA9IG5ldyBCcm9hZGNhc3RPcGVyYXRvcihhZGFwdGVyLCBuZXcgU2V0KFt0aGlzLmlkXSkpO1xuICAgIH1cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBKb2lucyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gcm9vbSAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgam9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5vcGVyYXRvci5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtCb29sZWFufSBjbG9zZSAtIGlmIGB0cnVlYCwgY2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0KGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5vcGVyYXRvci5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU29ja2V0ID0gUmVtb3RlU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNsaWVudCA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdNb2R1bGUgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB1cmwgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgZGVidWcgPSBkZWJ1Z01vZHVsZShcInNvY2tldC5pbzpjbGllbnRcIik7XG5jbGFzcyBDbGllbnQge1xuICAgIC8qKlxuICAgICAqIENsaWVudCBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzZXJ2ZXIgaW5zdGFuY2VcbiAgICAgKiBAcGFyYW0gY29ublxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBjb25uKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5uc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5jb25uID0gY29ubjtcbiAgICAgICAgdGhpcy5lbmNvZGVyID0gc2VydmVyLmVuY29kZXI7XG4gICAgICAgIHRoaXMuZGVjb2RlciA9IG5ldyBzZXJ2ZXIuX3BhcnNlci5EZWNvZGVyKCk7XG4gICAgICAgIHRoaXMuaWQgPSBjb25uLmlkO1xuICAgICAgICB0aGlzLnNldHVwKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm4gdGhlIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIEVuZ2luZS5JTyBjb25uZWN0aW9uXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbm4ucmVxdWVzdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBldmVudCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNldHVwKCkge1xuICAgICAgICB0aGlzLm9uY2xvc2UgPSB0aGlzLm9uY2xvc2UuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRhdGEgPSB0aGlzLm9uZGF0YS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZXJyb3IgPSB0aGlzLm9uZXJyb3IuYmluZCh0aGlzKTtcbiAgICAgICAgdGhpcy5vbmRlY29kZWQgPSB0aGlzLm9uZGVjb2RlZC5iaW5kKHRoaXMpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5vbihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJkYXRhXCIsIHRoaXMub25kYXRhKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiZXJyb3JcIiwgdGhpcy5vbmVycm9yKTtcbiAgICAgICAgdGhpcy5jb25uLm9uKFwiY2xvc2VcIiwgdGhpcy5vbmNsb3NlKTtcbiAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMubnNwcy5zaXplID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJubyBuYW1lc3BhY2Ugam9pbmVkIHlldCwgY2xvc2UgdGhlIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRoZSBjbGllbnQgaGFzIGFscmVhZHkgam9pbmVkIGEgbmFtZXNwYWNlLCBub3RoaW5nIHRvIGRvXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLnNlcnZlci5fY29ubmVjdFRpbWVvdXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgY29ubmVjdChuYW1lLCBhdXRoID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuc2VydmVyLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgZGVidWcoXCJjb25uZWN0aW5nIHRvIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlcnZlci5fY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgKGR5bmFtaWNOc3BOYW1lKSA9PiB7XG4gICAgICAgICAgICBpZiAoZHluYW1pY05zcE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRvQ29ubmVjdChuYW1lLCBhdXRoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpb24gb2YgbmFtZXNwYWNlICVzIHdhcyBkZW5pZWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGFja2V0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUixcbiAgICAgICAgICAgICAgICAgICAgbnNwOiBuYW1lLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgbmFtZXNwYWNlXCIsXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0cyBhIGNsaWVudCB0byBhIG5hbWVzcGFjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gdGhlIG5hbWVzcGFjZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhdXRoIC0gdGhlIGF1dGggcGFyYW1ldGVyc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nvbm5lY3QobmFtZSwgYXV0aCkge1xuICAgICAgICBjb25zdCBuc3AgPSB0aGlzLnNlcnZlci5vZihuYW1lKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gbnNwLl9hZGQodGhpcywgYXV0aCwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRzLnNldChzb2NrZXQuaWQsIHNvY2tldCk7XG4gICAgICAgICAgICB0aGlzLm5zcHMuc2V0KG5zcC5uYW1lLCBzb2NrZXQpO1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3RzIGZyb20gYWxsIG5hbWVzcGFjZXMgYW5kIGNsb3NlcyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9kaXNjb25uZWN0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldHMuaGFzKHNvY2tldC5pZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IG5zcCA9IHRoaXMuc29ja2V0cy5nZXQoc29ja2V0LmlkKS5uc3AubmFtZTtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgICAgIHRoaXMubnNwcy5kZWxldGUobnNwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcmVtb3ZlIGZvciAlc1wiLCBzb2NrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKFwib3BlblwiID09PSB0aGlzLmNvbm4ucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoXCJmb3JjaW5nIHRyYW5zcG9ydCBjbG9zZVwiKTtcbiAgICAgICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5vbmNsb3NlKFwiZm9yY2VkIHNlcnZlciBjbG9zZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgdG8gdGhlIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9wYWNrZXQocGFja2V0LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5yZWFkeVN0YXRlICE9PSBcIm9wZW5cIikge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyBwYWNrZXQgd3JpdGUgJWpcIiwgcGFja2V0KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IG9wdHMucHJlRW5jb2RlZFxuICAgICAgICAgICAgPyBwYWNrZXQgLy8gcHJldmlvdXMgdmVyc2lvbnMgb2YgdGhlIGFkYXB0ZXIgaW5jb3JyZWN0bHkgdXNlZCBzb2NrZXQucGFja2V0KCkgaW5zdGVhZCBvZiB3cml0ZVRvRW5naW5lKClcbiAgICAgICAgICAgIDogdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICB0aGlzLndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIG9wdHMpO1xuICAgIH1cbiAgICB3cml0ZVRvRW5naW5lKGVuY29kZWRQYWNrZXRzLCBvcHRzKSB7XG4gICAgICAgIGlmIChvcHRzLnZvbGF0aWxlICYmICF0aGlzLmNvbm4udHJhbnNwb3J0LndyaXRhYmxlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInZvbGF0aWxlIHBhY2tldCBpcyBkaXNjYXJkZWQgc2luY2UgdGhlIHRyYW5zcG9ydCBpcyBub3QgY3VycmVudGx5IHdyaXRhYmxlXCIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhY2tldHMgPSBBcnJheS5pc0FycmF5KGVuY29kZWRQYWNrZXRzKVxuICAgICAgICAgICAgPyBlbmNvZGVkUGFja2V0c1xuICAgICAgICAgICAgOiBbZW5jb2RlZFBhY2tldHNdO1xuICAgICAgICBmb3IgKGNvbnN0IGVuY29kZWRQYWNrZXQgb2YgcGFja2V0cykge1xuICAgICAgICAgICAgdGhpcy5jb25uLndyaXRlKGVuY29kZWRQYWNrZXQsIG9wdHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGluY29taW5nIHRyYW5zcG9ydCBkYXRhLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRhdGEoZGF0YSkge1xuICAgICAgICAvLyB0cnkvY2F0Y2ggaXMgbmVlZGVkIGZvciBwcm90b2NvbCB2aW9sYXRpb25zIChHSC0xODgwKVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5kZWNvZGVyLmFkZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgdGhpcy5vbmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHBhcnNlciBmdWxseSBkZWNvZGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmRlY29kZWQocGFja2V0KSB7XG4gICAgICAgIGlmIChzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUID09PSBwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHVybC5wYXJzZShwYWNrZXQubnNwLCB0cnVlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QocGFyc2VkLnBhdGhuYW1lLCBwYXJzZWQucXVlcnkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0KHBhY2tldC5uc3AsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwcy5nZXQocGFja2V0Lm5zcCk7XG4gICAgICAgICAgICBpZiAoc29ja2V0KSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5fb25wYWNrZXQocGFja2V0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwibm8gc29ja2V0IGZvciBuYW1lc3BhY2UgJXNcIiwgcGFja2V0Lm5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhbiBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmVycm9yKGVycikge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHNvY2tldC5fb25lcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubi5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgY2xvc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVhc29uXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNsb3NlKHJlYXNvbikge1xuICAgICAgICBkZWJ1ZyhcImNsaWVudCBjbG9zZSB3aXRoIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICAvLyBpZ25vcmUgYSBwb3RlbnRpYWwgc3Vic2VxdWVudCBgY2xvc2VgIGV2ZW50XG4gICAgICAgIHRoaXMuZGVzdHJveSgpO1xuICAgICAgICAvLyBgbnNwc2AgYW5kIGBzb2NrZXRzYCBhcmUgY2xlYW5lZCB1cCBzZWFtbGVzc2x5XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmNsb3NlKHJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zb2NrZXRzLmNsZWFyKCk7XG4gICAgICAgIHRoaXMuZGVjb2Rlci5kZXN0cm95KCk7IC8vIGNsZWFuIHVwIGRlY29kZXJcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xlYW5zIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImRhdGFcIiwgdGhpcy5vbmRhdGEpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ucmVtb3ZlTGlzdGVuZXIoXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuZGVjb2Rlci5yZW1vdmVMaXN0ZW5lcihcImRlY29kZWRcIiwgdGhpcy5vbmRlY29kZWQpO1xuICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0VGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2xpZW50ID0gQ2xpZW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZXNwYWNlID0gZXhwb3J0cy5Tb2NrZXQgPSBleHBvcnRzLlNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbmNvbnN0IHBhdGggPSByZXF1aXJlKFwicGF0aFwiKTtcbmNvbnN0IGVuZ2luZV9pb18xID0gcmVxdWlyZShcImVuZ2luZS5pb1wiKTtcbmNvbnN0IGNsaWVudF8xID0gcmVxdWlyZShcIi4vY2xpZW50XCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJOYW1lc3BhY2VcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIG5hbWVzcGFjZV8xLk5hbWVzcGFjZTsgfSB9KTtcbmNvbnN0IHBhcmVudF9uYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL3BhcmVudC1uYW1lc3BhY2VcIik7XG5jb25zdCBzb2NrZXRfaW9fYWRhcHRlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1hZGFwdGVyXCIpO1xuY29uc3QgcGFyc2VyID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfMS5Tb2NrZXQ7IH0gfSk7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IHV3c19qc18xID0gcmVxdWlyZShcIi4vdXdzLmpzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpzZXJ2ZXJcIik7XG5jb25zdCBjbGllbnRWZXJzaW9uID0gcmVxdWlyZShcIi4uL3BhY2thZ2UuanNvblwiKS52ZXJzaW9uO1xuY29uc3QgZG90TWFwUmVnZXggPSAvXFwubWFwLztcbmNsYXNzIFNlcnZlciBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3Ioc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBwcml2YXRlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9uc3BzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnBhcmVudE5zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIGlmIChcIm9iamVjdFwiID09PSB0eXBlb2Ygc3J2ICYmXG4gICAgICAgICAgICBzcnYgaW5zdGFuY2VvZiBPYmplY3QgJiZcbiAgICAgICAgICAgICFzcnYubGlzdGVuKSB7XG4gICAgICAgICAgICBvcHRzID0gc3J2O1xuICAgICAgICAgICAgc3J2ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucGF0aChvcHRzLnBhdGggfHwgXCIvc29ja2V0LmlvXCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0KG9wdHMuY29ubmVjdFRpbWVvdXQgfHwgNDUwMDApO1xuICAgICAgICB0aGlzLnNlcnZlQ2xpZW50KGZhbHNlICE9PSBvcHRzLnNlcnZlQ2xpZW50KTtcbiAgICAgICAgdGhpcy5fcGFyc2VyID0gb3B0cy5wYXJzZXIgfHwgcGFyc2VyO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBuZXcgdGhpcy5fcGFyc2VyLkVuY29kZXIoKTtcbiAgICAgICAgdGhpcy5hZGFwdGVyKG9wdHMuYWRhcHRlciB8fCBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIpO1xuICAgICAgICB0aGlzLnNvY2tldHMgPSB0aGlzLm9mKFwiL1wiKTtcbiAgICAgICAgdGhpcy5vcHRzID0gb3B0cztcbiAgICAgICAgaWYgKHNydiB8fCB0eXBlb2Ygc3J2ID09IFwibnVtYmVyXCIpXG4gICAgICAgICAgICB0aGlzLmF0dGFjaChzcnYpO1xuICAgIH1cbiAgICBzZXJ2ZUNsaWVudCh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9zZXJ2ZUNsaWVudDtcbiAgICAgICAgdGhpcy5fc2VydmVDbGllbnQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIG5hbWVzcGFjZSBub3QgYWxyZWFkeSBjcmVhdGVkIG9uIHRoZSBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZSAtIG5hbWUgb2YgaW5jb21pbmcgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICogQHBhcmFtIGZuIC0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2NoZWNrTmFtZXNwYWNlKG5hbWUsIGF1dGgsIGZuKSB7XG4gICAgICAgIGlmICh0aGlzLnBhcmVudE5zcHMuc2l6ZSA9PT0gMClcbiAgICAgICAgICAgIHJldHVybiBmbihmYWxzZSk7XG4gICAgICAgIGNvbnN0IGtleXNJdGVyYXRvciA9IHRoaXMucGFyZW50TnNwcy5rZXlzKCk7XG4gICAgICAgIGNvbnN0IHJ1biA9ICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5leHRGbiA9IGtleXNJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAobmV4dEZuLmRvbmUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV4dEZuLnZhbHVlKG5hbWUsIGF1dGgsIChlcnIsIGFsbG93KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciB8fCAhYWxsb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJ1bigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fbnNwcy5oYXMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlIG5hbWVzcGFjZSB3YXMgY3JlYXRlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJkeW5hbWljIG5hbWVzcGFjZSAlcyBhbHJlYWR5IGV4aXN0c1wiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKHRoaXMuX25zcHMuZ2V0KG5hbWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5wYXJlbnROc3BzLmdldChuZXh0Rm4udmFsdWUpLmNyZWF0ZUNoaWxkKG5hbWUpO1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiZHluYW1pYyBuYW1lc3BhY2UgJXMgd2FzIGNyZWF0ZWRcIiwgbmFtZSk7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cy5lbWl0UmVzZXJ2ZWQoXCJuZXdfbmFtZXNwYWNlXCIsIG5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgZm4obmFtZXNwYWNlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBydW4oKTtcbiAgICB9XG4gICAgcGF0aCh2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLl9wYXRoID0gdi5yZXBsYWNlKC9cXC8kLywgXCJcIik7XG4gICAgICAgIGNvbnN0IGVzY2FwZWRQYXRoID0gdGhpcy5fcGF0aC5yZXBsYWNlKC9bLVxcL1xcXFxeJCorPy4oKXxbXFxde31dL2csIFwiXFxcXCQmXCIpO1xuICAgICAgICB0aGlzLmNsaWVudFBhdGhSZWdleCA9IG5ldyBSZWdFeHAoXCJeXCIgK1xuICAgICAgICAgICAgZXNjYXBlZFBhdGggK1xuICAgICAgICAgICAgXCIvc29ja2V0XFxcXC5pbyhcXFxcLm1zZ3BhY2t8XFxcXC5lc20pPyhcXFxcLm1pbik/XFxcXC5qcyhcXFxcLm1hcCk/KD86XFxcXD98JClcIik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBjb25uZWN0VGltZW91dCh2KSB7XG4gICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY29ubmVjdFRpbWVvdXQ7XG4gICAgICAgIHRoaXMuX2Nvbm5lY3RUaW1lb3V0ID0gdjtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGFkYXB0ZXIodikge1xuICAgICAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fYWRhcHRlcjtcbiAgICAgICAgdGhpcy5fYWRhcHRlciA9IHY7XG4gICAgICAgIGZvciAoY29uc3QgbnNwIG9mIHRoaXMuX25zcHMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIG5zcC5faW5pdEFkYXB0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc29ja2V0LmlvIHRvIGEgc2VydmVyIG9yIHBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gc2VydmVyIG9yIHBvcnRcbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBsaXN0ZW4oc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKHNydiwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHNvY2tldC5pbyB0byBhIHNlcnZlciBvciBwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiAtIHNlcnZlciBvciBwb3J0XG4gICAgICogQHBhcmFtIG9wdHMgLSBvcHRpb25zIHBhc3NlZCB0byBlbmdpbmUuaW9cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYXR0YWNoKHNydiwgb3B0cyA9IHt9KSB7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIHNydikge1xuICAgICAgICAgICAgY29uc3QgbXNnID0gXCJZb3UgYXJlIHRyeWluZyB0byBhdHRhY2ggc29ja2V0LmlvIHRvIGFuIGV4cHJlc3MgXCIgK1xuICAgICAgICAgICAgICAgIFwicmVxdWVzdCBoYW5kbGVyIGZ1bmN0aW9uLiBQbGVhc2UgcGFzcyBhIGh0dHAuU2VydmVyIGluc3RhbmNlLlwiO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gaGFuZGxlIGEgcG9ydCBhcyBhIHN0cmluZ1xuICAgICAgICBpZiAoTnVtYmVyKHNydikgPT0gc3J2KSB7XG4gICAgICAgICAgICBzcnYgPSBOdW1iZXIoc3J2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJudW1iZXJcIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGh0dHAgc2VydmVyIGFuZCBiaW5kaW5nIHRvICVkXCIsIHNydik7XG4gICAgICAgICAgICBjb25zdCBwb3J0ID0gc3J2O1xuICAgICAgICAgICAgc3J2ID0gaHR0cC5jcmVhdGVTZXJ2ZXIoKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg0MDQpO1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc3J2Lmxpc3Rlbihwb3J0KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBtZXJnZSB0aGUgb3B0aW9ucyBwYXNzZWQgdG8gdGhlIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRzLCB0aGlzLm9wdHMpO1xuICAgICAgICAvLyBzZXQgZW5naW5lLmlvIHBhdGggdG8gYC9zb2NrZXQuaW9gXG4gICAgICAgIG9wdHMucGF0aCA9IG9wdHMucGF0aCB8fCB0aGlzLl9wYXRoO1xuICAgICAgICB0aGlzLmluaXRFbmdpbmUoc3J2LCBvcHRzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGF0dGFjaEFwcChhcHAgLyo6IFRlbXBsYXRlZEFwcCAqLywgb3B0cyA9IHt9KSB7XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIC8vIGluaXRpYWxpemUgZW5naW5lXG4gICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgdVdlYlNvY2tldHMuanMtYmFzZWQgZW5naW5lIHdpdGggb3B0cyAlalwiLCBvcHRzKTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gbmV3IGVuZ2luZV9pb18xLnVTZXJ2ZXIob3B0cyk7XG4gICAgICAgIGVuZ2luZS5hdHRhY2goYXBwLCBvcHRzKTtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZChlbmdpbmUpO1xuICAgICAgICBpZiAodGhpcy5fc2VydmVDbGllbnQpIHtcbiAgICAgICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgICAgICBhcHAuZ2V0KGAke3RoaXMuX3BhdGh9LypgLCAocmVzLCByZXEpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY2xpZW50UGF0aFJlZ2V4LnRlc3QocmVxLmdldFVybCgpKSkge1xuICAgICAgICAgICAgICAgICAgICByZXEuc2V0WWllbGQodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZmlsZW5hbWUgPSByZXFcbiAgICAgICAgICAgICAgICAgICAgLmdldFVybCgpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKHRoaXMuX3BhdGgsIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKVxuICAgICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzTWFwID0gZG90TWFwUmVnZXgudGVzdChmaWxlbmFtZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgICAgICAgICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzcyMzIjc2VjdGlvbi0yLjNcbiAgICAgICAgICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgICAgICAgICAgY29uc3Qgd2Vha0V0YWcgPSBcIlcvXCIgKyBleHBlY3RlZEV0YWc7XG4gICAgICAgICAgICAgICAgY29uc3QgZXRhZyA9IHJlcS5nZXRIZWFkZXIoXCJpZi1ub25lLW1hdGNoXCIpO1xuICAgICAgICAgICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleHBlY3RlZEV0YWcgPT09IGV0YWcgfHwgd2Vha0V0YWcgPT09IGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjMwNCBOb3QgTW9kaWZpZWRcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXNcIiwgdHlwZSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY2FjaGUtY29udHJvbFwiLCBcInB1YmxpYywgbWF4LWFnZT0wXCIpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImNvbnRlbnQtdHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWRlcihcImV0YWdcIiwgZXhwZWN0ZWRFdGFnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlcGF0aCA9IHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vY2xpZW50LWRpc3QvXCIsIGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICAoMCwgdXdzX2pzXzEuc2VydmVGaWxlKShyZXMsIGZpbGVwYXRoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCB1d3NfanNfMS5wYXRjaEFkYXB0ZXIpKGFwcCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgZW5naW5lXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gdGhlIHNlcnZlciB0byBhdHRhY2ggdG9cbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgaW5pdEVuZ2luZShzcnYsIG9wdHMpIHtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyBlbmdpbmUuaW8gaW5zdGFuY2Ugd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICB0aGlzLmVpbyA9ICgwLCBlbmdpbmVfaW9fMS5hdHRhY2gpKHNydiwgb3B0cyk7XG4gICAgICAgIC8vIGF0dGFjaCBzdGF0aWMgZmlsZSBzZXJ2aW5nXG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudClcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoU2VydmUoc3J2KTtcbiAgICAgICAgLy8gRXhwb3J0IGh0dHAgc2VydmVyXG4gICAgICAgIHRoaXMuaHR0cFNlcnZlciA9IHNydjtcbiAgICAgICAgLy8gYmluZCB0byBlbmdpbmUgZXZlbnRzXG4gICAgICAgIHRoaXMuYmluZCh0aGlzLmVpbyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEF0dGFjaGVzIHRoZSBzdGF0aWMgZmlsZSBzZXJ2aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNydiBodHRwIHNlcnZlclxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYXR0YWNoU2VydmUoc3J2KSB7XG4gICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIGNsaWVudCBzZXJ2aW5nIHJlcSBoYW5kbGVyXCIpO1xuICAgICAgICBjb25zdCBldnMgPSBzcnYubGlzdGVuZXJzKFwicmVxdWVzdFwiKS5zbGljZSgwKTtcbiAgICAgICAgc3J2LnJlbW92ZUFsbExpc3RlbmVycyhcInJlcXVlc3RcIik7XG4gICAgICAgIHNydi5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEudXJsKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VydmUocmVxLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBldnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZXZzW2ldLmNhbGwoc3J2LCByZXEsIHJlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIHJlcXVlc3Qgc2VydmluZyBvZiBjbGllbnQgc291cmNlIGFuZCBtYXBcbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXFcbiAgICAgKiBAcGFyYW0gcmVzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBzZXJ2ZShyZXEsIHJlcykge1xuICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcS51cmwucmVwbGFjZSh0aGlzLl9wYXRoLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IGlzTWFwID8gXCJtYXBcIiA6IFwic291cmNlXCI7XG4gICAgICAgIC8vIFBlciB0aGUgc3RhbmRhcmQsIEVUYWdzIG11c3QgYmUgcXVvdGVkOlxuICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICBjb25zdCBleHBlY3RlZEV0YWcgPSAnXCInICsgY2xpZW50VmVyc2lvbiArICdcIic7XG4gICAgICAgIGNvbnN0IHdlYWtFdGFnID0gXCJXL1wiICsgZXhwZWN0ZWRFdGFnO1xuICAgICAgICBjb25zdCBldGFnID0gcmVxLmhlYWRlcnNbXCJpZi1ub25lLW1hdGNoXCJdO1xuICAgICAgICBpZiAoZXRhZykge1xuICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzIDMwNFwiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDMwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNhY2hlLUNvbnRyb2xcIiwgXCJwdWJsaWMsIG1heC1hZ2U9MFwiKTtcbiAgICAgICAgcmVzLnNldEhlYWRlcihcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL1wiICsgKGlzTWFwID8gXCJqc29uXCIgOiBcImphdmFzY3JpcHRcIikpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiRVRhZ1wiLCBleHBlY3RlZEV0YWcpO1xuICAgICAgICBTZXJ2ZXIuc2VuZEZpbGUoZmlsZW5hbWUsIHJlcSwgcmVzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHBhcmFtIGZpbGVuYW1lXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYXJhbSByZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHN0YXRpYyBzZW5kRmlsZShmaWxlbmFtZSwgcmVxLCByZXMpIHtcbiAgICAgICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKHBhdGguam9pbihfX2Rpcm5hbWUsIFwiLi4vY2xpZW50LWRpc3QvXCIsIGZpbGVuYW1lKSk7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gYWNjZXB0cyhyZXEpLmVuY29kaW5ncyhbXCJiclwiLCBcImd6aXBcIiwgXCJkZWZsYXRlXCJdKTtcbiAgICAgICAgY29uc3Qgb25FcnJvciA9IChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIGNhc2UgXCJiclwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImJyXCIgfSk7XG4gICAgICAgICAgICAgICAgcmVhZFN0cmVhbS5waXBlKCgwLCB6bGliXzEuY3JlYXRlQnJvdGxpQ29tcHJlc3MpKCkpLnBpcGUocmVzKTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlQnJvdGxpQ29tcHJlc3MpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ3ppcFwiOlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB7IFwiY29udGVudC1lbmNvZGluZ1wiOiBcImd6aXBcIiB9KTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sICgwLCB6bGliXzEuY3JlYXRlR3ppcCkoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJkZWZsYXRlXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZGVmbGF0ZVwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVEZWZsYXRlKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJpbmRzIHNvY2tldC5pbyB0byBhbiBlbmdpbmUuaW8gaW5zdGFuY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2VuZ2luZS5TZXJ2ZXJ9IGVuZ2luZSBlbmdpbmUuaW8gKG9yIGNvbXBhdGlibGUpIHNlcnZlclxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBiaW5kKGVuZ2luZSkge1xuICAgICAgICB0aGlzLmVuZ2luZSA9IGVuZ2luZTtcbiAgICAgICAgdGhpcy5lbmdpbmUub24oXCJjb25uZWN0aW9uXCIsIHRoaXMub25jb25uZWN0aW9uLmJpbmQodGhpcykpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZWFjaCBpbmNvbWluZyB0cmFuc3BvcnQgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZW5naW5lLlNvY2tldH0gY29ublxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25jb25uZWN0aW9uKGNvbm4pIHtcbiAgICAgICAgZGVidWcoXCJpbmNvbWluZyBjb25uZWN0aW9uIHdpdGggaWQgJXNcIiwgY29ubi5pZCk7XG4gICAgICAgIGNvbnN0IGNsaWVudCA9IG5ldyBjbGllbnRfMS5DbGllbnQodGhpcywgY29ubik7XG4gICAgICAgIGlmIChjb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjbGllbnQuY29ubmVjdChcIi9cIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExvb2tzIHVwIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8UmVnRXhwfEZ1bmN0aW9ufSBuYW1lIG5zcCBuYW1lXG4gICAgICogQHBhcmFtIGZuIG9wdGlvbmFsLCBuc3AgYGNvbm5lY3Rpb25gIGV2IGhhbmRsZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb2YobmFtZSwgZm4pIHtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIgfHwgbmFtZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICAgICAgY29uc3QgcGFyZW50TnNwID0gbmV3IHBhcmVudF9uYW1lc3BhY2VfMS5QYXJlbnROYW1lc3BhY2UodGhpcyk7XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBwYXJlbnQgbmFtZXNwYWNlICVzXCIsIHBhcmVudE5zcC5uYW1lKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldChuYW1lLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJlbnROc3BzLnNldCgobnNwLCBjb25uLCBuZXh0KSA9PiBuZXh0KG51bGwsIG5hbWUudGVzdChuc3ApKSwgcGFyZW50TnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmbikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBwYXJlbnROc3Aub24oXCJjb25uZWN0XCIsIGZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwYXJlbnROc3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFN0cmluZyhuYW1lKVswXSAhPT0gXCIvXCIpXG4gICAgICAgICAgICBuYW1lID0gXCIvXCIgKyBuYW1lO1xuICAgICAgICBsZXQgbnNwID0gdGhpcy5fbnNwcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghbnNwKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImluaXRpYWxpemluZyBuYW1lc3BhY2UgJXNcIiwgbmFtZSk7XG4gICAgICAgICAgICBuc3AgPSBuZXcgbmFtZXNwYWNlXzEuTmFtZXNwYWNlKHRoaXMsIG5hbWUpO1xuICAgICAgICAgICAgdGhpcy5fbnNwcy5zZXQobmFtZSwgbnNwKTtcbiAgICAgICAgICAgIGlmIChuYW1lICE9PSBcIi9cIikge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuZW1pdFJlc2VydmVkKFwibmV3X25hbWVzcGFjZVwiLCBuc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmbilcbiAgICAgICAgICAgIG5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICByZXR1cm4gbnNwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgc2VydmVyIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwYXJhbSBbZm5dIG9wdGlvbmFsLCBjYWxsZWQgYXMgYGZuKFtlcnJdKWAgb24gZXJyb3IgT1IgYWxsIGNvbm5zIGNsb3NlZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjbG9zZShmbikge1xuICAgICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiB0aGlzLnNvY2tldHMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmNsb3NlKFwic2VydmVyIHNodXR0aW5nIGRvd25cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbmdpbmUuY2xvc2UoKTtcbiAgICAgICAgLy8gcmVzdG9yZSB0aGUgQWRhcHRlciBwcm90b3R5cGVcbiAgICAgICAgKDAsIHV3c19qc18xLnJlc3RvcmVBZGFwdGVyKSgpO1xuICAgICAgICBpZiAodGhpcy5odHRwU2VydmVyKSB7XG4gICAgICAgICAgICB0aGlzLmh0dHBTZXJ2ZXIuY2xvc2UoZm4pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIG5hbWVzcGFjZSBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLnNvY2tldHMudXNlKGZuKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZXhjZXB0KG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5leGNlcHQobmFtZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLnNvY2tldHMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXQgYSBwYWNrZXQgdG8gb3RoZXIgU29ja2V0LklPIHNlcnZlcnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiAtIHRoZSBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgLSBhbiBhcnJheSBvZiBhcmd1bWVudHMsIHdoaWNoIG1heSBpbmNsdWRlIGFuIGFja25vd2xlZGdlbWVudCBjYWxsYmFjayBhdCB0aGUgZW5kXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBzb2NrZXQgaWRzLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuYWxsU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5jb21wcmVzcyhjb21wcmVzcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgbWF5IGJlIGxvc3QgaWYgdGhlIGNsaWVudCBpcyBub3QgcmVhZHkgdG9cbiAgICAgKiByZWNlaXZlIG1lc3NhZ2VzIChiZWNhdXNlIG9mIG5ldHdvcmsgc2xvd25lc3Mgb3Igb3RoZXIgaXNzdWVzLCBvciBiZWNhdXNlIHRoZXnigJlyZSBjb25uZWN0ZWQgdGhyb3VnaCBsb25nIHBvbGxpbmdcbiAgICAgKiBhbmQgaXMgaW4gdGhlIG1pZGRsZSBvZiBhIHJlcXVlc3QtcmVzcG9uc2UgY3ljbGUpLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmZldGNoU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZGlzY29ubmVjdFNvY2tldHMoY2xvc2UpO1xuICAgIH1cbn1cbmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xuLyoqXG4gKiBFeHBvc2UgbWFpbiBuYW1lc3BhY2UgKC8pLlxuICovXG5jb25zdCBlbWl0dGVyTWV0aG9kcyA9IE9iamVjdC5rZXlzKGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGUpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgcmV0dXJuIHR5cGVvZiBldmVudHNfMS5FdmVudEVtaXR0ZXIucHJvdG90eXBlW2tleV0gPT09IFwiZnVuY3Rpb25cIjtcbn0pO1xuZW1pdHRlck1ldGhvZHMuZm9yRWFjaChmdW5jdGlvbiAoZm4pIHtcbiAgICBTZXJ2ZXIucHJvdG90eXBlW2ZuXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0c1tmbl0uYXBwbHkodGhpcy5zb2NrZXRzLCBhcmd1bWVudHMpO1xuICAgIH07XG59KTtcbm1vZHVsZS5leHBvcnRzID0gKHNydiwgb3B0cykgPT4gbmV3IFNlcnZlcihzcnYsIG9wdHMpO1xubW9kdWxlLmV4cG9ydHMuU2VydmVyID0gU2VydmVyO1xubW9kdWxlLmV4cG9ydHMuTmFtZXNwYWNlID0gbmFtZXNwYWNlXzEuTmFtZXNwYWNlO1xubW9kdWxlLmV4cG9ydHMuU29ja2V0ID0gc29ja2V0XzEuU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk5hbWVzcGFjZSA9IGV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5jb25zdCB0eXBlZF9ldmVudHNfMSA9IHJlcXVpcmUoXCIuL3R5cGVkLWV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IGJyb2FkY2FzdF9vcGVyYXRvcl8xID0gcmVxdWlyZShcIi4vYnJvYWRjYXN0LW9wZXJhdG9yXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzpuYW1lc3BhY2VcIik7XG5leHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IG5ldyBTZXQoW1wiY29ubmVjdFwiLCBcImNvbm5lY3Rpb25cIiwgXCJuZXdfbmFtZXNwYWNlXCJdKTtcbmNsYXNzIE5hbWVzcGFjZSBleHRlbmRzIHR5cGVkX2V2ZW50c18xLlN0cmljdEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogTmFtZXNwYWNlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlcnZlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBuYW1lXG4gICAgICovXG4gICAgY29uc3RydWN0b3Ioc2VydmVyLCBuYW1lKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLyoqIEBwcml2YXRlICovXG4gICAgICAgIHRoaXMuX2ZucyA9IFtdO1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5faWRzID0gMDtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBzZXJ2ZXI7XG4gICAgICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgICAgIHRoaXMuX2luaXRBZGFwdGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIHRoZSBgQWRhcHRlcmAgZm9yIHRoaXMgbnNwLlxuICAgICAqIFJ1biB1cG9uIGNoYW5naW5nIGFkYXB0ZXIgYnkgYFNlcnZlciNhZGFwdGVyYFxuICAgICAqIGluIGFkZGl0aW9uIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2luaXRBZGFwdGVyKCkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHRoaXMuYWRhcHRlciA9IG5ldyAodGhpcy5zZXJ2ZXIuYWRhcHRlcigpKSh0aGlzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB1cCBuYW1lc3BhY2UgbWlkZGxld2FyZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5fZm5zLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzb2NrZXQgLSB0aGUgc29ja2V0IHRoYXQgd2lsbCBnZXQgYWRkZWRcbiAgICAgKiBAcGFyYW0gZm4gLSBsYXN0IGZuIGNhbGwgaW4gdGhlIG1pZGRsZXdhcmVcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJ1bihzb2NrZXQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuX2Zucy5zbGljZSgwKTtcbiAgICAgICAgaWYgKCFmbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgICAgZm5zW2ldKHNvY2tldCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIC8vIHVwb24gZXJyb3IsIHNob3J0LWNpcmN1aXRcbiAgICAgICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4oZXJyKTtcbiAgICAgICAgICAgICAgICAvLyBpZiBubyBtaWRkbGV3YXJlIGxlZnQsIHN1bW1vbiBjYWxsYmFja1xuICAgICAgICAgICAgICAgIGlmICghZm5zW2kgKyAxXSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgICAgICAgICAgICAgIC8vIGdvIG9uIHRvIG5leHRcbiAgICAgICAgICAgICAgICBydW4oaSArIDEpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcnVuKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBpbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZXhjZXB0KHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbmV3IGNsaWVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH1cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9hZGQoY2xpZW50LCBxdWVyeSwgZm4pIHtcbiAgICAgICAgZGVidWcoXCJhZGRpbmcgc29ja2V0IHRvIG5zcCAlc1wiLCB0aGlzLm5hbWUpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgc29ja2V0XzEuU29ja2V0KHRoaXMsIGNsaWVudCwgcXVlcnkpO1xuICAgICAgICB0aGlzLnJ1bihzb2NrZXQsIChlcnIpID0+IHtcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChcIm9wZW5cIiA9PSBjbGllbnQuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjbGllbnQuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKGVyci5kYXRhIHx8IGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQuX2Vycm9yKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGE6IGVyci5kYXRhLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHRyYWNrIHNvY2tldFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXQncyBwYXJhbW91bnQgdGhhdCB0aGUgaW50ZXJuYWwgYG9uY29ubmVjdGAgbG9naWNcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZXMgYmVmb3JlIHVzZXItc2V0IGV2ZW50cyB0byBwcmV2ZW50IHN0YXRlIG9yZGVyXG4gICAgICAgICAgICAgICAgICAgIC8vIHZpb2xhdGlvbnMgKHN1Y2ggYXMgYSBkaXNjb25uZWN0aW9uIGJlZm9yZSB0aGUgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAgICAvLyBsb2dpYyBpcyBjb21wbGV0ZSlcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Ll9vbmNvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZmlyZSB1c2VyLXNldCBldmVudHNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0XCIsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiY29ubmVjdGlvblwiLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJuZXh0IGNhbGxlZCBhZnRlciBjbGllbnQgd2FzIGNsb3NlZCAtIGlnbm9yaW5nIHNvY2tldFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBjbGllbnQuIENhbGxlZCBieSBlYWNoIGBTb2NrZXRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVtb3ZlKHNvY2tldCkge1xuICAgICAgICBpZiAodGhpcy5zb2NrZXRzLmhhcyhzb2NrZXQuaWQpKSB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuZGVsZXRlKHNvY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHJlbW92ZSBmb3IgJXNcIiwgc29ja2V0LmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gQWx3YXlzIHRydWVcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhIHBhY2tldCB0byBvdGhlciBTb2NrZXQuSU8gc2VydmVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2V2fVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGFyZ3MudW5zaGlmdChldik7XG4gICAgICAgIHRoaXMuYWRhcHRlci5zZXJ2ZXJTaWRlRW1pdChhcmdzKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgcGFja2V0IGlzIHJlY2VpdmVkIGZyb20gYW5vdGhlciBTb2NrZXQuSU8gc2VydmVyXG4gICAgICpcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uU2VydmVyU2lkZUVtaXQoYXJncykge1xuICAgICAgICBzdXBlci5lbWl0VW50eXBlZC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuYWxsU29ja2V0cygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikudm9sYXRpbGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byB0aGUgY3VycmVudCBub2RlLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBsb2NhbCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuZmV0Y2hTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldHNMZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzTGVhdmUocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGRpc2Nvbm5lY3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBkaXNjb25uZWN0U29ja2V0cyhjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5OYW1lc3BhY2UgPSBOYW1lc3BhY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFyZW50TmFtZXNwYWNlID0gdm9pZCAwO1xuY29uc3QgbmFtZXNwYWNlXzEgPSByZXF1aXJlKFwiLi9uYW1lc3BhY2VcIik7XG5jbGFzcyBQYXJlbnROYW1lc3BhY2UgZXh0ZW5kcyBuYW1lc3BhY2VfMS5OYW1lc3BhY2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlcnZlcikge1xuICAgICAgICBzdXBlcihzZXJ2ZXIsIFwiL19cIiArIFBhcmVudE5hbWVzcGFjZS5jb3VudCsrKTtcbiAgICAgICAgdGhpcy5jaGlsZHJlbiA9IG5ldyBTZXQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEFkYXB0ZXIoKSB7XG4gICAgICAgIGNvbnN0IGJyb2FkY2FzdCA9IChwYWNrZXQsIG9wdHMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY2hpbGRyZW4uZm9yRWFjaCgobnNwKSA9PiB7XG4gICAgICAgICAgICAgICAgbnNwLmFkYXB0ZXIuYnJvYWRjYXN0KHBhY2tldCwgb3B0cyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZSBGSVhNRSBpcyB0aGVyZSBhIHdheSB0byBkZWNsYXJlIGFuIGlubmVyIGNsYXNzIGluIFR5cGVTY3JpcHQ/XG4gICAgICAgIHRoaXMuYWRhcHRlciA9IHsgYnJvYWRjYXN0IH07XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgIG5zcC5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjcmVhdGVDaGlsZChuYW1lKSB7XG4gICAgICAgIGNvbnN0IG5hbWVzcGFjZSA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcy5zZXJ2ZXIsIG5hbWUpO1xuICAgICAgICBuYW1lc3BhY2UuX2ZucyA9IHRoaXMuX2Zucy5zbGljZSgwKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0XCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0XCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzKFwiY29ubmVjdGlvblwiKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4gbmFtZXNwYWNlLm9uKFwiY29ubmVjdGlvblwiLCBsaXN0ZW5lcikpO1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmFkZChuYW1lc3BhY2UpO1xuICAgICAgICB0aGlzLnNlcnZlci5fbnNwcy5zZXQobmFtZSwgbmFtZXNwYWNlKTtcbiAgICAgICAgcmV0dXJuIG5hbWVzcGFjZTtcbiAgICB9XG4gICAgZmV0Y2hTb2NrZXRzKCkge1xuICAgICAgICAvLyBub3RlOiB3ZSBjb3VsZCBtYWtlIHRoZSBmZXRjaFNvY2tldHMoKSBtZXRob2Qgd29yayBmb3IgZHluYW1pYyBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIHJlZ2V4IChieSBzZW5kaW5nIHRoZVxuICAgICAgICAvLyByZWdleCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMsIGFuZCByZXR1cm5pbmcgdGhlIHNvY2tldHMgb2YgZWFjaCBtYXRjaGluZyBuYW1lc3BhY2UgZm9yIGV4YW1wbGUpLCBidXRcbiAgICAgICAgLy8gdGhlIGJlaGF2aW9yIGZvciBuYW1lc3BhY2VzIGNyZWF0ZWQgd2l0aCBhIGZ1bmN0aW9uIGlzIGxlc3MgY2xlYXJcbiAgICAgICAgLy8gbm90ZcKyOiB3ZSBjYW5ub3QgbG9vcCBvdmVyIGVhY2ggY2hpbGRyZW4gbmFtZXNwYWNlLCBiZWNhdXNlIHdpdGggbXVsdGlwbGUgU29ja2V0LklPIHNlcnZlcnMsIGEgZ2l2ZW4gbmFtZXNwYWNlXG4gICAgICAgIC8vIG1heSBleGlzdCBvbiBvbmUgbm9kZSBidXQgbm90IGV4aXN0IG9uIGFub3RoZXIgKHNpbmNlIGl0IGlzIGNyZWF0ZWQgdXBvbiBjbGllbnQgY29ubmVjdGlvbilcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmV0Y2hTb2NrZXRzKCkgaXMgbm90IHN1cHBvcnRlZCBvbiBwYXJlbnQgbmFtZXNwYWNlc1wiKTtcbiAgICB9XG59XG5leHBvcnRzLlBhcmVudE5hbWVzcGFjZSA9IFBhcmVudE5hbWVzcGFjZTtcblBhcmVudE5hbWVzcGFjZS5jb3VudCA9IDA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNvbnN0IGRlYnVnXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImRlYnVnXCIpKTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgYmFzZTY0aWRfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYmFzZTY0aWRcIikpO1xuY29uc3QgYnJvYWRjYXN0X29wZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9icm9hZGNhc3Qtb3BlcmF0b3JcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNvY2tldFwiKTtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXG4gICAgXCJjb25uZWN0XCIsXG4gICAgXCJjb25uZWN0X2Vycm9yXCIsXG4gICAgXCJkaXNjb25uZWN0XCIsXG4gICAgXCJkaXNjb25uZWN0aW5nXCIsXG4gICAgXCJuZXdMaXN0ZW5lclwiLFxuICAgIFwicmVtb3ZlTGlzdGVuZXJcIixcbl0pO1xuY2xhc3MgU29ja2V0IGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBJbnRlcmZhY2UgdG8gYSBgQ2xpZW50YCBmb3IgYSBnaXZlbiBgTmFtZXNwYWNlYC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7TmFtZXNwYWNlfSBuc3BcbiAgICAgKiBAcGFyYW0ge0NsaWVudH0gY2xpZW50XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGhcbiAgICAgKiBAcGFja2FnZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5zcCwgY2xpZW50LCBhdXRoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFkZGl0aW9uYWwgaW5mb3JtYXRpb24gdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIFNvY2tldCBpbnN0YW5jZSBhbmQgd2hpY2ggd2lsbCBiZSB1c2VkIGluIHRoZSBmZXRjaFNvY2tldHMgbWV0aG9kXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRhdGEgPSB7fTtcbiAgICAgICAgdGhpcy5jb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5hY2tzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmZucyA9IFtdO1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHRoaXMuc2VydmVyID0gbnNwLnNlcnZlcjtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gdGhpcy5uc3AuYWRhcHRlcjtcbiAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0aGlzLmlkID0gbnNwLm5hbWUgIT09IFwiL1wiID8gbnNwLm5hbWUgKyBcIiNcIiArIGNsaWVudC5pZCA6IGNsaWVudC5pZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuaWQgPSBiYXNlNjRpZF8xLmRlZmF1bHQuZ2VuZXJhdGVJZCgpOyAvLyBkb24ndCByZXVzZSB0aGUgRW5naW5lLklPIGlkIGJlY2F1c2UgaXQncyBzZW5zaXRpdmUgaW5mb3JtYXRpb25cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmhhbmRzaGFrZSA9IHRoaXMuYnVpbGRIYW5kc2hha2UoYXV0aCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyB0aGUgYGhhbmRzaGFrZWAgQkMgb2JqZWN0XG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGJ1aWxkSGFuZHNoYWtlKGF1dGgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGhlYWRlcnM6IHRoaXMucmVxdWVzdC5oZWFkZXJzLFxuICAgICAgICAgICAgdGltZTogbmV3IERhdGUoKSArIFwiXCIsXG4gICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmNvbm4ucmVtb3RlQWRkcmVzcyxcbiAgICAgICAgICAgIHhkb21haW46ICEhdGhpcy5yZXF1ZXN0LmhlYWRlcnMub3JpZ2luLFxuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgc2VjdXJlOiAhIXRoaXMucmVxdWVzdC5jb25uZWN0aW9uLmVuY3J5cHRlZCxcbiAgICAgICAgICAgIGlzc3VlZDogK25ldyBEYXRlKCksXG4gICAgICAgICAgICB1cmw6IHRoaXMucmVxdWVzdC51cmwsXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBxdWVyeTogdGhpcy5yZXF1ZXN0Ll9xdWVyeSxcbiAgICAgICAgICAgIGF1dGgsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIHRoaXMgY2xpZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgcmV0dXJucyBgdHJ1ZWAuXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKGV4cG9ydHMuUkVTRVJWRURfRVZFTlRTLmhhcyhldikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgXCIke2V2fVwiIGlzIGEgcmVzZXJ2ZWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBbZXYsIC4uLmFyZ3NdO1xuICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5FVkVOVCxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIC8vIGFjY2VzcyBsYXN0IGFyZ3VtZW50IHRvIHNlZSBpZiBpdCdzIGFuIEFDSyBjYWxsYmFja1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFbZGF0YS5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBjb25zdCBpZCA9IHRoaXMubnNwLl9pZHMrKztcbiAgICAgICAgICAgIGRlYnVnKFwiZW1pdHRpbmcgcGFja2V0IHdpdGggYWNrIGlkICVkXCIsIGlkKTtcbiAgICAgICAgICAgIHRoaXMucmVnaXN0ZXJBY2tDYWxsYmFjayhpZCwgZGF0YS5wb3AoKSk7XG4gICAgICAgICAgICBwYWNrZXQuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MpO1xuICAgICAgICB0aGlzLmZsYWdzID0ge307XG4gICAgICAgIHRoaXMucGFja2V0KHBhY2tldCwgZmxhZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICByZWdpc3RlckFja0NhbGxiYWNrKGlkLCBhY2spIHtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMuZmxhZ3MudGltZW91dDtcbiAgICAgICAgaWYgKHRpbWVvdXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgYWNrKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJldmVudCB3aXRoIGFjayBpZCAlZCBoYXMgdGltZWQgb3V0IGFmdGVyICVkIG1zXCIsIGlkLCB0aW1lb3V0KTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUoaWQpO1xuICAgICAgICAgICAgYWNrLmNhbGwodGhpcywgbmV3IEVycm9yKFwib3BlcmF0aW9uIGhhcyB0aW1lZCBvdXRcIikpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgdGhpcy5hY2tzLnNldChpZCwgKC4uLmFyZ3MpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBhY2suYXBwbHkodGhpcywgW251bGwsIC4uLmFyZ3NdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdG8ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLnRvKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGJyb2FkY2FzdGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3QnJvYWRjYXN0T3BlcmF0b3IoKS5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZXhjZXB0KHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3QnJvYWRjYXN0T3BlcmF0b3IoKS5leGNlcHQocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNlbmQoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgd3JpdGUoLi4uYXJncykge1xuICAgICAgICB0aGlzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAtIHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHBhY2tldChwYWNrZXQsIG9wdHMgPSB7fSkge1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlICE9PSBvcHRzLmNvbXByZXNzO1xuICAgICAgICB0aGlzLmNsaWVudC5fcGFja2V0KHBhY2tldCwgb3B0cyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tcyAtIHJvb20gb3IgYXJyYXkgb2Ygcm9vbXNcbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgam9pbihyb29tcykge1xuICAgICAgICBkZWJ1ZyhcImpvaW4gcm9vbSAlc1wiLCByb29tcyk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuYWRkQWxsKHRoaXMuaWQsIG5ldyBTZXQoQXJyYXkuaXNBcnJheShyb29tcykgPyByb29tcyA6IFtyb29tc10pKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmVzIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByb29tXG4gICAgICogQHJldHVybiBhIFByb21pc2Ugb3Igbm90aGluZywgZGVwZW5kaW5nIG9uIHRoZSBhZGFwdGVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxlYXZlKHJvb20pIHtcbiAgICAgICAgZGVidWcoXCJsZWF2ZSByb29tICVzXCIsIHJvb20pO1xuICAgICAgICByZXR1cm4gdGhpcy5hZGFwdGVyLmRlbCh0aGlzLmlkLCByb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGVhdmUgYWxsIHJvb21zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBsZWF2ZUFsbCgpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbEFsbCh0aGlzLmlkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIGJ5IGBOYW1lc3BhY2VgIHVwb24gc3VjY2Vzc2Z1bFxuICAgICAqIG1pZGRsZXdhcmUgZXhlY3V0aW9uIChpZTogYXV0aG9yaXphdGlvbikuXG4gICAgICogU29ja2V0IGlzIGFkZGVkIHRvIG5hbWVzcGFjZSBhcnJheSBiZWZvcmVcbiAgICAgKiBjYWxsIHRvIGpvaW4sIHNvIGFkYXB0ZXJzIGNhbiBhY2Nlc3MgaXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmNvbm5lY3QoKSB7XG4gICAgICAgIGRlYnVnKFwic29ja2V0IGNvbm5lY3RlZCAtIHdyaXRpbmcgcGFja2V0XCIpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuam9pbih0aGlzLmlkKTtcbiAgICAgICAgaWYgKHRoaXMuY29ubi5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNULCBkYXRhOiB7IHNpZDogdGhpcy5pZCB9IH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIGVhY2ggcGFja2V0LiBDYWxsZWQgYnkgYENsaWVudGAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25wYWNrZXQocGFja2V0KSB7XG4gICAgICAgIGRlYnVnKFwiZ290IHBhY2tldCAlalwiLCBwYWNrZXQpO1xuICAgICAgICBzd2l0Y2ggKHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgICAgIHRoaXMub25ldmVudChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5CSU5BUllfRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmFjayhwYWNrZXQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUOlxuICAgICAgICAgICAgICAgIHRoaXMub25kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgdGhpcy5fb25lcnJvcihuZXcgRXJyb3IocGFja2V0LmRhdGEpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBldmVudCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1BhY2tldH0gcGFja2V0IC0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25ldmVudChwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IHBhY2tldC5kYXRhIHx8IFtdO1xuICAgICAgICBkZWJ1ZyhcImVtaXR0aW5nIGV2ZW50ICVqXCIsIGFyZ3MpO1xuICAgICAgICBpZiAobnVsbCAhPSBwYWNrZXQuaWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYXR0YWNoaW5nIGFjayBjYWxsYmFjayB0byBldmVudFwiKTtcbiAgICAgICAgICAgIGFyZ3MucHVzaCh0aGlzLmFjayhwYWNrZXQuaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fYW55TGlzdGVuZXJzICYmIHRoaXMuX2FueUxpc3RlbmVycy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycy5zbGljZSgpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiBsaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRpc3BhdGNoKGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhbiBhY2sgY2FsbGJhY2sgdG8gZW1pdCB3aXRoIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOdW1iZXJ9IGlkIC0gcGFja2V0IGlkXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhY2soaWQpIHtcbiAgICAgICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgICAgIGxldCBzZW50ID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvLyBwcmV2ZW50IGRvdWJsZSBjYWxsYmFja3NcbiAgICAgICAgICAgIGlmIChzZW50KVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgZGVidWcoXCJzZW5kaW5nIGFjayAlalwiLCBhcmdzKTtcbiAgICAgICAgICAgIHNlbGYucGFja2V0KHtcbiAgICAgICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQUNLLFxuICAgICAgICAgICAgICAgIGRhdGE6IGFyZ3MsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbnQgPSB0cnVlO1xuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhY2sgcGFja2V0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmFjayhwYWNrZXQpIHtcbiAgICAgICAgY29uc3QgYWNrID0gdGhpcy5hY2tzLmdldChwYWNrZXQuaWQpO1xuICAgICAgICBpZiAoXCJmdW5jdGlvblwiID09IHR5cGVvZiBhY2spIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2FsbGluZyBhY2sgJXMgd2l0aCAlalwiLCBwYWNrZXQuaWQsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICB0aGlzLmFja3MuZGVsZXRlKHBhY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImJhZCBhY2sgJXNcIiwgcGFja2V0LmlkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBjbGllbnQgZGlzY29ubmVjdCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGlzY29ubmVjdCgpIHtcbiAgICAgICAgZGVidWcoXCJnb3QgZGlzY29ubmVjdCBwYWNrZXRcIik7XG4gICAgICAgIHRoaXMuX29uY2xvc2UoXCJjbGllbnQgbmFtZXNwYWNlIGRpc2Nvbm5lY3RcIik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhbmRsZXMgYSBjbGllbnQgZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbmVycm9yKGVycikge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoXCJlcnJvclwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJNaXNzaW5nIGVycm9yIGhhbmRsZXIgb24gYHNvY2tldGAuXCIpO1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIuc3RhY2spO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGNsb3NpbmcuIENhbGxlZCBieSBgQ2xpZW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSByZWFzb25cbiAgICAgKiBAdGhyb3cge0Vycm9yfSBvcHRpb25hbCBlcnJvciBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uY2xvc2UocmVhc29uKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgZGVidWcoXCJjbG9zaW5nIHNvY2tldCAtIHJlYXNvbiAlc1wiLCByZWFzb24pO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RpbmdcIiwgcmVhc29uKTtcbiAgICAgICAgdGhpcy5sZWF2ZUFsbCgpO1xuICAgICAgICB0aGlzLm5zcC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmNsaWVudC5fcmVtb3ZlKHRoaXMpO1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImRpc2Nvbm5lY3RcIiwgcmVhc29uKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9kdWNlcyBhbiBgZXJyb3JgIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBlcnIgLSBlcnJvciBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Vycm9yKGVycikge1xuICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1IsIGRhdGE6IGVyciB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGVkKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIGlmIChjbG9zZSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQuX2Rpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRElTQ09OTkVDVCB9KTtcbiAgICAgICAgICAgIHRoaXMuX29uY2xvc2UoXCJzZXJ2ZXIgbmFtZXNwYWNlIGRpc2Nvbm5lY3RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgY29tcHJlc3MoY29tcHJlc3MpIHtcbiAgICAgICAgdGhpcy5mbGFncy5jb21wcmVzcyA9IGNvbXByZXNzO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICB0aGlzLmZsYWdzLnZvbGF0aWxlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGV2ZW50IGRhdGEgd2lsbCBvbmx5IGJlIGJyb2FkY2FzdCB0byBldmVyeSBzb2NrZXRzIGJ1dCB0aGVcbiAgICAgKiBzZW5kZXIuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IGJyb2FkY2FzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubmV3QnJvYWRjYXN0T3BlcmF0b3IoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmxvY2FsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCB3aXRoIGFuIGVycm9yIHdoZW4gdGhlXG4gICAgICogZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgd2l0aG91dCBhbiBhY2tub3dsZWRnZW1lbnQgZnJvbSB0aGUgY2xpZW50OlxuICAgICAqXG4gICAgICogYGBgXG4gICAgICogc29ja2V0LnRpbWVvdXQoNTAwMCkuZW1pdChcIm15LWV2ZW50XCIsIChlcnIpID0+IHtcbiAgICAgKiAgIGlmIChlcnIpIHtcbiAgICAgKiAgICAgLy8gdGhlIGNsaWVudCBkaWQgbm90IGFja25vd2xlZGdlIHRoZSBldmVudCBpbiB0aGUgZ2l2ZW4gZGVsYXlcbiAgICAgKiAgIH1cbiAgICAgKiB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdGltZW91dCh0aW1lb3V0KSB7XG4gICAgICAgIHRoaXMuZmxhZ3MudGltZW91dCA9IHRpbWVvdXQ7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNwYXRjaCBpbmNvbWluZyBldmVudCB0byBzb2NrZXQgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQgLSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc3BhdGNoKGV2ZW50KSB7XG4gICAgICAgIGRlYnVnKFwiZGlzcGF0Y2hpbmcgYW4gZXZlbnQgJWpcIiwgZXZlbnQpO1xuICAgICAgICB0aGlzLnJ1bihldmVudCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fb25lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdFVudHlwZWQuYXBwbHkodGhpcywgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJpZ25vcmUgcGFja2V0IHJlY2VpdmVkIGFmdGVyIGRpc2Nvbm5lY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIHNvY2tldCBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBtaWRkbGV3YXJlIGZ1bmN0aW9uIChldmVudCwgbmV4dClcbiAgICAgKiBAcmV0dXJuIHtTb2NrZXR9IHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuZm5zLnB1c2goZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIG1pZGRsZXdhcmUgZm9yIGFuIGluY29taW5nIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtBcnJheX0gZXZlbnQgLSBldmVudCB0aGF0IHdpbGwgZ2V0IGVtaXR0ZWRcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGxhc3QgZm4gY2FsbCBpbiB0aGUgbWlkZGxld2FyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVuKGV2ZW50LCBmbikge1xuICAgICAgICBjb25zdCBmbnMgPSB0aGlzLmZucy5zbGljZSgwKTtcbiAgICAgICAgaWYgKCFmbnMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIGZuKG51bGwpO1xuICAgICAgICBmdW5jdGlvbiBydW4oaSkge1xuICAgICAgICAgICAgZm5zW2ldKGV2ZW50LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4obnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gZ28gb24gdG8gbmV4dFxuICAgICAgICAgICAgICAgIHJ1bihpICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW4oMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIHNvY2tldCBpcyBjdXJyZW50bHkgZGlzY29ubmVjdGVkXG4gICAgICovXG4gICAgZ2V0IGRpc2Nvbm5lY3RlZCgpIHtcbiAgICAgICAgcmV0dXJuICF0aGlzLmNvbm5lY3RlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQSByZWZlcmVuY2UgdG8gdGhlIHJlcXVlc3QgdGhhdCBvcmlnaW5hdGVkIHRoZSB1bmRlcmx5aW5nIEVuZ2luZS5JTyBTb2NrZXQuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHJlcXVlc3QoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5yZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBDbGllbnQgdHJhbnNwb3J0IGNvbm5lY3Rpb24gKEVuZ2luZS5JTyBTb2NrZXQgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgY29ubigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNvbm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgcm9vbXMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuc29ja2V0Um9vbXModGhpcy5pZCkgfHwgbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb25BbnkobGlzdGVuZXIpIHtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuIFRoZSBldmVudCBuYW1lIGlzIHBhc3NlZCBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlXG4gICAgICogY2FsbGJhY2suIFRoZSBsaXN0ZW5lciBpcyBhZGRlZCB0byB0aGUgYmVnaW5uaW5nIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgcHJlcGVuZEFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy51bnNoaWZ0KGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdGhlIGxpc3RlbmVyIHRoYXQgd2lsbCBiZSBmaXJlZCB3aGVuIGFueSBldmVudCBpcyBlbWl0dGVkLlxuICAgICAqXG4gICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIG9mZkFueShsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIXRoaXMuX2FueUxpc3RlbmVycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjb25zdCBsaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnM7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3RlbmVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChsaXN0ZW5lciA9PT0gbGlzdGVuZXJzW2ldKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVycy5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIGFuIGFycmF5IG9mIGxpc3RlbmVycyB0aGF0IGFyZSBsaXN0ZW5pbmcgZm9yIGFueSBldmVudCB0aGF0IGlzIHNwZWNpZmllZC4gVGhpcyBhcnJheSBjYW4gYmUgbWFuaXB1bGF0ZWQsXG4gICAgICogZS5nLiB0byByZW1vdmUgbGlzdGVuZXJzLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpc3RlbmVyc0FueSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICB9XG4gICAgbmV3QnJvYWRjYXN0T3BlcmF0b3IoKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIG5ldyBTZXQoKSwgbmV3IFNldChbdGhpcy5pZF0pLCBmbGFncyk7XG4gICAgfVxufVxuZXhwb3J0cy5Tb2NrZXQgPSBTb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuLyoqXG4gKiBTdHJpY3RseSB0eXBlZCB2ZXJzaW9uIG9mIGFuIGBFdmVudEVtaXR0ZXJgLiBBIGBUeXBlZEV2ZW50RW1pdHRlcmAgdGFrZXMgdHlwZVxuICogcGFyYW1ldGVycyBmb3IgbWFwcGluZ3Mgb2YgZXZlbnQgbmFtZXMgdG8gZXZlbnQgZGF0YSB0eXBlcywgYW5kIHN0cmljdGx5XG4gKiB0eXBlcyBtZXRob2QgY2FsbHMgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGFjY29yZGluZyB0byB0aGVzZSBldmVudCBtYXBzLlxuICpcbiAqIEB0eXBlUGFyYW0gTGlzdGVuRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogbGlzdGVuZWQgdG8gd2l0aCBgb25gIG9yIGBvbmNlYFxuICogQHR5cGVQYXJhbSBFbWl0RXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgdXNlci1kZWZpbmVkIGV2ZW50cyB0aGF0IGNhbiBiZVxuICogZW1pdHRlZCB3aXRoIGBlbWl0YFxuICogQHR5cGVQYXJhbSBSZXNlcnZlZEV2ZW50cyAtIGBFdmVudHNNYXBgIG9mIHJlc2VydmVkIGV2ZW50cywgdGhhdCBjYW4gYmVcbiAqIGVtaXR0ZWQgYnkgc29ja2V0LmlvIHdpdGggYGVtaXRSZXNlcnZlZGAsIGFuZCBjYW4gYmUgbGlzdGVuZWQgdG8gd2l0aFxuICogYGxpc3RlbmAuXG4gKi9cbmNsYXNzIFN0cmljdEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQWRkcyB0aGUgYGxpc3RlbmVyYCBmdW5jdGlvbiBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYGV2YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub24oZXYsIGxpc3RlbmVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIG9uZS10aW1lIGBsaXN0ZW5lcmAgZnVuY3Rpb24gYXMgYW4gZXZlbnQgbGlzdGVuZXIgZm9yIGBldmAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgTmFtZSBvZiB0aGUgZXZlbnRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXIgQ2FsbGJhY2sgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBvbmNlKGV2LCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gc3VwZXIub25jZShldiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBhcmdzIFZhbHVlcyB0byBzZW5kIHRvIGxpc3RlbmVycyBvZiB0aGlzIGV2ZW50XG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGEgcmVzZXJ2ZWQgZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGVtaXQgaXRzIG93biByZXNlcnZlZCBldmVudHMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgUmVzZXJ2ZWQgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFJlc2VydmVkKGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBgcHJvdGVjdGVkYCwgc28gdGhhdCBvbmx5IGEgY2xhc3MgZXh0ZW5kaW5nXG4gICAgICogYFN0cmljdEV2ZW50RW1pdHRlcmAgY2FuIGdldCBhcm91bmQgdGhlIHN0cmljdCB0eXBpbmcuIFRoaXMgaXMgdXNlZnVsIGZvclxuICAgICAqIGNhbGxpbmcgYGVtaXQuYXBwbHlgLCB3aGljaCBjYW4gYmUgY2FsbGVkIGFzIGBlbWl0VW50eXBlZC5hcHBseWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgRXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIEFyZ3VtZW50cyB0byBlbWl0IGFsb25nIHdpdGggdGhlIGV2ZW50XG4gICAgICovXG4gICAgZW1pdFVudHlwZWQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBsaXN0ZW5lcnMgbGlzdGVuaW5nIHRvIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2ZW50IEV2ZW50IG5hbWVcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBsaXN0ZW5lcnMgc3Vic2NyaWJlZCB0byBgZXZlbnRgXG4gICAgICovXG4gICAgbGlzdGVuZXJzKGV2ZW50KSB7XG4gICAgICAgIHJldHVybiBzdXBlci5saXN0ZW5lcnMoZXZlbnQpO1xuICAgIH1cbn1cbmV4cG9ydHMuU3RyaWN0RXZlbnRFbWl0dGVyID0gU3RyaWN0RXZlbnRFbWl0dGVyO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnNlcnZlRmlsZSA9IGV4cG9ydHMucmVzdG9yZUFkYXB0ZXIgPSBleHBvcnRzLnBhdGNoQWRhcHRlciA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBmc18xID0gcmVxdWlyZShcImZzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcInNvY2tldC5pbzphZGFwdGVyLXV3c1wiKTtcbmNvbnN0IFNFUEFSQVRPUiA9IFwiXFx4MWZcIjsgLy8gc2VlIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGltaXRlciNBU0NJSV9kZWxpbWl0ZWRfdGV4dFxuY29uc3QgeyBhZGRBbGwsIGRlbCwgYnJvYWRjYXN0IH0gPSBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlO1xuZnVuY3Rpb24gcGF0Y2hBZGFwdGVyKGFwcCAvKiA6IFRlbXBsYXRlZEFwcCAqLykge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gZnVuY3Rpb24gKGlkLCByb29tcykge1xuICAgICAgICBjb25zdCBpc05ldyA9ICF0aGlzLnNpZHMuaGFzKGlkKTtcbiAgICAgICAgYWRkQWxsLmNhbGwodGhpcywgaWQsIHJvb21zKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoIXNvY2tldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSA9PT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgc3Vic2NyaWJlKHRoaXMubnNwLm5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNOZXcpIHtcbiAgICAgICAgICAgIHNvY2tldC5jb25uLm9uKFwidXBncmFkZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9vbXMgPSB0aGlzLnNpZHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuZGVsID0gZnVuY3Rpb24gKGlkLCByb29tKSB7XG4gICAgICAgIGRlbC5jYWxsKHRoaXMsIGlkLCByb29tKTtcbiAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3Auc29ja2V0cy5nZXQoaWQpO1xuICAgICAgICBpZiAoc29ja2V0ICYmIHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBzb2NrZXQuY29ubi5pZDtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHdlYnNvY2tldCA9IHNvY2tldC5jb25uLnRyYW5zcG9ydC5zb2NrZXQ7XG4gICAgICAgICAgICBjb25zdCB0b3BpYyA9IGAke3RoaXMubnNwLm5hbWV9JHtTRVBBUkFUT1J9JHtyb29tfWA7XG4gICAgICAgICAgICBkZWJ1ZyhcInVuc3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgZnJvbSB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIHRvcGljKTtcbiAgICAgICAgICAgIHdlYnNvY2tldC51bnN1YnNjcmliZSh0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gZnVuY3Rpb24gKHBhY2tldCwgb3B0cykge1xuICAgICAgICBjb25zdCB1c2VGYXN0UHVibGlzaCA9IG9wdHMucm9vbXMuc2l6ZSA8PSAxICYmIG9wdHMuZXhjZXB0LnNpemUgPT09IDA7XG4gICAgICAgIGlmICghdXNlRmFzdFB1Ymxpc2gpIHtcbiAgICAgICAgICAgIGJyb2FkY2FzdC5jYWxsKHRoaXMsIHBhY2tldCwgb3B0cyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBiYXNlUGFja2V0T3B0cyA9IHtcbiAgICAgICAgICAgIHByZUVuY29kZWQ6IHRydWUsXG4gICAgICAgICAgICB2b2xhdGlsZTogZmxhZ3Mudm9sYXRpbGUsXG4gICAgICAgICAgICBjb21wcmVzczogZmxhZ3MuY29tcHJlc3MsXG4gICAgICAgIH07XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IHRoaXMuZW5jb2Rlci5lbmNvZGUocGFja2V0KTtcbiAgICAgICAgY29uc3QgdG9waWMgPSBvcHRzLnJvb21zLnNpemUgPT09IDBcbiAgICAgICAgICAgID8gdGhpcy5uc3AubmFtZVxuICAgICAgICAgICAgOiBgJHt0aGlzLm5zcC5uYW1lfSR7U0VQQVJBVE9SfSR7b3B0cy5yb29tcy5rZXlzKCkubmV4dCgpLnZhbHVlfWA7XG4gICAgICAgIGRlYnVnKFwiZmFzdCBwdWJsaXNoIHRvICVzXCIsIHRvcGljKTtcbiAgICAgICAgLy8gZmFzdCBwdWJsaXNoIGZvciBjbGllbnRzIGNvbm5lY3RlZCB3aXRoIFdlYlNvY2tldFxuICAgICAgICBlbmNvZGVkUGFja2V0cy5mb3JFYWNoKChlbmNvZGVkUGFja2V0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeSA9IHR5cGVvZiBlbmNvZGVkUGFja2V0ICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgLy8gXCI0XCIgYmVpbmcgdGhlIG1lc3NhZ2UgdHlwZSBpbiB0aGUgRW5naW5lLklPIHByb3RvY29sLCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3NvY2tldGlvL2VuZ2luZS5pby1wcm90b2NvbFxuICAgICAgICAgICAgYXBwLnB1Ymxpc2godG9waWMsIGlzQmluYXJ5ID8gZW5jb2RlZFBhY2tldCA6IFwiNFwiICsgZW5jb2RlZFBhY2tldCwgaXNCaW5hcnkpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5hcHBseShvcHRzLCAoc29ja2V0KSA9PiB7XG4gICAgICAgICAgICBpZiAoc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgIT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgICAgICAvLyBjbGFzc2ljIHB1Ymxpc2ggZm9yIGNsaWVudHMgY29ubmVjdGVkIHdpdGggSFRUUCBsb25nLXBvbGxpbmdcbiAgICAgICAgICAgICAgICBzb2NrZXQuY2xpZW50LndyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIGJhc2VQYWNrZXRPcHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydHMucGF0Y2hBZGFwdGVyID0gcGF0Y2hBZGFwdGVyO1xuZnVuY3Rpb24gc3Vic2NyaWJlKG5hbWVzcGFjZU5hbWUsIHNvY2tldCwgaXNOZXcsIHJvb21zKSB7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBjb25zdCB3ZWJzb2NrZXQgPSBzb2NrZXQuY29ubi50cmFuc3BvcnQuc29ja2V0O1xuICAgIGlmIChpc05ldykge1xuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgbmFtZXNwYWNlTmFtZSk7XG4gICAgICAgIHdlYnNvY2tldC5zdWJzY3JpYmUobmFtZXNwYWNlTmFtZSk7XG4gICAgfVxuICAgIHJvb21zLmZvckVhY2goKHJvb20pID0+IHtcbiAgICAgICAgY29uc3QgdG9waWMgPSBgJHtuYW1lc3BhY2VOYW1lfSR7U0VQQVJBVE9SfSR7cm9vbX1gOyAvLyAnIycgY2FuIGJlIHVzZWQgYXMgd2lsZGNhcmRcbiAgICAgICAgZGVidWcoXCJzdWJzY3JpYmUgY29ubmVjdGlvbiAlcyB0byB0b3BpYyAlc1wiLCBzZXNzaW9uSWQsIHRvcGljKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZSh0b3BpYyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiByZXN0b3JlQWRhcHRlcigpIHtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmFkZEFsbCA9IGFkZEFsbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmRlbCA9IGRlbDtcbiAgICBzb2NrZXRfaW9fYWRhcHRlcl8xLkFkYXB0ZXIucHJvdG90eXBlLmJyb2FkY2FzdCA9IGJyb2FkY2FzdDtcbn1cbmV4cG9ydHMucmVzdG9yZUFkYXB0ZXIgPSByZXN0b3JlQWRhcHRlcjtcbmNvbnN0IHRvQXJyYXlCdWZmZXIgPSAoYnVmZmVyKSA9PiB7XG4gICAgY29uc3QgeyBidWZmZXI6IGFycmF5QnVmZmVyLCBieXRlT2Zmc2V0LCBieXRlTGVuZ3RoIH0gPSBidWZmZXI7XG4gICAgcmV0dXJuIGFycmF5QnVmZmVyLnNsaWNlKGJ5dGVPZmZzZXQsIGJ5dGVPZmZzZXQgKyBieXRlTGVuZ3RoKTtcbn07XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9rb2xvZHppZWpjemFrLXN6L3V3ZWJzb2NrZXQtc2VydmVcbmZ1bmN0aW9uIHNlcnZlRmlsZShyZXMgLyogOiBIdHRwUmVzcG9uc2UgKi8sIGZpbGVwYXRoKSB7XG4gICAgY29uc3QgeyBzaXplIH0gPSAoMCwgZnNfMS5zdGF0U3luYykoZmlsZXBhdGgpO1xuICAgIGNvbnN0IHJlYWRTdHJlYW0gPSAoMCwgZnNfMS5jcmVhdGVSZWFkU3RyZWFtKShmaWxlcGF0aCk7XG4gICAgY29uc3QgZGVzdHJveVJlYWRTdHJlYW0gPSAoKSA9PiAhcmVhZFN0cmVhbS5kZXN0cm95ZWQgJiYgcmVhZFN0cmVhbS5kZXN0cm95KCk7XG4gICAgY29uc3Qgb25FcnJvciA9IChlcnJvcikgPT4ge1xuICAgICAgICBkZXN0cm95UmVhZFN0cmVhbSgpO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9O1xuICAgIGNvbnN0IG9uRGF0YUNodW5rID0gKGNodW5rKSA9PiB7XG4gICAgICAgIGNvbnN0IGFycmF5QnVmZmVyQ2h1bmsgPSB0b0FycmF5QnVmZmVyKGNodW5rKTtcbiAgICAgICAgY29uc3QgbGFzdE9mZnNldCA9IHJlcy5nZXRXcml0ZU9mZnNldCgpO1xuICAgICAgICBjb25zdCBbb2ssIGRvbmVdID0gcmVzLnRyeUVuZChhcnJheUJ1ZmZlckNodW5rLCBzaXplKTtcbiAgICAgICAgaWYgKCFkb25lICYmICFvaykge1xuICAgICAgICAgICAgcmVhZFN0cmVhbS5wYXVzZSgpO1xuICAgICAgICAgICAgcmVzLm9uV3JpdGFibGUoKG9mZnNldCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtvaywgZG9uZV0gPSByZXMudHJ5RW5kKGFycmF5QnVmZmVyQ2h1bmsuc2xpY2Uob2Zmc2V0IC0gbGFzdE9mZnNldCksIHNpemUpO1xuICAgICAgICAgICAgICAgIGlmICghZG9uZSAmJiBvaykge1xuICAgICAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnJlc3VtZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gb2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmVzLm9uQWJvcnRlZChkZXN0cm95UmVhZFN0cmVhbSk7XG4gICAgcmVhZFN0cmVhbVxuICAgICAgICAub24oXCJkYXRhXCIsIG9uRGF0YUNodW5rKVxuICAgICAgICAub24oXCJlcnJvclwiLCBvbkVycm9yKVxuICAgICAgICAub24oXCJlbmRcIiwgZGVzdHJveVJlYWRTdHJlYW0pO1xufVxuZXhwb3J0cy5zZXJ2ZUZpbGUgPSBzZXJ2ZUZpbGU7XG4iLCJpbXBvcnQgaW8gZnJvbSBcIi4vZGlzdC9pbmRleC5qc1wiO1xuXG5leHBvcnQgY29uc3Qge1NlcnZlciwgTmFtZXNwYWNlLCBTb2NrZXR9ID0gaW87XG4iXSwibmFtZXMiOlsiX19pbXBvcnREZWZhdWx0IiwibW9kIiwiX19lc01vZHVsZSIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwiZXhwb3J0cyIsInZhbHVlIiwiYmxha2UyYl8xIiwicmVxdWlyZSIsImJlY2gzMl8xIiwiREFUQSIsIkFzc2V0RmluZ2VycHJpbnQiLCJoYXNoQnVmIiwid29yZHMiLCJiZWNoMzIiLCJ0b1dvcmRzIiwiZW5jb2RlIiwiQnVmZmVyIiwiZnJvbSIsInRvU3RyaW5nIiwiZmluZ2VycHJpbnQiLCJzbGljZSIsImhhc2giLCJwb2xpY3lJZCIsImFzc2V0TmFtZSIsInVwZGF0ZSIsIlVpbnQ4QXJyYXkiLCJkaWdlc3QiLCJmcm9tSGFzaCIsImRlY29kZSIsInByZWZpeCIsIkVycm9yIiwiZnJvbVdvcmRzIiwiY2hhcnMiLCJsb29rdXAiLCJpIiwibGVuZ3RoIiwiY2hhckNvZGVBdCIsImFycmF5YnVmZmVyIiwiYnl0ZXMiLCJsZW4iLCJiYXNlNjQiLCJzdWJzdHJpbmciLCJidWZmZXJMZW5ndGgiLCJwIiwiZW5jb2RlZDEiLCJlbmNvZGVkMiIsImVuY29kZWQzIiwiZW5jb2RlZDQiLCJBcnJheUJ1ZmZlciIsIk5lZ290aWF0b3IiLCJtaW1lIiwibW9kdWxlIiwiQWNjZXB0cyIsInJlcSIsImhlYWRlcnMiLCJuZWdvdGlhdG9yIiwicHJvdG90eXBlIiwidHlwZSIsInR5cGVzIiwidHlwZXNfIiwiQXJyYXkiLCJpc0FycmF5IiwiYXJndW1lbnRzIiwibWVkaWFUeXBlcyIsImFjY2VwdCIsIm1pbWVzIiwibWFwIiwiZXh0VG9NaW1lIiwiYWNjZXB0cyIsImZpbHRlciIsInZhbGlkTWltZSIsImZpcnN0IiwiaW5kZXhPZiIsImVuY29kaW5nIiwiZW5jb2RpbmdzIiwiZW5jb2RpbmdzXyIsImNoYXJzZXQiLCJjaGFyc2V0cyIsImNoYXJzZXRzXyIsImxhbmciLCJsYW5ncyIsImxhbmd1YWdlIiwibGFuZ3VhZ2VzIiwibGFuZ3VhZ2VzXyIsInV0aWxzIiwic2V0dGxlIiwiY29va2llcyIsImJ1aWxkVVJMIiwiYnVpbGRGdWxsUGF0aCIsInBhcnNlSGVhZGVycyIsImlzVVJMU2FtZU9yaWdpbiIsImNyZWF0ZUVycm9yIiwieGhyQWRhcHRlciIsImNvbmZpZyIsIlByb21pc2UiLCJkaXNwYXRjaFhoclJlcXVlc3QiLCJyZXNvbHZlIiwicmVqZWN0IiwicmVxdWVzdERhdGEiLCJkYXRhIiwicmVxdWVzdEhlYWRlcnMiLCJyZXNwb25zZVR5cGUiLCJpc0Zvcm1EYXRhIiwicmVxdWVzdCIsIlhNTEh0dHBSZXF1ZXN0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJ1bmVzY2FwZSIsImVuY29kZVVSSUNvbXBvbmVudCIsIkF1dGhvcml6YXRpb24iLCJidG9hIiwiZnVsbFBhdGgiLCJiYXNlVVJMIiwidXJsIiwib3BlbiIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsInRpbWVvdXQiLCJvbmxvYWRlbmQiLCJyZXNwb25zZUhlYWRlcnMiLCJnZXRBbGxSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZURhdGEiLCJyZXNwb25zZVRleHQiLCJyZXNwb25zZSIsInN0YXR1cyIsInN0YXR1c1RleHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInJlc3BvbnNlVVJMIiwic2V0VGltZW91dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwidHJhbnNpdGlvbmFsIiwiY2xhcmlmeVRpbWVvdXRFcnJvciIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwieHNyZkNvb2tpZU5hbWUiLCJyZWFkIiwidW5kZWZpbmVkIiwieHNyZkhlYWRlck5hbWUiLCJmb3JFYWNoIiwic2V0UmVxdWVzdEhlYWRlciIsInZhbCIsImtleSIsInRvTG93ZXJDYXNlIiwiaXNVbmRlZmluZWQiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsInRoZW4iLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiYmluZCIsIkF4aW9zIiwibWVyZ2VDb25maWciLCJkZWZhdWx0cyIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImNvbnRleHQiLCJpbnN0YW5jZSIsImV4dGVuZCIsImF4aW9zIiwiY3JlYXRlIiwiaW5zdGFuY2VDb25maWciLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJzcHJlYWQiLCJpc0F4aW9zRXJyb3IiLCJtZXNzYWdlIiwiX19DQU5DRUxfXyIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJ0b2tlbiIsInJlYXNvbiIsInRocm93SWZSZXF1ZXN0ZWQiLCJzb3VyY2UiLCJjIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwidmFsaWRhdG9yIiwidmFsaWRhdG9ycyIsImludGVyY2VwdG9ycyIsImFzc2VydE9wdGlvbnMiLCJzaWxlbnRKU09OUGFyc2luZyIsImZvcmNlZEpTT05QYXJzaW5nIiwicmVxdWVzdEludGVyY2VwdG9yQ2hhaW4iLCJzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMiLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwicnVuV2hlbiIsInN5bmNocm9ub3VzIiwidW5zaGlmdCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicmVzcG9uc2VJbnRlcmNlcHRvckNoYWluIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwicHVzaCIsImNoYWluIiwiYXBwbHkiLCJjb25jYXQiLCJzaGlmdCIsIm5ld0NvbmZpZyIsIm9uRnVsZmlsbGVkIiwib25SZWplY3RlZCIsImVycm9yIiwiZ2V0VXJpIiwicmVwbGFjZSIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJoYW5kbGVycyIsInVzZSIsIm9wdGlvbnMiLCJlamVjdCIsImlkIiwiZm4iLCJmb3JFYWNoSGFuZGxlciIsImgiLCJpc0Fic29sdXRlVVJMIiwiY29tYmluZVVSTHMiLCJyZXF1ZXN0ZWRVUkwiLCJlbmhhbmNlRXJyb3IiLCJjb2RlIiwidHJhbnNmb3JtRGF0YSIsInRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJjYWxsIiwidHJhbnNmb3JtUmVxdWVzdCIsIm1lcmdlIiwiY29tbW9uIiwiY2xlYW5IZWFkZXJDb25maWciLCJhZGFwdGVyIiwib25BZGFwdGVyUmVzb2x1dGlvbiIsInRyYW5zZm9ybVJlc3BvbnNlIiwib25BZGFwdGVyUmVqZWN0aW9uIiwidG9KU09OIiwibmFtZSIsImRlc2NyaXB0aW9uIiwibnVtYmVyIiwiZmlsZU5hbWUiLCJsaW5lTnVtYmVyIiwiY29sdW1uTnVtYmVyIiwic3RhY2siLCJjb25maWcxIiwiY29uZmlnMiIsInZhbHVlRnJvbUNvbmZpZzJLZXlzIiwibWVyZ2VEZWVwUHJvcGVydGllc0tleXMiLCJkZWZhdWx0VG9Db25maWcyS2V5cyIsImRpcmVjdE1lcmdlS2V5cyIsImdldE1lcmdlZFZhbHVlIiwidGFyZ2V0IiwiaXNQbGFpbk9iamVjdCIsIm1lcmdlRGVlcFByb3BlcnRpZXMiLCJwcm9wIiwidmFsdWVGcm9tQ29uZmlnMiIsImRlZmF1bHRUb0NvbmZpZzIiLCJheGlvc0tleXMiLCJvdGhlcktleXMiLCJrZXlzIiwiZmlsdGVyQXhpb3NLZXlzIiwidmFsaWRhdGVTdGF0dXMiLCJmbnMiLCJ0cmFuc2Zvcm0iLCJub3JtYWxpemVIZWFkZXJOYW1lIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJnZXREZWZhdWx0QWRhcHRlciIsInByb2Nlc3MiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlciIsImVuY29kZXIiLCJpc1N0cmluZyIsIkpTT04iLCJwYXJzZSIsInRyaW0iLCJlIiwic3RyaW5naWZ5IiwiaXNBcnJheUJ1ZmZlciIsImlzQnVmZmVyIiwiaXNTdHJlYW0iLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0FycmF5QnVmZmVyVmlldyIsImJ1ZmZlciIsImlzVVJMU2VhcmNoUGFyYW1zIiwiaXNPYmplY3QiLCJzdHJpY3RKU09OUGFyc2luZyIsIm1heENvbnRlbnRMZW5ndGgiLCJtYXhCb2R5TGVuZ3RoIiwidGhpc0FyZyIsIndyYXAiLCJhcmdzIiwic2VyaWFsaXplZFBhcmFtcyIsInBhcnRzIiwic2VyaWFsaXplIiwicGFyc2VWYWx1ZSIsInYiLCJpc0RhdGUiLCJ0b0lTT1N0cmluZyIsImpvaW4iLCJoYXNobWFya0luZGV4IiwicmVsYXRpdmVVUkwiLCJzdGFuZGFyZEJyb3dzZXJFbnYiLCJ3cml0ZSIsImV4cGlyZXMiLCJwYXRoIiwiZG9tYWluIiwic2VjdXJlIiwiY29va2llIiwiaXNOdW1iZXIiLCJEYXRlIiwidG9HTVRTdHJpbmciLCJkb2N1bWVudCIsIm1hdGNoIiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVtb3ZlIiwibm93Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwidGVzdCIsInBheWxvYWQiLCJtc2llIiwibmF2aWdhdG9yIiwidXNlckFnZW50IiwidXJsUGFyc2luZ05vZGUiLCJjcmVhdGVFbGVtZW50Iiwib3JpZ2luVVJMIiwicmVzb2x2ZVVSTCIsImhyZWYiLCJzZXRBdHRyaWJ1dGUiLCJwcm90b2NvbCIsImhvc3QiLCJzZWFyY2giLCJob3N0bmFtZSIsInBvcnQiLCJwYXRobmFtZSIsImNoYXJBdCIsIndpbmRvdyIsImxvY2F0aW9uIiwicmVxdWVzdFVSTCIsInBhcnNlZCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImlnbm9yZUR1cGxpY2F0ZU9mIiwic3BsaXQiLCJsaW5lIiwic3Vic3RyIiwiY2FsbGJhY2siLCJhcnIiLCJwa2ciLCJ0aGluZyIsImRlcHJlY2F0ZWRXYXJuaW5ncyIsImN1cnJlbnRWZXJBcnIiLCJ2ZXJzaW9uIiwiaXNPbGRlclZlcnNpb24iLCJ0aGFuVmVyc2lvbiIsInBrZ1ZlcnNpb25BcnIiLCJkZXN0VmVyIiwiaXNEZXByZWNhdGVkIiwiZm9ybWF0TWVzc2FnZSIsIm9wdCIsImRlc2MiLCJvcHRzIiwiY29uc29sZSIsIndhcm4iLCJzY2hlbWEiLCJhbGxvd1Vua25vd24iLCJyZXN1bHQiLCJjb25zdHJ1Y3RvciIsIkZvcm1EYXRhIiwiaXNWaWV3IiwiZ2V0UHJvdG90eXBlT2YiLCJpc0Z1bmN0aW9uIiwicGlwZSIsIlVSTFNlYXJjaFBhcmFtcyIsInN0ciIsInByb2R1Y3QiLCJvYmoiLCJsIiwiaGFzT3duUHJvcGVydHkiLCJhc3NpZ25WYWx1ZSIsImEiLCJiIiwic3RyaXBCT00iLCJjb250ZW50IiwiYnl0ZUxlbmd0aCIsInRvQnl0ZUFycmF5IiwiZnJvbUJ5dGVBcnJheSIsInJldkxvb2t1cCIsIkFyciIsImdldExlbnMiLCJiNjQiLCJ2YWxpZExlbiIsInBsYWNlSG9sZGVyc0xlbiIsImxlbnMiLCJfYnl0ZUxlbmd0aCIsInRtcCIsImN1ckJ5dGUiLCJ0cmlwbGV0VG9CYXNlNjQiLCJudW0iLCJlbmNvZGVDaHVuayIsInVpbnQ4Iiwic3RhcnQiLCJlbmQiLCJvdXRwdXQiLCJleHRyYUJ5dGVzIiwibWF4Q2h1bmtMZW5ndGgiLCJsZW4yIiwiY3J5cHRvIiwiQmFzZTY0SWQiLCJnZXRSYW5kb21CeXRlcyIsIkJVRkZFUl9TSVpFIiwic2VsZiIsInJhbmRvbUJ5dGVzIiwiYnl0ZXNJbkJ1ZmZlciIsInBhcnNlSW50IiwidGhyZXNob2xkIiwiYnl0ZXNCdWZmZXJJbmRleCIsImJ5dGVzQnVmZmVyIiwiaXNHZW5lcmF0aW5nQnl0ZXMiLCJlcnIiLCJnZW5lcmF0ZUlkIiwicmFuZCIsImFsbG9jIiwid3JpdGVJbnQzMkJFIiwiTWF0aCIsImFicyIsInJhbmRvbSIsInNlcXVlbmNlTnVtYmVyIiwiY29weSIsInBvdyIsImJlY2gzMm0iLCJBTFBIQUJFVCIsIkFMUEhBQkVUX01BUCIsInoiLCJ4IiwicG9seW1vZFN0ZXAiLCJwcmUiLCJwcmVmaXhDaGsiLCJjaGsiLCJjb252ZXJ0IiwiaW5CaXRzIiwib3V0Qml0cyIsInBhZCIsImJpdHMiLCJtYXhWIiwiZnJvbVdvcmRzVW5zYWZlIiwicmVzIiwiZ2V0TGlicmFyeUZyb21FbmNvZGluZyIsIkVOQ09ESU5HX0NPTlNUIiwiTElNSVQiLCJfX2RlY29kZSIsImxvd2VyZWQiLCJ1cHBlcmVkIiwibGFzdEluZGV4T2YiLCJ3b3JkQ2hhcnMiLCJkZWNvZGVVbnNhZmUiLCJsb2FkV2ViQXNzZW1ibHkiLCJzdXBwb3J0ZWQiLCJXZWJBc3NlbWJseSIsImltcCIsImltcG9ydHMiLCJ3YXNtIiwidG9VaW50OEFycmF5IiwicmVhZHkiLCJtZW1vcnkiLCJyZWFsbG9jIiwib25sb2FkIiwic2l6ZSIsImdyb3ciLCJjZWlsIiwiY2IiLCJhc3luYyIsInNldHVwIiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJpbnN0YW50aWF0ZSIsInciLCJzIiwiYXRvYiIsImFzc2VydCIsImhlYWQiLCJmcmVlTGlzdCIsIkJsYWtlMmIiLCJCWVRFU19NSU4iLCJCWVRFU19NQVgiLCJCWVRFUyIsIktFWUJZVEVTX01JTiIsIktFWUJZVEVTX01BWCIsIktFWUJZVEVTIiwiU0FMVEJZVEVTIiwiUEVSU09OQUxCWVRFUyIsImRpZ2VzdExlbmd0aCIsInNhbHQiLCJwZXJzb25hbCIsIm5vQXNzZXJ0IiwiZmluYWxpemVkIiwicG9pbnRlciIsInBvcCIsImZpbGwiLCJzZXQiLCJibGFrZTJiX2luaXQiLCJpbnB1dCIsImJsYWtlMmJfdXBkYXRlIiwiZW5jIiwiYmxha2UyYl9maW5hbCIsImhleFNsaWNlIiwiV0FTTSIsIlNVUFBPUlRFRCIsIm5vb3AiLCJidWYiLCJ0b0hleCIsIm4iLCJiMndhc20iLCJBREQ2NEFBIiwibzAiLCJvMSIsIkFERDY0QUMiLCJiMCIsImIxIiwiQjJCX0dFVDMyIiwiQjJCX0ciLCJkIiwiaXgiLCJpeSIsIngwIiwibSIsIngxIiwieTAiLCJ5MSIsInhvcjAiLCJ4b3IxIiwiQkxBS0UyQl9JVjMyIiwiVWludDMyQXJyYXkiLCJTSUdNQTgiLCJTSUdNQTgyIiwiYmxha2UyYkNvbXByZXNzIiwiY3R4IiwibGFzdCIsInQiLCJwYXJhbWV0ZXJfYmxvY2siLCJvdXRsZW4iLCJibGFrZTJiVXBkYXRlIiwib3V0IiwiYmxha2UyYkZpbmFsIiwiUHJvdG8iLCJjcmVhdGVIYXNoIiwiV0FTTV9TVVBQT1JURUQiLCJXQVNNX0xPQURFRCIsImllZWU3NTQiLCJjdXN0b21JbnNwZWN0U3ltYm9sIiwiU3ltYm9sIiwiU2xvd0J1ZmZlciIsIklOU1BFQ1RfTUFYX0JZVEVTIiwiS19NQVhfTEVOR1RIIiwia01heExlbmd0aCIsIlRZUEVEX0FSUkFZX1NVUFBPUlQiLCJ0eXBlZEFycmF5U3VwcG9ydCIsInByb3RvIiwiZm9vIiwic2V0UHJvdG90eXBlT2YiLCJlbnVtZXJhYmxlIiwiZ2V0IiwiYnl0ZU9mZnNldCIsImNyZWF0ZUJ1ZmZlciIsIlJhbmdlRXJyb3IiLCJhcmciLCJlbmNvZGluZ09yT2Zmc2V0IiwiYWxsb2NVbnNhZmUiLCJwb29sU2l6ZSIsImZyb21TdHJpbmciLCJmcm9tQXJyYXlWaWV3IiwiaXNJbnN0YW5jZSIsImZyb21BcnJheUJ1ZmZlciIsIlNoYXJlZEFycmF5QnVmZmVyIiwidmFsdWVPZiIsImZyb21PYmplY3QiLCJ0b1ByaW1pdGl2ZSIsImFzc2VydFNpemUiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImFycmF5VmlldyIsIm51bWJlcklzTmFOIiwiX2lzQnVmZmVyIiwiY29tcGFyZSIsIm9mZnNldCIsInkiLCJtaW4iLCJTdHJpbmciLCJsaXN0IiwicG9zIiwibXVzdE1hdGNoIiwibG93ZXJlZENhc2UiLCJ1dGY4VG9CeXRlcyIsImJhc2U2NFRvQnl0ZXMiLCJzbG93VG9TdHJpbmciLCJ1dGY4U2xpY2UiLCJhc2NpaVNsaWNlIiwibGF0aW4xU2xpY2UiLCJiYXNlNjRTbGljZSIsInV0ZjE2bGVTbGljZSIsInN3YXAiLCJzd2FwMTYiLCJzd2FwMzIiLCJzd2FwNjQiLCJ0b0xvY2FsZVN0cmluZyIsImVxdWFscyIsImluc3BlY3QiLCJtYXgiLCJ0aGlzU3RhcnQiLCJ0aGlzRW5kIiwidGhpc0NvcHkiLCJ0YXJnZXRDb3B5IiwiYmlkaXJlY3Rpb25hbEluZGV4T2YiLCJkaXIiLCJhcnJheUluZGV4T2YiLCJpbmRleFNpemUiLCJhcnJMZW5ndGgiLCJ2YWxMZW5ndGgiLCJyZWFkVUludDE2QkUiLCJmb3VuZEluZGV4IiwiZm91bmQiLCJqIiwiaW5jbHVkZXMiLCJoZXhXcml0ZSIsIk51bWJlciIsInJlbWFpbmluZyIsInN0ckxlbiIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiX2FyciIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJoZXhTbGljZUxvb2t1cFRhYmxlIiwibmV3QnVmIiwic3ViYXJyYXkiLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVaW50TEUiLCJyZWFkVUludExFIiwibXVsIiwicmVhZFVpbnRCRSIsInJlYWRVSW50QkUiLCJyZWFkVWludDgiLCJyZWFkVUludDgiLCJyZWFkVWludDE2TEUiLCJyZWFkVUludDE2TEUiLCJyZWFkVWludDE2QkUiLCJyZWFkVWludDMyTEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVWludDMyQkUiLCJyZWFkVUludDMyQkUiLCJyZWFkQmlnVUludDY0TEUiLCJkZWZpbmVCaWdJbnRNZXRob2QiLCJ2YWxpZGF0ZU51bWJlciIsImJvdW5kc0Vycm9yIiwibG8iLCJoaSIsIkJpZ0ludCIsInJlYWRCaWdVSW50NjRCRSIsInJlYWRJbnRMRSIsInJlYWRJbnRCRSIsInJlYWRJbnQ4IiwicmVhZEludDE2TEUiLCJyZWFkSW50MTZCRSIsInJlYWRJbnQzMkxFIiwicmVhZEludDMyQkUiLCJyZWFkQmlnSW50NjRMRSIsInJlYWRCaWdJbnQ2NEJFIiwicmVhZEZsb2F0TEUiLCJyZWFkRmxvYXRCRSIsInJlYWREb3VibGVMRSIsInJlYWREb3VibGVCRSIsImNoZWNrSW50Iiwid3JpdGVVaW50TEUiLCJ3cml0ZVVJbnRMRSIsIm1heEJ5dGVzIiwid3JpdGVVaW50QkUiLCJ3cml0ZVVJbnRCRSIsIndyaXRlVWludDgiLCJ3cml0ZVVJbnQ4Iiwid3JpdGVVaW50MTZMRSIsIndyaXRlVUludDE2TEUiLCJ3cml0ZVVpbnQxNkJFIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVWludDMyTEUiLCJ3cml0ZVVJbnQzMkxFIiwid3JpdGVVaW50MzJCRSIsIndyaXRlVUludDMyQkUiLCJ3cnRCaWdVSW50NjRMRSIsImNoZWNrSW50QkkiLCJ3cnRCaWdVSW50NjRCRSIsIndyaXRlQmlnVUludDY0TEUiLCJ3cml0ZUJpZ1VJbnQ2NEJFIiwid3JpdGVJbnRMRSIsImxpbWl0Iiwic3ViIiwid3JpdGVJbnRCRSIsIndyaXRlSW50OCIsIndyaXRlSW50MTZMRSIsIndyaXRlSW50MTZCRSIsIndyaXRlSW50MzJMRSIsIndyaXRlQmlnSW50NjRMRSIsIndyaXRlQmlnSW50NjRCRSIsImNoZWNrSUVFRTc1NCIsIndyaXRlRmxvYXQiLCJsaXR0bGVFbmRpYW4iLCJ3cml0ZUZsb2F0TEUiLCJ3cml0ZUZsb2F0QkUiLCJ3cml0ZURvdWJsZSIsIndyaXRlRG91YmxlTEUiLCJ3cml0ZURvdWJsZUJFIiwidGFyZ2V0U3RhcnQiLCJjb3B5V2l0aGluIiwiZXJyb3JzIiwiRSIsInN5bSIsImdldE1lc3NhZ2UiLCJCYXNlIiwid3JpdGFibGUiLCJjb25maWd1cmFibGUiLCJyYW5nZSIsIm1zZyIsInJlY2VpdmVkIiwiaXNJbnRlZ2VyIiwiYWRkTnVtZXJpY2FsU2VwYXJhdG9yIiwiY2hlY2tCb3VuZHMiLCJFUlJfT1VUX09GX1JBTkdFIiwiRVJSX0lOVkFMSURfQVJHX1RZUEUiLCJmbG9vciIsIkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUyIsIklOVkFMSURfQkFTRTY0X1JFIiwiYmFzZTY0Y2xlYW4iLCJ1bml0cyIsIkluZmluaXR5IiwibGVhZFN1cnJvZ2F0ZSIsImJ5dGVBcnJheSIsInNyYyIsImRzdCIsImFscGhhYmV0IiwidGFibGUiLCJpMTYiLCJCdWZmZXJCaWdJbnROb3REZWZpbmVkIiwibWFzayIsInVubWFzayIsIl9fZGlybmFtZSIsIkVtaXR0ZXIiLCJtaXhpbiIsIm9uIiwiZXZlbnQiLCJfY2FsbGJhY2tzIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImNhbGxiYWNrcyIsInNwbGljZSIsImVtaXQiLCJsaXN0ZW5lcnMiLCJoYXNMaXN0ZW5lcnMiLCJmaWVsZENvbnRlbnRSZWdFeHAiLCJwYWlycyIsImRlYyIsInBhaXIiLCJpbmRleCIsInRyeURlY29kZSIsIm1heEFnZSIsImlzTmFOIiwidG9VVENTdHJpbmciLCJodHRwT25seSIsInNhbWVTaXRlIiwiYXNzaWduIiwidmFyeSIsIm9yaWdpbiIsIm1ldGhvZHMiLCJwcmVmbGlnaHRDb250aW51ZSIsIm9wdGlvbnNTdWNjZXNzU3RhdHVzIiwiaXNPcmlnaW5BbGxvd2VkIiwiYWxsb3dlZE9yaWdpbiIsImNvbmZpZ3VyZU9yaWdpbiIsInJlcXVlc3RPcmlnaW4iLCJpc0FsbG93ZWQiLCJjb25maWd1cmVNZXRob2RzIiwiY29uZmlndXJlQ3JlZGVudGlhbHMiLCJjcmVkZW50aWFscyIsImNvbmZpZ3VyZUFsbG93ZWRIZWFkZXJzIiwiYWxsb3dlZEhlYWRlcnMiLCJjb25maWd1cmVFeHBvc2VkSGVhZGVycyIsImV4cG9zZWRIZWFkZXJzIiwiY29uZmlndXJlTWF4QWdlIiwiYXBwbHlIZWFkZXJzIiwiaGVhZGVyIiwic2V0SGVhZGVyIiwiY29ycyIsIm5leHQiLCJzdGF0dXNDb2RlIiwibWlkZGxld2FyZVdyYXBwZXIiLCJvIiwib3B0aW9uc0NhbGxiYWNrIiwiY29yc01pZGRsZXdhcmUiLCJjb3JzT3B0aW9ucyIsIm9yaWdpbkNhbGxiYWNrIiwiZXJyMiIsImZvcm1hdEFyZ3MiLCJzYXZlIiwibG9hZCIsInVzZUNvbG9ycyIsInN0b3JhZ2UiLCJsb2NhbHN0b3JhZ2UiLCJkZXN0cm95Iiwid2FybmVkIiwiY29sb3JzIiwiX19ud2pzIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGUiLCJXZWJraXRBcHBlYXJhbmNlIiwiZmlyZWJ1ZyIsImV4Y2VwdGlvbiIsIiQxIiwibmFtZXNwYWNlIiwiaHVtYW5pemUiLCJkaWZmIiwiY29sb3IiLCJsYXN0QyIsImxvZyIsImRlYnVnIiwibmFtZXNwYWNlcyIsInNldEl0ZW0iLCJyZW1vdmVJdGVtIiwiciIsImdldEl0ZW0iLCJlbnYiLCJERUJVRyIsImxvY2FsU3RvcmFnZSIsImZvcm1hdHRlcnMiLCJjcmVhdGVEZWJ1ZyIsImNvZXJjZSIsImRpc2FibGUiLCJlbmFibGUiLCJlbmFibGVkIiwibmFtZXMiLCJza2lwcyIsInNlbGVjdENvbG9yIiwicHJldlRpbWUiLCJlbmFibGVPdmVycmlkZSIsIm5hbWVzcGFjZXNDYWNoZSIsImVuYWJsZWRDYWNoZSIsImN1cnIiLCJtcyIsInByZXYiLCJmb3JtYXQiLCJmb3JtYXR0ZXIiLCJsb2dGbiIsImluaXQiLCJkZWxpbWl0ZXIiLCJuZXdEZWJ1ZyIsInRvTmFtZXNwYWNlIiwicmVnZXhwIiwiZm10TG9uZyIsImZtdFNob3J0IiwiZXhlYyIsInBhcnNlRmxvYXQiLCJtc0FicyIsInJvdW5kIiwicGx1cmFsIiwiaXNQbHVyYWwiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIk51bWJlcklzTmFOIiwiRXZlbnRFbWl0dGVyIiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsIl9tYXhMaXN0ZW5lcnMiLCJkZWZhdWx0TWF4TGlzdGVuZXJzIiwiY2hlY2tMaXN0ZW5lciIsImxpc3RlbmVyIiwic2V0TWF4TGlzdGVuZXJzIiwiX2dldE1heExpc3RlbmVycyIsInRoYXQiLCJnZXRNYXhMaXN0ZW5lcnMiLCJkb0Vycm9yIiwiZXZlbnRzIiwiZXIiLCJoYW5kbGVyIiwiYXJyYXlDbG9uZSIsIl9hZGRMaXN0ZW5lciIsInByZXBlbmQiLCJleGlzdGluZyIsIm5ld0xpc3RlbmVyIiwiZW1pdHRlciIsImNvdW50IiwiYWRkTGlzdGVuZXIiLCJwcmVwZW5kTGlzdGVuZXIiLCJvbmNlV3JhcHBlciIsImZpcmVkIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJlcnJvckxpc3RlbmVyIiwicmVzb2x2ZXIiLCJldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIiLCJhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlciIsImZsYWdzIiwid3JhcExpc3RlbmVyIiwiaXNMRSIsIm1MZW4iLCJuQnl0ZXMiLCJlTGVuIiwiZU1heCIsImVCaWFzIiwibkJpdHMiLCJOYU4iLCJydCIsIkxOMiIsImluaGVyaXRzIiwiY3RvciIsInN1cGVyQ3RvciIsInN1cGVyXyIsIlRlbXBDdG9yIiwiZGIiLCJleHRuYW1lIiwiRVhUUkFDVF9UWVBFX1JFR0VYUCIsIlRFWFRfVFlQRV9SRUdFWFAiLCJjb250ZW50VHlwZSIsImV4dGVuc2lvbiIsImV4dGVuc2lvbnMiLCJwb3B1bGF0ZU1hcHMiLCJleHRzIiwicHJlZmVyZW5jZSIsImZvckVhY2hNaW1lVHlwZSIsInRvIiwibm90RXF1YWwiLCJub3RPayIsImVxdWFsIiwib2siLCJwcmVmZXJyZWRDaGFyc2V0cyIsInByZWZlcnJlZEVuY29kaW5ncyIsInByZWZlcnJlZExhbmd1YWdlcyIsInByZWZlcnJlZE1lZGlhVHlwZXMiLCJhdmFpbGFibGUiLCJtZWRpYVR5cGUiLCJwcmVmZXJyZWRDaGFyc2V0IiwicHJlZmVycmVkRW5jb2RpbmciLCJwcmVmZXJyZWRMYW5ndWFnZSIsInByZWZlcnJlZE1lZGlhVHlwZSIsInNpbXBsZUNoYXJzZXRSZWdFeHAiLCJwYXJzZUFjY2VwdENoYXJzZXQiLCJwYXJzZUNoYXJzZXQiLCJxIiwiZ2V0Q2hhcnNldFByaW9yaXR5IiwiYWNjZXB0ZWQiLCJwcmlvcml0eSIsInNwZWMiLCJzcGVjaWZ5IiwicHJvdmlkZWQiLCJpc1F1YWxpdHkiLCJzb3J0IiwiY29tcGFyZVNwZWNzIiwiZ2V0RnVsbENoYXJzZXQiLCJwcmlvcml0aWVzIiwiZ2V0UHJpb3JpdHkiLCJnZXRDaGFyc2V0Iiwic2ltcGxlRW5jb2RpbmdSZWdFeHAiLCJwYXJzZUFjY2VwdEVuY29kaW5nIiwiaGFzSWRlbnRpdHkiLCJtaW5RdWFsaXR5IiwicGFyc2VFbmNvZGluZyIsImdldEVuY29kaW5nUHJpb3JpdHkiLCJnZXRGdWxsRW5jb2RpbmciLCJnZXRFbmNvZGluZyIsInNpbXBsZUxhbmd1YWdlUmVnRXhwIiwicGFyc2VBY2NlcHRMYW5ndWFnZSIsInBhcnNlTGFuZ3VhZ2UiLCJzdWZmaXgiLCJmdWxsIiwiZ2V0TGFuZ3VhZ2VQcmlvcml0eSIsImdldEZ1bGxMYW5ndWFnZSIsImdldExhbmd1YWdlIiwic2ltcGxlTWVkaWFUeXBlUmVnRXhwIiwicGFyc2VBY2NlcHQiLCJzcGxpdE1lZGlhVHlwZXMiLCJwYXJzZU1lZGlhVHlwZSIsInN1YnR5cGUiLCJrdnBzIiwic3BsaXRQYXJhbWV0ZXJzIiwic3BsaXRLZXlWYWx1ZVBhaXIiLCJnZXRNZWRpYVR5cGVQcmlvcml0eSIsImV2ZXJ5IiwiayIsImdldEZ1bGxUeXBlIiwiZ2V0VHlwZSIsInF1b3RlQ291bnQiLCJwYXJhbWV0ZXJzIiwiZnMiLCJvcyIsInJ1bnRpbWVSZXF1aXJlIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIl9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fIiwidmFycyIsInZhcmlhYmxlcyIsInByZWJ1aWxkc09ubHkiLCJQUkVCVUlMRFNfT05MWSIsImFiaSIsInZlcnNpb25zIiwibW9kdWxlcyIsInJ1bnRpbWUiLCJpc0VsZWN0cm9uIiwiYXJjaCIsInBsYXRmb3JtIiwibGliYyIsIkxJQkMiLCJpc0FscGluZSIsImFybXYiLCJBUk1fVkVSU0lPTiIsImFybV92ZXJzaW9uIiwidXYiLCJyZWxlYXNlIiwiZ2V0Rmlyc3QiLCJtYXRjaEJ1aWxkIiwicHJlYnVpbGQiLCJuZWFyYnkiLCJkaXJuYW1lIiwiZXhlY1BhdGgiLCJub2RlIiwiZWxlY3Ryb24iLCJCb29sZWFuIiwidHVwbGVzIiwicmVhZGRpclN5bmMiLCJwYXJzZVR1cGxlIiwidHVwbGUiLCJtYXRjaFR1cGxlIiwiY29tcGFyZVR1cGxlcyIsInByZWJ1aWxkcyIsInBhcnNlVGFncyIsImNhbmRpZGF0ZXMiLCJtYXRjaFRhZ3MiLCJ3aW5uZXIiLCJjb21wYXJlVGFncyIsImZpbGUiLCJmaWxlcyIsImFyY2hpdGVjdHVyZXMiLCJ0YWdzIiwic3BlY2lmaWNpdHkiLCJ0YWciLCJuYXBpIiwicnVudGltZUFnbm9zdGljIiwiRUxFQ1RST05fUlVOX0FTX05PREUiLCJleGlzdHNTeW5jIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsInRlc3QyIiwib3JkZXIyIiwidGVzdDMiLCJsZXR0ZXIiLCJzeW1ib2xzIiwicXMiLCJzZXAiLCJlcSIsIm1heEtleXMiLCJpZHgiLCJrc3RyIiwidnN0ciIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImtzIiwiX2luaGVyaXRzTG9vc2UiLCJzdWJDbGFzcyIsInN1cGVyQ2xhc3MiLCJfX3Byb3RvX18iLCJjb2RlcyIsImNyZWF0ZUVycm9yVHlwZSIsImFyZzEiLCJhcmcyIiwiYXJnMyIsIk5vZGVFcnJvciIsIl9CYXNlIiwib25lT2YiLCJleHBlY3RlZCIsInN0YXJ0c1dpdGgiLCJlbmRzV2l0aCIsInRoaXNfbGVuIiwiZGV0ZXJtaW5lciIsIm9iamVjdEtleXMiLCJEdXBsZXgiLCJSZWFkYWJsZSIsIldyaXRhYmxlIiwiYWxsb3dIYWxmT3BlbiIsInJlYWRhYmxlIiwib25lbmQiLCJfd3JpdGFibGVTdGF0ZSIsImhpZ2hXYXRlck1hcmsiLCJnZXRCdWZmZXIiLCJlbmRlZCIsIm5leHRUaWNrIiwib25FbmROVCIsIl9yZWFkYWJsZVN0YXRlIiwiZGVzdHJveWVkIiwiUGFzc1Rocm91Z2giLCJUcmFuc2Zvcm0iLCJfdHJhbnNmb3JtIiwiY2h1bmsiLCJSZWFkYWJsZVN0YXRlIiwiRUUiLCJFRWxpc3RlbmVyQ291bnQiLCJTdHJlYW0iLCJPdXJVaW50OEFycmF5IiwiZ2xvYmFsIiwiX3VpbnQ4QXJyYXlUb0J1ZmZlciIsIl9pc1VpbnQ4QXJyYXkiLCJkZWJ1Z1V0aWwiLCJkZWJ1Z2xvZyIsIkJ1ZmZlckxpc3QiLCJkZXN0cm95SW1wbCIsIl9yZXF1aXJlIiwiZ2V0SGlnaFdhdGVyTWFyayIsIl9yZXF1aXJlJGNvZGVzIiwiRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiIsIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCIsIlN0cmluZ0RlY29kZXIiLCJjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJlcnJvck9yRGVzdHJveSIsImtQcm94eUV2ZW50cyIsInN0cmVhbSIsImlzRHVwbGV4Iiwib2JqZWN0TW9kZSIsInJlYWRhYmxlT2JqZWN0TW9kZSIsInBpcGVzIiwicGlwZXNDb3VudCIsImZsb3dpbmciLCJlbmRFbWl0dGVkIiwicmVhZGluZyIsInN5bmMiLCJuZWVkUmVhZGFibGUiLCJlbWl0dGVkUmVhZGFibGUiLCJyZWFkYWJsZUxpc3RlbmluZyIsInJlc3VtZVNjaGVkdWxlZCIsInBhdXNlZCIsImVtaXRDbG9zZSIsImF1dG9EZXN0cm95IiwiZGVmYXVsdEVuY29kaW5nIiwiYXdhaXREcmFpbiIsInJlYWRpbmdNb3JlIiwiZGVjb2RlciIsIl9yZWFkIiwiX2Rlc3Ryb3kiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwiY2xlYXIiLCJNQVhfSFdNIiwiY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsiLCJob3dNdWNoVG9SZWFkIiwibk9yaWciLCJlbmRSZWFkYWJsZSIsImRvUmVhZCIsImZyb21MaXN0IiwiZW1pdFJlYWRhYmxlXyIsImZsb3ciLCJtYXliZVJlYWRNb3JlXyIsImRlc3QiLCJwaXBlT3B0cyIsImRvRW5kIiwic3Rkb3V0Iiwic3RkZXJyIiwiZW5kRm4iLCJ1bnBpcGUiLCJvbnVucGlwZSIsInVucGlwZUluZm8iLCJoYXNVbnBpcGVkIiwiY2xlYW51cCIsIm9uZHJhaW4iLCJwaXBlT25EcmFpbiIsImNsZWFuZWRVcCIsIm9uY2xvc2UiLCJvbmZpbmlzaCIsIm9uZGF0YSIsIm5lZWREcmFpbiIsInBhdXNlIiwicmVzdW1lIiwicGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCIsImRlc3RzIiwiZXYiLCJuUmVhZGluZ05leHRUaWNrIiwidXBkYXRlUmVhZGFibGVMaXN0ZW5pbmciLCJyZXN1bWVfIiwiX3RoaXMiLCJtZXRob2RXcmFwIiwibWV0aG9kV3JhcFJldHVybkZ1bmN0aW9uIiwiYXN5bmNJdGVyYXRvciIsIl9mcm9tTGlzdCIsImNvbnN1bWUiLCJlbmRSZWFkYWJsZU5UIiwid1N0YXRlIiwiZmluaXNoZWQiLCJpdGVyYWJsZSIsInhzIiwiRVJSX01VTFRJUExFX0NBTExCQUNLIiwiRVJSX1RSQU5TRk9STV9BTFJFQURZX1RSQU5TRk9STUlORyIsIkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCIsImFmdGVyVHJhbnNmb3JtIiwidHMiLCJfdHJhbnNmb3JtU3RhdGUiLCJ0cmFuc2Zvcm1pbmciLCJ3cml0ZWNiIiwid3JpdGVjaHVuayIsInJzIiwibmVlZFRyYW5zZm9ybSIsIndyaXRlZW5jb2RpbmciLCJmbHVzaCIsIl9mbHVzaCIsInByZWZpbmlzaCIsImRvbmUiLCJfd3JpdGUiLCJXcml0ZVJlcSIsIkNvcmtlZFJlcXVlc3QiLCJlbnRyeSIsImZpbmlzaCIsIm9uQ29ya2VkRmluaXNoIiwiV3JpdGFibGVTdGF0ZSIsImludGVybmFsVXRpbCIsImRlcHJlY2F0ZSIsIkVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUiLCJFUlJfU1RSRUFNX0RFU1RST1lFRCIsIkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMiLCJFUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCIsIkVSUl9VTktOT1dOX0VOQ09ESU5HIiwibm9wIiwid3JpdGFibGVPYmplY3RNb2RlIiwiZmluYWxDYWxsZWQiLCJlbmRpbmciLCJub0RlY29kZSIsImRlY29kZVN0cmluZ3MiLCJ3cml0aW5nIiwiY29ya2VkIiwiYnVmZmVyUHJvY2Vzc2luZyIsIm9ud3JpdGUiLCJ3cml0ZWxlbiIsImJ1ZmZlcmVkUmVxdWVzdCIsImxhc3RCdWZmZXJlZFJlcXVlc3QiLCJwZW5kaW5nY2IiLCJwcmVmaW5pc2hlZCIsImVycm9yRW1pdHRlZCIsImJ1ZmZlcmVkUmVxdWVzdENvdW50IiwiY29ya2VkUmVxdWVzdHNGcmVlIiwiY3VycmVudCIsIndyaXRhYmxlU3RhdGVCdWZmZXJHZXR0ZXIiLCJfIiwicmVhbEhhc0luc3RhbmNlIiwiaGFzSW5zdGFuY2UiLCJvYmplY3QiLCJ3cml0ZXYiLCJfd3JpdGV2IiwiX2ZpbmFsIiwid3JpdGVBZnRlckVuZCIsInZhbGlkQ2h1bmsiLCJpc0J1ZiIsIndyaXRlT3JCdWZmZXIiLCJjb3JrIiwidW5jb3JrIiwiY2xlYXJCdWZmZXIiLCJzZXREZWZhdWx0RW5jb2RpbmciLCJkZWNvZGVDaHVuayIsIm5ld0NodW5rIiwiZG9Xcml0ZSIsIm9ud3JpdGVFcnJvciIsImZpbmlzaE1heWJlIiwib253cml0ZVN0YXRlVXBkYXRlIiwibmVlZEZpbmlzaCIsImFmdGVyV3JpdGUiLCJvbndyaXRlRHJhaW4iLCJob2xkZXIiLCJhbGxCdWZmZXJzIiwiZW5kV3JpdGFibGUiLCJjYWxsRmluYWwiLCJuZWVkIiwiclN0YXRlIiwiY29ya1JlcSIsIl9PYmplY3Qkc2V0UHJvdG90eXBlTyIsIl9kZWZpbmVQcm9wZXJ0eSIsImtMYXN0UmVzb2x2ZSIsImtMYXN0UmVqZWN0Iiwia0Vycm9yIiwia0VuZGVkIiwia0xhc3RQcm9taXNlIiwia0hhbmRsZVByb21pc2UiLCJrU3RyZWFtIiwiY3JlYXRlSXRlclJlc3VsdCIsInJlYWRBbmRSZXNvbHZlIiwiaXRlciIsIm9uUmVhZGFibGUiLCJ3cmFwRm9yTmV4dCIsImxhc3RQcm9taXNlIiwiQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsIlJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSIsIl9yZXR1cm4iLCJfdGhpczIiLCJfT2JqZWN0JGNyZWF0ZSIsIml0ZXJhdG9yIiwiZW51bWVyYWJsZU9ubHkiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfb2JqZWN0U3ByZWFkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3JlcXVpcmUyIiwiY3VzdG9tIiwiY29weUJ1ZmZlciIsInRhaWwiLCJoYXNTdHJpbmdzIiwiX2dldFN0cmluZyIsIl9nZXRCdWZmZXIiLCJuYiIsImRlcHRoIiwiY3VzdG9tSW5zcGVjdCIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsImVtaXRFcnJvckFuZENsb3NlTlQiLCJlbWl0Q2xvc2VOVCIsIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFIiwiY2FsbGVkIiwiX2xlbiIsIl9rZXkiLCJpc1JlcXVlc3QiLCJlb3MiLCJvbmxlZ2FjeWZpbmlzaCIsIndyaXRhYmxlRW5kZWQiLCJyZWFkYWJsZUVuZGVkIiwib25yZXF1ZXN0IiwiRVJSX01JU1NJTkdfQVJHUyIsImRlc3Ryb3llciIsImNsb3NlZCIsInBvcENhbGxiYWNrIiwic3RyZWFtcyIsInBpcGVsaW5lIiwiZGVzdHJveXMiLCJyZWR1Y2UiLCJFUlJfSU5WQUxJRF9PUFRfVkFMVUUiLCJoaWdoV2F0ZXJNYXJrRnJvbSIsImR1cGxleEtleSIsImh3bSIsImNvcHlQcm9wcyIsIlNhZmVCdWZmZXIiLCJBZGFwdGVyIiwiZXZlbnRzXzEiLCJuc3AiLCJyb29tcyIsIk1hcCIsInNpZHMiLCJzZXJ2ZXIiLCJoYXMiLCJTZXQiLCJyb29tIiwiYWRkIiwiX2RlbCIsIl9yb29tIiwiZGVsZXRlZCIsInBhY2tldCIsInBhY2tldE9wdHMiLCJwcmVFbmNvZGVkIiwiY29tcHJlc3MiLCJlbmNvZGVkUGFja2V0cyIsInNvY2tldCIsImNsaWVudCIsIndyaXRlVG9FbmdpbmUiLCJzb2NrZXRzIiwibGVhdmUiLCJjbG9zZSIsImRpc2Nvbm5lY3QiLCJleGNlcHQiLCJjb21wdXRlRXhjZXB0U2lkcyIsImlkcyIsImV4Y2VwdFJvb21zIiwiZXhjZXB0U2lkcyIsInNpZCIsInJlY29uc3RydWN0UGFja2V0IiwiZGVjb25zdHJ1Y3RQYWNrZXQiLCJpc19iaW5hcnlfMSIsImJ1ZmZlcnMiLCJwYWNrZXREYXRhIiwicGFjayIsIl9kZWNvbnN0cnVjdFBhY2tldCIsImF0dGFjaG1lbnRzIiwiaXNCaW5hcnkiLCJwbGFjZWhvbGRlciIsIl9wbGFjZWhvbGRlciIsIm5ld0RhdGEiLCJfcmVjb25zdHJ1Y3RQYWNrZXQiLCJEZWNvZGVyIiwiRW5jb2RlciIsIlBhY2tldFR5cGUiLCJiaW5hcnlfMSIsIkVWRU5UIiwiQUNLIiwiaGFzQmluYXJ5IiwiQklOQVJZX0VWRU5UIiwiQklOQVJZX0FDSyIsImVuY29kZUFzQmluYXJ5IiwiZW5jb2RlQXNTdHJpbmciLCJkZWNvbnN0cnVjdGlvbiIsImRlY29kZVN0cmluZyIsInJlY29uc3RydWN0b3IiLCJCaW5hcnlSZWNvbnN0cnVjdG9yIiwidGFrZUJpbmFyeURhdGEiLCJ0cnlQYXJzZSIsImlzUGF5bG9hZFZhbGlkIiwiZmluaXNoZWRSZWNvbnN0cnVjdGlvbiIsIkNPTk5FQ1QiLCJESVNDT05ORUNUIiwiQ09OTkVDVF9FUlJPUiIsInJlY29uUGFjayIsImJpbkRhdGEiLCJ3aXRoTmF0aXZlQXJyYXlCdWZmZXIiLCJ3aXRoTmF0aXZlQmxvYiIsIkJsb2IiLCJ3aXRoTmF0aXZlRmlsZSIsIkZpbGUiLCJDbGllbnRSZXF1ZXN0Iiwic3RhdHVzQ29kZXMiLCJodHRwIiwiZGVmYXVsdFByb3RvY29sIiwiSW5jb21pbmdNZXNzYWdlIiwiQWdlbnQiLCJkZWZhdWx0TWF4U29ja2V0cyIsImdsb2JhbEFnZW50IiwiU1RBVFVTX0NPREVTIiwiTUVUSE9EUyIsImZldGNoIiwiUmVhZGFibGVTdHJlYW0iLCJ3cml0YWJsZVN0cmVhbSIsIldyaXRhYmxlU3RyZWFtIiwiYWJvcnRDb250cm9sbGVyIiwiQWJvcnRDb250cm9sbGVyIiwieGhyIiwiZ2V0WEhSIiwiWERvbWFpblJlcXVlc3QiLCJjaGVja1R5cGVTdXBwb3J0IiwibXNzdHJlYW0iLCJtb3pjaHVua2VkYXJyYXlidWZmZXIiLCJvdmVycmlkZU1pbWVUeXBlIiwiY2FwYWJpbGl0eSIsInJTdGF0ZXMiLCJyZWFkeVN0YXRlcyIsImRlY2lkZU1vZGUiLCJwcmVmZXJCaW5hcnkiLCJ1c2VGZXRjaCIsIl9vcHRzIiwiX2JvZHkiLCJfaGVhZGVycyIsIm1vZGUiLCJfbW9kZSIsIl9mZXRjaFRpbWVyIiwiX3NvY2tldFRpbWVvdXQiLCJfc29ja2V0VGltZXIiLCJfb25GaW5pc2giLCJsb3dlck5hbWUiLCJ1bnNhZmVIZWFkZXJzIiwiZ2V0SGVhZGVyIiwicmVtb3ZlSGVhZGVyIiwiX2Rlc3Ryb3llZCIsImhlYWRlcnNPYmoiLCJib2R5IiwiaGVhZGVyc0xpc3QiLCJrZXlOYW1lIiwic2lnbmFsIiwiY29udHJvbGxlciIsIl9mZXRjaEFib3J0Q29udHJvbGxlciIsInJlcXVlc3RUaW1lb3V0IiwiX2ZldGNoUmVzcG9uc2UiLCJfcmVzZXRUaW1lcnMiLCJfY29ubmVjdCIsIl94aHIiLCJfcmVzcG9uc2UiLCJMT0FESU5HIiwiRE9ORSIsIl9vblhIUlByb2dyZXNzIiwib25wcm9ncmVzcyIsInN0YXR1c1ZhbGlkIiwiY2xlYXJUaW1lb3V0IiwiZmx1c2hIZWFkZXJzIiwic2V0Tm9EZWxheSIsInNldFNvY2tldEtlZXBBbGl2ZSIsIlVOU0VOVCIsIk9QRU5FRCIsIkhFQURFUlNfUkVDRUlWRUQiLCJyZXNldFRpbWVycyIsInJhd0hlYWRlcnMiLCJ0cmFpbGVycyIsInJhd1RyYWlsZXJzIiwicmVhZGVyIiwic3RhdHVzTWVzc2FnZSIsIl9yZXN1bWVGZXRjaCIsInBpcGVUbyIsImdldFJlYWRlciIsIl9wb3MiLCJtYXRjaGVzIiwiX2NoYXJzZXQiLCJtaW1lVHlwZSIsImNoYXJzZXRNYXRjaCIsIk1TU3RyZWFtUmVhZGVyIiwicmVhZEFzQXJyYXlCdWZmZXIiLCJfbm9ybWFsaXplRW5jb2RpbmciLCJyZXRyaWVkIiwibm9ybWFsaXplRW5jb2RpbmciLCJuZW5jIiwidGV4dCIsInV0ZjE2VGV4dCIsInV0ZjE2RW5kIiwiZmlsbExhc3QiLCJ1dGY4RmlsbExhc3QiLCJiYXNlNjRUZXh0IiwiYmFzZTY0RW5kIiwic2ltcGxlV3JpdGUiLCJzaW1wbGVFbmQiLCJsYXN0TmVlZCIsImxhc3RUb3RhbCIsImxhc3RDaGFyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsInB1bnljb2RlIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJkZWZpbmUiLCJhbWQiLCJ1dGlsIiwidXJsUGFyc2UiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJ1cmxGb3JtYXQiLCJVcmwiLCJzbGFzaGVzIiwicXVlcnkiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwicXVlcnlJbmRleCIsInNwbGl0dGVyIiwidVNwbGl0Iiwic2xhc2hSZWdleCIsInJlc3QiLCJzaW1wbGVQYXRoIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInJlbGF0aXZlIiwicmVsIiwidGtleXMiLCJ0ayIsInRrZXkiLCJya2V5cyIsInJrIiwicmtleSIsInJlbFBhdGgiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJhdXRoSW5Ib3N0IiwiaXNOdWxsIiwiaGFzVHJhaWxpbmdTbGFzaCIsInVwIiwiaXNBYnNvbHV0ZSIsImlzVmFsaWRVVEY4IiwiZGVwcmVjYXRlZCIsInRyYWNlIiwiYXBwZW5kIiwiRklFTERfTkFNRV9SRUdFWFAiLCJmaWVsZCIsImZpZWxkcyIsInZhbHMiLCJmbGQiLCJXZWJTb2NrZXQiLCJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCJTZXJ2ZXIiLCJSZWNlaXZlciIsIlNlbmRlciIsIldlYlNvY2tldFNlcnZlciIsIkVNUFRZX0JVRkZFUiIsInRvdGFsTGVuZ3RoIiwiX21hc2siLCJfdW5tYXNrIiwidG9BcnJheUJ1ZmZlciIsInRvQnVmZmVyIiwicmVhZE9ubHkiLCJidWZmZXJVdGlsIiwiQklOQVJZX1RZUEVTIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsImtDb2RlIiwia0RhdGEiLCJrTWVzc2FnZSIsImtSZWFzb24iLCJrVGFyZ2V0Iiwia1R5cGUiLCJrV2FzQ2xlYW4iLCJFdmVudCIsIkNsb3NlRXZlbnQiLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJFdmVudFRhcmdldCIsIndyYXBwZXIiLCJvbk1lc3NhZ2UiLCJvbkNsb3NlIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIm9uRXJyb3IiLCJvbk9wZW4iLCJ0b2tlbkNoYXJzIiwiZWxlbSIsIm9mZmVycyIsIm11c3RVbmVzY2FwZSIsImlzRXNjYXBpbmciLCJpblF1b3RlcyIsImV4dGVuc2lvbk5hbWUiLCJwYXJhbU5hbWUiLCJTeW50YXhFcnJvciIsImNvbmZpZ3VyYXRpb25zIiwidmFsdWVzIiwia0RvbmUiLCJrUnVuIiwiTGltaXRlciIsImNvbmN1cnJlbmN5IiwicGVuZGluZyIsImpvYnMiLCJqb2IiLCJ6bGliIiwiVFJBSUxFUiIsImtQZXJNZXNzYWdlRGVmbGF0ZSIsImtUb3RhbExlbmd0aCIsImtDYWxsYmFjayIsImtCdWZmZXJzIiwiemxpYkxpbWl0ZXIiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsImlzU2VydmVyIiwibWF4UGF5bG9hZCIsIl9tYXhQYXlsb2FkIiwiX29wdGlvbnMiLCJfdGhyZXNob2xkIiwiX2lzU2VydmVyIiwiX2RlZmxhdGUiLCJfaW5mbGF0ZSIsImNvbmN1cnJlbmN5TGltaXQiLCJzZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciIsInNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyIiwiY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIiLCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciIsInNlcnZlck1heFdpbmRvd0JpdHMiLCJzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzIiwiY2xpZW50TWF4V2luZG93Qml0cyIsImNsaWVudF9tYXhfd2luZG93X2JpdHMiLCJub3JtYWxpemVQYXJhbXMiLCJhY2NlcHRBc1NlcnZlciIsImFjY2VwdEFzQ2xpZW50IiwiZmluZCIsImZpbiIsIl9kZWNvbXByZXNzIiwiX2NvbXByZXNzIiwiZW5kcG9pbnQiLCJ3aW5kb3dCaXRzIiwiWl9ERUZBVUxUX1dJTkRPV0JJVFMiLCJjcmVhdGVJbmZsYXRlUmF3IiwiemxpYkluZmxhdGVPcHRpb25zIiwiaW5mbGF0ZU9uRXJyb3IiLCJpbmZsYXRlT25EYXRhIiwicmVzZXQiLCJjcmVhdGVEZWZsYXRlUmF3IiwiemxpYkRlZmxhdGVPcHRpb25zIiwiZGVmbGF0ZU9uRGF0YSIsIlpfU1lOQ19GTFVTSCIsImlzVmFsaWRTdGF0dXNDb2RlIiwiR0VUX0lORk8iLCJHRVRfUEFZTE9BRF9MRU5HVEhfMTYiLCJHRVRfUEFZTE9BRF9MRU5HVEhfNjQiLCJHRVRfTUFTSyIsIkdFVF9EQVRBIiwiSU5GTEFUSU5HIiwiX2JpbmFyeVR5cGUiLCJiaW5hcnlUeXBlIiwiX2V4dGVuc2lvbnMiLCJfc2tpcFVURjhWYWxpZGF0aW9uIiwic2tpcFVURjhWYWxpZGF0aW9uIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfYnVmZmVycyIsIl9jb21wcmVzc2VkIiwiX3BheWxvYWRMZW5ndGgiLCJfZnJhZ21lbnRlZCIsIl9tYXNrZWQiLCJfZmluIiwiX29wY29kZSIsIl90b3RhbFBheWxvYWRMZW5ndGgiLCJfbWVzc2FnZUxlbmd0aCIsIl9mcmFnbWVudHMiLCJfc3RhdGUiLCJfbG9vcCIsInN0YXJ0TG9vcCIsImdldEluZm8iLCJnZXRQYXlsb2FkTGVuZ3RoMTYiLCJnZXRQYXlsb2FkTGVuZ3RoNjQiLCJnZXRNYXNrIiwiZ2V0RGF0YSIsImNvbXByZXNzZWQiLCJoYXZlTGVuZ3RoIiwiY29udHJvbE1lc3NhZ2UiLCJkZWNvbXByZXNzIiwiZGF0YU1lc3NhZ2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsIm1lc3NhZ2VMZW5ndGgiLCJmcmFnbWVudHMiLCJFcnJvckN0b3IiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm5ldCIsInRscyIsInJhbmRvbUZpbGxTeW5jIiwiYXBwbHlNYXNrIiwiX3NvY2tldCIsIl9maXJzdEZyYWdtZW50IiwiX2RlZmxhdGluZyIsIl9xdWV1ZSIsImVucXVldWUiLCJkb0Nsb3NlIiwic2VuZEZyYW1lIiwiZnJhbWUiLCJyc3YxIiwib3Bjb2RlIiwiZG9QaW5nIiwiZG9Qb25nIiwiYmluYXJ5IiwiZGlzcGF0Y2giLCJkZXF1ZXVlIiwicGF5bG9hZExlbmd0aCIsImR1cGxleE9uRW5kIiwiZHVwbGV4T25FcnJvciIsIndzIiwicmVzdW1lT25SZWNlaXZlckRyYWluIiwidGVybWluYXRlT25EZXN0cm95IiwicmVjZWl2ZXJPbkRyYWluIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsImR1cGxleCIsIkNMT1NFRCIsInRlcm1pbmF0ZSIsIk9QRU4iLCJwcm90b2NvbHMiLCJfaXNWYWxpZFVURjgiLCJodHRwcyIsInN1YnByb3RvY29sIiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiQ0xPU0lORyIsImhhbmRsZVByb3RvY29scyIsImNsaWVudFRyYWNraW5nIiwidmVyaWZ5Q2xpZW50Iiwibm9TZXJ2ZXIiLCJiYWNrbG9nIiwiX3NlcnZlciIsImNyZWF0ZVNlcnZlciIsIndyaXRlSGVhZCIsImxpc3RlbiIsImVtaXRDb25uZWN0aW9uIiwiX3JlbW92ZUxpc3RlbmVycyIsImFkZExpc3RlbmVycyIsImxpc3RlbmluZyIsInVwZ3JhZGUiLCJoYW5kbGVVcGdyYWRlIiwiY2xpZW50cyIsIl9zaG91bGRFbWl0Q2xvc2UiLCJhZGRyZXNzIiwic29ja2V0T25FcnJvciIsInNob3VsZEhhbmRsZSIsImFib3J0SGFuZHNoYWtlIiwic2VjV2ViU29ja2V0UHJvdG9jb2wiLCJzZWNXZWJTb2NrZXRFeHRlbnNpb25zIiwiaW5mbyIsImF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJ2ZXJpZmllZCIsImNvbXBsZXRlVXBncmFkZSIsIl9wcm90b2NvbCIsInNldFNvY2tldCIsInJlbW92ZUxpc3RlbmVycyIsIkNvbm5lY3Rpb24iLCJVUkwiLCJzdWJwcm90b2NvbFJlZ2V4IiwicHJvdG9jb2xWZXJzaW9ucyIsImNsb3NlVGltZW91dCIsIl9jbG9zZUNvZGUiLCJfY2xvc2VNZXNzYWdlIiwiX2Nsb3NlVGltZXIiLCJfcmVhZHlTdGF0ZSIsIl9zZW5kZXIiLCJfYnVmZmVyZWRBbW91bnQiLCJfcmVkaXJlY3RzIiwiaW5pdEFzQ2xpZW50IiwiX3VybCIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNvY2tldE9uQ2xvc2UiLCJzb2NrZXRPbkRhdGEiLCJzb2NrZXRPbkVuZCIsIl9yZXEiLCJzZW5kQWZ0ZXJDbG9zZSIsInBpbmciLCJwb25nIiwicHJvcGVydHkiLCJ3ZWJzb2NrZXQiLCJwcm90b2NvbFZlcnNpb24iLCJmb2xsb3dSZWRpcmVjdHMiLCJtYXhSZWRpcmVjdHMiLCJjcmVhdGVDb25uZWN0aW9uIiwic29ja2V0UGF0aCIsInBhcnNlZFVybCIsImlzU2VjdXJlIiwiaXNVbml4U29ja2V0IiwiZGVmYXVsdFBvcnQiLCJwcm90b2NvbFNldCIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0IiwiVXBncmFkZSIsImhhbmRzaGFrZVRpbWVvdXQiLCJvZmZlciIsIk9yaWdpbiIsImFib3J0ZWQiLCJhZGRyIiwic2VydmVyUHJvdCIsInByb3RFcnJvciIsImV4dGVuc2lvbk5hbWVzIiwiY29ubmVjdCIsInNlcnZlcm5hbWUiLCJpc0lQIiwicmVjZWl2ZXJPbkZpbmlzaCIsIkVSUk9SX1BBQ0tFVCIsIlBBQ0tFVF9UWVBFU19SRVZFUlNFIiwiUEFDS0VUX1RZUEVTIiwiY29tbW9uc19qc18xIiwiYmFzZTY0X2FycmF5YnVmZmVyXzEiLCJkZWNvZGVQYWNrZXQiLCJlbmNvZGVkUGFja2V0IiwibWFwQmluYXJ5IiwiZGVjb2RlQmFzZTY0UGFja2V0IiwicGFja2V0VHlwZSIsImRlY29kZWQiLCJlbmNvZGVQYWNrZXQiLCJzdXBwb3J0c0JpbmFyeSIsImVuY29kZUJsb2JBc0Jhc2U2NCIsImZpbGVSZWFkZXIiLCJGaWxlUmVhZGVyIiwicmVhZEFzRGF0YVVSTCIsImRlY29kZVBheWxvYWQiLCJlbmNvZGVQYXlsb2FkIiwiZW5jb2RlUGFja2V0X2pzXzEiLCJkZWNvZGVQYWNrZXRfanNfMSIsIlNFUEFSQVRPUiIsInBhY2tldHMiLCJlbmNvZGVkUGF5bG9hZCIsImRlY29kZWRQYWNrZXQiLCJUcmFuc3BvcnQiLCJTb2NrZXQiLCJ1U2VydmVyIiwiYXR0YWNoIiwidHJhbnNwb3J0cyIsImh0dHBfMSIsInNlcnZlcl8xIiwiaW5kZXhfMSIsInVzZXJ2ZXJfMSIsInNvY2tldF8xIiwidHJhbnNwb3J0XzEiLCJlbmdpbmUiLCJodHRwU2VydmVyIiwiZGVjb2RlUGF5bG9hZEFzQmluYXJ5IiwiZW5jb2RlUGF5bG9hZEFzQmluYXJ5IiwiZW5jb2RlQmFzZTY0UGFja2V0IiwidXRmOCIsInBhY2tldHNsaXN0IiwidXRmOGVuY29kZSIsImVuY29kZUJ1ZmZlciIsImFycmF5QnVmZmVyVG9CdWZmZXIiLCJzdHJpY3QiLCJ0eXBlQnVmZmVyIiwidXRmOGRlY29kZSIsImludEFycmF5IiwiYWJ2IiwiZW5jb2RlT25lIiwiZG9uZUNhbGxiYWNrIiwic2V0TGVuZ3RoSGVhZGVyIiwicmVzdWx0cyIsImFyeSIsImVhY2giLCJjaHIiLCJtb3JlIiwiYnVmZmVyVG9TdHJpbmciLCJzdHJpbmdUb0J1ZmZlciIsImVuY29kZU9uZUJpbmFyeVBhY2tldCIsIm9uQmluYXJ5UGFja2V0RW5jb2RlIiwiZW5jb2RpbmdMZW5ndGgiLCJzaXplQnVmZmVyIiwiYnVmZmVyVGFpbCIsIm1zZ0xlbmd0aCIsImNoZWNrU2NhbGFyVmFsdWUiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwiYnl0ZVN0cmluZyIsInJlYWRDb250aW51YXRpb25CeXRlIiwiYnl0ZUluZGV4IiwiYnl0ZUNvdW50IiwiY29udGludWF0aW9uQnl0ZSIsImRlY29kZVN5bWJvbCIsImJ5dGUxIiwiYnl0ZTIiLCJieXRlMyIsImJ5dGU0IiwiQmFzZVNlcnZlciIsInVybF8xIiwiYmFzZTY0aWQiLCJ0cmFuc3BvcnRzXzEiLCJkZWJ1Z18xIiwiY29va2llXzEiLCJ3c18xIiwiY2xpZW50c0NvdW50Iiwid3NFbmdpbmUiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInVwZ3JhZGVUaW1lb3V0IiwibWF4SHR0cEJ1ZmZlclNpemUiLCJhbGxvd1VwZ3JhZGVzIiwiaHR0cENvbXByZXNzaW9uIiwiYWxsb3dFSU8zIiwidHJhbnNwb3J0IiwidXBncmFkZXNUbyIsIl9xdWVyeSIsIlVOS05PV05fVFJBTlNQT1JUIiwiaXNPcmlnaW5JbnZhbGlkIiwiY2hlY2tJbnZhbGlkSGVhZGVyQ2hhciIsIkJBRF9SRVFVRVNUIiwiVU5LTk9XTl9TSUQiLCJwcmV2aW91c1RyYW5zcG9ydCIsIkJBRF9IQU5EU0hBS0VfTUVUSE9EIiwiYWxsb3dSZXF1ZXN0Iiwic3VjY2VzcyIsIkZPUkJJRERFTiIsInRyYW5zcG9ydE5hbWUiLCJjbG9zZUNvbm5lY3Rpb24iLCJFSU8iLCJVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OIiwiZXJyb3JNZXNzYWdlcyIsImNyZWF0ZVRyYW5zcG9ydCIsImlzSW5pdGlhbFJlcXVlc3QiLCJvblJlcXVlc3QiLCJoZWFkZXJzQXJyYXkiLCJhZGRpdGlvbmFsSGVhZGVycyIsInByZXBhcmUiLCJlcnJvckNvbnRleHQiLCJhYm9ydFJlcXVlc3QiLCJoYW5kc2hha2UiLCJ2ZXJpZnkiLCJ1cGdyYWRlSGVhZCIsImFib3J0VXBncmFkZSIsIm9uV2ViU29ja2V0Iiwib25VcGdyYWRlRXJyb3IiLCJoYW5kbGVzVXBncmFkZXMiLCJ1cGdyYWRpbmciLCJ1cGdyYWRlZCIsIm1heWJlVXBncmFkZSIsImRlc3Ryb3lVcGdyYWRlVGltZW91dCIsImNoZWNrIiwiaGFuZGxlUmVxdWVzdCIsImRlc3Ryb3lVcGdyYWRlIiwiYnl0ZXNXcml0dGVuIiwidmFsaWRIZHJDaGFycyIsInRpbWVyc18xIiwid3JpdGVCdWZmZXIiLCJwYWNrZXRzRm4iLCJzZW50Q2FsbGJhY2tGbiIsImNsZWFudXBGbiIsInJlbW90ZUFkZHJlc3MiLCJjb25uZWN0aW9uIiwiY2hlY2tJbnRlcnZhbFRpbWVyIiwidXBncmFkZVRpbWVvdXRUaW1lciIsInBpbmdUaW1lb3V0VGltZXIiLCJwaW5nSW50ZXJ2YWxUaW1lciIsInNldFRyYW5zcG9ydCIsInNlbmRQYWNrZXQiLCJ1cGdyYWRlcyIsImdldEF2YWlsYWJsZVVwZ3JhZGVzIiwiaW5pdGlhbFBhY2tldCIsInJlc2V0UGluZ1RpbWVvdXQiLCJzY2hlZHVsZVBpbmciLCJyZWZyZXNoIiwib25QYWNrZXQiLCJzZXR1cFNlbmRDYWxsYmFjayIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImRpc2NhcmQiLCJjbGVhclRyYW5zcG9ydCIsIm9uVHJhbnNwb3J0Q2xvc2UiLCJ0b0NsZWFuVXAiLCJvbkRyYWluIiwic2VxRm4iLCJ3YnVmIiwic3VwcG9ydHNGcmFtaW5nIiwiYXZhaWxhYmxlVXBncmFkZXMiLCJhbGxVcGdyYWRlcyIsInVwZyIsImNsb3NlVHJhbnNwb3J0IiwicGFyc2VyX3Y0IiwicGFyc2VyX3YzIiwiZGlzY2FyZGVkIiwicG9sbGluZ18xIiwid2Vic29ja2V0XzEiLCJwb2xsaW5nIiwiUG9sbGluZyIsInpsaWJfMSIsImNvbXByZXNzaW9uTWV0aG9kcyIsImd6aXAiLCJjcmVhdGVHemlwIiwiZGVmbGF0ZSIsImNyZWF0ZURlZmxhdGUiLCJnZXRNZXRob2QiLCJvblBvbGxSZXF1ZXN0Iiwib25EYXRhUmVxdWVzdCIsIndyaXRlU3RhdHVzIiwib25BYm9ydGVkIiwic2hvdWxkQ2xvc2UiLCJkYXRhUmVxIiwiZXhwZWN0ZWRDb250ZW50TGVuZ3RoIiwiZGF0YVJlcyIsIndyaXRlSGVhZGVyIiwib25FbmQiLCJvbkRhdGEiLCJvbkRhdGFSZXF1ZXN0Q2xlYW51cCIsImFycmF5QnVmZmVyIiwiaXNMYXN0Iiwic29tZSIsInJlc3BvbmQiLCJucmVhZCIsImNsb3NlVGltZW91dFRpbWVyIiwidWEiLCJ3c1ByZUVuY29kZWQiLCJwb2xsaW5nX2pzb25wXzEiLCJKU09OUCIsInJEb3VibGVTbGFzaGVzIiwiclNsYXNoZXMiLCJmb290IiwianMiLCJjaHVua3MiLCJjb250ZW50TGVuZ3RoIiwidHJhbnNwb3J0c191d3NfMSIsImdldFF1ZXJ5IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCIsImFwcCIsImFueSIsImNvbXByZXNzaW9uIiwiaWRsZVRpbWVvdXQiLCJtYXhCYWNrcHJlc3N1cmUiLCJtYXhQYXlsb2FkTGVuZ3RoIiwiZ2V0VXJsIiwiUmVzcG9uc2VXcmFwcGVyIiwic3RhdHVzV3JpdHRlbiIsIndyaXRlQnVmZmVyZWRIZWFkZXJzIiwiUmVtb3RlU29ja2V0IiwiQnJvYWRjYXN0T3BlcmF0b3IiLCJzb2NrZXRfaW9fcGFyc2VyXzEiLCJsb2NhbCIsIlJFU0VSVkVEX0VWRU5UUyIsImJyb2FkY2FzdCIsImZldGNoU29ja2V0cyIsImFkZFNvY2tldHMiLCJkZWxTb2NrZXRzIiwiZGlzY29ubmVjdFNvY2tldHMiLCJkZXRhaWxzIiwib3BlcmF0b3IiLCJzb2NrZXRzSm9pbiIsInNvY2tldHNMZWF2ZSIsIkNsaWVudCIsImRlYnVnTW9kdWxlIiwiY29ubiIsIm5zcHMiLCJfcGFyc2VyIiwib25kZWNvZGVkIiwiY29ubmVjdFRpbWVvdXQiLCJfY29ubmVjdFRpbWVvdXQiLCJfbnNwcyIsImRvQ29ubmVjdCIsIl9jaGVja05hbWVzcGFjZSIsImR5bmFtaWNOc3BOYW1lIiwiX3BhY2tldCIsIm9mIiwiX2FkZCIsIl9vbnBhY2tldCIsIl9vbmVycm9yIiwiX29uY2xvc2UiLCJfX2NyZWF0ZUJpbmRpbmciLCJrMiIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsIl9faW1wb3J0U3RhciIsIk5hbWVzcGFjZSIsImZzXzEiLCJzdHJlYW1fMSIsImVuZ2luZV9pb18xIiwiY2xpZW50XzEiLCJuYW1lc3BhY2VfMSIsInBhcmVudF9uYW1lc3BhY2VfMSIsInNvY2tldF9pb19hZGFwdGVyXzEiLCJ0eXBlZF9ldmVudHNfMSIsInV3c19qc18xIiwiY2xpZW50VmVyc2lvbiIsImRvdE1hcFJlZ2V4Iiwic3J2IiwicGFyZW50TnNwcyIsInNlcnZlQ2xpZW50IiwiX3NlcnZlQ2xpZW50Iiwia2V5c0l0ZXJhdG9yIiwicnVuIiwibmV4dEZuIiwiYWxsb3ciLCJjcmVhdGVDaGlsZCIsImVtaXRSZXNlcnZlZCIsIl9wYXRoIiwiZXNjYXBlZFBhdGgiLCJjbGllbnRQYXRoUmVnZXgiLCJfYWRhcHRlciIsIl9pbml0QWRhcHRlciIsImluaXRFbmdpbmUiLCJzZXRZaWVsZCIsImZpbGVuYW1lIiwiaXNNYXAiLCJleHBlY3RlZEV0YWciLCJ3ZWFrRXRhZyIsImV0YWciLCJmaWxlcGF0aCIsInNlcnZlRmlsZSIsInBhdGNoQWRhcHRlciIsImVpbyIsImF0dGFjaFNlcnZlIiwiZXZzIiwic2VydmUiLCJzZW5kRmlsZSIsIm9uY29ubmVjdGlvbiIsInBhcmVudE5zcCIsIlBhcmVudE5hbWVzcGFjZSIsInJlc3RvcmVBZGFwdGVyIiwic2VydmVyU2lkZUVtaXQiLCJhbGxTb2NrZXRzIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJjcmVhdGVCcm90bGlDb21wcmVzcyIsIlN0cmljdEV2ZW50RW1pdHRlciIsImVtaXR0ZXJNZXRob2RzIiwiYnJvYWRjYXN0X29wZXJhdG9yXzEiLCJfZm5zIiwiX2lkcyIsIl9lcnJvciIsIl9vbmNvbm5lY3QiLCJjaGlsZHJlbiIsImJhc2U2NGlkXzEiLCJjb25uZWN0ZWQiLCJhY2tzIiwiYnVpbGRIYW5kc2hha2UiLCJ0aW1lIiwieGRvbWFpbiIsImlzc3VlZCIsInJlZ2lzdGVyQWNrQ2FsbGJhY2siLCJhY2siLCJ0aW1lciIsIm5ld0Jyb2FkY2FzdE9wZXJhdG9yIiwiYWRkQWxsIiwiZGVsIiwiZGVsQWxsIiwib25ldmVudCIsIm9uYWNrIiwib25kaXNjb25uZWN0IiwiX2FueUxpc3RlbmVycyIsInNlbnQiLCJsZWF2ZUFsbCIsIl9yZW1vdmUiLCJfZGlzY29ubmVjdCIsInNvY2tldFJvb21zIiwiaXNOZXciLCJzdWJzY3JpYmUiLCJzZXNzaW9uSWQiLCJ0b3BpYyIsInVuc3Vic2NyaWJlIiwidXNlRmFzdFB1Ymxpc2giLCJiYXNlUGFja2V0T3B0cyIsInB1Ymxpc2giLCJuYW1lc3BhY2VOYW1lIiwic3RhdFN5bmMiLCJkZXN0cm95UmVhZFN0cmVhbSIsIm9uRGF0YUNodW5rIiwiYXJyYXlCdWZmZXJDaHVuayIsImxhc3RPZmZzZXQiLCJnZXRXcml0ZU9mZnNldCIsInRyeUVuZCIsIm9uV3JpdGFibGUiLCJpbyJdLCJzb3VyY2VSb290IjoiIn0=