(self["webpackChunkwallet_test"] = self["webpackChunkwallet_test"] || []).push([["vendors-node_modules_emurgo_cip14-js_index_js-node_modules_axios_index_js-node_modules_form-d-eebe24"],{

/***/ "./node_modules/@emurgo/cip14-js/index.js":
/*!************************************************!*\
  !*** ./node_modules/@emurgo/cip14-js/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var blake2b_1 = __importDefault(__webpack_require__(/*! blake2b */ "./node_modules/blake2b/index.js"));

var bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js"); /// note: this function can't be inverted due to the hash


var DATA = "asset";

var AssetFingerprint = /*#__PURE__*/function () {
  function AssetFingerprint(hashBuf) {
    _classCallCheck(this, AssetFingerprint);

    this.hashBuf = hashBuf;
  }

  _createClass(AssetFingerprint, [{
    key: "fingerprint",
    value: function fingerprint() {
      var words = bech32_1.bech32.toWords(this.hashBuf);
      return bech32_1.bech32.encode(DATA, words);
    }
  }, {
    key: "hash",
    value: function hash() {
      return Buffer.from(this.hashBuf).toString("hex");
    }
  }, {
    key: "prefix",
    value: function prefix() {
      return DATA;
    } // The last six characters of the data part form a checksum and contain no information

  }, {
    key: "checksum",
    value: function checksum() {
      return this.fingerprint().slice(-6);
    }
  }], [{
    key: "fromHash",
    value: function fromHash(hash) {
      return new AssetFingerprint(hash);
    }
  }, {
    key: "fromParts",
    value: function fromParts(policyId, assetName) {
      // see https://github.com/cardano-foundation/CIPs/pull/64
      var hashBuf = (0, blake2b_1["default"])(20).update(new Uint8Array([].concat(_toConsumableArray(policyId), _toConsumableArray(assetName)))).digest("binary");
      return AssetFingerprint.fromHash(hashBuf);
    }
  }, {
    key: "fromBech32",
    value: function fromBech32(fingerprint) {
      var _bech32_1$bech32$deco = bech32_1.bech32.decode(fingerprint),
          prefix = _bech32_1$bech32$deco.prefix,
          words = _bech32_1$bech32$deco.words;

      if (prefix !== DATA) {
        throw new Error("Invalid asset fingerprint");
      }

      var hashBuf = Buffer.from(bech32_1.bech32.fromWords(words));
      return AssetFingerprint.fromHash(hashBuf);
    }
  }]);

  return AssetFingerprint;
}();

exports["default"] = AssetFingerprint;

/***/ }),

/***/ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "decode": () => (/* binding */ decode),
/* harmony export */   "encode": () => (/* binding */ encode)
/* harmony export */ });
/*
 * base64-arraybuffer 1.0.1 <https://github.com/niklasvh/base64-arraybuffer>
 * Copyright (c) 2022 Niklas von Hertzen <https://hertzen.com>
 * Released under MIT License
 */
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; // Use a lookup table to find the index.

var lookup = typeof Uint8Array === 'undefined' ? [] : new Uint8Array(256);

for (var i = 0; i < chars.length; i++) {
  lookup[chars.charCodeAt(i)] = i;
}

var encode = function encode(arraybuffer) {
  var bytes = new Uint8Array(arraybuffer),
      i,
      len = bytes.length,
      base64 = '';

  for (i = 0; i < len; i += 3) {
    base64 += chars[bytes[i] >> 2];
    base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
    base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
    base64 += chars[bytes[i + 2] & 63];
  }

  if (len % 3 === 2) {
    base64 = base64.substring(0, base64.length - 1) + '=';
  } else if (len % 3 === 1) {
    base64 = base64.substring(0, base64.length - 2) + '==';
  }

  return base64;
};

var decode = function decode(base64) {
  var bufferLength = base64.length * 0.75,
      len = base64.length,
      i,
      p = 0,
      encoded1,
      encoded2,
      encoded3,
      encoded4;

  if (base64[base64.length - 1] === '=') {
    bufferLength--;

    if (base64[base64.length - 2] === '=') {
      bufferLength--;
    }
  }

  var arraybuffer = new ArrayBuffer(bufferLength),
      bytes = new Uint8Array(arraybuffer);

  for (i = 0; i < len; i += 4) {
    encoded1 = lookup[base64.charCodeAt(i)];
    encoded2 = lookup[base64.charCodeAt(i + 1)];
    encoded3 = lookup[base64.charCodeAt(i + 2)];
    encoded4 = lookup[base64.charCodeAt(i + 3)];
    bytes[p++] = encoded1 << 2 | encoded2 >> 4;
    bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
    bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
  }

  return arraybuffer;
};



/***/ }),

/***/ "./node_modules/accepts/index.js":
/*!***************************************!*\
  !*** ./node_modules/accepts/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var Negotiator = __webpack_require__(/*! negotiator */ "./node_modules/negotiator/index.js");

var mime = __webpack_require__(/*! mime-types */ "./node_modules/mime-types/index.js");
/**
 * Module exports.
 * @public
 */


module.exports = Accepts;
/**
 * Create a new Accepts object for the given req.
 *
 * @param {object} req
 * @public
 */

function Accepts(req) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req);
  }

  this.headers = req.headers;
  this.negotiator = new Negotiator(req);
}
/**
 * Check if the given `type(s)` is acceptable, returning
 * the best match when true, otherwise `undefined`, in which
 * case you should respond with 406 "Not Acceptable".
 *
 * The `type` value may be a single mime type string
 * such as "application/json", the extension name
 * such as "json" or an array `["json", "html", "text/plain"]`. When a list
 * or array is given the _best_ match, if any is returned.
 *
 * Examples:
 *
 *     // Accept: text/html
 *     this.types('html');
 *     // => "html"
 *
 *     // Accept: text/*, application/json
 *     this.types('html');
 *     // => "html"
 *     this.types('text/html');
 *     // => "text/html"
 *     this.types('json', 'text');
 *     // => "json"
 *     this.types('application/json');
 *     // => "application/json"
 *
 *     // Accept: text/*, application/json
 *     this.types('image/png');
 *     this.types('png');
 *     // => undefined
 *
 *     // Accept: text/*;q=.5, application/json
 *     this.types(['html', 'json']);
 *     this.types('html', 'json');
 *     // => "json"
 *
 * @param {String|Array} types...
 * @return {String|Array|Boolean}
 * @public
 */


Accepts.prototype.type = Accepts.prototype.types = function (types_) {
  var types = types_; // support flattened arguments

  if (types && !Array.isArray(types)) {
    types = new Array(arguments.length);

    for (var i = 0; i < types.length; i++) {
      types[i] = arguments[i];
    }
  } // no types, return all requested types


  if (!types || types.length === 0) {
    return this.negotiator.mediaTypes();
  } // no accept header, return first given type


  if (!this.headers.accept) {
    return types[0];
  }

  var mimes = types.map(extToMime);
  var accepts = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first = accepts[0];
  return first ? types[mimes.indexOf(first)] : false;
};
/**
 * Return accepted encodings or best fit based on `encodings`.
 *
 * Given `Accept-Encoding: gzip, deflate`
 * an array sorted by quality is returned:
 *
 *     ['gzip', 'deflate']
 *
 * @param {String|Array} encodings...
 * @return {String|Array}
 * @public
 */


Accepts.prototype.encoding = Accepts.prototype.encodings = function (encodings_) {
  var encodings = encodings_; // support flattened arguments

  if (encodings && !Array.isArray(encodings)) {
    encodings = new Array(arguments.length);

    for (var i = 0; i < encodings.length; i++) {
      encodings[i] = arguments[i];
    }
  } // no encodings, return all requested encodings


  if (!encodings || encodings.length === 0) {
    return this.negotiator.encodings();
  }

  return this.negotiator.encodings(encodings)[0] || false;
};
/**
 * Return accepted charsets or best fit based on `charsets`.
 *
 * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`
 * an array sorted by quality is returned:
 *
 *     ['utf-8', 'utf-7', 'iso-8859-1']
 *
 * @param {String|Array} charsets...
 * @return {String|Array}
 * @public
 */


Accepts.prototype.charset = Accepts.prototype.charsets = function (charsets_) {
  var charsets = charsets_; // support flattened arguments

  if (charsets && !Array.isArray(charsets)) {
    charsets = new Array(arguments.length);

    for (var i = 0; i < charsets.length; i++) {
      charsets[i] = arguments[i];
    }
  } // no charsets, return all requested charsets


  if (!charsets || charsets.length === 0) {
    return this.negotiator.charsets();
  }

  return this.negotiator.charsets(charsets)[0] || false;
};
/**
 * Return accepted languages or best fit based on `langs`.
 *
 * Given `Accept-Language: en;q=0.8, es, pt`
 * an array sorted by quality is returned:
 *
 *     ['es', 'pt', 'en']
 *
 * @param {String|Array} langs...
 * @return {Array|String}
 * @public
 */


Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function (languages_) {
  var languages = languages_; // support flattened arguments

  if (languages && !Array.isArray(languages)) {
    languages = new Array(arguments.length);

    for (var i = 0; i < languages.length; i++) {
      languages[i] = arguments[i];
    }
  } // no languages, return all requested languages


  if (!languages || languages.length === 0) {
    return this.negotiator.languages();
  }

  return this.negotiator.languages(languages)[0] || false;
};
/**
 * Convert extnames to mime.
 *
 * @param {String} type
 * @return {String}
 * @private
 */


function extToMime(type) {
  return type.indexOf('/') === -1 ? mime.lookup(type) : type;
}
/**
 * Check if mime is valid.
 *
 * @param {String} type
 * @return {String}
 * @private
 */


function validMime(type) {
  return typeof type === 'string';
}

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");

var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");

var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'


        setTimeout(onloadend);
      };
    } // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js"); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {



module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */

function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      forcedJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators["boolean"], '1.0.0')
    }, false);
  } // filter out skipped interceptors


  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }

  var newConfig = config;

  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();

    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/

  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });
  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data) || headers && headers['Content-Type'] === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }

          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {



module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = function isAxiosError(payload) {
  return _typeof(payload) === 'object' && payload.isAxiosError === true;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {}; // eslint-disable-next-line func-names

['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return _typeof(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');
/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */

function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');

  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }

  return false;
}
/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */


validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  } // eslint-disable-next-line func-names


  return function (value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console

      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */


function assertOptions(options, schema, allowUnknown) {
  if (_typeof(options) !== 'object') {
    throw new TypeError('options must be an object');
  }

  var keys = Object.keys(options);
  var i = keys.length;

  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];

    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);

      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }

      continue;
    }

    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js"); // utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function
  /* obj1, obj2, obj3, ... */
merge() {
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/base64id/lib/base64id.js":
/*!***********************************************!*\
  !*** ./node_modules/base64id/lib/base64id.js ***!
  \***********************************************/
/***/ ((module, exports, __webpack_require__) => {

/*!
 * base64id v0.1.0
 */

/**
 * Module dependencies
 */
var crypto = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));
/**
 * Constructor
 */


var Base64Id = function Base64Id() {};
/**
 * Get random bytes
 *
 * Uses a buffer if available, falls back to crypto.randomBytes
 */


Base64Id.prototype.getRandomBytes = function (bytes) {
  var BUFFER_SIZE = 4096;
  var self = this;
  bytes = bytes || 12;

  if (bytes > BUFFER_SIZE) {
    return crypto.randomBytes(bytes);
  }

  var bytesInBuffer = parseInt(BUFFER_SIZE / bytes);
  var threshold = parseInt(bytesInBuffer * 0.85);

  if (!threshold) {
    return crypto.randomBytes(bytes);
  }

  if (this.bytesBufferIndex == null) {
    this.bytesBufferIndex = -1;
  }

  if (this.bytesBufferIndex == bytesInBuffer) {
    this.bytesBuffer = null;
    this.bytesBufferIndex = -1;
  } // No buffered bytes available or index above threshold


  if (this.bytesBufferIndex == -1 || this.bytesBufferIndex > threshold) {
    if (!this.isGeneratingBytes) {
      this.isGeneratingBytes = true;
      crypto.randomBytes(BUFFER_SIZE, function (err, bytes) {
        self.bytesBuffer = bytes;
        self.bytesBufferIndex = 0;
        self.isGeneratingBytes = false;
      });
    } // Fall back to sync call when no buffered bytes are available


    if (this.bytesBufferIndex == -1) {
      return crypto.randomBytes(bytes);
    }
  }

  var result = this.bytesBuffer.slice(bytes * this.bytesBufferIndex, bytes * (this.bytesBufferIndex + 1));
  this.bytesBufferIndex++;
  return result;
};
/**
 * Generates a base64 id
 *
 * (Original version from socket.io <http://socket.io>)
 */


Base64Id.prototype.generateId = function () {
  var rand = Buffer.alloc(15); // multiple of 3 for base64

  if (!rand.writeInt32BE) {
    return Math.abs(Math.random() * Math.random() * Date.now() | 0).toString() + Math.abs(Math.random() * Math.random() * Date.now() | 0).toString();
  }

  this.sequenceNumber = this.sequenceNumber + 1 | 0;
  rand.writeInt32BE(this.sequenceNumber, 11);

  if (crypto.randomBytes) {
    this.getRandomBytes(12).copy(rand);
  } else {
    // not secure for node 0.4
    [0, 4, 8].forEach(function (i) {
      rand.writeInt32BE(Math.random() * Math.pow(2, 32) | 0, i);
    });
  }

  return rand.toString('base64').replace(/\//g, '_').replace(/\+/g, '-');
};
/**
 * Export
 */


exports = module.exports = new Base64Id();

/***/ }),

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bech32m = exports.bech32 = void 0;
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var ALPHABET_MAP = {};

for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}

function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}

function prefixChk(prefix) {
  var chk = 1;

  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }

  chk = polymodStep(chk);

  for (var _i = 0; _i < prefix.length; ++_i) {
    var v = prefix.charCodeAt(_i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }

  return chk;
}

function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];

  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;

    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }

  return result;
}

function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}

function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}

function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}

function getLibraryFromEncoding(encoding) {
  var ENCODING_CONST;

  if (encoding === 'bech32') {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 0x2bc830a3;
  }

  function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase(); // determine chk mod

    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';

    for (var i = 0; i < words.length; ++i) {
      var _x = words[i];
      if (_x >> 5 !== 0) throw new Error('Non 5-bit word');
      chk = polymodStep(chk) ^ _x;
      result += ALPHABET.charAt(_x);
    }

    for (var _i2 = 0; _i2 < 6; ++_i2) {
      chk = polymodStep(chk);
    }

    chk ^= ENCODING_CONST;

    for (var _i3 = 0; _i3 < 6; ++_i3) {
      var v = chk >> (5 - _i3) * 5 & 0x1f;
      result += ALPHABET.charAt(v);
    }

    return result;
  }

  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case

    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];

    for (var i = 0; i < wordChars.length; ++i) {
      var c = wordChars.charAt(i);
      var v = ALPHABET_MAP[c];
      if (v === undefined) return 'Unknown character ' + c;
      chk = polymodStep(chk) ^ v; // not in the checksum?

      if (i + 6 >= wordChars.length) continue;
      words.push(v);
    }

    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
    return {
      prefix: prefix,
      words: words
    };
  }

  function decodeUnsafe(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
  }

  function decode(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
    throw new Error(res);
  }

  return {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
  };
}

exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

/***/ }),

/***/ "./node_modules/blake2b-wasm/blake2b.js":
/*!**********************************************!*\
  !*** ./node_modules/blake2b-wasm/blake2b.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0r+68tzwhC0Lx7fT4paf9p6V/IQxC0YWa7/rPlIfRACENQp/Y+dnCkdqCm38hDkLr+obav7X2wR8hD0L5wvibkaOz8NsAIRAgACkDACERIABBCGopAwAhEiAAQRBqKQMAIRMgAEEYaikDACEUIABBIGopAwAhFSAAQShqKQMAIRYgAEEwaikDACEXIABBOGopAwAhGCAAQcAAaikDACEZIABByABqKQMAIRogAEHQAGopAwAhGyAAQdgAaikDACEcIABB4ABqKQMAIR0gAEHoAGopAwAhHiAAQfAAaikDACEfIABB+ABqKQMAISAgDSAAQcABaikDAIUhDSAPIABB0AFqKQMAhSEPIAEgBSARfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgEnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBN8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAUfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgFXx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBZ8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAXfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggGHx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBl8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAafHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgG3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBx8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAdfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHnx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB98fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAgfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgH3x8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBt8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAVfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGXx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBp8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAgfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggHnx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBd8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiASfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgHXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBF8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByATfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHHx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBh8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAWfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgFHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBx8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAZfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgHXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBF8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAWfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgE3x8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIICB8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAefHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgG3x8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB98fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAUfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgF3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBh8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCASfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgGnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBV8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAYfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgGnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBR8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiASfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgHnx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB18fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAcfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggH3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBN8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAXfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgFnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBt8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAVfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggEXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFICB8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAZfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgGnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBF8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAWfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgGHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBN8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAVfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggG3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIICB8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAffHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBx8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAdfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggF3x8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBl8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAUfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgHnx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBN8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAdfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgF3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBt8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByARfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgHHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBl8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAUfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgFXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB58fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAYfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgFnx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIICB8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAffHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgEnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBp8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAdfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgFnx8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBJ8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAgfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgH3x8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIB58fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCAVfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggG3x8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGIBF8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAYfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgF3x8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIBR8fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAafHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggE3x8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIBl8fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSAcfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgHnx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBx8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiAYfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgH3x8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIB18fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByASfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggFHx8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBp8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAWfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgEXx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHICB8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAVfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggGXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIBd8fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSATfHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgG3x8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIBd8fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAgfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgH3x8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBp8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAcfHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgFHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIBF8fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAZfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgHXx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIBN8fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByAefHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgGHx8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBJ8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAVfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgG3x8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBZ8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFIAEgBSAbfHwhASANIAGFQiCKIQ0gCSANfCEJIAUgCYVCGIohBSABIAUgE3x8IQEgDSABhUIQiiENIAkgDXwhCSAFIAmFQj+KIQUgAiAGIBl8fCECIA4gAoVCIIohDiAKIA58IQogBiAKhUIYiiEGIAIgBiAVfHwhAiAOIAKFQhCKIQ4gCiAOfCEKIAYgCoVCP4ohBiADIAcgGHx8IQMgDyADhUIgiiEPIAsgD3whCyAHIAuFQhiKIQcgAyAHIBd8fCEDIA8gA4VCEIohDyALIA98IQsgByALhUI/iiEHIAQgCCASfHwhBCAQIASFQiCKIRAgDCAQfCEMIAggDIVCGIohCCAEIAggFnx8IQQgECAEhUIQiiEQIAwgEHwhDCAIIAyFQj+KIQggASAGICB8fCEBIBAgAYVCIIohECALIBB8IQsgBiALhUIYiiEGIAEgBiAcfHwhASAQIAGFQhCKIRAgCyAQfCELIAYgC4VCP4ohBiACIAcgGnx8IQIgDSAChUIgiiENIAwgDXwhDCAHIAyFQhiKIQcgAiAHIB98fCECIA0gAoVCEIohDSAMIA18IQwgByAMhUI/iiEHIAMgCCAUfHwhAyAOIAOFQiCKIQ4gCSAOfCEJIAggCYVCGIohCCADIAggHXx8IQMgDiADhUIQiiEOIAkgDnwhCSAIIAmFQj+KIQggBCAFIB58fCEEIA8gBIVCIIohDyAKIA98IQogBSAKhUIYiiEFIAQgBSARfHwhBCAPIASFQhCKIQ8gCiAPfCEKIAUgCoVCP4ohBSABIAUgEXx8IQEgDSABhUIgiiENIAkgDXwhCSAFIAmFQhiKIQUgASAFIBJ8fCEBIA0gAYVCEIohDSAJIA18IQkgBSAJhUI/iiEFIAIgBiATfHwhAiAOIAKFQiCKIQ4gCiAOfCEKIAYgCoVCGIohBiACIAYgFHx8IQIgDiAChUIQiiEOIAogDnwhCiAGIAqFQj+KIQYgAyAHIBV8fCEDIA8gA4VCIIohDyALIA98IQsgByALhUIYiiEHIAMgByAWfHwhAyAPIAOFQhCKIQ8gCyAPfCELIAcgC4VCP4ohByAEIAggF3x8IQQgECAEhUIgiiEQIAwgEHwhDCAIIAyFQhiKIQggBCAIIBh8fCEEIBAgBIVCEIohECAMIBB8IQwgCCAMhUI/iiEIIAEgBiAZfHwhASAQIAGFQiCKIRAgCyAQfCELIAYgC4VCGIohBiABIAYgGnx8IQEgECABhUIQiiEQIAsgEHwhCyAGIAuFQj+KIQYgAiAHIBt8fCECIA0gAoVCIIohDSAMIA18IQwgByAMhUIYiiEHIAIgByAcfHwhAiANIAKFQhCKIQ0gDCANfCEMIAcgDIVCP4ohByADIAggHXx8IQMgDiADhUIgiiEOIAkgDnwhCSAIIAmFQhiKIQggAyAIIB58fCEDIA4gA4VCEIohDiAJIA58IQkgCCAJhUI/iiEIIAQgBSAffHwhBCAPIASFQiCKIQ8gCiAPfCEKIAUgCoVCGIohBSAEIAUgIHx8IQQgDyAEhUIQiiEPIAogD3whCiAFIAqFQj+KIQUgASAFIB98fCEBIA0gAYVCIIohDSAJIA18IQkgBSAJhUIYiiEFIAEgBSAbfHwhASANIAGFQhCKIQ0gCSANfCEJIAUgCYVCP4ohBSACIAYgFXx8IQIgDiAChUIgiiEOIAogDnwhCiAGIAqFQhiKIQYgAiAGIBl8fCECIA4gAoVCEIohDiAKIA58IQogBiAKhUI/iiEGIAMgByAafHwhAyAPIAOFQiCKIQ8gCyAPfCELIAcgC4VCGIohByADIAcgIHx8IQMgDyADhUIQiiEPIAsgD3whCyAHIAuFQj+KIQcgBCAIIB58fCEEIBAgBIVCIIohECAMIBB8IQwgCCAMhUIYiiEIIAQgCCAXfHwhBCAQIASFQhCKIRAgDCAQfCEMIAggDIVCP4ohCCABIAYgEnx8IQEgECABhUIgiiEQIAsgEHwhCyAGIAuFQhiKIQYgASAGIB18fCEBIBAgAYVCEIohECALIBB8IQsgBiALhUI/iiEGIAIgByARfHwhAiANIAKFQiCKIQ0gDCANfCEMIAcgDIVCGIohByACIAcgE3x8IQIgDSAChUIQiiENIAwgDXwhDCAHIAyFQj+KIQcgAyAIIBx8fCEDIA4gA4VCIIohDiAJIA58IQkgCCAJhUIYiiEIIAMgCCAYfHwhAyAOIAOFQhCKIQ4gCSAOfCEJIAggCYVCP4ohCCAEIAUgFnx8IQQgDyAEhUIgiiEPIAogD3whCiAFIAqFQhiKIQUgBCAFIBR8fCEEIA8gBIVCEIohDyAKIA98IQogBSAKhUI/iiEFICEgISkDACABIAmFhTcDACAiICIpAwAgAiAKhYU3AwAgIyAjKQMAIAMgC4WFNwMAICQgJCkDACAEIAyFhTcDACAlICUpAwAgBSANhYU3AwAgJiAmKQMAIAYgDoWFNwMAICcgJykDACAHIA+FhTcDACAoICgpAwAgCCAQhYU3AwAL');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null))["catch"](cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new ((__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer))(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

/***/ }),

/***/ "./node_modules/blake2b-wasm/index.js":
/*!********************************************!*\
  !*** ./node_modules/blake2b-wasm/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var wasm = __webpack_require__(/*! ./blake2b */ "./node_modules/blake2b-wasm/blake2b.js")();

var head = 64;
var freeList = [];
module.exports = Blake2b;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;

function Blake2b(digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');
  if (!digestLength) digestLength = 32;

  if (noAssert !== true) {
    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);
    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }

  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();
  wasm.memory.fill(0, 0, 64);
  wasm.memory[0] = this.digestLength;
  wasm.memory[1] = key ? key.length : 0;
  wasm.memory[2] = 1; // fanout

  wasm.memory[3] = 1; // depth

  if (salt) wasm.memory.set(salt, 32);
  if (personal) wasm.memory.set(personal, 48);
  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state

  wasm.exports.blake2b_init(this.pointer, this.digestLength);

  if (key) {
    this.update(key);
    wasm.memory.fill(0, head, head + key.length); // whiteout key

    wasm.memory[this.pointer + 200] = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(this.finalized === false, 'Hash instance finalized');
  assert(input, 'input must be TypedArray or Buffer');
  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.set(input, head);
  wasm.exports.blake2b_update(this.pointer, head, head + input.length);
  return this;
};

Blake2b.prototype.digest = function (enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  wasm.exports.blake2b_final(this.pointer);

  if (!enc || enc === 'binary') {
    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  }

  if (enc === 'hex') {
    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
  }

  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer');

  for (var i = 0; i < this.digestLength; i++) {
    enc[i] = wasm.memory[this.pointer + 128 + i];
  }

  return enc;
}; // libsodium compat


Blake2b.prototype["final"] = Blake2b.prototype.digest;
Blake2b.WASM = wasm && wasm.buffer;
Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined';

Blake2b.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported')); // backwards compat, can be removed in a new major

  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve();else reject();
      cb(err);
    });
  });
  return p;
};

Blake2b.prototype.ready = Blake2b.ready;

function noop() {}

function hexSlice(buf, start, len) {
  var str = '';

  for (var i = 0; i < len; i++) {
    str += toHex(buf[start + i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

/***/ }),

/***/ "./node_modules/blake2b/index.js":
/*!***************************************!*\
  !*** ./node_modules/blake2b/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var b2wasm = __webpack_require__(/*! blake2b-wasm */ "./node_modules/blake2b-wasm/index.js"); // 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array


function ADD64AA(v, a, b) {
  var o0 = v[a] + v[b];
  var o1 = v[a + 1] + v[b + 1];

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits


function ADD64AC(v, a, b0, b1) {
  var o0 = v[a] + b0;

  if (b0 < 0) {
    o0 += 0x100000000;
  }

  var o1 = v[a + 1] + b1;

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // Little-endian byte access


function B2B_GET32(arr, i) {
  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
} // G Mixing function
// The ROTRs are inlined for speed


function B2B_G(a, b, c, d, ix, iy) {
  var x0 = m[ix];
  var x1 = m[ix + 1];
  var y0 = m[iy];
  var y1 = m[iy + 1];
  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s

  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits

  var xor0 = v[d] ^ v[a];
  var xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor0 >>> 24 ^ xor1 << 8;
  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v, a, b);
  ADD64AC(v, a, y0, y1); // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits

  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor0 >>> 16 ^ xor1 << 16;
  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor1 >>> 31 ^ xor0 << 1;
  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
} // Initialization Vector


var BLAKE2B_IV32 = new Uint32Array([0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85, 0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A, 0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C, 0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19]);
var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; // These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s

var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
  return x * 2;
})); // Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s

var v = new Uint32Array(32);
var m = new Uint32Array(32);

function blake2bCompress(ctx, last) {
  var i = 0; // init work variables

  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i];
    v[i + 16] = BLAKE2B_IV32[i];
  } // low 64 bits of offset


  v[24] = v[24] ^ ctx.t;
  v[25] = v[25] ^ ctx.t / 0x100000000; // high 64 bits not supported, offset may not be higher than 2**53-1
  // last block flag set ?

  if (last) {
    v[28] = ~v[28];
    v[29] = ~v[29];
  } // get little-endian words


  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i);
  } // twelve rounds of mixing


  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
  }
} // reusable parameter_block


var parameter_block = new Uint8Array([0, 0, 0, 0, //  0: outlen, keylen, fanout, depth
0, 0, 0, 0, //  4: leaf length, sequential mode
0, 0, 0, 0, //  8: node offset
0, 0, 0, 0, // 12: node offset
0, 0, 0, 0, // 16: node depth, inner length, rfu
0, 0, 0, 0, // 20: rfu
0, 0, 0, 0, // 24: rfu
0, 0, 0, 0, // 28: rfu
0, 0, 0, 0, // 32: salt
0, 0, 0, 0, // 36: salt
0, 0, 0, 0, // 40: salt
0, 0, 0, 0, // 44: salt
0, 0, 0, 0, // 48: personal
0, 0, 0, 0, // 52: personal
0, 0, 0, 0, // 56: personal
0, 0, 0, 0 // 60: personal
]); // Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key

function Blake2b(outlen, key, salt, personal) {
  // zero out parameter_block before usage
  parameter_block.fill(0); // state, 'param block'

  this.b = new Uint8Array(128);
  this.h = new Uint32Array(16);
  this.t = 0; // input count

  this.c = 0; // pointer within buffer

  this.outlen = outlen; // output length in bytes

  parameter_block[0] = outlen;
  if (key) parameter_block[1] = key.length;
  parameter_block[2] = 1; // fanout

  parameter_block[3] = 1; // depth

  if (salt) parameter_block.set(salt, 32);
  if (personal) parameter_block.set(personal, 48); // initialize hash state

  for (var i = 0; i < 16; i++) {
    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
  } // key the hash, if applicable


  if (key) {
    blake2bUpdate(this, key); // at the end

    this.c = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(input != null, 'input must be Uint8Array or Buffer');
  blake2bUpdate(this, input);
  return this;
};

Blake2b.prototype.digest = function (out) {
  var buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out;
  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
  blake2bFinal(this, buf);
  if (out === 'hex') return hexSlice(buf);
  return buf;
};

Blake2b.prototype["final"] = Blake2b.prototype.digest;

Blake2b.ready = function (cb) {
  b2wasm.ready(function () {
    cb(); // ignore the error
  });
}; // Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)


function blake2bUpdate(ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c; // add counters

      blake2bCompress(ctx, false); // compress (not last)

      ctx.c = 0; // counter to zero
    }

    ctx.b[ctx.c++] = input[i];
  }
} // Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest


function blake2bFinal(ctx, out) {
  ctx.t += ctx.c; // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0;
  }

  blake2bCompress(ctx, true); // final block flag = 1

  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
  }

  return out;
}

function hexSlice(buf) {
  var str = '';

  for (var i = 0; i < buf.length; i++) {
    str += toHex(buf[i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

var Proto = Blake2b;

module.exports = function createHash(outlen, key, salt, personal, noAssert) {
  if (noAssert !== true) {
    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  return new Proto(outlen, key, salt, personal);
};

module.exports.ready = function (cb) {
  b2wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
b2wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    Proto = b2wasm;
  }
});

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }

  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }

  return fromArrayLike(arrayView);
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }

    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  var i;

  for (i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
          thirdByte = void 0,
          fourthByte = void 0,
          tempCodePoint = void 0;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = (first << 24) + // Overflow
  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}

function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage


var errors = {};

function E(sym, getMessage, Base) {
  errors[sym] = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);

    var _super = _createSuper(NodeError);

    function NodeError() {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _super.call(this);
      Object.defineProperty(_assertThisInitialized(_this), 'message', {
        value: getMessage.apply(_assertThisInitialized(_this), arguments),
        writable: true,
        configurable: true
      }); // Add the error code to the name to include it in the stack trace.

      _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
      // from the name.

      _this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.

      delete _this.name;
      return _this;
    }

    _createClass(NodeError, [{
      key: "code",
      get: function get() {
        return sym;
      },
      set: function set(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value: value,
          writable: true
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
      }
    }]);

    return NodeError;
  }(Base);
}

E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;

  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);

    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }

    received += 'n';
  }

  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);

function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;

  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }

  return "".concat(val.slice(0, i)).concat(res);
} // CHECK FUNCTIONS
// ===============


function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');

  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}

function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;

    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }

    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }

  checkBounds(buf, offset, byteLength);
}

function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}

function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
} // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  var i;

  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
} // Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219


var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);

  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;

    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }

  return table;
}(); // Return not function with Error if BigInt not supported


function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}

function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

/***/ }),

/***/ "./node_modules/bufferutil/fallback.js":
/*!*********************************************!*\
  !*** ./node_modules/bufferutil/fallback.js ***!
  \*********************************************/
/***/ ((module) => {


/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */

var mask = function mask(source, _mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ _mask[i & 3];
  }
};
/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */


var unmask = function unmask(buffer, mask) {
  // Required until https://github.com/nodejs/node/issues/9006 is resolved.
  var length = buffer.length;

  for (var i = 0; i < length; i++) {
    buffer[i] ^= mask[i & 3];
  }
};

module.exports = {
  mask: mask,
  unmask: unmask
};

/***/ }),

/***/ "./node_modules/bufferutil/index.js":
/*!******************************************!*\
  !*** ./node_modules/bufferutil/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __dirname = "/";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "./node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "./node_modules/bufferutil/fallback.js");
}

/***/ }),

/***/ "./node_modules/component-emitter/index.js":
/*!*************************************************!*\
  !*** ./node_modules/component-emitter/index.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * Expose `Emitter`.
 */
if (true) {
  module.exports = Emitter;
}
/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */


function Emitter(obj) {
  if (obj) return mixin(obj);
}

;
/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }

  return obj;
}
/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.on = Emitter.prototype.addEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || []).push(fn);
  return this;
};
/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.once = function (event, fn) {
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};
/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */


Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function (event, fn) {
  this._callbacks = this._callbacks || {}; // all

  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  } // specific event


  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this; // remove all handlers

  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  } // remove specific handler


  var cb;

  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];

    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  } // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.


  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};
/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */


Emitter.prototype.emit = function (event) {
  this._callbacks = this._callbacks || {};
  var args = new Array(arguments.length - 1),
      callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);

    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};
/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */


Emitter.prototype.listeners = function (event) {
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};
/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */


Emitter.prototype.hasListeners = function (event) {
  return !!this.listeners(event).length;
};

/***/ }),

/***/ "./node_modules/cookie/index.js":
/*!**************************************!*\
  !*** ./node_modules/cookie/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */

var decode = decodeURIComponent;
var encode = encodeURIComponent;
/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */

var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */

function parse(str, options) {
  if (typeof str !== 'string') {
    throw new TypeError('argument str must be a string');
  }

  var obj = {};
  var opt = options || {};
  var pairs = str.split(';');
  var dec = opt.decode || decode;

  for (var i = 0; i < pairs.length; i++) {
    var pair = pairs[i];
    var index = pair.indexOf('='); // skip things that don't look like key=value

    if (index < 0) {
      continue;
    }

    var key = pair.substring(0, index).trim(); // only assign once

    if (undefined == obj[key]) {
      var val = pair.substring(index + 1, pair.length).trim(); // quoted values

      if (val[0] === '"') {
        val = val.slice(1, -1);
      }

      obj[key] = tryDecode(val, dec);
    }
  }

  return obj;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */


function serialize(name, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode;

  if (typeof enc !== 'function') {
    throw new TypeError('option encode is invalid');
  }

  if (!fieldContentRegExp.test(name)) {
    throw new TypeError('argument name is invalid');
  }

  var value = enc(val);

  if (value && !fieldContentRegExp.test(value)) {
    throw new TypeError('argument val is invalid');
  }

  var str = name + '=' + value;

  if (null != opt.maxAge) {
    var maxAge = opt.maxAge - 0;

    if (isNaN(maxAge) || !isFinite(maxAge)) {
      throw new TypeError('option maxAge is invalid');
    }

    str += '; Max-Age=' + Math.floor(maxAge);
  }

  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError('option domain is invalid');
    }

    str += '; Domain=' + opt.domain;
  }

  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError('option path is invalid');
    }

    str += '; Path=' + opt.path;
  }

  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== 'function') {
      throw new TypeError('option expires is invalid');
    }

    str += '; Expires=' + opt.expires.toUTCString();
  }

  if (opt.httpOnly) {
    str += '; HttpOnly';
  }

  if (opt.secure) {
    str += '; Secure';
  }

  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;

    switch (sameSite) {
      case true:
        str += '; SameSite=Strict';
        break;

      case 'lax':
        str += '; SameSite=Lax';
        break;

      case 'strict':
        str += '; SameSite=Strict';
        break;

      case 'none':
        str += '; SameSite=None';
        break;

      default:
        throw new TypeError('option sameSite is invalid');
    }
  }

  return str;
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */


function tryDecode(str, decode) {
  try {
    return decode(str);
  } catch (e) {
    return str;
  }
}

/***/ }),

/***/ "./node_modules/cors/lib/index.js":
/*!****************************************!*\
  !*** ./node_modules/cors/lib/index.js ***!
  \****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

(function () {
  'use strict';

  var assign = __webpack_require__(/*! object-assign */ "./node_modules/object-assign/index.js");

  var vary = __webpack_require__(/*! vary */ "./node_modules/vary/index.js");

  var defaults = {
    origin: '*',
    methods: 'GET,HEAD,PUT,PATCH,POST,DELETE',
    preflightContinue: false,
    optionsSuccessStatus: 204
  };

  function isString(s) {
    return typeof s === 'string' || s instanceof String;
  }

  function isOriginAllowed(origin, allowedOrigin) {
    if (Array.isArray(allowedOrigin)) {
      for (var i = 0; i < allowedOrigin.length; ++i) {
        if (isOriginAllowed(origin, allowedOrigin[i])) {
          return true;
        }
      }

      return false;
    } else if (isString(allowedOrigin)) {
      return origin === allowedOrigin;
    } else if (allowedOrigin instanceof RegExp) {
      return allowedOrigin.test(origin);
    } else {
      return !!allowedOrigin;
    }
  }

  function configureOrigin(options, req) {
    var requestOrigin = req.headers.origin,
        headers = [],
        isAllowed;

    if (!options.origin || options.origin === '*') {
      // allow any origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: '*'
      }]);
    } else if (isString(options.origin)) {
      // fixed origin
      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: options.origin
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    } else {
      isAllowed = isOriginAllowed(requestOrigin, options.origin); // reflect origin

      headers.push([{
        key: 'Access-Control-Allow-Origin',
        value: isAllowed ? requestOrigin : false
      }]);
      headers.push([{
        key: 'Vary',
        value: 'Origin'
      }]);
    }

    return headers;
  }

  function configureMethods(options) {
    var methods = options.methods;

    if (methods.join) {
      methods = options.methods.join(','); // .methods is an array, so turn it into a string
    }

    return {
      key: 'Access-Control-Allow-Methods',
      value: methods
    };
  }

  function configureCredentials(options) {
    if (options.credentials === true) {
      return {
        key: 'Access-Control-Allow-Credentials',
        value: 'true'
      };
    }

    return null;
  }

  function configureAllowedHeaders(options, req) {
    var allowedHeaders = options.allowedHeaders || options.headers;
    var headers = [];

    if (!allowedHeaders) {
      allowedHeaders = req.headers['access-control-request-headers']; // .headers wasn't specified, so reflect the request headers

      headers.push([{
        key: 'Vary',
        value: 'Access-Control-Request-Headers'
      }]);
    } else if (allowedHeaders.join) {
      allowedHeaders = allowedHeaders.join(','); // .headers is an array, so turn it into a string
    }

    if (allowedHeaders && allowedHeaders.length) {
      headers.push([{
        key: 'Access-Control-Allow-Headers',
        value: allowedHeaders
      }]);
    }

    return headers;
  }

  function configureExposedHeaders(options) {
    var headers = options.exposedHeaders;

    if (!headers) {
      return null;
    } else if (headers.join) {
      headers = headers.join(','); // .headers is an array, so turn it into a string
    }

    if (headers && headers.length) {
      return {
        key: 'Access-Control-Expose-Headers',
        value: headers
      };
    }

    return null;
  }

  function configureMaxAge(options) {
    var maxAge = (typeof options.maxAge === 'number' || options.maxAge) && options.maxAge.toString();

    if (maxAge && maxAge.length) {
      return {
        key: 'Access-Control-Max-Age',
        value: maxAge
      };
    }

    return null;
  }

  function applyHeaders(headers, res) {
    for (var i = 0, n = headers.length; i < n; i++) {
      var header = headers[i];

      if (header) {
        if (Array.isArray(header)) {
          applyHeaders(header, res);
        } else if (header.key === 'Vary' && header.value) {
          vary(res, header.value);
        } else if (header.value) {
          res.setHeader(header.key, header.value);
        }
      }
    }
  }

  function cors(options, req, res, next) {
    var headers = [],
        method = req.method && req.method.toUpperCase && req.method.toUpperCase();

    if (method === 'OPTIONS') {
      // preflight
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureMethods(options, req));
      headers.push(configureAllowedHeaders(options, req));
      headers.push(configureMaxAge(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);

      if (options.preflightContinue) {
        next();
      } else {
        // Safari (and potentially other browsers) need content-length 0,
        //   for 204 or they just hang waiting for a body
        res.statusCode = options.optionsSuccessStatus;
        res.setHeader('Content-Length', '0');
        res.end();
      }
    } else {
      // actual response
      headers.push(configureOrigin(options, req));
      headers.push(configureCredentials(options, req));
      headers.push(configureExposedHeaders(options, req));
      applyHeaders(headers, res);
      next();
    }
  }

  function middlewareWrapper(o) {
    // if options are static (either via defaults or custom options passed in), wrap in a function
    var optionsCallback = null;

    if (typeof o === 'function') {
      optionsCallback = o;
    } else {
      optionsCallback = function optionsCallback(req, cb) {
        cb(null, o);
      };
    }

    return function corsMiddleware(req, res, next) {
      optionsCallback(req, function (err, options) {
        if (err) {
          next(err);
        } else {
          var corsOptions = assign({}, defaults, options);
          var originCallback = null;

          if (corsOptions.origin && typeof corsOptions.origin === 'function') {
            originCallback = corsOptions.origin;
          } else if (corsOptions.origin) {
            originCallback = function originCallback(origin, cb) {
              cb(null, corsOptions.origin);
            };
          }

          if (originCallback) {
            originCallback(req.headers.origin, function (err2, origin) {
              if (err2 || !origin) {
                next(err2);
              } else {
                corsOptions.origin = origin;
                cors(corsOptions, req, res, next);
              }
            });
          } else {
            next();
          }
        }
      });
    };
  } // can pass either an options hash, an options delegate, or nothing


  module.exports = middlewareWrapper;
})();

/***/ }),

/***/ "./node_modules/engine.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/engine.io/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/engine.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/engine.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/engine.io/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/engine.io/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* eslint-env browser */
module.exports = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' ? self.FormData : window.FormData;

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/mime-db/index.js":
/*!***************************************!*\
  !*** ./node_modules/mime-db/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */
module.exports = __webpack_require__(/*! ./db.json */ "./node_modules/mime-db/db.json");

/***/ }),

/***/ "./node_modules/mime-types/index.js":
/*!******************************************!*\
  !*** ./node_modules/mime-types/index.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module dependencies.
 * @private
 */

var db = __webpack_require__(/*! mime-db */ "./node_modules/mime-db/index.js");

var extname = Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }());
/**
 * Module variables.
 * @private
 */


var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;
/**
 * Module exports.
 * @public
 */

exports.charset = charset;
exports.charsets = {
  lookup: charset
};
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null); // Populate the extensions/types maps

populateMaps(exports.extensions, exports.types);
/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && db[match[1].toLowerCase()];

  if (mime && mime.charset) {
    return mime.charset;
  } // default text/* to utf-8


  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8';
  }

  return false;
}
/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */


function contentType(str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false;
  }

  var mime = str.indexOf('/') === -1 ? exports.lookup(str) : str;

  if (!mime) {
    return false;
  } // TODO: use content-type or other module


  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime);
    if (charset) mime += '; charset=' + charset.toLowerCase();
  }

  return mime;
}
/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */


function extension(type) {
  if (!type || typeof type !== 'string') {
    return false;
  } // TODO: use media-typer


  var match = EXTRACT_TYPE_REGEXP.exec(type); // get extensions

  var exts = match && exports.extensions[match[1].toLowerCase()];

  if (!exts || !exts.length) {
    return false;
  }

  return exts[0];
}
/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */


function lookup(path) {
  if (!path || typeof path !== 'string') {
    return false;
  } // get the extension ("ext" or ".ext" or full path)


  var extension = extname('x.' + path).toLowerCase().substr(1);

  if (!extension) {
    return false;
  }

  return exports.types[extension] || false;
}
/**
 * Populate the extensions and types maps.
 * @private
 */


function populateMaps(extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana'];
  Object.keys(db).forEach(function forEachMimeType(type) {
    var mime = db[type];
    var exts = mime.extensions;

    if (!exts || !exts.length) {
      return;
    } // mime -> extensions


    extensions[type] = exts; // extension -> mime

    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];

      if (types[extension]) {
        var from = preference.indexOf(db[types[extension]].source);
        var to = preference.indexOf(mime.source);

        if (types[extension] !== 'application/octet-stream' && (from > to || from === to && types[extension].substr(0, 12) === 'application/')) {
          // skip the remapping
          continue;
        }
      } // set the extension -> mime


      types[extension] = type;
    }
  });
}

/***/ }),

/***/ "./node_modules/nanoassert/index.js":
/*!******************************************!*\
  !*** ./node_modules/nanoassert/index.js ***!
  \******************************************/
/***/ ((module) => {

assert.notEqual = notEqual;
assert.notOk = notOk;
assert.equal = equal;
assert.ok = assert;
module.exports = assert;

function equal(a, b, m) {
  assert(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual(a, b, m) {
  assert(a != b, m); // eslint-disable-line eqeqeq
}

function notOk(t, m) {
  assert(!t, m);
}

function assert(t, m) {
  if (!t) throw new Error(m || 'AssertionError');
}

/***/ }),

/***/ "./node_modules/negotiator/index.js":
/*!******************************************!*\
  !*** ./node_modules/negotiator/index.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */


var preferredCharsets = __webpack_require__(/*! ./lib/charset */ "./node_modules/negotiator/lib/charset.js");

var preferredEncodings = __webpack_require__(/*! ./lib/encoding */ "./node_modules/negotiator/lib/encoding.js");

var preferredLanguages = __webpack_require__(/*! ./lib/language */ "./node_modules/negotiator/lib/language.js");

var preferredMediaTypes = __webpack_require__(/*! ./lib/mediaType */ "./node_modules/negotiator/lib/mediaType.js");
/**
 * Module exports.
 * @public
 */


module.exports = Negotiator;
module.exports.Negotiator = Negotiator;
/**
 * Create a Negotiator instance from a request.
 * @param {object} request
 * @public
 */

function Negotiator(request) {
  if (!(this instanceof Negotiator)) {
    return new Negotiator(request);
  }

  this.request = request;
}

Negotiator.prototype.charset = function charset(available) {
  var set = this.charsets(available);
  return set && set[0];
};

Negotiator.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers['accept-charset'], available);
};

Negotiator.prototype.encoding = function encoding(available) {
  var set = this.encodings(available);
  return set && set[0];
};

Negotiator.prototype.encodings = function encodings(available) {
  return preferredEncodings(this.request.headers['accept-encoding'], available);
};

Negotiator.prototype.language = function language(available) {
  var set = this.languages(available);
  return set && set[0];
};

Negotiator.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers['accept-language'], available);
};

Negotiator.prototype.mediaType = function mediaType(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};

Negotiator.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
}; // Backwards compatibility


Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
Negotiator.prototype.preferredMediaTypes = Negotiator.prototype.mediaTypes;

/***/ }),

/***/ "./node_modules/negotiator/lib/charset.js":
/*!************************************************!*\
  !*** ./node_modules/negotiator/lib/charset.js ***!
  \************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredCharsets;
module.exports.preferredCharsets = preferredCharsets;
/**
 * Module variables.
 * @private
 */

var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Charset header.
 * @private
 */

function parseAcceptCharset(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var charset = parseCharset(accepts[i].trim(), i);

    if (charset) {
      accepts[j++] = charset;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a charset from the Accept-Charset header.
 * @private
 */


function parseCharset(str, i) {
  var match = simpleCharsetRegExp.exec(str);
  if (!match) return null;
  var charset = match[1];
  var q = 1;

  if (match[2]) {
    var params = match[2].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');

      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    charset: charset,
    q: q,
    i: i
  };
}
/**
 * Get the priority of a charset.
 * @private
 */


function getCharsetPriority(charset, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(charset, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the charset.
 * @private
 */


function specify(charset, spec, index) {
  var s = 0;

  if (spec.charset.toLowerCase() === charset.toLowerCase()) {
    s |= 1;
  } else if (spec.charset !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred charsets from an Accept-Charset header.
 * @public
 */


function preferredCharsets(accept, provided) {
  // RFC 2616 sec 14.2: no header = *
  var accepts = parseAcceptCharset(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all charsets
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullCharset);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getCharsetPriority(type, accepts, index);
  }); // sorted list of accepted charsets

  return priorities.filter(isQuality).sort(compareSpecs).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full charset string.
 * @private
 */


function getFullCharset(spec) {
  return spec.charset;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/encoding.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/encoding.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredEncodings;
module.exports.preferredEncodings = preferredEncodings;
/**
 * Module variables.
 * @private
 */

var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Encoding header.
 * @private
 */

function parseAcceptEncoding(accept) {
  var accepts = accept.split(',');
  var hasIdentity = false;
  var minQuality = 1;

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var encoding = parseEncoding(accepts[i].trim(), i);

    if (encoding) {
      accepts[j++] = encoding;
      hasIdentity = hasIdentity || specify('identity', encoding);
      minQuality = Math.min(minQuality, encoding.q || 1);
    }
  }

  if (!hasIdentity) {
    /*
     * If identity doesn't explicitly appear in the accept-encoding header,
     * it's added to the list of acceptable encoding with the lowest q
     */
    accepts[j++] = {
      encoding: 'identity',
      q: minQuality,
      i: i
    };
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse an encoding from the Accept-Encoding header.
 * @private
 */


function parseEncoding(str, i) {
  var match = simpleEncodingRegExp.exec(str);
  if (!match) return null;
  var encoding = match[1];
  var q = 1;

  if (match[2]) {
    var params = match[2].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].trim().split('=');

      if (p[0] === 'q') {
        q = parseFloat(p[1]);
        break;
      }
    }
  }

  return {
    encoding: encoding,
    q: q,
    i: i
  };
}
/**
 * Get the priority of an encoding.
 * @private
 */


function getEncodingPriority(encoding, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(encoding, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the encoding.
 * @private
 */


function specify(encoding, spec, index) {
  var s = 0;

  if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
    s |= 1;
  } else if (spec.encoding !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

;
/**
 * Get the preferred encodings from an Accept-Encoding header.
 * @public
 */

function preferredEncodings(accept, provided) {
  var accepts = parseAcceptEncoding(accept || '');

  if (!provided) {
    // sorted list of all encodings
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullEncoding);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getEncodingPriority(type, accepts, index);
  }); // sorted list of accepted encodings

  return priorities.filter(isQuality).sort(compareSpecs).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full encoding string.
 * @private
 */


function getFullEncoding(spec) {
  return spec.encoding;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/language.js":
/*!*************************************************!*\
  !*** ./node_modules/negotiator/lib/language.js ***!
  \*************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredLanguages;
module.exports.preferredLanguages = preferredLanguages;
/**
 * Module variables.
 * @private
 */

var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
/**
 * Parse the Accept-Language header.
 * @private
 */

function parseAcceptLanguage(accept) {
  var accepts = accept.split(',');

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var language = parseLanguage(accepts[i].trim(), i);

    if (language) {
      accepts[j++] = language;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a language from the Accept-Language header.
 * @private
 */


function parseLanguage(str, i) {
  var match = simpleLanguageRegExp.exec(str);
  if (!match) return null;
  var prefix = match[1];
  var suffix = match[2];
  var full = prefix;
  if (suffix) full += "-" + suffix;
  var q = 1;

  if (match[3]) {
    var params = match[3].split(';');

    for (var j = 0; j < params.length; j++) {
      var p = params[j].split('=');
      if (p[0] === 'q') q = parseFloat(p[1]);
    }
  }

  return {
    prefix: prefix,
    suffix: suffix,
    q: q,
    i: i,
    full: full
  };
}
/**
 * Get the priority of a language.
 * @private
 */


function getLanguagePriority(language, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(language, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the language.
 * @private
 */


function specify(language, spec, index) {
  var p = parseLanguage(language);
  if (!p) return null;
  var s = 0;

  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s |= 1;
  } else if (spec.full !== '*') {
    return null;
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}

;
/**
 * Get the preferred languages from an Accept-Language header.
 * @public
 */

function preferredLanguages(accept, provided) {
  // RFC 2616 sec 14.4: no header = *
  var accepts = parseAcceptLanguage(accept === undefined ? '*' : accept || '');

  if (!provided) {
    // sorted list of all languages
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullLanguage);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getLanguagePriority(type, accepts, index);
  }); // sorted list of accepted languages

  return priorities.filter(isQuality).sort(compareSpecs).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full language string.
 * @private
 */


function getFullLanguage(spec) {
  return spec.full;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}

/***/ }),

/***/ "./node_modules/negotiator/lib/mediaType.js":
/*!**************************************************!*\
  !*** ./node_modules/negotiator/lib/mediaType.js ***!
  \**************************************************/
/***/ ((module) => {

/**
 * negotiator
 * Copyright(c) 2012 Isaac Z. Schlueter
 * Copyright(c) 2014 Federico Romero
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 * @public
 */

module.exports = preferredMediaTypes;
module.exports.preferredMediaTypes = preferredMediaTypes;
/**
 * Module variables.
 * @private
 */

var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
/**
 * Parse the Accept header.
 * @private
 */

function parseAccept(accept) {
  var accepts = splitMediaTypes(accept);

  for (var i = 0, j = 0; i < accepts.length; i++) {
    var mediaType = parseMediaType(accepts[i].trim(), i);

    if (mediaType) {
      accepts[j++] = mediaType;
    }
  } // trim accepts


  accepts.length = j;
  return accepts;
}
/**
 * Parse a media type from the Accept header.
 * @private
 */


function parseMediaType(str, i) {
  var match = simpleMediaTypeRegExp.exec(str);
  if (!match) return null;
  var params = Object.create(null);
  var q = 1;
  var subtype = match[2];
  var type = match[1];

  if (match[3]) {
    var kvps = splitParameters(match[3]).map(splitKeyValuePair);

    for (var j = 0; j < kvps.length; j++) {
      var pair = kvps[j];
      var key = pair[0].toLowerCase();
      var val = pair[1]; // get the value, unwrapping quotes

      var value = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;

      if (key === 'q') {
        q = parseFloat(value);
        break;
      } // store parameter


      params[key] = value;
    }
  }

  return {
    type: type,
    subtype: subtype,
    params: params,
    q: q,
    i: i
  };
}
/**
 * Get the priority of a media type.
 * @private
 */


function getMediaTypePriority(type, accepted, index) {
  var priority = {
    o: -1,
    q: 0,
    s: 0
  };

  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type, accepted[i], index);

    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }

  return priority;
}
/**
 * Get the specificity of the media type.
 * @private
 */


function specify(type, spec, index) {
  var p = parseMediaType(type);
  var s = 0;

  if (!p) {
    return null;
  }

  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s |= 4;
  } else if (spec.type != '*') {
    return null;
  }

  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s |= 2;
  } else if (spec.subtype != '*') {
    return null;
  }

  var keys = Object.keys(spec.params);

  if (keys.length > 0) {
    if (keys.every(function (k) {
      return spec.params[k] == '*' || (spec.params[k] || '').toLowerCase() == (p.params[k] || '').toLowerCase();
    })) {
      s |= 1;
    } else {
      return null;
    }
  }

  return {
    i: index,
    o: spec.i,
    q: spec.q,
    s: s
  };
}
/**
 * Get the preferred media types from an Accept header.
 * @public
 */


function preferredMediaTypes(accept, provided) {
  // RFC 2616 sec 14.2: no header = */*
  var accepts = parseAccept(accept === undefined ? '*/*' : accept || '');

  if (!provided) {
    // sorted list of all types
    return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
  }

  var priorities = provided.map(function getPriority(type, index) {
    return getMediaTypePriority(type, accepts, index);
  }); // sorted list of accepted types

  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
/**
 * Compare two specs.
 * @private
 */


function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
/**
 * Get full type string.
 * @private
 */


function getFullType(spec) {
  return spec.type + '/' + spec.subtype;
}
/**
 * Check if a spec has any quality.
 * @private
 */


function isQuality(spec) {
  return spec.q > 0;
}
/**
 * Count the number of quotes in a string.
 * @private
 */


function quoteCount(string) {
  var count = 0;
  var index = 0;

  while ((index = string.indexOf('"', index)) !== -1) {
    count++;
    index++;
  }

  return count;
}
/**
 * Split a key value pair.
 * @private
 */


function splitKeyValuePair(str) {
  var index = str.indexOf('=');
  var key;
  var val;

  if (index === -1) {
    key = str;
  } else {
    key = str.substr(0, index);
    val = str.substr(index + 1);
  }

  return [key, val];
}
/**
 * Split an Accept header into media types.
 * @private
 */


function splitMediaTypes(accept) {
  var accepts = accept.split(',');

  for (var i = 1, j = 0; i < accepts.length; i++) {
    if (quoteCount(accepts[j]) % 2 == 0) {
      accepts[++j] = accepts[i];
    } else {
      accepts[j] += ',' + accepts[i];
    }
  } // trim accepts


  accepts.length = j + 1;
  return accepts;
}
/**
 * Split a string of parameters.
 * @private
 */


function splitParameters(str) {
  var parameters = str.split(';');

  for (var i = 1, j = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j]) % 2 == 0) {
      parameters[++j] = parameters[i];
    } else {
      parameters[j] += ';' + parameters[i];
    }
  } // trim parameters


  parameters.length = j + 1;

  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }

  return parameters;
}

/***/ }),

/***/ "./node_modules/node-gyp-build/index.js":
/*!**********************************************!*\
  !*** ./node_modules/node-gyp-build/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var fs = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var os = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'os'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())); // Workaround to fix webpack's build warnings: 'the request of a dependency is an expression'


var runtimeRequire =  true ? require : 0; // eslint-disable-line

var vars = process.config && process.config.variables || {};
var prebuildsOnly = !!process.env.PREBUILDS_ONLY;
var abi = process.versions.modules; // TODO: support old node where this is undef

var runtime = isElectron() ? 'electron' : 'node';
var arch = os.arch();
var platform = os.platform();
var libc = process.env.LIBC || (isAlpine(platform) ? 'musl' : 'glibc');
var armv = process.env.ARM_VERSION || (arch === 'arm64' ? '8' : vars.arm_version) || '';
var uv = (process.versions.uv || '').split('.')[0];
module.exports = load;

function load(dir) {
  return runtimeRequire(load.path(dir));
}

load.path = function (dir) {
  dir = path.resolve(dir || '.');

  try {
    var name = runtimeRequire(path.join(dir, 'package.json')).name.toUpperCase().replace(/-/g, '_');
    if (process.env[name + '_PREBUILD']) dir = process.env[name + '_PREBUILD'];
  } catch (err) {}

  if (!prebuildsOnly) {
    var release = getFirst(path.join(dir, 'build/Release'), matchBuild);
    if (release) return release;
    var debug = getFirst(path.join(dir, 'build/Debug'), matchBuild);
    if (debug) return debug;
  }

  var prebuild = resolve(dir);
  if (prebuild) return prebuild;
  var nearby = resolve(path.dirname(process.execPath));
  if (nearby) return nearby;
  var target = ['platform=' + platform, 'arch=' + arch, 'runtime=' + runtime, 'abi=' + abi, 'uv=' + uv, armv ? 'armv=' + armv : '', 'libc=' + libc, 'node=' + process.versions.node, process.versions.electron ? 'electron=' + process.versions.electron : '',  true ? 'webpack=true' : 0 // eslint-disable-line
  ].filter(Boolean).join(' ');
  throw new Error('No native build was found for ' + target + '\n    loaded from: ' + dir + '\n');

  function resolve(dir) {
    // Find matching "prebuilds/<platform>-<arch>" directory
    var tuples = readdirSync(path.join(dir, 'prebuilds')).map(parseTuple);
    var tuple = tuples.filter(matchTuple(platform, arch)).sort(compareTuples)[0];
    if (!tuple) return; // Find most specific flavor first

    var prebuilds = path.join(dir, 'prebuilds', tuple.name);
    var parsed = readdirSync(prebuilds).map(parseTags);
    var candidates = parsed.filter(matchTags(runtime, abi));
    var winner = candidates.sort(compareTags(runtime))[0];
    if (winner) return path.join(prebuilds, winner.file);
  }
};

function readdirSync(dir) {
  try {
    return fs.readdirSync(dir);
  } catch (err) {
    return [];
  }
}

function getFirst(dir, filter) {
  var files = readdirSync(dir).filter(filter);
  return files[0] && path.join(dir, files[0]);
}

function matchBuild(name) {
  return /\.node$/.test(name);
}

function parseTuple(name) {
  // Example: darwin-x64+arm64
  var arr = name.split('-');
  if (arr.length !== 2) return;
  var platform = arr[0];
  var architectures = arr[1].split('+');
  if (!platform) return;
  if (!architectures.length) return;
  if (!architectures.every(Boolean)) return;
  return {
    name: name,
    platform: platform,
    architectures: architectures
  };
}

function matchTuple(platform, arch) {
  return function (tuple) {
    if (tuple == null) return false;
    if (tuple.platform !== platform) return false;
    return tuple.architectures.includes(arch);
  };
}

function compareTuples(a, b) {
  // Prefer single-arch prebuilds over multi-arch
  return a.architectures.length - b.architectures.length;
}

function parseTags(file) {
  var arr = file.split('.');
  var extension = arr.pop();
  var tags = {
    file: file,
    specificity: 0
  };
  if (extension !== 'node') return;

  for (var i = 0; i < arr.length; i++) {
    var tag = arr[i];

    if (tag === 'node' || tag === 'electron' || tag === 'node-webkit') {
      tags.runtime = tag;
    } else if (tag === 'napi') {
      tags.napi = true;
    } else if (tag.slice(0, 3) === 'abi') {
      tags.abi = tag.slice(3);
    } else if (tag.slice(0, 2) === 'uv') {
      tags.uv = tag.slice(2);
    } else if (tag.slice(0, 4) === 'armv') {
      tags.armv = tag.slice(4);
    } else if (tag === 'glibc' || tag === 'musl') {
      tags.libc = tag;
    } else {
      continue;
    }

    tags.specificity++;
  }

  return tags;
}

function matchTags(runtime, abi) {
  return function (tags) {
    if (tags == null) return false;
    if (tags.runtime !== runtime && !runtimeAgnostic(tags)) return false;
    if (tags.abi !== abi && !tags.napi) return false;
    if (tags.uv && tags.uv !== uv) return false;
    if (tags.armv && tags.armv !== armv) return false;
    if (tags.libc && tags.libc !== libc) return false;
    return true;
  };
}

function runtimeAgnostic(tags) {
  return tags.runtime === 'node' && tags.napi;
}

function compareTags(runtime) {
  // Precedence: non-agnostic runtime, abi over napi, then by specificity.
  return function (a, b) {
    if (a.runtime !== b.runtime) {
      return a.runtime === runtime ? -1 : 1;
    } else if (a.abi !== b.abi) {
      return a.abi ? -1 : 1;
    } else if (a.specificity !== b.specificity) {
      return a.specificity > b.specificity ? -1 : 1;
    } else {
      return 0;
    }
  };
}

function isElectron() {
  if (process.versions && process.versions.electron) return true;
  if (process.env.ELECTRON_RUN_AS_NODE) return true;
  return typeof window !== 'undefined' && window.process && window.process.type === 'renderer';
}

function isAlpine(platform) {
  return platform === 'linux' && fs.existsSync('/etc/alpine-release');
} // Exposed for unit tests
// TODO: move to lib


load.parseTags = parseTags;
load.matchTags = matchTags;
load.compareTags = compareTags;
load.parseTuple = parseTuple;
load.matchTuple = matchTuple;
load.compareTuples = compareTuples;

/***/ }),

/***/ "./node_modules/object-assign/index.js":
/*!*********************************************!*\
  !*** ./node_modules/object-assign/index.js ***!
  \*********************************************/
/***/ ((module) => {

/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

/* eslint-disable no-unused-vars */

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
  if (val === null || val === undefined) {
    throw new TypeError('Object.assign cannot be called with null or undefined');
  }

  return Object(val);
}

function shouldUseNative() {
  try {
    if (!Object.assign) {
      return false;
    } // Detect buggy property enumeration order in older V8 versions.
    // https://bugs.chromium.org/p/v8/issues/detail?id=4118


    var test1 = new String('abc'); // eslint-disable-line no-new-wrappers

    test1[5] = 'de';

    if (Object.getOwnPropertyNames(test1)[0] === '5') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test2 = {};

    for (var i = 0; i < 10; i++) {
      test2['_' + String.fromCharCode(i)] = i;
    }

    var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
      return test2[n];
    });

    if (order2.join('') !== '0123456789') {
      return false;
    } // https://bugs.chromium.org/p/v8/issues/detail?id=3056


    var test3 = {};
    'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
      test3[letter] = letter;
    });

    if (Object.keys(_extends({}, test3)).join('') !== 'abcdefghijklmnopqrst') {
      return false;
    }

    return true;
  } catch (err) {
    // We don't expect any of the above to throw, but better to be safe.
    return false;
  }
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
  var from;
  var to = toObject(target);
  var symbols;

  for (var s = 1; s < arguments.length; s++) {
    from = Object(arguments[s]);

    for (var key in from) {
      if (hasOwnProperty.call(from, key)) {
        to[key] = from[key];
      }
    }

    if (getOwnPropertySymbols) {
      symbols = getOwnPropertySymbols(from);

      for (var i = 0; i < symbols.length; i++) {
        if (propIsEnumerable.call(from, symbols[i])) {
          to[symbols[i]] = from[symbols[i]];
        }
      }
    }
  }

  return to;
};

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/socket.io-adapter/dist/index.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-adapter/dist/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e2) { throw _e2; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e3) { didErr = true; err = _e3; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Adapter = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var Adapter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Adapter, _events_1$EventEmitte);

  var _super = _createSuper(Adapter);

  /**
   * In-memory adapter constructor.
   *
   * @param {Namespace} nsp
   */
  function Adapter(nsp) {
    var _this;

    _classCallCheck(this, Adapter);

    _this = _super.call(this);
    _this.nsp = nsp;
    _this.rooms = new Map();
    _this.sids = new Map();
    _this.encoder = nsp.server.encoder;
    return _this;
  }
  /**
   * To be overridden
   */


  _createClass(Adapter, [{
    key: "init",
    value: function init() {}
    /**
     * To be overridden
     */

  }, {
    key: "close",
    value: function close() {}
    /**
     * Adds a socket to a list of room.
     *
     * @param {SocketId}  id      the socket id
     * @param {Set<Room>} rooms   a set of rooms
     * @public
     */

  }, {
    key: "addAll",
    value: function addAll(id, rooms) {
      if (!this.sids.has(id)) {
        this.sids.set(id, new Set());
      }

      var _iterator = _createForOfIteratorHelper(rooms),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var room = _step.value;
          this.sids.get(id).add(room);

          if (!this.rooms.has(room)) {
            this.rooms.set(room, new Set());
            this.emit("create-room", room);
          }

          if (!this.rooms.get(room).has(id)) {
            this.rooms.get(room).add(id);
            this.emit("join-room", room, id);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    /**
     * Removes a socket from a room.
     *
     * @param {SocketId} id     the socket id
     * @param {Room}     room   the room name
     */

  }, {
    key: "del",
    value: function del(id, room) {
      if (this.sids.has(id)) {
        this.sids.get(id)["delete"](room);
      }

      this._del(room, id);
    }
  }, {
    key: "_del",
    value: function _del(room, id) {
      var _room = this.rooms.get(room);

      if (_room != null) {
        var deleted = _room["delete"](id);

        if (deleted) {
          this.emit("leave-room", room, id);
        }

        if (_room.size === 0 && this.rooms["delete"](room)) {
          this.emit("delete-room", room);
        }
      }
    }
    /**
     * Removes a socket from all rooms it's joined.
     *
     * @param {SocketId} id   the socket id
     */

  }, {
    key: "delAll",
    value: function delAll(id) {
      if (!this.sids.has(id)) {
        return;
      }

      var _iterator2 = _createForOfIteratorHelper(this.sids.get(id)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var room = _step2.value;

          this._del(room, id);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.sids["delete"](id);
    }
    /**
     * Broadcasts a packet.
     *
     * Options:
     *  - `flags` {Object} flags for this packet
     *  - `except` {Array} sids that should be excluded
     *  - `rooms` {Array} list of rooms to broadcast to
     *
     * @param {Object} packet   the packet object
     * @param {Object} opts     the options
     * @public
     */

  }, {
    key: "broadcast",
    value: function broadcast(packet, opts) {
      var flags = opts.flags || {};
      var packetOpts = {
        preEncoded: true,
        "volatile": flags["volatile"],
        compress: flags.compress
      };
      packet.nsp = this.nsp.name;
      var encodedPackets = this.encoder.encode(packet);
      this.apply(opts, function (socket) {
        socket.client.writeToEngine(encodedPackets, packetOpts);
      });
    }
    /**
     * Gets a list of sockets by sid.
     *
     * @param {Set<Room>} rooms   the explicit set of rooms to check.
     */

  }, {
    key: "sockets",
    value: function sockets(rooms) {
      var sids = new Set();
      this.apply({
        rooms: rooms
      }, function (socket) {
        sids.add(socket.id);
      });
      return Promise.resolve(sids);
    }
    /**
     * Gets the list of rooms a given socket has joined.
     *
     * @param {SocketId} id   the socket id
     */

  }, {
    key: "socketRooms",
    value: function socketRooms(id) {
      return this.sids.get(id);
    }
    /**
     * Returns the matching socket instances
     *
     * @param opts - the filters to apply
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets(opts) {
      var sockets = [];
      this.apply(opts, function (socket) {
        sockets.push(socket);
      });
      return Promise.resolve(sockets);
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to join
     */

  }, {
    key: "addSockets",
    value: function addSockets(opts, rooms) {
      this.apply(opts, function (socket) {
        socket.join(rooms);
      });
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param opts - the filters to apply
     * @param rooms - the rooms to leave
     */

  }, {
    key: "delSockets",
    value: function delSockets(opts, rooms) {
      this.apply(opts, function (socket) {
        rooms.forEach(function (room) {
          return socket.leave(room);
        });
      });
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param opts - the filters to apply
     * @param close - whether to close the underlying connection
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets(opts, close) {
      this.apply(opts, function (socket) {
        socket.disconnect(close);
      });
    }
  }, {
    key: "apply",
    value: function apply(opts, callback) {
      var rooms = opts.rooms;
      var except = this.computeExceptSids(opts.except);

      if (rooms.size) {
        var ids = new Set();

        var _iterator3 = _createForOfIteratorHelper(rooms),
            _step3;

        try {
          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
            var room = _step3.value;
            if (!this.rooms.has(room)) continue;

            var _iterator4 = _createForOfIteratorHelper(this.rooms.get(room)),
                _step4;

            try {
              for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
                var id = _step4.value;
                if (ids.has(id) || except.has(id)) continue;
                var socket = this.nsp.sockets.get(id);

                if (socket) {
                  callback(socket);
                  ids.add(id);
                }
              }
            } catch (err) {
              _iterator4.e(err);
            } finally {
              _iterator4.f();
            }
          }
        } catch (err) {
          _iterator3.e(err);
        } finally {
          _iterator3.f();
        }
      } else {
        var _iterator5 = _createForOfIteratorHelper(this.sids),
            _step5;

        try {
          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {
            var _step5$value = _slicedToArray(_step5.value, 1),
                _id = _step5$value[0];

            if (except.has(_id)) continue;

            var _socket = this.nsp.sockets.get(_id);

            if (_socket) callback(_socket);
          }
        } catch (err) {
          _iterator5.e(err);
        } finally {
          _iterator5.f();
        }
      }
    }
  }, {
    key: "computeExceptSids",
    value: function computeExceptSids(exceptRooms) {
      var exceptSids = new Set();

      if (exceptRooms && exceptRooms.size > 0) {
        var _iterator6 = _createForOfIteratorHelper(exceptRooms),
            _step6;

        try {
          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {
            var room = _step6.value;

            if (this.rooms.has(room)) {
              this.rooms.get(room).forEach(function (sid) {
                return exceptSids.add(sid);
              });
            }
          }
        } catch (err) {
          _iterator6.e(err);
        } finally {
          _iterator6.f();
        }
      }

      return exceptSids;
    }
    /**
     * Send a packet to the other Socket.IO servers in the cluster
     * @param packet - an array of arguments, which may include an acknowledgement callback at the end
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(packet) {
      throw new Error("this adapter does not support the serverSideEmit() functionality");
    }
  }]);

  return Adapter;
}(events_1.EventEmitter);

exports.Adapter = Adapter;

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/binary.js":
/*!******************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/binary.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.reconstructPacket = exports.deconstructPacket = void 0;

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");
/**
 * Replaces every Buffer | ArrayBuffer | Blob | File in packet with a numbered placeholder.
 *
 * @param {Object} packet - socket.io event packet
 * @return {Object} with deconstructed packet and list of buffers
 * @public
 */


function deconstructPacket(packet) {
  var buffers = [];
  var packetData = packet.data;
  var pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length; // number of binary 'attachments'

  return {
    packet: pack,
    buffers: buffers
  };
}

exports.deconstructPacket = deconstructPacket;

function _deconstructPacket(data, buffers) {
  if (!data) return data;

  if (is_binary_1.isBinary(data)) {
    var placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    var newData = new Array(data.length);

    for (var i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }

    return newData;
  } else if (_typeof(data) === "object" && !(data instanceof Date)) {
    var _newData = {};

    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        _newData[key] = _deconstructPacket(data[key], buffers);
      }
    }

    return _newData;
  }

  return data;
}
/**
 * Reconstructs a binary packet from its placeholder packet and buffers
 *
 * @param {Object} packet - event packet with placeholders
 * @param {Array} buffers - binary buffers to put in placeholder positions
 * @return {Object} reconstructed packet
 * @public
 */


function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  packet.attachments = undefined; // no longer useful

  return packet;
}

exports.reconstructPacket = reconstructPacket;

function _reconstructPacket(data, buffers) {
  if (!data) return data;

  if (data && data._placeholder) {
    return buffers[data.num]; // appropriate buffer (should be natural order anyway)
  } else if (Array.isArray(data)) {
    for (var i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (_typeof(data) === "object") {
    for (var key in data) {
      if (data.hasOwnProperty(key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }

  return data;
}

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Decoder = exports.Encoder = exports.PacketType = exports.protocol = void 0;

var Emitter = __webpack_require__(/*! component-emitter */ "./node_modules/component-emitter/index.js");

var binary_1 = __webpack_require__(/*! ./binary */ "./node_modules/socket.io-parser/dist/binary.js");

var is_binary_1 = __webpack_require__(/*! ./is-binary */ "./node_modules/socket.io-parser/dist/is-binary.js");

var debug = __webpack_require__(/*! debug */ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js")("socket.io-parser");
/**
 * Protocol version.
 *
 * @public
 */


exports.protocol = 5;
var PacketType;

(function (PacketType) {
  PacketType[PacketType["CONNECT"] = 0] = "CONNECT";
  PacketType[PacketType["DISCONNECT"] = 1] = "DISCONNECT";
  PacketType[PacketType["EVENT"] = 2] = "EVENT";
  PacketType[PacketType["ACK"] = 3] = "ACK";
  PacketType[PacketType["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
  PacketType[PacketType["BINARY_EVENT"] = 5] = "BINARY_EVENT";
  PacketType[PacketType["BINARY_ACK"] = 6] = "BINARY_ACK";
})(PacketType = exports.PacketType || (exports.PacketType = {}));
/**
 * A socket.io Encoder instance
 */


var Encoder = /*#__PURE__*/function () {
  function Encoder() {
    _classCallCheck(this, Encoder);
  }

  _createClass(Encoder, [{
    key: "encode",
    value:
    /**
     * Encode a packet as a single string if non-binary, or as a
     * buffer sequence, depending on packet type.
     *
     * @param {Object} obj - packet object
     */
    function encode(obj) {
      debug("encoding packet %j", obj);

      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }

      return [this.encodeAsString(obj)];
    }
    /**
     * Encode packet as string.
     */

  }, {
    key: "encodeAsString",
    value: function encodeAsString(obj) {
      // first is type
      var str = "" + obj.type; // attachments if we have them

      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      } // if we have a namespace other than `/`
      // we append it followed by a comma `,`


      if (obj.nsp && "/" !== obj.nsp) {
        str += obj.nsp + ",";
      } // immediately followed by the id


      if (null != obj.id) {
        str += obj.id;
      } // json data


      if (null != obj.data) {
        str += JSON.stringify(obj.data);
      }

      debug("encoded %j as %s", obj, str);
      return str;
    }
    /**
     * Encode packet as 'buffer sequence' by removing blobs, and
     * deconstructing packet into object with placeholders and
     * a list of buffers.
     */

  }, {
    key: "encodeAsBinary",
    value: function encodeAsBinary(obj) {
      var deconstruction = binary_1.deconstructPacket(obj);
      var pack = this.encodeAsString(deconstruction.packet);
      var buffers = deconstruction.buffers;
      buffers.unshift(pack); // add packet info to beginning of data list

      return buffers; // write all the buffers
    }
  }]);

  return Encoder;
}();

exports.Encoder = Encoder;
/**
 * A socket.io Decoder instance
 *
 * @return {Object} decoder
 */

var Decoder = /*#__PURE__*/function (_Emitter) {
  _inherits(Decoder, _Emitter);

  var _super = _createSuper(Decoder);

  function Decoder() {
    _classCallCheck(this, Decoder);

    return _super.call(this);
  }
  /**
   * Decodes an encoded packet string into packet JSON.
   *
   * @param {String} obj - encoded packet
   */


  _createClass(Decoder, [{
    key: "add",
    value: function add(obj) {
      var packet;

      if (typeof obj === "string") {
        packet = this.decodeString(obj);

        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          // binary packet's json
          this.reconstructor = new BinaryReconstructor(packet); // no attachments, labeled binary but no binary data to follow

          if (packet.attachments === 0) {
            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        } else {
          // non-binary full packet
          _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        // raw binary data
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);

          if (packet) {
            // received final buffer
            this.reconstructor = null;

            _get(_getPrototypeOf(Decoder.prototype), "emit", this).call(this, "decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    /**
     * Decode a packet String (JSON data)
     *
     * @param {String} str
     * @return {Object} packet
     */

  }, {
    key: "decodeString",
    value: function decodeString(str) {
      var i = 0; // look up type

      var p = {
        type: Number(str.charAt(0))
      };

      if (PacketType[p.type] === undefined) {
        throw new Error("unknown packet type " + p.type);
      } // look up attachments if type binary


      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        var start = i + 1;

        while (str.charAt(++i) !== "-" && i != str.length) {}

        var buf = str.substring(start, i);

        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }

        p.attachments = Number(buf);
      } // look up namespace (if any)


      if ("/" === str.charAt(i + 1)) {
        var _start = i + 1;

        while (++i) {
          var c = str.charAt(i);
          if ("," === c) break;
          if (i === str.length) break;
        }

        p.nsp = str.substring(_start, i);
      } else {
        p.nsp = "/";
      } // look up id


      var next = str.charAt(i + 1);

      if ("" !== next && Number(next) == next) {
        var _start2 = i + 1;

        while (++i) {
          var _c = str.charAt(i);

          if (null == _c || Number(_c) != _c) {
            --i;
            break;
          }

          if (i === str.length) break;
        }

        p.id = Number(str.substring(_start2, i + 1));
      } // look up json data


      if (str.charAt(++i)) {
        var payload = tryParse(str.substr(i));

        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }

      debug("decoded %s as %j", str, p);
      return p;
    }
  }, {
    key: "destroy",
    value:
    /**
     * Deallocates a parser's resources
     */
    function destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  }], [{
    key: "isPayloadValid",
    value: function isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return _typeof(payload) === "object";

        case PacketType.DISCONNECT:
          return payload === undefined;

        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || _typeof(payload) === "object";

        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;

        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
  }]);

  return Decoder;
}(Emitter);

exports.Decoder = Decoder;

function tryParse(str) {
  try {
    return JSON.parse(str);
  } catch (e) {
    return false;
  }
}
/**
 * A manager of a binary event's 'buffer sequence'. Should
 * be constructed whenever a packet of type BINARY_EVENT is
 * decoded.
 *
 * @param {Object} packet
 * @return {BinaryReconstructor} initialized reconstructor
 */


var BinaryReconstructor = /*#__PURE__*/function () {
  function BinaryReconstructor(packet) {
    _classCallCheck(this, BinaryReconstructor);

    this.packet = packet;
    this.buffers = [];
    this.reconPack = packet;
  }
  /**
   * Method to be called when binary data received from connection
   * after a BINARY_EVENT packet.
   *
   * @param {Buffer | ArrayBuffer} binData - the raw binary data received
   * @return {null | Object} returns null if more binary data is expected or
   *   a reconstructed packet object if all buffers have been received.
   */


  _createClass(BinaryReconstructor, [{
    key: "takeBinaryData",
    value: function takeBinaryData(binData) {
      this.buffers.push(binData);

      if (this.buffers.length === this.reconPack.attachments) {
        // done with buffer list
        var packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }

      return null;
    }
    /**
     * Cleans up binary packet reconstruction variables.
     */

  }, {
    key: "finishedReconstruction",
    value: function finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  }]);

  return BinaryReconstructor;
}();

/***/ }),

/***/ "./node_modules/socket.io-parser/dist/is-binary.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io-parser/dist/is-binary.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.hasBinary = exports.isBinary = void 0;
var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
};

var toString = Object.prototype.toString;
var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
/**
 * Returns true if obj is a Buffer, an ArrayBuffer, a Blob or a File.
 *
 * @private
 */

function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}

exports.isBinary = isBinary;

function hasBinary(obj, toJSON) {
  if (!obj || _typeof(obj) !== "object") {
    return false;
  }

  if (Array.isArray(obj)) {
    for (var i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }

    return false;
  }

  if (isBinary(obj)) {
    return true;
  }

  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }

  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }

  return false;
}

exports.hasBinary = hasBinary;

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/browser.js ***!
  \*************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/socket.io-parser/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/debug/src/common.js":
/*!************************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/debug/src/common.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io-parser/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/socket.io-parser/node_modules/ms/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/socket.io-parser/node_modules/ms/index.js ***!
  \****************************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/socket.io/node_modules/debug/src/browser.js":
/*!******************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/browser.js ***!
  \******************************************************************/
/***/ ((module, exports, __webpack_require__) => {

/* eslint-env browser */

/**
 * This is the web browser implementation of `debug()`.
 */
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();

exports.destroy = function () {
  var warned = false;
  return function () {
    if (!warned) {
      warned = true;
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  };
}();
/**
 * Colors.
 */


exports.colors = ['#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC', '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF', '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC', '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF', '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC', '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033', '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366', '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933', '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC', '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF', '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'];
/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */
// eslint-disable-next-line complexity

function useColors() {
  // NB: In an Electron preload script, document will be defined but not fully
  // initialized. Since we know we're in Chrome, we'll just detect this case
  // explicitly
  if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
    return true;
  } // Internet Explorer and Edge do not support colors.


  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
    return false;
  } // Is webkit? http://stackoverflow.com/a/16459606/376773
  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632


  return typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
  typeof window !== 'undefined' && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
  // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
  typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
}
/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */


function formatArgs(args) {
  args[0] = (this.useColors ? '%c' : '') + this.namespace + (this.useColors ? ' %c' : ' ') + args[0] + (this.useColors ? '%c ' : ' ') + '+' + module.exports.humanize(this.diff);

  if (!this.useColors) {
    return;
  }

  var c = 'color: ' + this.color;
  args.splice(1, 0, c, 'color: inherit'); // The final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into

  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-zA-Z%]/g, function (match) {
    if (match === '%%') {
      return;
    }

    index++;

    if (match === '%c') {
      // We only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });
  args.splice(lastC, 0, c);
}
/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */


exports.log = console.debug || console.log || function () {};
/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */


function save(namespaces) {
  try {
    if (namespaces) {
      exports.storage.setItem('debug', namespaces);
    } else {
      exports.storage.removeItem('debug');
    }
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}
/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */


function load() {
  var r;

  try {
    r = exports.storage.getItem('debug');
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  } // If debug isn't set in LS, and we're in Electron, try to load $DEBUG


  if (!r && typeof process !== 'undefined' && 'env' in process) {
    r = process.env.DEBUG;
  }

  return r;
}
/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */


function localstorage() {
  try {
    // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
    // The Browser also has localStorage in the global context.
    return localStorage;
  } catch (error) {// Swallow
    // XXX (@Qix-) should we be logging these?
  }
}

module.exports = __webpack_require__(/*! ./common */ "./node_modules/socket.io/node_modules/debug/src/common.js")(exports);
var formatters = module.exports.formatters;
/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
  try {
    return JSON.stringify(v);
  } catch (error) {
    return '[UnexpectedJSONParseError]: ' + error.message;
  }
};

/***/ }),

/***/ "./node_modules/socket.io/node_modules/debug/src/common.js":
/*!*****************************************************************!*\
  !*** ./node_modules/socket.io/node_modules/debug/src/common.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */
function setup(env) {
  createDebug.debug = createDebug;
  createDebug["default"] = createDebug;
  createDebug.coerce = coerce;
  createDebug.disable = disable;
  createDebug.enable = enable;
  createDebug.enabled = enabled;
  createDebug.humanize = __webpack_require__(/*! ms */ "./node_modules/socket.io/node_modules/ms/index.js");
  createDebug.destroy = destroy;
  Object.keys(env).forEach(function (key) {
    createDebug[key] = env[key];
  });
  /**
  * The currently active debug mode names, and names to skip.
  */

  createDebug.names = [];
  createDebug.skips = [];
  /**
  * Map of special "%n" handling functions, for the debug "format" argument.
  *
  * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
  */

  createDebug.formatters = {};
  /**
  * Selects a color for a debug namespace
  * @param {String} namespace The namespace string for the debug instance to be colored
  * @return {Number|String} An ANSI color code for the given namespace
  * @api private
  */

  function selectColor(namespace) {
    var hash = 0;

    for (var i = 0; i < namespace.length; i++) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i);
      hash |= 0; // Convert to 32bit integer
    }

    return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
  }

  createDebug.selectColor = selectColor;
  /**
  * Create a debugger with the given `namespace`.
  *
  * @param {String} namespace
  * @return {Function}
  * @api public
  */

  function createDebug(namespace) {
    var prevTime;
    var enableOverride = null;
    var namespacesCache;
    var enabledCache;

    function debug() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      // Disabled?
      if (!debug.enabled) {
        return;
      }

      var self = debug; // Set `diff` timestamp

      var curr = Number(new Date());
      var ms = curr - (prevTime || curr);
      self.diff = ms;
      self.prev = prevTime;
      self.curr = curr;
      prevTime = curr;
      args[0] = createDebug.coerce(args[0]);

      if (typeof args[0] !== 'string') {
        // Anything else let's inspect with %O
        args.unshift('%O');
      } // Apply any `formatters` transformations


      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function (match, format) {
        // If we encounter an escaped % then don't increase the array index
        if (match === '%%') {
          return '%';
        }

        index++;
        var formatter = createDebug.formatters[format];

        if (typeof formatter === 'function') {
          var val = args[index];
          match = formatter.call(self, val); // Now we need to remove `args[index]` since it's inlined in the `format`

          args.splice(index, 1);
          index--;
        }

        return match;
      }); // Apply env-specific formatting (colors, etc.)

      createDebug.formatArgs.call(self, args);
      var logFn = self.log || createDebug.log;
      logFn.apply(self, args);
    }

    debug.namespace = namespace;
    debug.useColors = createDebug.useColors();
    debug.color = createDebug.selectColor(namespace);
    debug.extend = extend;
    debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

    Object.defineProperty(debug, 'enabled', {
      enumerable: true,
      configurable: false,
      get: function get() {
        if (enableOverride !== null) {
          return enableOverride;
        }

        if (namespacesCache !== createDebug.namespaces) {
          namespacesCache = createDebug.namespaces;
          enabledCache = createDebug.enabled(namespace);
        }

        return enabledCache;
      },
      set: function set(v) {
        enableOverride = v;
      }
    }); // Env-specific initialization logic for debug instances

    if (typeof createDebug.init === 'function') {
      createDebug.init(debug);
    }

    return debug;
  }

  function extend(namespace, delimiter) {
    var newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
    newDebug.log = this.log;
    return newDebug;
  }
  /**
  * Enables a debug mode by namespaces. This can include modes
  * separated by a colon and wildcards.
  *
  * @param {String} namespaces
  * @api public
  */


  function enable(namespaces) {
    createDebug.save(namespaces);
    createDebug.namespaces = namespaces;
    createDebug.names = [];
    createDebug.skips = [];
    var i;
    var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
    var len = split.length;

    for (i = 0; i < len; i++) {
      if (!split[i]) {
        // ignore empty strings
        continue;
      }

      namespaces = split[i].replace(/\*/g, '.*?');

      if (namespaces[0] === '-') {
        createDebug.skips.push(new RegExp('^' + namespaces.slice(1) + '$'));
      } else {
        createDebug.names.push(new RegExp('^' + namespaces + '$'));
      }
    }
  }
  /**
  * Disable debug output.
  *
  * @return {String} namespaces
  * @api public
  */


  function disable() {
    var namespaces = [].concat(_toConsumableArray(createDebug.names.map(toNamespace)), _toConsumableArray(createDebug.skips.map(toNamespace).map(function (namespace) {
      return '-' + namespace;
    }))).join(',');
    createDebug.enable('');
    return namespaces;
  }
  /**
  * Returns true if the given mode name is enabled, false otherwise.
  *
  * @param {String} name
  * @return {Boolean}
  * @api public
  */


  function enabled(name) {
    if (name[name.length - 1] === '*') {
      return true;
    }

    var i;
    var len;

    for (i = 0, len = createDebug.skips.length; i < len; i++) {
      if (createDebug.skips[i].test(name)) {
        return false;
      }
    }

    for (i = 0, len = createDebug.names.length; i < len; i++) {
      if (createDebug.names[i].test(name)) {
        return true;
      }
    }

    return false;
  }
  /**
  * Convert regexp to namespace
  *
  * @param {RegExp} regxep
  * @return {String} namespace
  * @api private
  */


  function toNamespace(regexp) {
    return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, '*');
  }
  /**
  * Coerce `val`.
  *
  * @param {Mixed} val
  * @return {Mixed}
  * @api private
  */


  function coerce(val) {
    if (val instanceof Error) {
      return val.stack || val.message;
    }

    return val;
  }
  /**
  * XXX DO NOT USE. This is a temporary stub function.
  * XXX It WILL be removed in the next major release.
  */


  function destroy() {
    console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
  }

  createDebug.enable(createDebug.load());
  return createDebug;
}

module.exports = setup;

/***/ }),

/***/ "./node_modules/socket.io/node_modules/ms/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/node_modules/ms/index.js ***!
  \*********************************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;
/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

module.exports = function (val, options) {
  options = options || {};

  var type = _typeof(val);

  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options["long"] ? fmtLong(val) : fmtShort(val);
  }

  throw new Error('val is not a non-empty string or a valid number. val=' + JSON.stringify(val));
};
/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */


function parse(str) {
  str = String(str);

  if (str.length > 100) {
    return;
  }

  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);

  if (!match) {
    return;
  }

  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();

  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;

    case 'weeks':
    case 'week':
    case 'w':
      return n * w;

    case 'days':
    case 'day':
    case 'd':
      return n * d;

    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;

    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;

    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;

    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;

    default:
      return undefined;
  }
}
/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtShort(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }

  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }

  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }

  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }

  return ms + 'ms';
}
/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */


function fmtLong(ms) {
  var msAbs = Math.abs(ms);

  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }

  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }

  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }

  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }

  return ms + ' ms';
}
/**
 * Pluralization helper.
 */


function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  var freeModule = ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
  var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if ( true && _typeof(__webpack_require__.amdO) == 'object' && __webpack_require__.amdO) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (freeExports && freeModule) {
    if (module.exports == freeExports) {
      // in Node.js or RingoJS v0.8.0+
      freeModule.exports = punycode;
    } else {
      // in Narwhal or RingoJS v0.7.0-
      for (key in punycode) {
        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
      }
    }
  } else {
    // in Rhino or a web browser
    root.punycode = punycode;
  }
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + _typeof(url));
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return _typeof(arg) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/utf-8-validate/fallback.js":
/*!*************************************************!*\
  !*** ./node_modules/utf-8-validate/fallback.js ***!
  \*************************************************/
/***/ ((module) => {


/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */

function isValidUTF8(buf) {
  var len = buf.length;
  var i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0x00) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // overlong
      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // overlong
      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

module.exports = isValidUTF8;

/***/ }),

/***/ "./node_modules/utf-8-validate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/utf-8-validate/index.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var __dirname = "/";


try {
  module.exports = __webpack_require__(/*! node-gyp-build */ "./node_modules/node-gyp-build/index.js")(__dirname);
} catch (e) {
  module.exports = __webpack_require__(/*! ./fallback */ "./node_modules/utf-8-validate/fallback.js");
}

/***/ }),

/***/ "./node_modules/vary/index.js":
/*!************************************!*\
  !*** ./node_modules/vary/index.js ***!
  \************************************/
/***/ ((module) => {

/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */

/**
 * Module exports.
 */

module.exports = vary;
module.exports.append = append;
/**
 * RegExp to match field-name in RFC 7230 sec 3.2
 *
 * field-name    = token
 * token         = 1*tchar
 * tchar         = "!" / "#" / "$" / "%" / "&" / "'" / "*"
 *               / "+" / "-" / "." / "^" / "_" / "`" / "|" / "~"
 *               / DIGIT / ALPHA
 *               ; any VCHAR, except delimiters
 */

var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
/**
 * Append a field to a vary header.
 *
 * @param {String} header
 * @param {String|Array} field
 * @return {String}
 * @public
 */

function append(header, field) {
  if (typeof header !== 'string') {
    throw new TypeError('header argument is required');
  }

  if (!field) {
    throw new TypeError('field argument is required');
  } // get fields array


  var fields = !Array.isArray(field) ? parse(String(field)) : field; // assert on invalid field names

  for (var j = 0; j < fields.length; j++) {
    if (!FIELD_NAME_REGEXP.test(fields[j])) {
      throw new TypeError('field argument contains an invalid header name');
    }
  } // existing, unspecified vary


  if (header === '*') {
    return header;
  } // enumerate current values


  var val = header;
  var vals = parse(header.toLowerCase()); // unspecified vary

  if (fields.indexOf('*') !== -1 || vals.indexOf('*') !== -1) {
    return '*';
  }

  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase(); // append value (case-preserving)

    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ', ' + fields[i] : fields[i];
    }
  }

  return val;
}
/**
 * Parse a vary header into an array.
 *
 * @param {String} header
 * @return {Array}
 * @private
 */


function parse(header) {
  var end = 0;
  var list = [];
  var start = 0; // gather tokens

  for (var i = 0, len = header.length; i < len; i++) {
    switch (header.charCodeAt(i)) {
      case 0x20:
        /*   */
        if (start === end) {
          start = end = i + 1;
        }

        break;

      case 0x2c:
        /* , */
        list.push(header.substring(start, end));
        start = end = i + 1;
        break;

      default:
        end = i + 1;
        break;
    }
  } // final token


  list.push(header.substring(start, end));
  return list;
}
/**
 * Mark that a request is varied on a header field.
 *
 * @param {Object} res
 * @param {String|Array} field
 * @public
 */


function vary(res, field) {
  if (!res || !res.getHeader || !res.setHeader) {
    // quack quack
    throw new TypeError('res argument is required');
  } // get existing header


  var val = res.getHeader('Vary') || '';
  var header = Array.isArray(val) ? val.join(', ') : String(val); // set new header

  if (val = append(header, field)) {
    res.setHeader('Vary', val);
  }
}

/***/ }),

/***/ "./node_modules/ws/index.js":
/*!**********************************!*\
  !*** ./node_modules/ws/index.js ***!
  \**********************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var WebSocket = __webpack_require__(/*! ./lib/websocket */ "./node_modules/ws/lib/websocket.js");

WebSocket.createWebSocketStream = __webpack_require__(/*! ./lib/stream */ "./node_modules/ws/lib/stream.js");
WebSocket.Server = __webpack_require__(/*! ./lib/websocket-server */ "./node_modules/ws/lib/websocket-server.js");
WebSocket.Receiver = __webpack_require__(/*! ./lib/receiver */ "./node_modules/ws/lib/receiver.js");
WebSocket.Sender = __webpack_require__(/*! ./lib/sender */ "./node_modules/ws/lib/sender.js");
WebSocket.WebSocket = WebSocket;
WebSocket.WebSocketServer = WebSocket.Server;
module.exports = WebSocket;

/***/ }),

/***/ "./node_modules/ws/lib/buffer-util.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/buffer-util.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    EMPTY_BUFFER = _require.EMPTY_BUFFER;
/**
 * Merges an array of buffers into a new buffer.
 *
 * @param {Buffer[]} list The array of buffers to concat
 * @param {Number} totalLength The total length of buffers in the list
 * @return {Buffer} The resulting buffer
 * @public
 */


function concat(list, totalLength) {
  if (list.length === 0) return EMPTY_BUFFER;
  if (list.length === 1) return list[0];
  var target = Buffer.allocUnsafe(totalLength);
  var offset = 0;

  for (var i = 0; i < list.length; i++) {
    var buf = list[i];
    target.set(buf, offset);
    offset += buf.length;
  }

  if (offset < totalLength) return target.slice(0, offset);
  return target;
}
/**
 * Masks a buffer using the given mask.
 *
 * @param {Buffer} source The buffer to mask
 * @param {Buffer} mask The mask to use
 * @param {Buffer} output The buffer where to store the result
 * @param {Number} offset The offset at which to start writing
 * @param {Number} length The number of bytes to mask.
 * @public
 */


function _mask(source, mask, output, offset, length) {
  for (var i = 0; i < length; i++) {
    output[offset + i] = source[i] ^ mask[i & 3];
  }
}
/**
 * Unmasks a buffer using the given mask.
 *
 * @param {Buffer} buffer The buffer to unmask
 * @param {Buffer} mask The mask to use
 * @public
 */


function _unmask(buffer, mask) {
  for (var i = 0; i < buffer.length; i++) {
    buffer[i] ^= mask[i & 3];
  }
}
/**
 * Converts a buffer to an `ArrayBuffer`.
 *
 * @param {Buffer} buf The buffer to convert
 * @return {ArrayBuffer} Converted buffer
 * @public
 */


function toArrayBuffer(buf) {
  if (buf.byteLength === buf.buffer.byteLength) {
    return buf.buffer;
  }

  return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength);
}
/**
 * Converts `data` to a `Buffer`.
 *
 * @param {*} data The data to convert
 * @return {Buffer} The buffer
 * @throws {TypeError}
 * @public
 */


function toBuffer(data) {
  toBuffer.readOnly = true;
  if (Buffer.isBuffer(data)) return data;
  var buf;

  if (data instanceof ArrayBuffer) {
    buf = Buffer.from(data);
  } else if (ArrayBuffer.isView(data)) {
    buf = Buffer.from(data.buffer, data.byteOffset, data.byteLength);
  } else {
    buf = Buffer.from(data);
    toBuffer.readOnly = false;
  }

  return buf;
}

try {
  var bufferUtil = __webpack_require__(/*! bufferutil */ "./node_modules/bufferutil/index.js");

  module.exports = {
    concat: concat,
    mask: function mask(source, _mask2, output, offset, length) {
      if (length < 48) _mask(source, _mask2, output, offset, length);else bufferUtil.mask(source, _mask2, output, offset, length);
    },
    toArrayBuffer: toArrayBuffer,
    toBuffer: toBuffer,
    unmask: function unmask(buffer, mask) {
      if (buffer.length < 32) _unmask(buffer, mask);else bufferUtil.unmask(buffer, mask);
    }
  };
} catch (e)
/* istanbul ignore next */
{
  module.exports = {
    concat: concat,
    mask: _mask,
    toArrayBuffer: toArrayBuffer,
    toBuffer: toBuffer,
    unmask: _unmask
  };
}

/***/ }),

/***/ "./node_modules/ws/lib/constants.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/constants.js ***!
  \******************************************/
/***/ ((module) => {



module.exports = {
  BINARY_TYPES: ['nodebuffer', 'arraybuffer', 'fragments'],
  EMPTY_BUFFER: Buffer.alloc(0),
  GUID: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11',
  kForOnEventAttribute: Symbol('kIsForOnEventAttribute'),
  kListener: Symbol('kListener'),
  kStatusCode: Symbol('status-code'),
  kWebSocket: Symbol('websocket'),
  NOOP: function NOOP() {}
};

/***/ }),

/***/ "./node_modules/ws/lib/event-target.js":
/*!*********************************************!*\
  !*** ./node_modules/ws/lib/event-target.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    kForOnEventAttribute = _require.kForOnEventAttribute,
    kListener = _require.kListener;

var kCode = Symbol('kCode');
var kData = Symbol('kData');
var kError = Symbol('kError');
var kMessage = Symbol('kMessage');
var kReason = Symbol('kReason');
var kTarget = Symbol('kTarget');
var kType = Symbol('kType');
var kWasClean = Symbol('kWasClean');
/**
 * Class representing an event.
 */

var Event = /*#__PURE__*/function () {
  /**
   * Create a new `Event`.
   *
   * @param {String} type The name of the event
   * @throws {TypeError} If the `type` argument is not specified
   */
  function Event(type) {
    _classCallCheck(this, Event);

    this[kTarget] = null;
    this[kType] = type;
  }
  /**
   * @type {*}
   */


  _createClass(Event, [{
    key: "target",
    get: function get() {
      return this[kTarget];
    }
    /**
     * @type {String}
     */

  }, {
    key: "type",
    get: function get() {
      return this[kType];
    }
  }]);

  return Event;
}();

Object.defineProperty(Event.prototype, 'target', {
  enumerable: true
});
Object.defineProperty(Event.prototype, 'type', {
  enumerable: true
});
/**
 * Class representing a close event.
 *
 * @extends Event
 */

var CloseEvent = /*#__PURE__*/function (_Event) {
  _inherits(CloseEvent, _Event);

  var _super = _createSuper(CloseEvent);

  /**
   * Create a new `CloseEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {Number} [options.code=0] The status code explaining why the
   *     connection was closed
   * @param {String} [options.reason=''] A human-readable string explaining why
   *     the connection was closed
   * @param {Boolean} [options.wasClean=false] Indicates whether or not the
   *     connection was cleanly closed
   */
  function CloseEvent(type) {
    var _this;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, CloseEvent);

    _this = _super.call(this, type);
    _this[kCode] = options.code === undefined ? 0 : options.code;
    _this[kReason] = options.reason === undefined ? '' : options.reason;
    _this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;
    return _this;
  }
  /**
   * @type {Number}
   */


  _createClass(CloseEvent, [{
    key: "code",
    get: function get() {
      return this[kCode];
    }
    /**
     * @type {String}
     */

  }, {
    key: "reason",
    get: function get() {
      return this[kReason];
    }
    /**
     * @type {Boolean}
     */

  }, {
    key: "wasClean",
    get: function get() {
      return this[kWasClean];
    }
  }]);

  return CloseEvent;
}(Event);

Object.defineProperty(CloseEvent.prototype, 'code', {
  enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'reason', {
  enumerable: true
});
Object.defineProperty(CloseEvent.prototype, 'wasClean', {
  enumerable: true
});
/**
 * Class representing an error event.
 *
 * @extends Event
 */

var ErrorEvent = /*#__PURE__*/function (_Event2) {
  _inherits(ErrorEvent, _Event2);

  var _super2 = _createSuper(ErrorEvent);

  /**
   * Create a new `ErrorEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.error=null] The error that generated this event
   * @param {String} [options.message=''] The error message
   */
  function ErrorEvent(type) {
    var _this2;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, ErrorEvent);

    _this2 = _super2.call(this, type);
    _this2[kError] = options.error === undefined ? null : options.error;
    _this2[kMessage] = options.message === undefined ? '' : options.message;
    return _this2;
  }
  /**
   * @type {*}
   */


  _createClass(ErrorEvent, [{
    key: "error",
    get: function get() {
      return this[kError];
    }
    /**
     * @type {String}
     */

  }, {
    key: "message",
    get: function get() {
      return this[kMessage];
    }
  }]);

  return ErrorEvent;
}(Event);

Object.defineProperty(ErrorEvent.prototype, 'error', {
  enumerable: true
});
Object.defineProperty(ErrorEvent.prototype, 'message', {
  enumerable: true
});
/**
 * Class representing a message event.
 *
 * @extends Event
 */

var MessageEvent = /*#__PURE__*/function (_Event3) {
  _inherits(MessageEvent, _Event3);

  var _super3 = _createSuper(MessageEvent);

  /**
   * Create a new `MessageEvent`.
   *
   * @param {String} type The name of the event
   * @param {Object} [options] A dictionary object that allows for setting
   *     attributes via object members of the same name
   * @param {*} [options.data=null] The message content
   */
  function MessageEvent(type) {
    var _this3;

    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, MessageEvent);

    _this3 = _super3.call(this, type);
    _this3[kData] = options.data === undefined ? null : options.data;
    return _this3;
  }
  /**
   * @type {*}
   */


  _createClass(MessageEvent, [{
    key: "data",
    get: function get() {
      return this[kData];
    }
  }]);

  return MessageEvent;
}(Event);

Object.defineProperty(MessageEvent.prototype, 'data', {
  enumerable: true
});
/**
 * This provides methods for emulating the `EventTarget` interface. It's not
 * meant to be used directly.
 *
 * @mixin
 */

var EventTarget = {
  /**
   * Register an event listener.
   *
   * @param {String} type A string representing the event type to listen for
   * @param {Function} listener The listener to add
   * @param {Object} [options] An options object specifies characteristics about
   *     the event listener
   * @param {Boolean} [options.once=false] A `Boolean` indicating that the
   *     listener should be invoked at most once after being added. If `true`,
   *     the listener would be automatically removed when invoked.
   * @public
   */
  addEventListener: function addEventListener(type, listener) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var wrapper;

    if (type === 'message') {
      wrapper = function onMessage(data, isBinary) {
        var event = new MessageEvent('message', {
          data: isBinary ? data : data.toString()
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'close') {
      wrapper = function onClose(code, message) {
        var event = new CloseEvent('close', {
          code: code,
          reason: message.toString(),
          wasClean: this._closeFrameReceived && this._closeFrameSent
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'error') {
      wrapper = function onError(error) {
        var event = new ErrorEvent('error', {
          error: error,
          message: error.message
        });
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else if (type === 'open') {
      wrapper = function onOpen() {
        var event = new Event('open');
        event[kTarget] = this;
        listener.call(this, event);
      };
    } else {
      return;
    }

    wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
    wrapper[kListener] = listener;

    if (options.once) {
      this.once(type, wrapper);
    } else {
      this.on(type, wrapper);
    }
  },

  /**
   * Remove an event listener.
   *
   * @param {String} type A string representing the event type to remove
   * @param {Function} handler The listener to remove
   * @public
   */
  removeEventListener: function removeEventListener(type, handler) {
    var _iterator = _createForOfIteratorHelper(this.listeners(type)),
        _step;

    try {
      for (_iterator.s(); !(_step = _iterator.n()).done;) {
        var listener = _step.value;

        if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
          this.removeListener(type, listener);
          break;
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
};
module.exports = {
  CloseEvent: CloseEvent,
  ErrorEvent: ErrorEvent,
  Event: Event,
  EventTarget: EventTarget,
  MessageEvent: MessageEvent
};

/***/ }),

/***/ "./node_modules/ws/lib/extension.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/extension.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    tokenChars = _require.tokenChars;
/**
 * Adds an offer to the map of extension offers or a parameter to the map of
 * parameters.
 *
 * @param {Object} dest The map of extension offers or parameters
 * @param {String} name The extension or parameter name
 * @param {(Object|Boolean|String)} elem The extension parameters or the
 *     parameter value
 * @private
 */


function push(dest, name, elem) {
  if (dest[name] === undefined) dest[name] = [elem];else dest[name].push(elem);
}
/**
 * Parses the `Sec-WebSocket-Extensions` header into an object.
 *
 * @param {String} header The field value of the header
 * @return {Object} The parsed object
 * @public
 */


function parse(header) {
  var offers = Object.create(null);
  var params = Object.create(null);
  var mustUnescape = false;
  var isEscaping = false;
  var inQuotes = false;
  var extensionName;
  var paramName;
  var start = -1;
  var code = -1;
  var end = -1;
  var i = 0;

  for (; i < header.length; i++) {
    code = header.charCodeAt(i);

    if (extensionName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (i !== 0 && (code === 0x20
      /* ' ' */
      || code === 0x09)
      /* '\t' */
      ) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b
      /* ';' */
      || code === 0x2c
      /* ',' */
      ) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        var name = header.slice(start, end);

        if (code === 0x2c) {
          push(offers, name, params);
          params = Object.create(null);
        } else {
          extensionName = name;
        }

        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    } else if (paramName === undefined) {
      if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (code === 0x20 || code === 0x09) {
        if (end === -1 && start !== -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        push(params, header.slice(start, end), true);

        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        start = end = -1;
      } else if (code === 0x3d
      /* '=' */
      && start !== -1 && end === -1) {
        paramName = header.slice(start, i);
        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    } else {
      //
      // The value of a quoted-string after unescaping must conform to the
      // token ABNF, so only token characters are valid.
      // Ref: https://tools.ietf.org/html/rfc6455#section-9.1
      //
      if (isEscaping) {
        if (tokenChars[code] !== 1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (start === -1) start = i;else if (!mustUnescape) mustUnescape = true;
        isEscaping = false;
      } else if (inQuotes) {
        if (tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (code === 0x22
        /* '"' */
        && start !== -1) {
          inQuotes = false;
          end = i;
        } else if (code === 0x5c
        /* '\' */
        ) {
          isEscaping = true;
        } else {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }
      } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {
        inQuotes = true;
      } else if (end === -1 && tokenChars[code] === 1) {
        if (start === -1) start = i;
      } else if (start !== -1 && (code === 0x20 || code === 0x09)) {
        if (end === -1) end = i;
      } else if (code === 0x3b || code === 0x2c) {
        if (start === -1) {
          throw new SyntaxError("Unexpected character at index ".concat(i));
        }

        if (end === -1) end = i;
        var value = header.slice(start, end);

        if (mustUnescape) {
          value = value.replace(/\\/g, '');
          mustUnescape = false;
        }

        push(params, paramName, value);

        if (code === 0x2c) {
          push(offers, extensionName, params);
          params = Object.create(null);
          extensionName = undefined;
        }

        paramName = undefined;
        start = end = -1;
      } else {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }
    }
  }

  if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {
    throw new SyntaxError('Unexpected end of input');
  }

  if (end === -1) end = i;
  var token = header.slice(start, end);

  if (extensionName === undefined) {
    push(offers, token, params);
  } else {
    if (paramName === undefined) {
      push(params, token, true);
    } else if (mustUnescape) {
      push(params, paramName, token.replace(/\\/g, ''));
    } else {
      push(params, paramName, token);
    }

    push(offers, extensionName, params);
  }

  return offers;
}
/**
 * Builds the `Sec-WebSocket-Extensions` header field value.
 *
 * @param {Object} extensions The map of extensions and parameters to format
 * @return {String} A string representing the given object
 * @public
 */


function format(extensions) {
  return Object.keys(extensions).map(function (extension) {
    var configurations = extensions[extension];
    if (!Array.isArray(configurations)) configurations = [configurations];
    return configurations.map(function (params) {
      return [extension].concat(Object.keys(params).map(function (k) {
        var values = params[k];
        if (!Array.isArray(values)) values = [values];
        return values.map(function (v) {
          return v === true ? k : "".concat(k, "=").concat(v);
        }).join('; ');
      })).join('; ');
    }).join(', ');
  }).join(', ');
}

module.exports = {
  format: format,
  parse: parse
};

/***/ }),

/***/ "./node_modules/ws/lib/limiter.js":
/*!****************************************!*\
  !*** ./node_modules/ws/lib/limiter.js ***!
  \****************************************/
/***/ ((module) => {



function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var kDone = Symbol('kDone');
var kRun = Symbol('kRun');
/**
 * A very simple job queue with adjustable concurrency. Adapted from
 * https://github.com/STRML/async-limiter
 */

var Limiter = /*#__PURE__*/function () {
  /**
   * Creates a new `Limiter`.
   *
   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
   *     to run concurrently
   */
  function Limiter(concurrency) {
    var _this = this;

    _classCallCheck(this, Limiter);

    this[kDone] = function () {
      _this.pending--;

      _this[kRun]();
    };

    this.concurrency = concurrency || Infinity;
    this.jobs = [];
    this.pending = 0;
  }
  /**
   * Adds a job to the queue.
   *
   * @param {Function} job The job to run
   * @public
   */


  _createClass(Limiter, [{
    key: "add",
    value: function add(job) {
      this.jobs.push(job);
      this[kRun]();
    }
    /**
     * Removes a job from the queue and runs it if possible.
     *
     * @private
     */

  }, {
    key: kRun,
    value: function value() {
      if (this.pending === this.concurrency) return;

      if (this.jobs.length) {
        var job = this.jobs.shift();
        this.pending++;
        job(this[kDone]);
      }
    }
  }]);

  return Limiter;
}();

module.exports = Limiter;

/***/ }),

/***/ "./node_modules/ws/lib/permessage-deflate.js":
/*!***************************************************!*\
  !*** ./node_modules/ws/lib/permessage-deflate.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var zlib = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var bufferUtil = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js");

var Limiter = __webpack_require__(/*! ./limiter */ "./node_modules/ws/lib/limiter.js");

var _require = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    kStatusCode = _require.kStatusCode;

var TRAILER = Buffer.from([0x00, 0x00, 0xff, 0xff]);
var kPerMessageDeflate = Symbol('permessage-deflate');
var kTotalLength = Symbol('total-length');
var kCallback = Symbol('callback');
var kBuffers = Symbol('buffers');
var kError = Symbol('error'); //
// We limit zlib concurrency, which prevents severe memory fragmentation
// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913
// and https://github.com/websockets/ws/issues/1202
//
// Intentionally global; it's the global thread pool that's an issue.
//

var zlibLimiter;
/**
 * permessage-deflate implementation.
 */

var PerMessageDeflate = /*#__PURE__*/function () {
  /**
   * Creates a PerMessageDeflate instance.
   *
   * @param {Object} [options] Configuration options
   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
   *     for, or request, a custom client window size
   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
   *     acknowledge disabling of client context takeover
   * @param {Number} [options.concurrencyLimit=10] The number of concurrent
   *     calls to zlib
   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
   *     use of a custom server window size
   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
   *     disabling of server context takeover
   * @param {Number} [options.threshold=1024] Size (in bytes) below which
   *     messages should not be compressed if context takeover is disabled
   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
   *     deflate
   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
   *     inflate
   * @param {Boolean} [isServer=false] Create the instance in either server or
   *     client mode
   * @param {Number} [maxPayload=0] The maximum allowed message length
   */
  function PerMessageDeflate(options, isServer, maxPayload) {
    _classCallCheck(this, PerMessageDeflate);

    this._maxPayload = maxPayload | 0;
    this._options = options || {};
    this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;
    this._isServer = !!isServer;
    this._deflate = null;
    this._inflate = null;
    this.params = null;

    if (!zlibLimiter) {
      var concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;
      zlibLimiter = new Limiter(concurrency);
    }
  }
  /**
   * @type {String}
   */


  _createClass(PerMessageDeflate, [{
    key: "offer",
    value:
    /**
     * Create an extension negotiation offer.
     *
     * @return {Object} Extension parameters
     * @public
     */
    function offer() {
      var params = {};

      if (this._options.serverNoContextTakeover) {
        params.server_no_context_takeover = true;
      }

      if (this._options.clientNoContextTakeover) {
        params.client_no_context_takeover = true;
      }

      if (this._options.serverMaxWindowBits) {
        params.server_max_window_bits = this._options.serverMaxWindowBits;
      }

      if (this._options.clientMaxWindowBits) {
        params.client_max_window_bits = this._options.clientMaxWindowBits;
      } else if (this._options.clientMaxWindowBits == null) {
        params.client_max_window_bits = true;
      }

      return params;
    }
    /**
     * Accept an extension negotiation offer/response.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Object} Accepted configuration
     * @public
     */

  }, {
    key: "accept",
    value: function accept(configurations) {
      configurations = this.normalizeParams(configurations);
      this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
      return this.params;
    }
    /**
     * Releases all resources used by the extension.
     *
     * @public
     */

  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this._inflate) {
        this._inflate.close();

        this._inflate = null;
      }

      if (this._deflate) {
        var callback = this._deflate[kCallback];

        this._deflate.close();

        this._deflate = null;

        if (callback) {
          callback(new Error('The deflate stream was closed while data was being processed'));
        }
      }
    }
    /**
     *  Accept an extension negotiation offer.
     *
     * @param {Array} offers The extension negotiation offers
     * @return {Object} Accepted configuration
     * @private
     */

  }, {
    key: "acceptAsServer",
    value: function acceptAsServer(offers) {
      var opts = this._options;
      var accepted = offers.find(function (params) {
        if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === 'number' && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === 'number' && !params.client_max_window_bits) {
          return false;
        }

        return true;
      });

      if (!accepted) {
        throw new Error('None of the extension offers can be accepted');
      }

      if (opts.serverNoContextTakeover) {
        accepted.server_no_context_takeover = true;
      }

      if (opts.clientNoContextTakeover) {
        accepted.client_no_context_takeover = true;
      }

      if (typeof opts.serverMaxWindowBits === 'number') {
        accepted.server_max_window_bits = opts.serverMaxWindowBits;
      }

      if (typeof opts.clientMaxWindowBits === 'number') {
        accepted.client_max_window_bits = opts.clientMaxWindowBits;
      } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
        delete accepted.client_max_window_bits;
      }

      return accepted;
    }
    /**
     * Accept the extension negotiation response.
     *
     * @param {Array} response The extension negotiation response
     * @return {Object} Accepted configuration
     * @private
     */

  }, {
    key: "acceptAsClient",
    value: function acceptAsClient(response) {
      var params = response[0];

      if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {
        throw new Error('Unexpected parameter "client_no_context_takeover"');
      }

      if (!params.client_max_window_bits) {
        if (typeof this._options.clientMaxWindowBits === 'number') {
          params.client_max_window_bits = this._options.clientMaxWindowBits;
        }
      } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === 'number' && params.client_max_window_bits > this._options.clientMaxWindowBits) {
        throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
      }

      return params;
    }
    /**
     * Normalize parameters.
     *
     * @param {Array} configurations The extension negotiation offers/reponse
     * @return {Array} The offers/response with normalized parameters
     * @private
     */

  }, {
    key: "normalizeParams",
    value: function normalizeParams(configurations) {
      var _this = this;

      configurations.forEach(function (params) {
        Object.keys(params).forEach(function (key) {
          var value = params[key];

          if (value.length > 1) {
            throw new Error("Parameter \"".concat(key, "\" must have only a single value"));
          }

          value = value[0];

          if (key === 'client_max_window_bits') {
            if (value !== true) {
              var num = +value;

              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
              }

              value = num;
            } else if (!_this._isServer) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }
          } else if (key === 'server_max_window_bits') {
            var _num = +value;

            if (!Number.isInteger(_num) || _num < 8 || _num > 15) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }

            value = _num;
          } else if (key === 'client_no_context_takeover' || key === 'server_no_context_takeover') {
            if (value !== true) {
              throw new TypeError("Invalid value for parameter \"".concat(key, "\": ").concat(value));
            }
          } else {
            throw new Error("Unknown parameter \"".concat(key, "\""));
          }

          params[key] = value;
        });
      });
      return configurations;
    }
    /**
     * Decompress data. Concurrency limited.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */

  }, {
    key: "decompress",
    value: function decompress(data, fin, callback) {
      var _this2 = this;

      zlibLimiter.add(function (done) {
        _this2._decompress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Compress data. Concurrency limited.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @public
     */

  }, {
    key: "compress",
    value: function compress(data, fin, callback) {
      var _this3 = this;

      zlibLimiter.add(function (done) {
        _this3._compress(data, fin, function (err, result) {
          done();
          callback(err, result);
        });
      });
    }
    /**
     * Decompress data.
     *
     * @param {Buffer} data Compressed data
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */

  }, {
    key: "_decompress",
    value: function _decompress(data, fin, callback) {
      var _this4 = this;

      var endpoint = this._isServer ? 'client' : 'server';

      if (!this._inflate) {
        var key = "".concat(endpoint, "_max_window_bits");
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._inflate = zlib.createInflateRaw(_objectSpread(_objectSpread({}, this._options.zlibInflateOptions), {}, {
          windowBits: windowBits
        }));
        this._inflate[kPerMessageDeflate] = this;
        this._inflate[kTotalLength] = 0;
        this._inflate[kBuffers] = [];

        this._inflate.on('error', inflateOnError);

        this._inflate.on('data', inflateOnData);
      }

      this._inflate[kCallback] = callback;

      this._inflate.write(data);

      if (fin) this._inflate.write(TRAILER);

      this._inflate.flush(function () {
        var err = _this4._inflate[kError];

        if (err) {
          _this4._inflate.close();

          _this4._inflate = null;
          callback(err);
          return;
        }

        var data = bufferUtil.concat(_this4._inflate[kBuffers], _this4._inflate[kTotalLength]);

        if (_this4._inflate._readableState.endEmitted) {
          _this4._inflate.close();

          _this4._inflate = null;
        } else {
          _this4._inflate[kTotalLength] = 0;
          _this4._inflate[kBuffers] = [];

          if (fin && _this4.params["".concat(endpoint, "_no_context_takeover")]) {
            _this4._inflate.reset();
          }
        }

        callback(null, data);
      });
    }
    /**
     * Compress data.
     *
     * @param {Buffer} data Data to compress
     * @param {Boolean} fin Specifies whether or not this is the last fragment
     * @param {Function} callback Callback
     * @private
     */

  }, {
    key: "_compress",
    value: function _compress(data, fin, callback) {
      var _this5 = this;

      var endpoint = this._isServer ? 'server' : 'client';

      if (!this._deflate) {
        var key = "".concat(endpoint, "_max_window_bits");
        var windowBits = typeof this.params[key] !== 'number' ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
        this._deflate = zlib.createDeflateRaw(_objectSpread(_objectSpread({}, this._options.zlibDeflateOptions), {}, {
          windowBits: windowBits
        }));
        this._deflate[kTotalLength] = 0;
        this._deflate[kBuffers] = [];

        this._deflate.on('data', deflateOnData);
      }

      this._deflate[kCallback] = callback;

      this._deflate.write(data);

      this._deflate.flush(zlib.Z_SYNC_FLUSH, function () {
        if (!_this5._deflate) {
          //
          // The deflate stream was closed while data was being processed.
          //
          return;
        }

        var data = bufferUtil.concat(_this5._deflate[kBuffers], _this5._deflate[kTotalLength]);
        if (fin) data = data.slice(0, data.length - 4); //
        // Ensure that the callback will not be called again in
        // `PerMessageDeflate#cleanup()`.
        //

        _this5._deflate[kCallback] = null;
        _this5._deflate[kTotalLength] = 0;
        _this5._deflate[kBuffers] = [];

        if (fin && _this5.params["".concat(endpoint, "_no_context_takeover")]) {
          _this5._deflate.reset();
        }

        callback(null, data);
      });
    }
  }], [{
    key: "extensionName",
    get: function get() {
      return 'permessage-deflate';
    }
  }]);

  return PerMessageDeflate;
}();

module.exports = PerMessageDeflate;
/**
 * The listener of the `zlib.DeflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */

function deflateOnData(chunk) {
  this[kBuffers].push(chunk);
  this[kTotalLength] += chunk.length;
}
/**
 * The listener of the `zlib.InflateRaw` stream `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */


function inflateOnData(chunk) {
  this[kTotalLength] += chunk.length;

  if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
    this[kBuffers].push(chunk);
    return;
  }

  this[kError] = new RangeError('Max payload size exceeded');
  this[kError].code = 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH';
  this[kError][kStatusCode] = 1009;
  this.removeListener('data', inflateOnData);
  this.reset();
}
/**
 * The listener of the `zlib.InflateRaw` stream `'error'` event.
 *
 * @param {Error} err The emitted error
 * @private
 */


function inflateOnError(err) {
  //
  // There is no need to call `Zlib#close()` as the handle is automatically
  // closed when an error is emitted.
  //
  this[kPerMessageDeflate]._inflate = null;
  err[kStatusCode] = 1007;
  this[kCallback](err);
}

/***/ }),

/***/ "./node_modules/ws/lib/receiver.js":
/*!*****************************************!*\
  !*** ./node_modules/ws/lib/receiver.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Writable = _require.Writable;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    BINARY_TYPES = _require2.BINARY_TYPES,
    EMPTY_BUFFER = _require2.EMPTY_BUFFER,
    kStatusCode = _require2.kStatusCode,
    kWebSocket = _require2.kWebSocket;

var _require3 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    concat = _require3.concat,
    toArrayBuffer = _require3.toArrayBuffer,
    unmask = _require3.unmask;

var _require4 = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    isValidStatusCode = _require4.isValidStatusCode,
    isValidUTF8 = _require4.isValidUTF8;

var GET_INFO = 0;
var GET_PAYLOAD_LENGTH_16 = 1;
var GET_PAYLOAD_LENGTH_64 = 2;
var GET_MASK = 3;
var GET_DATA = 4;
var INFLATING = 5;
/**
 * HyBi Receiver implementation.
 *
 * @extends Writable
 */

var Receiver = /*#__PURE__*/function (_Writable) {
  _inherits(Receiver, _Writable);

  var _super = _createSuper(Receiver);

  /**
   * Creates a Receiver instance.
   *
   * @param {Object} [options] Options object
   * @param {String} [options.binaryType=nodebuffer] The type for binary data
   * @param {Object} [options.extensions] An object containing the negotiated
   *     extensions
   * @param {Boolean} [options.isServer=false] Specifies whether to operate in
   *     client or server mode
   * @param {Number} [options.maxPayload=0] The maximum allowed message length
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   */
  function Receiver() {
    var _this;

    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, Receiver);

    _this = _super.call(this);
    _this._binaryType = options.binaryType || BINARY_TYPES[0];
    _this._extensions = options.extensions || {};
    _this._isServer = !!options.isServer;
    _this._maxPayload = options.maxPayload | 0;
    _this._skipUTF8Validation = !!options.skipUTF8Validation;
    _this[kWebSocket] = undefined;
    _this._bufferedBytes = 0;
    _this._buffers = [];
    _this._compressed = false;
    _this._payloadLength = 0;
    _this._mask = undefined;
    _this._fragmented = 0;
    _this._masked = false;
    _this._fin = false;
    _this._opcode = 0;
    _this._totalPayloadLength = 0;
    _this._messageLength = 0;
    _this._fragments = [];
    _this._state = GET_INFO;
    _this._loop = false;
    return _this;
  }
  /**
   * Implements `Writable.prototype._write()`.
   *
   * @param {Buffer} chunk The chunk of data to write
   * @param {String} encoding The character encoding of `chunk`
   * @param {Function} cb Callback
   * @private
   */


  _createClass(Receiver, [{
    key: "_write",
    value: function _write(chunk, encoding, cb) {
      if (this._opcode === 0x08 && this._state == GET_INFO) return cb();
      this._bufferedBytes += chunk.length;

      this._buffers.push(chunk);

      this.startLoop(cb);
    }
    /**
     * Consumes `n` bytes from the buffered data.
     *
     * @param {Number} n The number of bytes to consume
     * @return {Buffer} The consumed bytes
     * @private
     */

  }, {
    key: "consume",
    value: function consume(n) {
      this._bufferedBytes -= n;
      if (n === this._buffers[0].length) return this._buffers.shift();

      if (n < this._buffers[0].length) {
        var buf = this._buffers[0];
        this._buffers[0] = buf.slice(n);
        return buf.slice(0, n);
      }

      var dst = Buffer.allocUnsafe(n);

      do {
        var _buf = this._buffers[0];
        var offset = dst.length - n;

        if (n >= _buf.length) {
          dst.set(this._buffers.shift(), offset);
        } else {
          dst.set(new Uint8Array(_buf.buffer, _buf.byteOffset, n), offset);
          this._buffers[0] = _buf.slice(n);
        }

        n -= _buf.length;
      } while (n > 0);

      return dst;
    }
    /**
     * Starts the parsing loop.
     *
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "startLoop",
    value: function startLoop(cb) {
      var err;
      this._loop = true;

      do {
        switch (this._state) {
          case GET_INFO:
            err = this.getInfo();
            break;

          case GET_PAYLOAD_LENGTH_16:
            err = this.getPayloadLength16();
            break;

          case GET_PAYLOAD_LENGTH_64:
            err = this.getPayloadLength64();
            break;

          case GET_MASK:
            this.getMask();
            break;

          case GET_DATA:
            err = this.getData(cb);
            break;

          default:
            // `INFLATING`
            this._loop = false;
            return;
        }
      } while (this._loop);

      cb(err);
    }
    /**
     * Reads the first two bytes of a frame.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getInfo",
    value: function getInfo() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      var buf = this.consume(2);

      if ((buf[0] & 0x30) !== 0x00) {
        this._loop = false;
        return error(RangeError, 'RSV2 and RSV3 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_2_3');
      }

      var compressed = (buf[0] & 0x40) === 0x40;

      if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
        this._loop = false;
        return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
      }

      this._fin = (buf[0] & 0x80) === 0x80;
      this._opcode = buf[0] & 0x0f;
      this._payloadLength = buf[1] & 0x7f;

      if (this._opcode === 0x00) {
        if (compressed) {
          this._loop = false;
          return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (!this._fragmented) {
          this._loop = false;
          return error(RangeError, 'invalid opcode 0', true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._opcode = this._fragmented;
      } else if (this._opcode === 0x01 || this._opcode === 0x02) {
        if (this._fragmented) {
          this._loop = false;
          return error(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
        }

        this._compressed = compressed;
      } else if (this._opcode > 0x07 && this._opcode < 0x0b) {
        if (!this._fin) {
          this._loop = false;
          return error(RangeError, 'FIN must be set', true, 1002, 'WS_ERR_EXPECTED_FIN');
        }

        if (compressed) {
          this._loop = false;
          return error(RangeError, 'RSV1 must be clear', true, 1002, 'WS_ERR_UNEXPECTED_RSV_1');
        }

        if (this._payloadLength > 0x7d) {
          this._loop = false;
          return error(RangeError, "invalid payload length ".concat(this._payloadLength), true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        }
      } else {
        this._loop = false;
        return error(RangeError, "invalid opcode ".concat(this._opcode), true, 1002, 'WS_ERR_INVALID_OPCODE');
      }

      if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
      this._masked = (buf[1] & 0x80) === 0x80;

      if (this._isServer) {
        if (!this._masked) {
          this._loop = false;
          return error(RangeError, 'MASK must be set', true, 1002, 'WS_ERR_EXPECTED_MASK');
        }
      } else if (this._masked) {
        this._loop = false;
        return error(RangeError, 'MASK must be clear', true, 1002, 'WS_ERR_UNEXPECTED_MASK');
      }

      if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;else return this.haveLength();
    }
    /**
     * Gets extended payload length (7+16).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getPayloadLength16",
    value: function getPayloadLength16() {
      if (this._bufferedBytes < 2) {
        this._loop = false;
        return;
      }

      this._payloadLength = this.consume(2).readUInt16BE(0);
      return this.haveLength();
    }
    /**
     * Gets extended payload length (7+64).
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getPayloadLength64",
    value: function getPayloadLength64() {
      if (this._bufferedBytes < 8) {
        this._loop = false;
        return;
      }

      var buf = this.consume(8);
      var num = buf.readUInt32BE(0); //
      // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned
      // if payload length is greater than this number.
      //

      if (num > Math.pow(2, 53 - 32) - 1) {
        this._loop = false;
        return error(RangeError, 'Unsupported WebSocket frame: payload length > 2^53 - 1', false, 1009, 'WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH');
      }

      this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
      return this.haveLength();
    }
    /**
     * Payload length has been read.
     *
     * @return {(RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "haveLength",
    value: function haveLength() {
      if (this._payloadLength && this._opcode < 0x08) {
        this._totalPayloadLength += this._payloadLength;

        if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
          this._loop = false;
          return error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH');
        }
      }

      if (this._masked) this._state = GET_MASK;else this._state = GET_DATA;
    }
    /**
     * Reads mask bytes.
     *
     * @private
     */

  }, {
    key: "getMask",
    value: function getMask() {
      if (this._bufferedBytes < 4) {
        this._loop = false;
        return;
      }

      this._mask = this.consume(4);
      this._state = GET_DATA;
    }
    /**
     * Reads data bytes.
     *
     * @param {Function} cb Callback
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "getData",
    value: function getData(cb) {
      var data = EMPTY_BUFFER;

      if (this._payloadLength) {
        if (this._bufferedBytes < this._payloadLength) {
          this._loop = false;
          return;
        }

        data = this.consume(this._payloadLength);
        if (this._masked) unmask(data, this._mask);
      }

      if (this._opcode > 0x07) return this.controlMessage(data);

      if (this._compressed) {
        this._state = INFLATING;
        this.decompress(data, cb);
        return;
      }

      if (data.length) {
        //
        // This message is not compressed so its length is the sum of the payload
        // length of all fragments.
        //
        this._messageLength = this._totalPayloadLength;

        this._fragments.push(data);
      }

      return this.dataMessage();
    }
    /**
     * Decompresses data.
     *
     * @param {Buffer} data Compressed data
     * @param {Function} cb Callback
     * @private
     */

  }, {
    key: "decompress",
    value: function decompress(data, cb) {
      var _this2 = this;

      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      perMessageDeflate.decompress(data, this._fin, function (err, buf) {
        if (err) return cb(err);

        if (buf.length) {
          _this2._messageLength += buf.length;

          if (_this2._messageLength > _this2._maxPayload && _this2._maxPayload > 0) {
            return cb(error(RangeError, 'Max payload size exceeded', false, 1009, 'WS_ERR_UNSUPPORTED_MESSAGE_LENGTH'));
          }

          _this2._fragments.push(buf);
        }

        var er = _this2.dataMessage();

        if (er) return cb(er);

        _this2.startLoop(cb);
      });
    }
    /**
     * Handles a data message.
     *
     * @return {(Error|undefined)} A possible error
     * @private
     */

  }, {
    key: "dataMessage",
    value: function dataMessage() {
      if (this._fin) {
        var messageLength = this._messageLength;
        var fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];

        if (this._opcode === 2) {
          var data;

          if (this._binaryType === 'nodebuffer') {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === 'arraybuffer') {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }

          this.emit('message', data, true);
        } else {
          var buf = concat(fragments, messageLength);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            this._loop = false;
            return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('message', buf, false);
        }
      }

      this._state = GET_INFO;
    }
    /**
     * Handles a control message.
     *
     * @param {Buffer} data Data to handle
     * @return {(Error|RangeError|undefined)} A possible error
     * @private
     */

  }, {
    key: "controlMessage",
    value: function controlMessage(data) {
      if (this._opcode === 0x08) {
        this._loop = false;

        if (data.length === 0) {
          this.emit('conclude', 1005, EMPTY_BUFFER);
          this.end();
        } else if (data.length === 1) {
          return error(RangeError, 'invalid payload length 1', true, 1002, 'WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH');
        } else {
          var code = data.readUInt16BE(0);

          if (!isValidStatusCode(code)) {
            return error(RangeError, "invalid status code ".concat(code), true, 1002, 'WS_ERR_INVALID_CLOSE_CODE');
          }

          var buf = data.slice(2);

          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            return error(Error, 'invalid UTF-8 sequence', true, 1007, 'WS_ERR_INVALID_UTF8');
          }

          this.emit('conclude', code, buf);
          this.end();
        }
      } else if (this._opcode === 0x09) {
        this.emit('ping', data);
      } else {
        this.emit('pong', data);
      }

      this._state = GET_INFO;
    }
  }]);

  return Receiver;
}(Writable);

module.exports = Receiver;
/**
 * Builds an error object.
 *
 * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
 * @param {String} message The error message
 * @param {Boolean} prefix Specifies whether or not to add a default prefix to
 *     `message`
 * @param {Number} statusCode The status code
 * @param {String} errorCode The exposed error code
 * @return {(Error|RangeError)} The error
 * @private
 */

function error(ErrorCtor, message, prefix, statusCode, errorCode) {
  var err = new ErrorCtor(prefix ? "Invalid WebSocket frame: ".concat(message) : message);
  Error.captureStackTrace(err, error);
  err.code = errorCode;
  err[kStatusCode] = statusCode;
  return err;
}

/***/ }),

/***/ "./node_modules/ws/lib/sender.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/sender.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls$" }] */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    randomFillSync = _require.randomFillSync;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    EMPTY_BUFFER = _require2.EMPTY_BUFFER;

var _require3 = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    isValidStatusCode = _require3.isValidStatusCode;

var _require4 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    applyMask = _require4.mask,
    toBuffer = _require4.toBuffer;

var mask = Buffer.alloc(4);
/**
 * HyBi Sender implementation.
 */

var Sender = /*#__PURE__*/function () {
  /**
   * Creates a Sender instance.
   *
   * @param {(net.Socket|tls.Socket)} socket The connection socket
   * @param {Object} [extensions] An object containing the negotiated extensions
   */
  function Sender(socket, extensions) {
    _classCallCheck(this, Sender);

    this._extensions = extensions || {};
    this._socket = socket;
    this._firstFragment = true;
    this._compress = false;
    this._bufferedBytes = 0;
    this._deflating = false;
    this._queue = [];
  }
  /**
   * Frames a piece of data according to the HyBi WebSocket protocol.
   *
   * @param {Buffer} data The data to frame
   * @param {Object} options Options object
   * @param {Boolean} [options.fin=false] Specifies whether or not to set the
   *     FIN bit
   * @param {Boolean} [options.mask=false] Specifies whether or not to mask
   *     `data`
   * @param {Number} options.opcode The opcode
   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
   *     modified
   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
   *     RSV1 bit
   * @return {Buffer[]} The framed data as a list of `Buffer` instances
   * @public
   */


  _createClass(Sender, [{
    key: "close",
    value:
    /**
     * Sends a close message to the other peer.
     *
     * @param {Number} [code] The status code component of the body
     * @param {(String|Buffer)} [data] The message component of the body
     * @param {Boolean} [mask=false] Specifies whether or not to mask the message
     * @param {Function} [cb] Callback
     * @public
     */
    function close(code, data, mask, cb) {
      var buf;

      if (code === undefined) {
        buf = EMPTY_BUFFER;
      } else if (typeof code !== 'number' || !isValidStatusCode(code)) {
        throw new TypeError('First argument must be a valid error code number');
      } else if (data === undefined || !data.length) {
        buf = Buffer.allocUnsafe(2);
        buf.writeUInt16BE(code, 0);
      } else {
        var length = Buffer.byteLength(data);

        if (length > 123) {
          throw new RangeError('The message must not be greater than 123 bytes');
        }

        buf = Buffer.allocUnsafe(2 + length);
        buf.writeUInt16BE(code, 0);

        if (typeof data === 'string') {
          buf.write(data, 2);
        } else {
          buf.set(data, 2);
        }
      }

      if (this._deflating) {
        this.enqueue([this.doClose, buf, mask, cb]);
      } else {
        this.doClose(buf, mask, cb);
      }
    }
    /**
     * Frames and sends a close message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doClose",
    value: function doClose(data, mask, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x08,
        mask: mask,
        readOnly: false
      }), cb);
    }
    /**
     * Sends a ping message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "ping",
    value: function ping(data, mask, cb) {
      var buf = toBuffer(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPing, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPing(buf, mask, toBuffer.readOnly, cb);
      }
    }
    /**
     * Frames and sends a ping message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doPing",
    value: function doPing(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x09,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a pong message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "pong",
    value: function pong(data, mask, cb) {
      var buf = toBuffer(data);

      if (buf.length > 125) {
        throw new RangeError('The data size must not be greater than 125 bytes');
      }

      if (this._deflating) {
        this.enqueue([this.doPong, buf, mask, toBuffer.readOnly, cb]);
      } else {
        this.doPong(buf, mask, toBuffer.readOnly, cb);
      }
    }
    /**
     * Frames and sends a pong message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
     * @param {Boolean} [readOnly=false] Specifies whether `data` can be modified
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "doPong",
    value: function doPong(data, mask, readOnly, cb) {
      this.sendFrame(Sender.frame(data, {
        fin: true,
        rsv1: false,
        opcode: 0x0a,
        mask: mask,
        readOnly: readOnly
      }), cb);
    }
    /**
     * Sends a data message to the other peer.
     *
     * @param {*} data The message to send
     * @param {Object} options Options object
     * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
     *     or text
     * @param {Boolean} [options.compress=false] Specifies whether or not to
     *     compress `data`
     * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Function} [cb] Callback
     * @public
     */

  }, {
    key: "send",
    value: function send(data, options, cb) {
      var buf = toBuffer(data);
      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      var opcode = options.binary ? 2 : 1;
      var rsv1 = options.compress;

      if (this._firstFragment) {
        this._firstFragment = false;

        if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? 'server_no_context_takeover' : 'client_no_context_takeover']) {
          rsv1 = buf.length >= perMessageDeflate._threshold;
        }

        this._compress = rsv1;
      } else {
        rsv1 = false;
        opcode = 0;
      }

      if (options.fin) this._firstFragment = true;

      if (perMessageDeflate) {
        var opts = {
          fin: options.fin,
          rsv1: rsv1,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        };

        if (this._deflating) {
          this.enqueue([this.dispatch, buf, this._compress, opts, cb]);
        } else {
          this.dispatch(buf, this._compress, opts, cb);
        }
      } else {
        this.sendFrame(Sender.frame(buf, {
          fin: options.fin,
          rsv1: false,
          opcode: opcode,
          mask: options.mask,
          readOnly: toBuffer.readOnly
        }), cb);
      }
    }
    /**
     * Dispatches a data message.
     *
     * @param {Buffer} data The message to send
     * @param {Boolean} [compress=false] Specifies whether or not to compress
     *     `data`
     * @param {Object} options Options object
     * @param {Number} options.opcode The opcode
     * @param {Boolean} [options.fin=false] Specifies whether or not to set the
     *     FIN bit
     * @param {Boolean} [options.mask=false] Specifies whether or not to mask
     *     `data`
     * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
     *     modified
     * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
     *     RSV1 bit
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "dispatch",
    value: function dispatch(data, compress, options, cb) {
      var _this = this;

      if (!compress) {
        this.sendFrame(Sender.frame(data, options), cb);
        return;
      }

      var perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
      this._bufferedBytes += data.length;
      this._deflating = true;
      perMessageDeflate.compress(data, options.fin, function (_, buf) {
        if (_this._socket.destroyed) {
          var err = new Error('The socket was closed while data was being compressed');
          if (typeof cb === 'function') cb(err);

          for (var i = 0; i < _this._queue.length; i++) {
            var callback = _this._queue[i][4];
            if (typeof callback === 'function') callback(err);
          }

          return;
        }

        _this._bufferedBytes -= data.length;
        _this._deflating = false;
        options.readOnly = false;

        _this.sendFrame(Sender.frame(buf, options), cb);

        _this.dequeue();
      });
    }
    /**
     * Executes queued send operations.
     *
     * @private
     */

  }, {
    key: "dequeue",
    value: function dequeue() {
      while (!this._deflating && this._queue.length) {
        var params = this._queue.shift();

        this._bufferedBytes -= params[1].length;
        Reflect.apply(params[0], this, params.slice(1));
      }
    }
    /**
     * Enqueues a send operation.
     *
     * @param {Array} params Send operation parameters.
     * @private
     */

  }, {
    key: "enqueue",
    value: function enqueue(params) {
      this._bufferedBytes += params[1].length;

      this._queue.push(params);
    }
    /**
     * Sends a frame.
     *
     * @param {Buffer[]} list The frame to send
     * @param {Function} [cb] Callback
     * @private
     */

  }, {
    key: "sendFrame",
    value: function sendFrame(list, cb) {
      if (list.length === 2) {
        this._socket.cork();

        this._socket.write(list[0]);

        this._socket.write(list[1], cb);

        this._socket.uncork();
      } else {
        this._socket.write(list[0], cb);
      }
    }
  }], [{
    key: "frame",
    value: function frame(data, options) {
      var merge = options.mask && options.readOnly;
      var offset = options.mask ? 6 : 2;
      var payloadLength = data.length;

      if (data.length >= 65536) {
        offset += 8;
        payloadLength = 127;
      } else if (data.length > 125) {
        offset += 2;
        payloadLength = 126;
      }

      var target = Buffer.allocUnsafe(merge ? data.length + offset : offset);
      target[0] = options.fin ? options.opcode | 0x80 : options.opcode;
      if (options.rsv1) target[0] |= 0x40;
      target[1] = payloadLength;

      if (payloadLength === 126) {
        target.writeUInt16BE(data.length, 2);
      } else if (payloadLength === 127) {
        target.writeUInt32BE(0, 2);
        target.writeUInt32BE(data.length, 6);
      }

      if (!options.mask) return [target, data];
      randomFillSync(mask, 0, 4);
      target[1] |= 0x80;
      target[offset - 4] = mask[0];
      target[offset - 3] = mask[1];
      target[offset - 2] = mask[2];
      target[offset - 1] = mask[3];

      if (merge) {
        applyMask(data, mask, target, offset, data.length);
        return [target];
      }

      applyMask(data, mask, data, 0, data.length);
      return [target, data];
    }
  }]);

  return Sender;
}();

module.exports = Sender;

/***/ }),

/***/ "./node_modules/ws/lib/stream.js":
/*!***************************************!*\
  !*** ./node_modules/ws/lib/stream.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Duplex = _require.Duplex;
/**
 * Emits the `'close'` event on a stream.
 *
 * @param {Duplex} stream The stream.
 * @private
 */


function emitClose(stream) {
  stream.emit('close');
}
/**
 * The listener of the `'end'` event.
 *
 * @private
 */


function duplexOnEnd() {
  if (!this.destroyed && this._writableState.finished) {
    this.destroy();
  }
}
/**
 * The listener of the `'error'` event.
 *
 * @param {Error} err The error
 * @private
 */


function duplexOnError(err) {
  this.removeListener('error', duplexOnError);
  this.destroy();

  if (this.listenerCount('error') === 0) {
    // Do not suppress the throwing behavior.
    this.emit('error', err);
  }
}
/**
 * Wraps a `WebSocket` in a duplex stream.
 *
 * @param {WebSocket} ws The `WebSocket` to wrap
 * @param {Object} [options] The options for the `Duplex` constructor
 * @return {Duplex} The duplex stream
 * @public
 */


function createWebSocketStream(ws, options) {
  var resumeOnReceiverDrain = true;
  var terminateOnDestroy = true;

  function receiverOnDrain() {
    if (resumeOnReceiverDrain) ws._socket.resume();
  }

  if (ws.readyState === ws.CONNECTING) {
    ws.once('open', function open() {
      ws._receiver.removeAllListeners('drain');

      ws._receiver.on('drain', receiverOnDrain);
    });
  } else {
    ws._receiver.removeAllListeners('drain');

    ws._receiver.on('drain', receiverOnDrain);
  }

  var duplex = new Duplex(_objectSpread(_objectSpread({}, options), {}, {
    autoDestroy: false,
    emitClose: false,
    objectMode: false,
    writableObjectMode: false
  }));
  ws.on('message', function message(msg, isBinary) {
    var data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;

    if (!duplex.push(data)) {
      resumeOnReceiverDrain = false;

      ws._socket.pause();
    }
  });
  ws.once('error', function error(err) {
    if (duplex.destroyed) return; // Prevent `ws.terminate()` from being called by `duplex._destroy()`.
    //
    // - If the `'error'` event is emitted before the `'open'` event, then
    //   `ws.terminate()` is a noop as no socket is assigned.
    // - Otherwise, the error is re-emitted by the listener of the `'error'`
    //   event of the `Receiver` object. The listener already closes the
    //   connection by calling `ws.close()`. This allows a close frame to be
    //   sent to the other peer. If `ws.terminate()` is called right after this,
    //   then the close frame might not be sent.

    terminateOnDestroy = false;
    duplex.destroy(err);
  });
  ws.once('close', function close() {
    if (duplex.destroyed) return;
    duplex.push(null);
  });

  duplex._destroy = function (err, callback) {
    if (ws.readyState === ws.CLOSED) {
      callback(err);
      process.nextTick(emitClose, duplex);
      return;
    }

    var called = false;
    ws.once('error', function error(err) {
      called = true;
      callback(err);
    });
    ws.once('close', function close() {
      if (!called) callback(err);
      process.nextTick(emitClose, duplex);
    });
    if (terminateOnDestroy) ws.terminate();
  };

  duplex._final = function (callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._final(callback);
      });
      return;
    } // If the value of the `_socket` property is `null` it means that `ws` is a
    // client websocket and the handshake failed. In fact, when this happens, a
    // socket is never assigned to the websocket. Wait for the `'error'` event
    // that will be emitted by the websocket.


    if (ws._socket === null) return;

    if (ws._socket._writableState.finished) {
      callback();
      if (duplex._readableState.endEmitted) duplex.destroy();
    } else {
      ws._socket.once('finish', function finish() {
        // `duplex` is not destroyed here because the `'end'` event will be
        // emitted on `duplex` after this `'finish'` event. The EOF signaling
        // `null` chunk is, in fact, pushed when the websocket emits `'close'`.
        callback();
      });

      ws.close();
    }
  };

  duplex._read = function () {
    if (ws.readyState === ws.OPEN && !resumeOnReceiverDrain) {
      resumeOnReceiverDrain = true;
      if (!ws._receiver._writableState.needDrain) ws._socket.resume();
    }
  };

  duplex._write = function (chunk, encoding, callback) {
    if (ws.readyState === ws.CONNECTING) {
      ws.once('open', function open() {
        duplex._write(chunk, encoding, callback);
      });
      return;
    }

    ws.send(chunk, callback);
  };

  duplex.on('end', duplexOnEnd);
  duplex.on('error', duplexOnError);
  return duplex;
}

module.exports = createWebSocketStream;

/***/ }),

/***/ "./node_modules/ws/lib/subprotocol.js":
/*!********************************************!*\
  !*** ./node_modules/ws/lib/subprotocol.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _require = __webpack_require__(/*! ./validation */ "./node_modules/ws/lib/validation.js"),
    tokenChars = _require.tokenChars;
/**
 * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.
 *
 * @param {String} header The field value of the header
 * @return {Set} The subprotocol names
 * @public
 */


function parse(header) {
  var protocols = new Set();
  var start = -1;
  var end = -1;
  var i = 0;

  for (i; i < header.length; i++) {
    var code = header.charCodeAt(i);

    if (end === -1 && tokenChars[code] === 1) {
      if (start === -1) start = i;
    } else if (i !== 0 && (code === 0x20
    /* ' ' */
    || code === 0x09)
    /* '\t' */
    ) {
      if (end === -1 && start !== -1) end = i;
    } else if (code === 0x2c
    /* ',' */
    ) {
      if (start === -1) {
        throw new SyntaxError("Unexpected character at index ".concat(i));
      }

      if (end === -1) end = i;

      var _protocol = header.slice(start, end);

      if (protocols.has(_protocol)) {
        throw new SyntaxError("The \"".concat(_protocol, "\" subprotocol is duplicated"));
      }

      protocols.add(_protocol);
      start = end = -1;
    } else {
      throw new SyntaxError("Unexpected character at index ".concat(i));
    }
  }

  if (start === -1 || end !== -1) {
    throw new SyntaxError('Unexpected end of input');
  }

  var protocol = header.slice(start, i);

  if (protocols.has(protocol)) {
    throw new SyntaxError("The \"".concat(protocol, "\" subprotocol is duplicated"));
  }

  protocols.add(protocol);
  return protocols;
}

module.exports = {
  parse: parse
};

/***/ }),

/***/ "./node_modules/ws/lib/validation.js":
/*!*******************************************!*\
  !*** ./node_modules/ws/lib/validation.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

 //
// Allowed token characters:
//
// '!', '#', '$', '%', '&', ''', '*', '+', '-',
// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'
//
// tokenChars[32] === 0 // ' '
// tokenChars[33] === 1 // '!'
// tokenChars[34] === 0 // '"'
// ...
//
// prettier-ignore

var tokenChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 0 - 15
0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, // 16 - 31
0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 0, // 32 - 47
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, // 48 - 63
0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 64 - 79
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 1, // 80 - 95
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, // 96 - 111
1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0 // 112 - 127
];
/**
 * Checks if a status code is allowed in a close frame.
 *
 * @param {Number} code The status code
 * @return {Boolean} `true` if the status code is valid, else `false`
 * @public
 */

function isValidStatusCode(code) {
  return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;
}
/**
 * Checks if a given buffer contains only correct UTF-8.
 * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by
 * Markus Kuhn.
 *
 * @param {Buffer} buf The buffer to check
 * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`
 * @public
 */


function _isValidUTF8(buf) {
  var len = buf.length;
  var i = 0;

  while (i < len) {
    if ((buf[i] & 0x80) === 0) {
      // 0xxxxxxx
      i++;
    } else if ((buf[i] & 0xe0) === 0xc0) {
      // 110xxxxx 10xxxxxx
      if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong
      ) {
        return false;
      }

      i += 2;
    } else if ((buf[i] & 0xf0) === 0xe0) {
      // 1110xxxx 10xxxxxx 10xxxxxx
      if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong
      buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)
      ) {
        return false;
      }

      i += 3;
    } else if ((buf[i] & 0xf8) === 0xf0) {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong
      buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF
      ) {
        return false;
      }

      i += 4;
    } else {
      return false;
    }
  }

  return true;
}

try {
  var _isValidUTF = __webpack_require__(/*! utf-8-validate */ "./node_modules/utf-8-validate/index.js");

  module.exports = {
    isValidStatusCode: isValidStatusCode,
    isValidUTF8: function isValidUTF8(buf) {
      return buf.length < 150 ? _isValidUTF8(buf) : _isValidUTF(buf);
    },
    tokenChars: tokenChars
  };
} catch (e)
/* istanbul ignore next */
{
  module.exports = {
    isValidStatusCode: isValidStatusCode,
    isValidUTF8: _isValidUTF8,
    tokenChars: tokenChars
  };
}

/***/ }),

/***/ "./node_modules/ws/lib/websocket-server.js":
/*!*************************************************!*\
  !*** ./node_modules/ws/lib/websocket-server.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^net|tls|https$" }] */


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    createHash = _require.createHash;

var extension = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js");

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var subprotocol = __webpack_require__(/*! ./subprotocol */ "./node_modules/ws/lib/subprotocol.js");

var WebSocket = __webpack_require__(/*! ./websocket */ "./node_modules/ws/lib/websocket.js");

var _require2 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    GUID = _require2.GUID,
    kWebSocket = _require2.kWebSocket;

var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
var RUNNING = 0;
var CLOSING = 1;
var CLOSED = 2;
/**
 * Class representing a WebSocket server.
 *
 * @extends EventEmitter
 */

var WebSocketServer = /*#__PURE__*/function (_EventEmitter) {
  _inherits(WebSocketServer, _EventEmitter);

  var _super = _createSuper(WebSocketServer);

  /**
   * Create a `WebSocketServer` instance.
   *
   * @param {Object} options Configuration options
   * @param {Number} [options.backlog=511] The maximum length of the queue of
   *     pending connections
   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
   *     track clients
   * @param {Function} [options.handleProtocols] A hook to handle protocols
   * @param {String} [options.host] The hostname where to bind the server
   * @param {Number} [options.maxPayload=104857600] The maximum allowed message
   *     size
   * @param {Boolean} [options.noServer=false] Enable no server mode
   * @param {String} [options.path] Accept only connections matching this path
   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
   *     permessage-deflate
   * @param {Number} [options.port] The port where to bind the server
   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
   *     server to use
   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
   *     not to skip UTF-8 validation for text and close messages
   * @param {Function} [options.verifyClient] A hook to reject connections
   * @param {Function} [callback] A listener for the `listening` event
   */
  function WebSocketServer(options, callback) {
    var _this;

    _classCallCheck(this, WebSocketServer);

    _this = _super.call(this);
    options = _objectSpread({
      maxPayload: 100 * 1024 * 1024,
      skipUTF8Validation: false,
      perMessageDeflate: false,
      handleProtocols: null,
      clientTracking: true,
      verifyClient: null,
      noServer: false,
      backlog: null,
      // use default (511 as implemented in net.js)
      server: null,
      host: null,
      path: null,
      port: null
    }, options);

    if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
      throw new TypeError('One and only one of the "port", "server", or "noServer" options ' + 'must be specified');
    }

    if (options.port != null) {
      _this._server = http.createServer(function (req, res) {
        var body = http.STATUS_CODES[426];
        res.writeHead(426, {
          'Content-Length': body.length,
          'Content-Type': 'text/plain'
        });
        res.end(body);
      });

      _this._server.listen(options.port, options.host, options.backlog, callback);
    } else if (options.server) {
      _this._server = options.server;
    }

    if (_this._server) {
      var emitConnection = _this.emit.bind(_assertThisInitialized(_this), 'connection');

      _this._removeListeners = addListeners(_this._server, {
        listening: _this.emit.bind(_assertThisInitialized(_this), 'listening'),
        error: _this.emit.bind(_assertThisInitialized(_this), 'error'),
        upgrade: function upgrade(req, socket, head) {
          _this.handleUpgrade(req, socket, head, emitConnection);
        }
      });
    }

    if (options.perMessageDeflate === true) options.perMessageDeflate = {};

    if (options.clientTracking) {
      _this.clients = new Set();
      _this._shouldEmitClose = false;
    }

    _this.options = options;
    _this._state = RUNNING;
    return _this;
  }
  /**
   * Returns the bound address, the address family name, and port of the server
   * as reported by the operating system if listening on an IP socket.
   * If the server is listening on a pipe or UNIX domain socket, the name is
   * returned as a string.
   *
   * @return {(Object|String|null)} The address of the server
   * @public
   */


  _createClass(WebSocketServer, [{
    key: "address",
    value: function address() {
      if (this.options.noServer) {
        throw new Error('The server is operating in "noServer" mode');
      }

      if (!this._server) return null;
      return this._server.address();
    }
    /**
     * Stop the server from accepting new connections and emit the `'close'` event
     * when all existing connections are closed.
     *
     * @param {Function} [cb] A one-time listener for the `'close'` event
     * @public
     */

  }, {
    key: "close",
    value: function close(cb) {
      var _this2 = this;

      if (this._state === CLOSED) {
        if (cb) {
          this.once('close', function () {
            cb(new Error('The server is not running'));
          });
        }

        process.nextTick(emitClose, this);
        return;
      }

      if (cb) this.once('close', cb);
      if (this._state === CLOSING) return;
      this._state = CLOSING;

      if (this.options.noServer || this.options.server) {
        if (this._server) {
          this._removeListeners();

          this._removeListeners = this._server = null;
        }

        if (this.clients) {
          if (!this.clients.size) {
            process.nextTick(emitClose, this);
          } else {
            this._shouldEmitClose = true;
          }
        } else {
          process.nextTick(emitClose, this);
        }
      } else {
        var server = this._server;

        this._removeListeners();

        this._removeListeners = this._server = null; //
        // The HTTP/S server was created internally. Close it, and rely on its
        // `'close'` event.
        //

        server.close(function () {
          emitClose(_this2);
        });
      }
    }
    /**
     * See if a given request should be handled by this server instance.
     *
     * @param {http.IncomingMessage} req Request object to inspect
     * @return {Boolean} `true` if the request is valid, else `false`
     * @public
     */

  }, {
    key: "shouldHandle",
    value: function shouldHandle(req) {
      if (this.options.path) {
        var index = req.url.indexOf('?');
        var pathname = index !== -1 ? req.url.slice(0, index) : req.url;
        if (pathname !== this.options.path) return false;
      }

      return true;
    }
    /**
     * Handle a HTTP Upgrade request.
     *
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @public
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, head, cb) {
      var _this3 = this;

      socket.on('error', socketOnError);
      var key = req.headers['sec-websocket-key'] !== undefined ? req.headers['sec-websocket-key'] : false;
      var version = +req.headers['sec-websocket-version'];

      if (req.method !== 'GET' || req.headers.upgrade.toLowerCase() !== 'websocket' || !key || !keyRegex.test(key) || version !== 8 && version !== 13 || !this.shouldHandle(req)) {
        return abortHandshake(socket, 400);
      }

      var secWebSocketProtocol = req.headers['sec-websocket-protocol'];
      var protocols = new Set();

      if (secWebSocketProtocol !== undefined) {
        try {
          protocols = subprotocol.parse(secWebSocketProtocol);
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      }

      var secWebSocketExtensions = req.headers['sec-websocket-extensions'];
      var extensions = {};

      if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {
        var perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);

        try {
          var offers = extension.parse(secWebSocketExtensions);

          if (offers[PerMessageDeflate.extensionName]) {
            perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
            extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
          }
        } catch (err) {
          return abortHandshake(socket, 400);
        }
      } //
      // Optionally call external client verification handler.
      //


      if (this.options.verifyClient) {
        var info = {
          origin: req.headers["".concat(version === 8 ? 'sec-websocket-origin' : 'origin')],
          secure: !!(req.socket.authorized || req.socket.encrypted),
          req: req
        };

        if (this.options.verifyClient.length === 2) {
          this.options.verifyClient(info, function (verified, code, message, headers) {
            if (!verified) {
              return abortHandshake(socket, code || 401, message, headers);
            }

            _this3.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
          });
          return;
        }

        if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
      }

      this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
    }
    /**
     * Upgrade the connection to WebSocket.
     *
     * @param {Object} extensions The accepted extensions
     * @param {String} key The value of the `Sec-WebSocket-Key` header
     * @param {Set} protocols The subprotocols
     * @param {http.IncomingMessage} req The request object
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Function} cb Callback
     * @throws {Error} If called more than once with the same socket
     * @private
     */

  }, {
    key: "completeUpgrade",
    value: function completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
      var _this4 = this;

      //
      // Destroy the socket if the client has already sent a FIN packet.
      //
      if (!socket.readable || !socket.writable) return socket.destroy();

      if (socket[kWebSocket]) {
        throw new Error('server.handleUpgrade() was called more than once with the same ' + 'socket, possibly due to a misconfiguration');
      }

      if (this._state > RUNNING) return abortHandshake(socket, 503);
      var digest = createHash('sha1').update(key + GUID).digest('base64');
      var headers = ['HTTP/1.1 101 Switching Protocols', 'Upgrade: websocket', 'Connection: Upgrade', "Sec-WebSocket-Accept: ".concat(digest)];
      var ws = new WebSocket(null);

      if (protocols.size) {
        //
        // Optionally call external protocol selection handler.
        //
        var protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;

        if (protocol) {
          headers.push("Sec-WebSocket-Protocol: ".concat(protocol));
          ws._protocol = protocol;
        }
      }

      if (extensions[PerMessageDeflate.extensionName]) {
        var params = extensions[PerMessageDeflate.extensionName].params;
        var value = extension.format(_defineProperty({}, PerMessageDeflate.extensionName, [params]));
        headers.push("Sec-WebSocket-Extensions: ".concat(value));
        ws._extensions = extensions;
      } //
      // Allow external modification/inspection of handshake headers.
      //


      this.emit('headers', headers, req);
      socket.write(headers.concat('\r\n').join('\r\n'));
      socket.removeListener('error', socketOnError);
      ws.setSocket(socket, head, {
        maxPayload: this.options.maxPayload,
        skipUTF8Validation: this.options.skipUTF8Validation
      });

      if (this.clients) {
        this.clients.add(ws);
        ws.on('close', function () {
          _this4.clients["delete"](ws);

          if (_this4._shouldEmitClose && !_this4.clients.size) {
            process.nextTick(emitClose, _this4);
          }
        });
      }

      cb(ws, req);
    }
  }]);

  return WebSocketServer;
}(EventEmitter);

module.exports = WebSocketServer;
/**
 * Add event listeners on an `EventEmitter` using a map of <event, listener>
 * pairs.
 *
 * @param {EventEmitter} server The event emitter
 * @param {Object.<String, Function>} map The listeners to add
 * @return {Function} A function that will remove the added listeners when
 *     called
 * @private
 */

function addListeners(server, map) {
  for (var _i = 0, _Object$keys = Object.keys(map); _i < _Object$keys.length; _i++) {
    var event = _Object$keys[_i];
    server.on(event, map[event]);
  }

  return function removeListeners() {
    for (var _i2 = 0, _Object$keys2 = Object.keys(map); _i2 < _Object$keys2.length; _i2++) {
      var _event = _Object$keys2[_i2];
      server.removeListener(_event, map[_event]);
    }
  };
}
/**
 * Emit a `'close'` event on an `EventEmitter`.
 *
 * @param {EventEmitter} server The event emitter
 * @private
 */


function emitClose(server) {
  server._state = CLOSED;
  server.emit('close');
}
/**
 * Handle premature socket errors.
 *
 * @private
 */


function socketOnError() {
  this.destroy();
}
/**
 * Close the connection when preconditions are not fulfilled.
 *
 * @param {(net.Socket|tls.Socket)} socket The socket of the upgrade request
 * @param {Number} code The HTTP response status code
 * @param {String} [message] The HTTP response body
 * @param {Object} [headers] Additional HTTP response headers
 * @private
 */


function abortHandshake(socket, code, message, headers) {
  if (socket.writable) {
    message = message || http.STATUS_CODES[code];
    headers = _objectSpread({
      Connection: 'close',
      'Content-Type': 'text/html',
      'Content-Length': Buffer.byteLength(message)
    }, headers);
    socket.write("HTTP/1.1 ".concat(code, " ").concat(http.STATUS_CODES[code], "\r\n") + Object.keys(headers).map(function (h) {
      return "".concat(h, ": ").concat(headers[h]);
    }).join('\r\n') + '\r\n\r\n' + message);
  }

  socket.removeListener('error', socketOnError);
  socket.destroy();
}

/***/ }),

/***/ "./node_modules/ws/lib/websocket.js":
/*!******************************************!*\
  !*** ./node_modules/ws/lib/websocket.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/* eslint no-unused-vars: ["error", { "varsIgnorePattern": "^Readable$" }] */


function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var https = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'https'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var net = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'net'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var tls = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'tls'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var _require = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'crypto'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    randomBytes = _require.randomBytes,
    createHash = _require.createHash;

var _require2 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }())),
    Readable = _require2.Readable;

var _require3 = __webpack_require__(/*! url */ "./node_modules/url/url.js"),
    URL = _require3.URL;

var PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ "./node_modules/ws/lib/permessage-deflate.js");

var Receiver = __webpack_require__(/*! ./receiver */ "./node_modules/ws/lib/receiver.js");

var Sender = __webpack_require__(/*! ./sender */ "./node_modules/ws/lib/sender.js");

var _require4 = __webpack_require__(/*! ./constants */ "./node_modules/ws/lib/constants.js"),
    BINARY_TYPES = _require4.BINARY_TYPES,
    EMPTY_BUFFER = _require4.EMPTY_BUFFER,
    GUID = _require4.GUID,
    kForOnEventAttribute = _require4.kForOnEventAttribute,
    kListener = _require4.kListener,
    kStatusCode = _require4.kStatusCode,
    kWebSocket = _require4.kWebSocket,
    NOOP = _require4.NOOP;

var _require5 = __webpack_require__(/*! ./event-target */ "./node_modules/ws/lib/event-target.js"),
    _require5$EventTarget = _require5.EventTarget,
    addEventListener = _require5$EventTarget.addEventListener,
    removeEventListener = _require5$EventTarget.removeEventListener;

var _require6 = __webpack_require__(/*! ./extension */ "./node_modules/ws/lib/extension.js"),
    format = _require6.format,
    parse = _require6.parse;

var _require7 = __webpack_require__(/*! ./buffer-util */ "./node_modules/ws/lib/buffer-util.js"),
    toBuffer = _require7.toBuffer;

var readyStates = ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'];
var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
var protocolVersions = [8, 13];
var closeTimeout = 30 * 1000;
/**
 * Class representing a WebSocket.
 *
 * @extends EventEmitter
 */

var WebSocket = /*#__PURE__*/function (_EventEmitter) {
  _inherits(WebSocket, _EventEmitter);

  var _super = _createSuper(WebSocket);

  /**
   * Create a new `WebSocket`.
   *
   * @param {(String|URL)} address The URL to which to connect
   * @param {(String|String[])} [protocols] The subprotocols
   * @param {Object} [options] Connection options
   */
  function WebSocket(address, protocols, options) {
    var _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this);
    _this._binaryType = BINARY_TYPES[0];
    _this._closeCode = 1006;
    _this._closeFrameReceived = false;
    _this._closeFrameSent = false;
    _this._closeMessage = EMPTY_BUFFER;
    _this._closeTimer = null;
    _this._extensions = {};
    _this._protocol = '';
    _this._readyState = WebSocket.CONNECTING;
    _this._receiver = null;
    _this._sender = null;
    _this._socket = null;

    if (address !== null) {
      _this._bufferedAmount = 0;
      _this._isServer = false;
      _this._redirects = 0;

      if (protocols === undefined) {
        protocols = [];
      } else if (!Array.isArray(protocols)) {
        if (_typeof(protocols) === 'object' && protocols !== null) {
          options = protocols;
          protocols = [];
        } else {
          protocols = [protocols];
        }
      }

      initAsClient(_assertThisInitialized(_this), address, protocols, options);
    } else {
      _this._isServer = true;
    }

    return _this;
  }
  /**
   * This deviates from the WHATWG interface since ws doesn't support the
   * required default "blob" type (instead we define a custom "nodebuffer"
   * type).
   *
   * @type {String}
   */


  _createClass(WebSocket, [{
    key: "binaryType",
    get: function get() {
      return this._binaryType;
    },
    set: function set(type) {
      if (!BINARY_TYPES.includes(type)) return;
      this._binaryType = type; //
      // Allow to change `binaryType` on the fly.
      //

      if (this._receiver) this._receiver._binaryType = type;
    }
    /**
     * @type {Number}
     */

  }, {
    key: "bufferedAmount",
    get: function get() {
      if (!this._socket) return this._bufferedAmount;
      return this._socket._writableState.length + this._sender._bufferedBytes;
    }
    /**
     * @type {String}
     */

  }, {
    key: "extensions",
    get: function get() {
      return Object.keys(this._extensions).join();
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onclose",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onerror",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onopen",
    get: function get() {
      return null;
    }
    /**
     * @type {Function}
     */

    /* istanbul ignore next */

  }, {
    key: "onmessage",
    get: function get() {
      return null;
    }
    /**
     * @type {String}
     */

  }, {
    key: "protocol",
    get: function get() {
      return this._protocol;
    }
    /**
     * @type {Number}
     */

  }, {
    key: "readyState",
    get: function get() {
      return this._readyState;
    }
    /**
     * @type {String}
     */

  }, {
    key: "url",
    get: function get() {
      return this._url;
    }
    /**
     * Set up the socket and the internal resources.
     *
     * @param {(net.Socket|tls.Socket)} socket The network socket between the
     *     server and client
     * @param {Buffer} head The first packet of the upgraded stream
     * @param {Object} options Options object
     * @param {Number} [options.maxPayload=0] The maximum allowed message size
     * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
     *     not to skip UTF-8 validation for text and close messages
     * @private
     */

  }, {
    key: "setSocket",
    value: function setSocket(socket, head, options) {
      var receiver = new Receiver({
        binaryType: this.binaryType,
        extensions: this._extensions,
        isServer: this._isServer,
        maxPayload: options.maxPayload,
        skipUTF8Validation: options.skipUTF8Validation
      });
      this._sender = new Sender(socket, this._extensions);
      this._receiver = receiver;
      this._socket = socket;
      receiver[kWebSocket] = this;
      socket[kWebSocket] = this;
      receiver.on('conclude', receiverOnConclude);
      receiver.on('drain', receiverOnDrain);
      receiver.on('error', receiverOnError);
      receiver.on('message', receiverOnMessage);
      receiver.on('ping', receiverOnPing);
      receiver.on('pong', receiverOnPong);
      socket.setTimeout(0);
      socket.setNoDelay();
      if (head.length > 0) socket.unshift(head);
      socket.on('close', socketOnClose);
      socket.on('data', socketOnData);
      socket.on('end', socketOnEnd);
      socket.on('error', socketOnError);
      this._readyState = WebSocket.OPEN;
      this.emit('open');
    }
    /**
     * Emit the `'close'` event.
     *
     * @private
     */

  }, {
    key: "emitClose",
    value: function emitClose() {
      if (!this._socket) {
        this._readyState = WebSocket.CLOSED;
        this.emit('close', this._closeCode, this._closeMessage);
        return;
      }

      if (this._extensions[PerMessageDeflate.extensionName]) {
        this._extensions[PerMessageDeflate.extensionName].cleanup();
      }

      this._receiver.removeAllListeners();

      this._readyState = WebSocket.CLOSED;
      this.emit('close', this._closeCode, this._closeMessage);
    }
    /**
     * Start a closing handshake.
     *
     *          +----------+   +-----------+   +----------+
     *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
     *    |     +----------+   +-----------+   +----------+     |
     *          +----------+   +-----------+         |
     * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
     *          +----------+   +-----------+   |
     *    |           |                        |   +---+        |
     *                +------------------------+-->|fin| - - - -
     *    |         +---+                      |   +---+
     *     - - - - -|fin|<---------------------+
     *              +---+
     *
     * @param {Number} [code] Status code explaining why the connection is closing
     * @param {(String|Buffer)} [data] The reason why the connection is
     *     closing
     * @public
     */

  }, {
    key: "close",
    value: function close(code, data) {
      var _this2 = this;

      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake(this, this._req, msg);
      }

      if (this.readyState === WebSocket.CLOSING) {
        if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
          this._socket.end();
        }

        return;
      }

      this._readyState = WebSocket.CLOSING;

      this._sender.close(code, data, !this._isServer, function (err) {
        //
        // This error is handled by the `'error'` listener on the socket. We only
        // want to know if the close frame has been sent here.
        //
        if (err) return;
        _this2._closeFrameSent = true;

        if (_this2._closeFrameReceived || _this2._receiver._writableState.errorEmitted) {
          _this2._socket.end();
        }
      }); //
      // Specify a timeout for the closing handshake to complete.
      //


      this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
    }
    /**
     * Send a ping.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the ping is sent
     * @public
     */

  }, {
    key: "ping",
    value: function ping(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.ping(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a pong.
     *
     * @param {*} [data] The data to send
     * @param {Boolean} [mask] Indicates whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when the pong is sent
     * @public
     */

  }, {
    key: "pong",
    value: function pong(data, mask, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof data === 'function') {
        cb = data;
        data = mask = undefined;
      } else if (typeof mask === 'function') {
        cb = mask;
        mask = undefined;
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      if (mask === undefined) mask = !this._isServer;

      this._sender.pong(data || EMPTY_BUFFER, mask, cb);
    }
    /**
     * Send a data message.
     *
     * @param {*} data The message to send
     * @param {Object} [options] Options object
     * @param {Boolean} [options.binary] Specifies whether `data` is binary or
     *     text
     * @param {Boolean} [options.compress] Specifies whether or not to compress
     *     `data`
     * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
     *     last one
     * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
     * @param {Function} [cb] Callback which is executed when data is written out
     * @public
     */

  }, {
    key: "send",
    value: function send(data, options, cb) {
      if (this.readyState === WebSocket.CONNECTING) {
        throw new Error('WebSocket is not open: readyState 0 (CONNECTING)');
      }

      if (typeof options === 'function') {
        cb = options;
        options = {};
      }

      if (typeof data === 'number') data = data.toString();

      if (this.readyState !== WebSocket.OPEN) {
        sendAfterClose(this, data, cb);
        return;
      }

      var opts = _objectSpread({
        binary: typeof data !== 'string',
        mask: !this._isServer,
        compress: true,
        fin: true
      }, options);

      if (!this._extensions[PerMessageDeflate.extensionName]) {
        opts.compress = false;
      }

      this._sender.send(data || EMPTY_BUFFER, opts, cb);
    }
    /**
     * Forcibly close the connection.
     *
     * @public
     */

  }, {
    key: "terminate",
    value: function terminate() {
      if (this.readyState === WebSocket.CLOSED) return;

      if (this.readyState === WebSocket.CONNECTING) {
        var msg = 'WebSocket was closed before the connection was established';
        return abortHandshake(this, this._req, msg);
      }

      if (this._socket) {
        this._readyState = WebSocket.CLOSING;

        this._socket.destroy();
      }
    }
  }]);

  return WebSocket;
}(EventEmitter);
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket
 */


Object.defineProperty(WebSocket, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} CONNECTING
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CONNECTING', {
  enumerable: true,
  value: readyStates.indexOf('CONNECTING')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} OPEN
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'OPEN', {
  enumerable: true,
  value: readyStates.indexOf('OPEN')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSING
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CLOSING', {
  enumerable: true,
  value: readyStates.indexOf('CLOSING')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket
 */

Object.defineProperty(WebSocket, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});
/**
 * @constant {Number} CLOSED
 * @memberof WebSocket.prototype
 */

Object.defineProperty(WebSocket.prototype, 'CLOSED', {
  enumerable: true,
  value: readyStates.indexOf('CLOSED')
});
['binaryType', 'bufferedAmount', 'extensions', 'protocol', 'readyState', 'url'].forEach(function (property) {
  Object.defineProperty(WebSocket.prototype, property, {
    enumerable: true
  });
}); //
// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.
// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface
//

['open', 'error', 'close', 'message'].forEach(function (method) {
  Object.defineProperty(WebSocket.prototype, "on".concat(method), {
    enumerable: true,
    get: function get() {
      var _iterator = _createForOfIteratorHelper(this.listeners(method)),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var listener = _step.value;
          if (listener[kForOnEventAttribute]) return listener[kListener];
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return null;
    },
    set: function set(handler) {
      var _iterator2 = _createForOfIteratorHelper(this.listeners(method)),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var listener = _step2.value;

          if (listener[kForOnEventAttribute]) {
            this.removeListener(method, listener);
            break;
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      if (typeof handler !== 'function') return;
      this.addEventListener(method, handler, _defineProperty({}, kForOnEventAttribute, true));
    }
  });
});
WebSocket.prototype.addEventListener = addEventListener;
WebSocket.prototype.removeEventListener = removeEventListener;
module.exports = WebSocket;
/**
 * Initialize a WebSocket client.
 *
 * @param {WebSocket} websocket The client to initialize
 * @param {(String|URL)} address The URL to which to connect
 * @param {Array} protocols The subprotocols
 * @param {Object} [options] Connection options
 * @param {Boolean} [options.followRedirects=false] Whether or not to follow
 *     redirects
 * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the
 *     handshake request
 * @param {Number} [options.maxPayload=104857600] The maximum allowed message
 *     size
 * @param {Number} [options.maxRedirects=10] The maximum number of redirects
 *     allowed
 * @param {String} [options.origin] Value of the `Origin` or
 *     `Sec-WebSocket-Origin` header
 * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable
 *     permessage-deflate
 * @param {Number} [options.protocolVersion=13] Value of the
 *     `Sec-WebSocket-Version` header
 * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
 *     not to skip UTF-8 validation for text and close messages
 * @private
 */

function initAsClient(websocket, address, protocols, options) {
  var opts = _objectSpread(_objectSpread({
    protocolVersion: protocolVersions[1],
    maxPayload: 100 * 1024 * 1024,
    skipUTF8Validation: false,
    perMessageDeflate: true,
    followRedirects: false,
    maxRedirects: 10
  }, options), {}, {
    createConnection: undefined,
    socketPath: undefined,
    hostname: undefined,
    protocol: undefined,
    timeout: undefined,
    method: undefined,
    host: undefined,
    path: undefined,
    port: undefined
  });

  if (!protocolVersions.includes(opts.protocolVersion)) {
    throw new RangeError("Unsupported protocol version: ".concat(opts.protocolVersion, " ") + "(supported versions: ".concat(protocolVersions.join(', '), ")"));
  }

  var parsedUrl;

  if (address instanceof URL) {
    parsedUrl = address;
    websocket._url = address.href;
  } else {
    try {
      parsedUrl = new URL(address);
    } catch (e) {
      throw new SyntaxError("Invalid URL: ".concat(address));
    }

    websocket._url = address;
  }

  var isSecure = parsedUrl.protocol === 'wss:';
  var isUnixSocket = parsedUrl.protocol === 'ws+unix:';

  if (parsedUrl.protocol !== 'ws:' && !isSecure && !isUnixSocket) {
    throw new SyntaxError('The URL\'s protocol must be one of "ws:", "wss:", or "ws+unix:"');
  }

  if (isUnixSocket && !parsedUrl.pathname) {
    throw new SyntaxError("The URL's pathname is empty");
  }

  if (parsedUrl.hash) {
    throw new SyntaxError('The URL contains a fragment identifier');
  }

  var defaultPort = isSecure ? 443 : 80;
  var key = randomBytes(16).toString('base64');
  var get = isSecure ? https.get : http.get;
  var protocolSet = new Set();
  var perMessageDeflate;
  opts.createConnection = isSecure ? tlsConnect : netConnect;
  opts.defaultPort = opts.defaultPort || defaultPort;
  opts.port = parsedUrl.port || defaultPort;
  opts.host = parsedUrl.hostname.startsWith('[') ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
  opts.headers = _objectSpread({
    'Sec-WebSocket-Version': opts.protocolVersion,
    'Sec-WebSocket-Key': key,
    Connection: 'Upgrade',
    Upgrade: 'websocket'
  }, opts.headers);
  opts.path = parsedUrl.pathname + parsedUrl.search;
  opts.timeout = opts.handshakeTimeout;

  if (opts.perMessageDeflate) {
    perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
    opts.headers['Sec-WebSocket-Extensions'] = format(_defineProperty({}, PerMessageDeflate.extensionName, perMessageDeflate.offer()));
  }

  if (protocols.length) {
    var _iterator3 = _createForOfIteratorHelper(protocols),
        _step3;

    try {
      for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
        var protocol = _step3.value;

        if (typeof protocol !== 'string' || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {
          throw new SyntaxError('An invalid or duplicated subprotocol was specified');
        }

        protocolSet.add(protocol);
      }
    } catch (err) {
      _iterator3.e(err);
    } finally {
      _iterator3.f();
    }

    opts.headers['Sec-WebSocket-Protocol'] = protocols.join(',');
  }

  if (opts.origin) {
    if (opts.protocolVersion < 13) {
      opts.headers['Sec-WebSocket-Origin'] = opts.origin;
    } else {
      opts.headers.Origin = opts.origin;
    }
  }

  if (parsedUrl.username || parsedUrl.password) {
    opts.auth = "".concat(parsedUrl.username, ":").concat(parsedUrl.password);
  }

  if (isUnixSocket) {
    var parts = opts.path.split(':');
    opts.socketPath = parts[0];
    opts.path = parts[1];
  }

  var req = websocket._req = get(opts);

  if (opts.timeout) {
    req.on('timeout', function () {
      abortHandshake(websocket, req, 'Opening handshake has timed out');
    });
  }

  req.on('error', function (err) {
    if (req === null || req.aborted) return;
    req = websocket._req = null;
    websocket._readyState = WebSocket.CLOSING;
    websocket.emit('error', err);
    websocket.emitClose();
  });
  req.on('response', function (res) {
    var location = res.headers.location;
    var statusCode = res.statusCode;

    if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
      if (++websocket._redirects > opts.maxRedirects) {
        abortHandshake(websocket, req, 'Maximum redirects exceeded');
        return;
      }

      req.abort();
      var addr = new URL(location, address);
      initAsClient(websocket, addr, protocols, options);
    } else if (!websocket.emit('unexpected-response', req, res)) {
      abortHandshake(websocket, req, "Unexpected server response: ".concat(res.statusCode));
    }
  });
  req.on('upgrade', function (res, socket, head) {
    websocket.emit('upgrade', res); //
    // The user may have closed the connection from a listener of the `upgrade`
    // event.
    //

    if (websocket.readyState !== WebSocket.CONNECTING) return;
    req = websocket._req = null;
    var digest = createHash('sha1').update(key + GUID).digest('base64');

    if (res.headers['sec-websocket-accept'] !== digest) {
      abortHandshake(websocket, socket, 'Invalid Sec-WebSocket-Accept header');
      return;
    }

    var serverProt = res.headers['sec-websocket-protocol'];
    var protError;

    if (serverProt !== undefined) {
      if (!protocolSet.size) {
        protError = 'Server sent a subprotocol but none was requested';
      } else if (!protocolSet.has(serverProt)) {
        protError = 'Server sent an invalid subprotocol';
      }
    } else if (protocolSet.size) {
      protError = 'Server sent no subprotocol';
    }

    if (protError) {
      abortHandshake(websocket, socket, protError);
      return;
    }

    if (serverProt) websocket._protocol = serverProt;
    var secWebSocketExtensions = res.headers['sec-websocket-extensions'];

    if (secWebSocketExtensions !== undefined) {
      if (!perMessageDeflate) {
        var message = 'Server sent a Sec-WebSocket-Extensions header but no extension ' + 'was requested';
        abortHandshake(websocket, socket, message);
        return;
      }

      var extensions;

      try {
        extensions = parse(secWebSocketExtensions);
      } catch (err) {
        var _message = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, _message);
        return;
      }

      var extensionNames = Object.keys(extensions);

      if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
        var _message2 = 'Server indicated an extension that was not requested';
        abortHandshake(websocket, socket, _message2);
        return;
      }

      try {
        perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
      } catch (err) {
        var _message3 = 'Invalid Sec-WebSocket-Extensions header';
        abortHandshake(websocket, socket, _message3);
        return;
      }

      websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
    }

    websocket.setSocket(socket, head, {
      maxPayload: opts.maxPayload,
      skipUTF8Validation: opts.skipUTF8Validation
    });
  });
}
/**
 * Create a `net.Socket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {net.Socket} The newly created socket used to start the connection
 * @private
 */


function netConnect(options) {
  options.path = options.socketPath;
  return net.connect(options);
}
/**
 * Create a `tls.TLSSocket` and initiate a connection.
 *
 * @param {Object} options Connection options
 * @return {tls.TLSSocket} The newly created socket used to start the connection
 * @private
 */


function tlsConnect(options) {
  options.path = undefined;

  if (!options.servername && options.servername !== '') {
    options.servername = net.isIP(options.host) ? '' : options.host;
  }

  return tls.connect(options);
}
/**
 * Abort the handshake and emit an error.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to
 *     abort or the socket to destroy
 * @param {String} message The error message
 * @private
 */


function abortHandshake(websocket, stream, message) {
  websocket._readyState = WebSocket.CLOSING;
  var err = new Error(message);
  Error.captureStackTrace(err, abortHandshake);

  if (stream.setHeader) {
    stream.abort();

    if (stream.socket && !stream.socket.destroyed) {
      //
      // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if
      // called after the request completed. See
      // https://github.com/websockets/ws/issues/1869.
      //
      stream.socket.destroy();
    }

    stream.once('abort', websocket.emitClose.bind(websocket));
    websocket.emit('error', err);
  } else {
    stream.destroy(err);
    stream.once('error', websocket.emit.bind(websocket, 'error'));
    stream.once('close', websocket.emitClose.bind(websocket));
  }
}
/**
 * Handle cases where the `ping()`, `pong()`, or `send()` methods are called
 * when the `readyState` attribute is `CLOSING` or `CLOSED`.
 *
 * @param {WebSocket} websocket The WebSocket instance
 * @param {*} [data] The data to send
 * @param {Function} [cb] Callback
 * @private
 */


function sendAfterClose(websocket, data, cb) {
  if (data) {
    var length = toBuffer(data).length; //
    // The `_bufferedAmount` property is used only when the peer is a client and
    // the opening handshake fails. Under these circumstances, in fact, the
    // `setSocket()` method is not called, so the `_socket` and `_sender`
    // properties are set to `null`.
    //

    if (websocket._socket) websocket._sender._bufferedBytes += length;else websocket._bufferedAmount += length;
  }

  if (cb) {
    var err = new Error("WebSocket is not open: readyState ".concat(websocket.readyState, " ") + "(".concat(readyStates[websocket.readyState], ")"));
    cb(err);
  }
}
/**
 * The listener of the `Receiver` `'conclude'` event.
 *
 * @param {Number} code The status code
 * @param {Buffer} reason The reason for closing
 * @private
 */


function receiverOnConclude(code, reason) {
  var websocket = this[kWebSocket];
  websocket._closeFrameReceived = true;
  websocket._closeMessage = reason;
  websocket._closeCode = code;
  if (websocket._socket[kWebSocket] === undefined) return;

  websocket._socket.removeListener('data', socketOnData);

  process.nextTick(resume, websocket._socket);
  if (code === 1005) websocket.close();else websocket.close(code, reason);
}
/**
 * The listener of the `Receiver` `'drain'` event.
 *
 * @private
 */


function receiverOnDrain() {
  this[kWebSocket]._socket.resume();
}
/**
 * The listener of the `Receiver` `'error'` event.
 *
 * @param {(RangeError|Error)} err The emitted error
 * @private
 */


function receiverOnError(err) {
  var websocket = this[kWebSocket];

  if (websocket._socket[kWebSocket] !== undefined) {
    websocket._socket.removeListener('data', socketOnData); //
    // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See
    // https://github.com/websockets/ws/issues/1940.
    //


    process.nextTick(resume, websocket._socket);
    websocket.close(err[kStatusCode]);
  }

  websocket.emit('error', err);
}
/**
 * The listener of the `Receiver` `'finish'` event.
 *
 * @private
 */


function receiverOnFinish() {
  this[kWebSocket].emitClose();
}
/**
 * The listener of the `Receiver` `'message'` event.
 *
 * @param {Buffer|ArrayBuffer|Buffer[])} data The message
 * @param {Boolean} isBinary Specifies whether the message is binary or not
 * @private
 */


function receiverOnMessage(data, isBinary) {
  this[kWebSocket].emit('message', data, isBinary);
}
/**
 * The listener of the `Receiver` `'ping'` event.
 *
 * @param {Buffer} data The data included in the ping frame
 * @private
 */


function receiverOnPing(data) {
  var websocket = this[kWebSocket];
  websocket.pong(data, !websocket._isServer, NOOP);
  websocket.emit('ping', data);
}
/**
 * The listener of the `Receiver` `'pong'` event.
 *
 * @param {Buffer} data The data included in the pong frame
 * @private
 */


function receiverOnPong(data) {
  this[kWebSocket].emit('pong', data);
}
/**
 * Resume a readable stream
 *
 * @param {Readable} stream The readable stream
 * @private
 */


function resume(stream) {
  stream.resume();
}
/**
 * The listener of the `net.Socket` `'close'` event.
 *
 * @private
 */


function socketOnClose() {
  var websocket = this[kWebSocket];
  this.removeListener('close', socketOnClose);
  this.removeListener('data', socketOnData);
  this.removeListener('end', socketOnEnd);
  websocket._readyState = WebSocket.CLOSING;
  var chunk; //
  // The close frame might not have been received or the `'end'` event emitted,
  // for example, if the socket was destroyed due to an error. Ensure that the
  // `receiver` stream is closed after writing any remaining buffered data to
  // it. If the readable side of the socket is in flowing mode then there is no
  // buffered data as everything has been already written and `readable.read()`
  // will return `null`. If instead, the socket is paused, any possible buffered
  // data will be read as a single chunk.
  //

  if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
    websocket._receiver.write(chunk);
  }

  websocket._receiver.end();

  this[kWebSocket] = undefined;
  clearTimeout(websocket._closeTimer);

  if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
    websocket.emitClose();
  } else {
    websocket._receiver.on('error', receiverOnFinish);

    websocket._receiver.on('finish', receiverOnFinish);
  }
}
/**
 * The listener of the `net.Socket` `'data'` event.
 *
 * @param {Buffer} chunk A chunk of data
 * @private
 */


function socketOnData(chunk) {
  if (!this[kWebSocket]._receiver.write(chunk)) {
    this.pause();
  }
}
/**
 * The listener of the `net.Socket` `'end'` event.
 *
 * @private
 */


function socketOnEnd() {
  var websocket = this[kWebSocket];
  websocket._readyState = WebSocket.CLOSING;

  websocket._receiver.end();

  this.end();
}
/**
 * The listener of the `net.Socket` `'error'` event.
 *
 * @private
 */


function socketOnError() {
  var websocket = this[kWebSocket];
  this.removeListener('error', socketOnError);
  this.on('error', NOOP);

  if (websocket) {
    websocket._readyState = WebSocket.CLOSING;
    this.destroy();
  }
}

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/commons.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/commons.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ERROR_PACKET = exports.PACKET_TYPES_REVERSE = exports.PACKET_TYPES = void 0;
var PACKET_TYPES = Object.create(null); // no Map = no polyfill

exports.PACKET_TYPES = PACKET_TYPES;
PACKET_TYPES["open"] = "0";
PACKET_TYPES["close"] = "1";
PACKET_TYPES["ping"] = "2";
PACKET_TYPES["pong"] = "3";
PACKET_TYPES["message"] = "4";
PACKET_TYPES["upgrade"] = "5";
PACKET_TYPES["noop"] = "6";
var PACKET_TYPES_REVERSE = Object.create(null);
exports.PACKET_TYPES_REVERSE = PACKET_TYPES_REVERSE;
Object.keys(PACKET_TYPES).forEach(function (key) {
  PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
});
var ERROR_PACKET = {
  type: "error",
  data: "parser error"
};
exports.ERROR_PACKET = ERROR_PACKET;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var commons_js_1 = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/cjs/commons.js");

var base64_arraybuffer_1 = __webpack_require__(/*! @socket.io/base64-arraybuffer */ "./node_modules/@socket.io/base64-arraybuffer/dist/base64-arraybuffer.es5.js");

var withNativeArrayBuffer = typeof ArrayBuffer === "function";

var decodePacket = function decodePacket(encodedPacket, binaryType) {
  if (typeof encodedPacket !== "string") {
    return {
      type: "message",
      data: mapBinary(encodedPacket, binaryType)
    };
  }

  var type = encodedPacket.charAt(0);

  if (type === "b") {
    return {
      type: "message",
      data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
    };
  }

  var packetType = commons_js_1.PACKET_TYPES_REVERSE[type];

  if (!packetType) {
    return commons_js_1.ERROR_PACKET;
  }

  return encodedPacket.length > 1 ? {
    type: commons_js_1.PACKET_TYPES_REVERSE[type],
    data: encodedPacket.substring(1)
  } : {
    type: commons_js_1.PACKET_TYPES_REVERSE[type]
  };
};

var decodeBase64Packet = function decodeBase64Packet(data, binaryType) {
  if (withNativeArrayBuffer) {
    var decoded = (0, base64_arraybuffer_1.decode)(data);
    return mapBinary(decoded, binaryType);
  } else {
    return {
      base64: true,
      data: data
    }; // fallback for old browsers
  }
};

var mapBinary = function mapBinary(data, binaryType) {
  switch (binaryType) {
    case "blob":
      return data instanceof ArrayBuffer ? new Blob([data]) : data;

    case "arraybuffer":
    default:
      return data;
    // assuming the data is already an ArrayBuffer
  }
};

exports["default"] = decodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js":
/*!*************************************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var commons_js_1 = __webpack_require__(/*! ./commons.js */ "./node_modules/engine.io-parser/build/cjs/commons.js");

var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
var withNativeArrayBuffer = typeof ArrayBuffer === "function"; // ArrayBuffer.isView method is not defined in IE10

var isView = function isView(obj) {
  return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
};

var encodePacket = function encodePacket(_ref, supportsBinary, callback) {
  var type = _ref.type,
      data = _ref.data;

  if (withNativeBlob && data instanceof Blob) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(data, callback);
    }
  } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
    if (supportsBinary) {
      return callback(data);
    } else {
      return encodeBlobAsBase64(new Blob([data]), callback);
    }
  } // plain string


  return callback(commons_js_1.PACKET_TYPES[type] + (data || ""));
};

var encodeBlobAsBase64 = function encodeBlobAsBase64(data, callback) {
  var fileReader = new FileReader();

  fileReader.onload = function () {
    var content = fileReader.result.split(",")[1];
    callback("b" + content);
  };

  return fileReader.readAsDataURL(data);
};

exports["default"] = encodePacket;

/***/ }),

/***/ "./node_modules/engine.io-parser/build/cjs/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io-parser/build/cjs/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodePayload = exports.decodePacket = exports.encodePayload = exports.encodePacket = exports.protocol = void 0;

var encodePacket_js_1 = __webpack_require__(/*! ./encodePacket.js */ "./node_modules/engine.io-parser/build/cjs/encodePacket.browser.js");

exports.encodePacket = encodePacket_js_1["default"];

var decodePacket_js_1 = __webpack_require__(/*! ./decodePacket.js */ "./node_modules/engine.io-parser/build/cjs/decodePacket.browser.js");

exports.decodePacket = decodePacket_js_1["default"];
var SEPARATOR = String.fromCharCode(30); // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var encodePayload = function encodePayload(packets, callback) {
  // some packets may be added to the array while encoding, so the initial length must be saved
  var length = packets.length;
  var encodedPackets = new Array(length);
  var count = 0;
  packets.forEach(function (packet, i) {
    // force base64 encoding for binary packets
    (0, encodePacket_js_1["default"])(packet, false, function (encodedPacket) {
      encodedPackets[i] = encodedPacket;

      if (++count === length) {
        callback(encodedPackets.join(SEPARATOR));
      }
    });
  });
};

exports.encodePayload = encodePayload;

var decodePayload = function decodePayload(encodedPayload, binaryType) {
  var encodedPackets = encodedPayload.split(SEPARATOR);
  var packets = [];

  for (var i = 0; i < encodedPackets.length; i++) {
    var decodedPacket = (0, decodePacket_js_1["default"])(encodedPackets[i], binaryType);
    packets.push(decodedPacket);

    if (decodedPacket.type === "error") {
      break;
    }
  }

  return packets;
};

exports.decodePayload = decodePayload;
exports.protocol = 4;

/***/ }),

/***/ "./node_modules/engine.io/build/engine.io.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/engine.io.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.protocol = exports.Transport = exports.Socket = exports.uServer = exports.parser = exports.attach = exports.listen = exports.transports = exports.Server = void 0;

var http_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var server_1 = __webpack_require__(/*! ./server */ "./node_modules/engine.io/build/server.js");

Object.defineProperty(exports, "Server", ({
  enumerable: true,
  get: function get() {
    return server_1.Server;
  }
}));

var index_1 = __webpack_require__(/*! ./transports/index */ "./node_modules/engine.io/build/transports/index.js");

exports.transports = index_1["default"];

var parser = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/cjs/index.js");

exports.parser = parser;

var userver_1 = __webpack_require__(/*! ./userver */ "./node_modules/engine.io/build/userver.js");

Object.defineProperty(exports, "uServer", ({
  enumerable: true,
  get: function get() {
    return userver_1.uServer;
  }
}));

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/engine.io/build/socket.js");

Object.defineProperty(exports, "Socket", ({
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
}));

var transport_1 = __webpack_require__(/*! ./transport */ "./node_modules/engine.io/build/transport.js");

Object.defineProperty(exports, "Transport", ({
  enumerable: true,
  get: function get() {
    return transport_1.Transport;
  }
}));
exports.protocol = parser.protocol;
/**
 * Creates an http.Server exclusively used for WS upgrades.
 *
 * @param {Number} port
 * @param {Function} callback
 * @param {Object} options
 * @return {Server} websocket.io server
 * @api public
 */

function listen(port, options, fn) {
  if ("function" === typeof options) {
    fn = options;
    options = {};
  }

  var server = (0, http_1.createServer)(function (req, res) {
    res.writeHead(501);
    res.end("Not Implemented");
  }); // create engine server

  var engine = attach(server, options);
  engine.httpServer = server;
  server.listen(port, fn);
  return engine;
}

exports.listen = listen;
/**
 * Captures upgrade requests for a http.Server.
 *
 * @param {http.Server} server
 * @param {Object} options
 * @return {Server} engine server
 * @api public
 */

function attach(server, options) {
  var engine = new server_1.Server(options);
  engine.attach(server, options);
  return engine;
}

exports.attach = attach;

/***/ }),

/***/ "./node_modules/engine.io/build/parser-v3/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/index.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

 // imported from https://github.com/socketio/engine.io-parser/tree/2.2.x

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.decodePayloadAsBinary = exports.encodePayloadAsBinary = exports.decodePayload = exports.encodePayload = exports.decodeBase64Packet = exports.decodePacket = exports.encodeBase64Packet = exports.encodePacket = exports.packets = exports.protocol = void 0;
/**
 * Module dependencies.
 */

var utf8 = __webpack_require__(/*! ./utf8 */ "./node_modules/engine.io/build/parser-v3/utf8.js");
/**
 * Current protocol version.
 */


exports.protocol = 3;

var hasBinary = function hasBinary(packets) {
  var _iterator = _createForOfIteratorHelper(packets),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var packet = _step.value;

      if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
        return true;
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
};
/**
 * Packet types.
 */


exports.packets = {
  open: 0 // non-ws
  ,
  close: 1 // non-ws
  ,
  ping: 2,
  pong: 3,
  message: 4,
  upgrade: 5,
  noop: 6
};
var packetslist = Object.keys(exports.packets);
/**
 * Premade error packet.
 */

var err = {
  type: 'error',
  data: 'parser error'
};
var EMPTY_BUFFER = Buffer.concat([]);
/**
 * Encodes a packet.
 *
 *     <packet type id> [ <data> ]
 *
 * Example:
 *
 *     5hello world
 *     3
 *     4
 *
 * Binary is encoded in an identical principle
 *
 * @api private
 */

function encodePacket(packet, supportsBinary, utf8encode, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (typeof utf8encode === 'function') {
    callback = utf8encode;
    utf8encode = null;
  }

  if (Buffer.isBuffer(packet.data)) {
    return encodeBuffer(packet, supportsBinary, callback);
  } else if (packet.data && (packet.data.buffer || packet.data) instanceof ArrayBuffer) {
    return encodeBuffer({
      type: packet.type,
      data: arrayBufferToBuffer(packet.data)
    }, supportsBinary, callback);
  } // Sending data as a utf-8 string


  var encoded = exports.packets[packet.type]; // data fragment is optional

  if (undefined !== packet.data) {
    encoded += utf8encode ? utf8.encode(String(packet.data), {
      strict: false
    }) : String(packet.data);
  }

  return callback('' + encoded);
}

exports.encodePacket = encodePacket;
;
/**
 * Encode Buffer data
 */

function encodeBuffer(packet, supportsBinary, callback) {
  if (!supportsBinary) {
    return encodeBase64Packet(packet, callback);
  }

  var data = packet.data;
  var typeBuffer = Buffer.allocUnsafe(1);
  typeBuffer[0] = exports.packets[packet.type];
  return callback(Buffer.concat([typeBuffer, data]));
}
/**
 * Encodes a packet with binary data in a base64 string
 *
 * @param {Object} packet, has `type` and `data`
 * @return {String} base64 encoded message
 */


function encodeBase64Packet(packet, callback) {
  var data = Buffer.isBuffer(packet.data) ? packet.data : arrayBufferToBuffer(packet.data);
  var message = 'b' + exports.packets[packet.type];
  message += data.toString('base64');
  return callback(message);
}

exports.encodeBase64Packet = encodeBase64Packet;
;
/**
 * Decodes a packet. Data also available as an ArrayBuffer if requested.
 *
 * @return {Object} with `type` and `data` (if any)
 * @api private
 */

function decodePacket(data, binaryType, utf8decode) {
  if (data === undefined) {
    return err;
  }

  var type; // String data

  if (typeof data === 'string') {
    type = data.charAt(0);

    if (type === 'b') {
      return decodeBase64Packet(data.substr(1), binaryType);
    }

    if (utf8decode) {
      data = tryDecode(data);

      if (data === false) {
        return err;
      }
    }

    if (Number(type) != type || !packetslist[type]) {
      return err;
    }

    if (data.length > 1) {
      return {
        type: packetslist[type],
        data: data.substring(1)
      };
    } else {
      return {
        type: packetslist[type]
      };
    }
  } // Binary data


  if (binaryType === 'arraybuffer') {
    // wrap Buffer/ArrayBuffer data into an Uint8Array
    var intArray = new Uint8Array(data);
    type = intArray[0];
    return {
      type: packetslist[type],
      data: intArray.buffer.slice(1)
    };
  }

  if (data instanceof ArrayBuffer) {
    data = arrayBufferToBuffer(data);
  }

  type = data[0];
  return {
    type: packetslist[type],
    data: data.slice(1)
  };
}

exports.decodePacket = decodePacket;
;

function tryDecode(data) {
  try {
    data = utf8.decode(data, {
      strict: false
    });
  } catch (e) {
    return false;
  }

  return data;
}
/**
 * Decodes a packet encoded in a base64 string.
 *
 * @param {String} base64 encoded message
 * @return {Object} with `type` and `data` (if any)
 */


function decodeBase64Packet(msg, binaryType) {
  var type = packetslist[msg.charAt(0)];
  var data = Buffer.from(msg.substr(1), 'base64');

  if (binaryType === 'arraybuffer') {
    var abv = new Uint8Array(data.length);

    for (var i = 0; i < abv.length; i++) {
      abv[i] = data[i];
    } // @ts-ignore


    data = abv.buffer;
  }

  return {
    type: type,
    data: data
  };
}

exports.decodeBase64Packet = decodeBase64Packet;
;
/**
 * Encodes multiple messages (payload).
 *
 *     <length>:data
 *
 * Example:
 *
 *     11:hello world2:hi
 *
 * If any contents are binary, they will be encoded as base64 strings. Base64
 * encoded strings are marked with a b before the length specifier
 *
 * @param {Array} packets
 * @api private
 */

function encodePayload(packets, supportsBinary, callback) {
  if (typeof supportsBinary === 'function') {
    callback = supportsBinary;
    supportsBinary = null;
  }

  if (supportsBinary && hasBinary(packets)) {
    return encodePayloadAsBinary(packets, callback);
  }

  if (!packets.length) {
    return callback('0:');
  }

  function encodeOne(packet, doneCallback) {
    encodePacket(packet, supportsBinary, false, function (message) {
      doneCallback(null, setLengthHeader(message));
    });
  }

  map(packets, encodeOne, function (err, results) {
    return callback(results.join(''));
  });
}

exports.encodePayload = encodePayload;
;

function setLengthHeader(message) {
  return message.length + ':' + message;
}
/**
 * Async array map using after
 */


function map(ary, each, done) {
  var results = new Array(ary.length);
  var count = 0;

  var _loop = function _loop(i) {
    each(ary[i], function (error, msg) {
      results[i] = msg;

      if (++count === ary.length) {
        done(null, results);
      }
    });
  };

  for (var i = 0; i < ary.length; i++) {
    _loop(i);
  }
}
/*
 * Decodes data when a payload is maybe expected. Possible binary contents are
 * decoded from their base64 representation
 *
 * @param {String} data, callback method
 * @api public
 */


function decodePayload(data, binaryType, callback) {
  if (typeof data !== 'string') {
    return decodePayloadAsBinary(data, binaryType, callback);
  }

  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  if (data === '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }

  var length = '',
      n,
      msg,
      packet;

  for (var i = 0, l = data.length; i < l; i++) {
    var chr = data.charAt(i);

    if (chr !== ':') {
      length += chr;
      continue;
    } // @ts-ignore


    if (length === '' || length != (n = Number(length))) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    msg = data.substr(i + 1, n);

    if (length != msg.length) {
      // parser error - ignoring payload
      return callback(err, 0, 1);
    }

    if (msg.length) {
      packet = decodePacket(msg, binaryType, false);

      if (err.type === packet.type && err.data === packet.data) {
        // parser error in individual packet - ignoring payload
        return callback(err, 0, 1);
      }

      var more = callback(packet, i + n, l);
      if (false === more) return;
    } // advance cursor


    i += n;
    length = '';
  }

  if (length !== '') {
    // parser error - ignoring payload
    return callback(err, 0, 1);
  }
}

exports.decodePayload = decodePayload;
;
/**
 *
 * Converts a buffer to a utf8.js encoded string
 *
 * @api private
 */

function bufferToString(buffer) {
  var str = '';

  for (var i = 0, l = buffer.length; i < l; i++) {
    str += String.fromCharCode(buffer[i]);
  }

  return str;
}
/**
 *
 * Converts a utf8.js encoded string to a buffer
 *
 * @api private
 */


function stringToBuffer(string) {
  var buf = Buffer.allocUnsafe(string.length);

  for (var i = 0, l = string.length; i < l; i++) {
    buf.writeUInt8(string.charCodeAt(i), i);
  }

  return buf;
}
/**
 *
 * Converts an ArrayBuffer to a Buffer
 *
 * @api private
 */


function arrayBufferToBuffer(data) {
  // data is either an ArrayBuffer or ArrayBufferView.
  var length = data.byteLength || data.length;
  var offset = data.byteOffset || 0;
  return Buffer.from(data.buffer || data, offset, length);
}
/**
 * Encodes multiple messages (payload) as binary.
 *
 * <1 = binary, 0 = string><number from 0-9><number from 0-9>[...]<number
 * 255><data>
 *
 * Example:
 * 1 3 255 1 2 3, if the binary contents are interpreted as 8 bit integers
 *
 * @param {Array} packets
 * @return {Buffer} encoded payload
 * @api private
 */


function encodePayloadAsBinary(packets, callback) {
  if (!packets.length) {
    return callback(EMPTY_BUFFER);
  }

  map(packets, encodeOneBinaryPacket, function (err, results) {
    return callback(Buffer.concat(results));
  });
}

exports.encodePayloadAsBinary = encodePayloadAsBinary;
;

function encodeOneBinaryPacket(p, doneCallback) {
  function onBinaryPacketEncode(packet) {
    var encodingLength = '' + packet.length;
    var sizeBuffer;

    if (typeof packet === 'string') {
      sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
      sizeBuffer[0] = 0; // is a string (not true binary = 0)

      for (var i = 0; i < encodingLength.length; i++) {
        sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
      }

      sizeBuffer[sizeBuffer.length - 1] = 255;
      return doneCallback(null, Buffer.concat([sizeBuffer, stringToBuffer(packet)]));
    }

    sizeBuffer = Buffer.allocUnsafe(encodingLength.length + 2);
    sizeBuffer[0] = 1; // is binary (true binary = 1)

    for (var i = 0; i < encodingLength.length; i++) {
      sizeBuffer[i + 1] = parseInt(encodingLength[i], 10);
    }

    sizeBuffer[sizeBuffer.length - 1] = 255;
    doneCallback(null, Buffer.concat([sizeBuffer, packet]));
  }

  encodePacket(p, true, true, onBinaryPacketEncode);
}
/*
 * Decodes data when a payload is maybe expected. Strings are decoded by
 * interpreting each byte as a key code for entries marked to start with 0. See
 * description of encodePayloadAsBinary

 * @param {Buffer} data, callback method
 * @api public
 */


function decodePayloadAsBinary(data, binaryType, callback) {
  if (typeof binaryType === 'function') {
    callback = binaryType;
    binaryType = null;
  }

  var bufferTail = data;
  var buffers = [];
  var i;

  while (bufferTail.length > 0) {
    var strLen = '';
    var isString = bufferTail[0] === 0;

    for (i = 1;; i++) {
      if (bufferTail[i] === 255) break; // 310 = char length of Number.MAX_VALUE

      if (strLen.length > 310) {
        return callback(err, 0, 1);
      }

      strLen += '' + bufferTail[i];
    }

    bufferTail = bufferTail.slice(strLen.length + 1);
    var msgLength = parseInt(strLen, 10);
    var msg = bufferTail.slice(1, msgLength + 1);
    if (isString) msg = bufferToString(msg);
    buffers.push(msg);
    bufferTail = bufferTail.slice(msgLength + 1);
  }

  var total = buffers.length;

  for (i = 0; i < total; i++) {
    var buffer = buffers[i];
    callback(decodePacket(buffer, binaryType, true), i, total);
  }
}

exports.decodePayloadAsBinary = decodePayloadAsBinary;
;

/***/ }),

/***/ "./node_modules/engine.io/build/parser-v3/utf8.js":
/*!********************************************************!*\
  !*** ./node_modules/engine.io/build/parser-v3/utf8.js ***!
  \********************************************************/
/***/ ((module) => {

/*! https://mths.be/utf8js v2.1.2 by @mathias */
var stringFromCharCode = String.fromCharCode; // Taken from https://mths.be/punycode

function ucs2decode(string) {
  var output = [];
  var counter = 0;
  var length = string.length;
  var value;
  var extra;

  while (counter < length) {
    value = string.charCodeAt(counter++);

    if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
      // high surrogate, and there is a next character
      extra = string.charCodeAt(counter++);

      if ((extra & 0xFC00) == 0xDC00) {
        // low surrogate
        output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
      } else {
        // unmatched surrogate; only append this code unit, in case the next
        // code unit is the high surrogate of a surrogate pair
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }

  return output;
} // Taken from https://mths.be/punycode


function ucs2encode(array) {
  var length = array.length;
  var index = -1;
  var value;
  var output = '';

  while (++index < length) {
    value = array[index];

    if (value > 0xFFFF) {
      value -= 0x10000;
      output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
      value = 0xDC00 | value & 0x3FF;
    }

    output += stringFromCharCode(value);
  }

  return output;
}

function checkScalarValue(codePoint, strict) {
  if (codePoint >= 0xD800 && codePoint <= 0xDFFF) {
    if (strict) {
      throw Error('Lone surrogate U+' + codePoint.toString(16).toUpperCase() + ' is not a scalar value');
    }

    return false;
  }

  return true;
}
/*--------------------------------------------------------------------------*/


function createByte(codePoint, shift) {
  return stringFromCharCode(codePoint >> shift & 0x3F | 0x80);
}

function encodeCodePoint(codePoint, strict) {
  if ((codePoint & 0xFFFFFF80) == 0) {
    // 1-byte sequence
    return stringFromCharCode(codePoint);
  }

  var symbol = '';

  if ((codePoint & 0xFFFFF800) == 0) {
    // 2-byte sequence
    symbol = stringFromCharCode(codePoint >> 6 & 0x1F | 0xC0);
  } else if ((codePoint & 0xFFFF0000) == 0) {
    // 3-byte sequence
    if (!checkScalarValue(codePoint, strict)) {
      codePoint = 0xFFFD;
    }

    symbol = stringFromCharCode(codePoint >> 12 & 0x0F | 0xE0);
    symbol += createByte(codePoint, 6);
  } else if ((codePoint & 0xFFE00000) == 0) {
    // 4-byte sequence
    symbol = stringFromCharCode(codePoint >> 18 & 0x07 | 0xF0);
    symbol += createByte(codePoint, 12);
    symbol += createByte(codePoint, 6);
  }

  symbol += stringFromCharCode(codePoint & 0x3F | 0x80);
  return symbol;
}

function utf8encode(string, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  var codePoints = ucs2decode(string);
  var length = codePoints.length;
  var index = -1;
  var codePoint;
  var byteString = '';

  while (++index < length) {
    codePoint = codePoints[index];
    byteString += encodeCodePoint(codePoint, strict);
  }

  return byteString;
}
/*--------------------------------------------------------------------------*/


function readContinuationByte() {
  if (byteIndex >= byteCount) {
    throw Error('Invalid byte index');
  }

  var continuationByte = byteArray[byteIndex] & 0xFF;
  byteIndex++;

  if ((continuationByte & 0xC0) == 0x80) {
    return continuationByte & 0x3F;
  } // If we end up here, its not a continuation byte


  throw Error('Invalid continuation byte');
}

function decodeSymbol(strict) {
  var byte1;
  var byte2;
  var byte3;
  var byte4;
  var codePoint;

  if (byteIndex > byteCount) {
    throw Error('Invalid byte index');
  }

  if (byteIndex == byteCount) {
    return false;
  } // Read first byte


  byte1 = byteArray[byteIndex] & 0xFF;
  byteIndex++; // 1-byte sequence (no continuation bytes)

  if ((byte1 & 0x80) == 0) {
    return byte1;
  } // 2-byte sequence


  if ((byte1 & 0xE0) == 0xC0) {
    byte2 = readContinuationByte();
    codePoint = (byte1 & 0x1F) << 6 | byte2;

    if (codePoint >= 0x80) {
      return codePoint;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 3-byte sequence (may include unpaired surrogates)


  if ((byte1 & 0xF0) == 0xE0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    codePoint = (byte1 & 0x0F) << 12 | byte2 << 6 | byte3;

    if (codePoint >= 0x0800) {
      return checkScalarValue(codePoint, strict) ? codePoint : 0xFFFD;
    } else {
      throw Error('Invalid continuation byte');
    }
  } // 4-byte sequence


  if ((byte1 & 0xF8) == 0xF0) {
    byte2 = readContinuationByte();
    byte3 = readContinuationByte();
    byte4 = readContinuationByte();
    codePoint = (byte1 & 0x07) << 0x12 | byte2 << 0x0C | byte3 << 0x06 | byte4;

    if (codePoint >= 0x010000 && codePoint <= 0x10FFFF) {
      return codePoint;
    }
  }

  throw Error('Invalid UTF-8 detected');
}

var byteArray;
var byteCount;
var byteIndex;

function utf8decode(byteString, opts) {
  opts = opts || {};
  var strict = false !== opts.strict;
  byteArray = ucs2decode(byteString);
  byteCount = byteArray.length;
  byteIndex = 0;
  var codePoints = [];
  var tmp;

  while ((tmp = decodeSymbol(strict)) !== false) {
    codePoints.push(tmp);
  }

  return ucs2encode(codePoints);
}

module.exports = {
  version: '2.1.2',
  encode: utf8encode,
  decode: utf8decode
};

/***/ }),

/***/ "./node_modules/engine.io/build/server.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/server.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Server = exports.BaseServer = void 0;

var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

var url_1 = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var base64id = __webpack_require__(/*! base64id */ "./node_modules/base64id/lib/base64id.js");

var transports_1 = __webpack_require__(/*! ./transports */ "./node_modules/engine.io/build/transports/index.js");

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/engine.io/build/socket.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var cookie_1 = __webpack_require__(/*! cookie */ "./node_modules/cookie/index.js");

var ws_1 = __webpack_require__(/*! ws */ "./node_modules/ws/index.js");

var debug = (0, debug_1["default"])("engine");

var BaseServer = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(BaseServer, _events_1$EventEmitte);

  var _super = _createSuper(BaseServer);

  /**
   * Server constructor.
   *
   * @param {Object} opts - options
   * @api public
   */
  function BaseServer() {
    var _this;

    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, BaseServer);

    _this = _super.call(this);
    _this.clients = {};
    _this.clientsCount = 0;
    _this.opts = _extends({
      wsEngine: ws_1.Server,
      pingTimeout: 20000,
      pingInterval: 25000,
      upgradeTimeout: 10000,
      maxHttpBufferSize: 1e6,
      transports: Object.keys(transports_1["default"]),
      allowUpgrades: true,
      httpCompression: {
        threshold: 1024
      },
      cors: false,
      allowEIO3: false
    }, opts);

    if (opts.cookie) {
      _this.opts.cookie = _extends({
        name: "io",
        path: "/",
        // @ts-ignore
        httpOnly: opts.cookie.path !== false,
        sameSite: "lax"
      }, opts.cookie);
    }

    if (_this.opts.cors) {
      _this.corsMiddleware = __webpack_require__(/*! cors */ "./node_modules/cors/lib/index.js")(_this.opts.cors);
    }

    if (opts.perMessageDeflate) {
      _this.opts.perMessageDeflate = _extends({
        threshold: 1024
      }, opts.perMessageDeflate);
    }

    _this.init();

    return _this;
  }
  /**
   * Returns a list of available transports for upgrade given a certain transport.
   *
   * @return {Array}
   * @api public
   */


  _createClass(BaseServer, [{
    key: "upgrades",
    value: function upgrades(transport) {
      if (!this.opts.allowUpgrades) return [];
      return transports_1["default"][transport].upgradesTo || [];
    }
    /**
     * Verifies a request.
     *
     * @param {http.IncomingMessage}
     * @return {Boolean} whether the request is valid
     * @api private
     */

  }, {
    key: "verify",
    value: function verify(req, upgrade, fn) {
      // transport check
      var transport = req._query.transport;

      if (!~this.opts.transports.indexOf(transport)) {
        debug('unknown transport "%s"', transport);
        return fn(Server.errors.UNKNOWN_TRANSPORT, {
          transport: transport
        });
      } // 'Origin' header check


      var isOriginInvalid = checkInvalidHeaderChar(req.headers.origin);

      if (isOriginInvalid) {
        var origin = req.headers.origin;
        req.headers.origin = null;
        debug("origin header invalid");
        return fn(Server.errors.BAD_REQUEST, {
          name: "INVALID_ORIGIN",
          origin: origin
        });
      } // sid check


      var sid = req._query.sid;

      if (sid) {
        if (!this.clients.hasOwnProperty(sid)) {
          debug('unknown sid "%s"', sid);
          return fn(Server.errors.UNKNOWN_SID, {
            sid: sid
          });
        }

        var previousTransport = this.clients[sid].transport.name;

        if (!upgrade && previousTransport !== transport) {
          debug("bad request: unexpected transport without upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_MISMATCH",
            transport: transport,
            previousTransport: previousTransport
          });
        }
      } else {
        // handshake is GET only
        if ("GET" !== req.method) {
          return fn(Server.errors.BAD_HANDSHAKE_METHOD, {
            method: req.method
          });
        }

        if (transport === "websocket" && !upgrade) {
          debug("invalid transport upgrade");
          return fn(Server.errors.BAD_REQUEST, {
            name: "TRANSPORT_HANDSHAKE_ERROR"
          });
        }

        if (!this.opts.allowRequest) return fn();
        return this.opts.allowRequest(req, function (message, success) {
          if (!success) {
            return fn(Server.errors.FORBIDDEN, {
              message: message
            });
          }

          fn();
        });
      }

      fn();
    }
    /**
     * Closes all clients.
     *
     * @api public
     */

  }, {
    key: "close",
    value: function close() {
      debug("closing all open clients");

      for (var i in this.clients) {
        if (this.clients.hasOwnProperty(i)) {
          this.clients[i].close(true);
        }
      }

      this.cleanup();
      return this;
    }
    /**
     * generate a socket id.
     * Overwrite this method to generate your custom socket id
     *
     * @param {Object} request object
     * @api public
     */

  }, {
    key: "generateId",
    value: function generateId(req) {
      return base64id.generateId();
    }
    /**
     * Handshakes a new client.
     *
     * @param {String} transport name
     * @param {Object} request object
     * @param {Function} closeConnection
     *
     * @api protected
     */

  }, {
    key: "handshake",
    value: function () {
      var _handshake = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(transportName, req, closeConnection) {
        var _this2 = this;

        var protocol, id, transport, socket;
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

                if (!(protocol === 3 && !this.opts.allowEIO3)) {
                  _context.next = 6;
                  break;
                }

                debug("unsupported protocol version");
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.UNSUPPORTED_PROTOCOL_VERSION,
                  message: Server.errorMessages[Server.errors.UNSUPPORTED_PROTOCOL_VERSION],
                  context: {
                    protocol: protocol
                  }
                });
                closeConnection(Server.errors.UNSUPPORTED_PROTOCOL_VERSION);
                return _context.abrupt("return");

              case 6:
                _context.prev = 6;
                _context.next = 9;
                return this.generateId(req);

              case 9:
                id = _context.sent;
                _context.next = 18;
                break;

              case 12:
                _context.prev = 12;
                _context.t0 = _context["catch"](6);
                debug("error while generating an id");
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.BAD_REQUEST,
                  message: Server.errorMessages[Server.errors.BAD_REQUEST],
                  context: {
                    name: "ID_GENERATION_ERROR",
                    error: _context.t0
                  }
                });
                closeConnection(Server.errors.BAD_REQUEST);
                return _context.abrupt("return");

              case 18:
                debug('handshaking client "%s"', id);
                _context.prev = 19;
                transport = this.createTransport(transportName, req);

                if ("polling" === transportName) {
                  transport.maxHttpBufferSize = this.opts.maxHttpBufferSize;
                  transport.httpCompression = this.opts.httpCompression;
                } else if ("websocket" === transportName) {
                  transport.perMessageDeflate = this.opts.perMessageDeflate;
                }

                if (req._query && req._query.b64) {
                  transport.supportsBinary = false;
                } else {
                  transport.supportsBinary = true;
                }

                _context.next = 31;
                break;

              case 25:
                _context.prev = 25;
                _context.t1 = _context["catch"](19);
                debug('error handshaking to transport "%s"', transportName);
                this.emit("connection_error", {
                  req: req,
                  code: Server.errors.BAD_REQUEST,
                  message: Server.errorMessages[Server.errors.BAD_REQUEST],
                  context: {
                    name: "TRANSPORT_HANDSHAKE_ERROR",
                    error: _context.t1
                  }
                });
                closeConnection(Server.errors.BAD_REQUEST);
                return _context.abrupt("return");

              case 31:
                socket = new socket_1.Socket(id, this, transport, req, protocol);
                transport.on("headers", function (headers, req) {
                  var isInitialRequest = !req._query.sid;

                  if (isInitialRequest) {
                    if (_this2.opts.cookie) {
                      headers["Set-Cookie"] = [// @ts-ignore
                      (0, cookie_1.serialize)(_this2.opts.cookie.name, id, _this2.opts.cookie)];
                    }

                    _this2.emit("initial_headers", headers, req);
                  }

                  _this2.emit("headers", headers, req);
                });
                transport.onRequest(req);
                this.clients[id] = socket;
                this.clientsCount++;
                socket.once("close", function () {
                  delete _this2.clients[id];
                  _this2.clientsCount--;
                });
                this.emit("connection", socket);
                return _context.abrupt("return", transport);

              case 39:
              case "end":
                return _context.stop();
            }
          }
        }, _callee, this, [[6, 12], [19, 25]]);
      }));

      function handshake(_x, _x2, _x3) {
        return _handshake.apply(this, arguments);
      }

      return handshake;
    }()
  }]);

  return BaseServer;
}(events_1.EventEmitter);

exports.BaseServer = BaseServer;
/**
 * Protocol errors mappings.
 */

BaseServer.errors = {
  UNKNOWN_TRANSPORT: 0,
  UNKNOWN_SID: 1,
  BAD_HANDSHAKE_METHOD: 2,
  BAD_REQUEST: 3,
  FORBIDDEN: 4,
  UNSUPPORTED_PROTOCOL_VERSION: 5
};
BaseServer.errorMessages = {
  0: "Transport unknown",
  1: "Session ID unknown",
  2: "Bad handshake method",
  3: "Bad request",
  4: "Forbidden",
  5: "Unsupported protocol version"
};

var Server = /*#__PURE__*/function (_BaseServer) {
  _inherits(Server, _BaseServer);

  var _super2 = _createSuper(Server);

  function Server() {
    _classCallCheck(this, Server);

    return _super2.apply(this, arguments);
  }

  _createClass(Server, [{
    key: "init",
    value:
    /**
     * Initialize websocket server
     *
     * @api protected
     */
    function init() {
      var _this3 = this;

      if (!~this.opts.transports.indexOf("websocket")) return;
      if (this.ws) this.ws.close();
      this.ws = new this.opts.wsEngine({
        noServer: true,
        clientTracking: false,
        perMessageDeflate: this.opts.perMessageDeflate,
        maxPayload: this.opts.maxHttpBufferSize
      });

      if (typeof this.ws.on === "function") {
        this.ws.on("headers", function (headersArray, req) {
          // note: 'ws' uses an array of headers, while Engine.IO uses an object (response.writeHead() accepts both formats)
          // we could also try to parse the array and then sync the values, but that will be error-prone
          var additionalHeaders = {};
          var isInitialRequest = !req._query.sid;

          if (isInitialRequest) {
            _this3.emit("initial_headers", additionalHeaders, req);
          }

          _this3.emit("headers", additionalHeaders, req);

          Object.keys(additionalHeaders).forEach(function (key) {
            headersArray.push("".concat(key, ": ").concat(additionalHeaders[key]));
          });
        });
      }
    }
  }, {
    key: "cleanup",
    value: function cleanup() {
      if (this.ws) {
        debug("closing webSocketServer");
        this.ws.close(); // don't delete this.ws because it can be used again if the http server starts listening again
      }
    }
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */

  }, {
    key: "prepare",
    value: function prepare(req) {
      // try to leverage pre-existing `req._query` (e.g: from connect)
      if (!req._query) {
        req._query = ~req.url.indexOf("?") ? qs.parse((0, url_1.parse)(req.url).query) : {};
      }
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_1["default"][transportName](req);
    }
    /**
     * Handles an Engine.IO HTTP request.
     *
     * @param {http.IncomingMessage} request
     * @param {http.ServerResponse|http.OutgoingMessage} response
     * @api public
     */

  }, {
    key: "handleRequest",
    value: function handleRequest(req, res) {
      var _this4 = this;

      debug('handling "%s" http request "%s"', req.method, req.url);
      this.prepare(req);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this4.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortRequest(res, errorCode, errorContext);
          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this4.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return abortRequest(res, errorCode, errorContext);
          };

          _this4.handshake(req._query.transport, req, closeConnection);
        }
      };

      if (this.corsMiddleware) {
        this.corsMiddleware.call(null, req, res, function () {
          _this4.verify(req, false, callback);
        });
      } else {
        this.verify(req, false, callback);
      }
    }
    /**
     * Handles an Engine.IO HTTP Upgrade.
     *
     * @api public
     */

  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(req, socket, upgradeHead) {
      var _this5 = this;

      this.prepare(req);
      this.verify(req, true, function (errorCode, errorContext) {
        if (errorCode) {
          _this5.emit("connection_error", {
            req: req,
            code: errorCode,
            message: Server.errorMessages[errorCode],
            context: errorContext
          });

          abortUpgrade(socket, errorCode, errorContext);
          return;
        }

        var head = Buffer.from(upgradeHead); // eslint-disable-line node/no-deprecated-api

        upgradeHead = null; // delegate to ws

        _this5.ws.handleUpgrade(req, socket, head, function (websocket) {
          _this5.onWebSocket(req, socket, websocket);
        });
      });
    }
    /**
     * Called upon a ws.io connection.
     *
     * @param {ws.Socket} websocket
     * @api private
     */

  }, {
    key: "onWebSocket",
    value: function onWebSocket(req, socket, websocket) {
      websocket.on("error", onUpgradeError);

      if (transports_1["default"][req._query.transport] !== undefined && !transports_1["default"][req._query.transport].prototype.handlesUpgrades) {
        debug("transport doesnt handle upgraded requests");
        websocket.close();
        return;
      } // get client id


      var id = req._query.sid; // keep a reference to the ws.Socket

      req.websocket = websocket;

      if (id) {
        var client = this.clients[id];

        if (!client) {
          debug("upgrade attempt for closed client");
          websocket.close();
        } else if (client.upgrading) {
          debug("transport has already been trying to upgrade");
          websocket.close();
        } else if (client.upgraded) {
          debug("transport had already been upgraded");
          websocket.close();
        } else {
          debug("upgrading existing transport"); // transport error handling takes over

          websocket.removeListener("error", onUpgradeError);
          var transport = this.createTransport(req._query.transport, req);

          if (req._query && req._query.b64) {
            transport.supportsBinary = false;
          } else {
            transport.supportsBinary = true;
          }

          transport.perMessageDeflate = this.opts.perMessageDeflate;
          client.maybeUpgrade(transport);
        }
      } else {
        var closeConnection = function closeConnection(errorCode, errorContext) {
          return abortUpgrade(socket, errorCode, errorContext);
        };

        this.handshake(req._query.transport, req, closeConnection);
      }

      function onUpgradeError() {
        debug("websocket error before upgrade"); // websocket.close() not needed
      }
    }
    /**
     * Captures upgrade requests for a http.Server.
     *
     * @param {http.Server} server
     * @param {Object} options
     * @api public
     */

  }, {
    key: "attach",
    value: function attach(server) {
      var _this6 = this;

      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var path = (options.path || "/engine.io").replace(/\/$/, "");
      var destroyUpgradeTimeout = options.destroyUpgradeTimeout || 1000; // normalize path

      path += "/";

      function check(req) {
        return path === req.url.substr(0, path.length);
      } // cache and clean up listeners


      var listeners = server.listeners("request").slice(0);
      server.removeAllListeners("request");
      server.on("close", this.close.bind(this));
      server.on("listening", this.init.bind(this)); // add request handler

      server.on("request", function (req, res) {
        if (check(req)) {
          debug('intercepting request for path "%s"', path);

          _this6.handleRequest(req, res);
        } else {
          var i = 0;
          var l = listeners.length;

          for (; i < l; i++) {
            listeners[i].call(server, req, res);
          }
        }
      });

      if (~this.opts.transports.indexOf("websocket")) {
        server.on("upgrade", function (req, socket, head) {
          if (check(req)) {
            _this6.handleUpgrade(req, socket, head);
          } else if (false !== options.destroyUpgrade) {
            // default node behavior is to disconnect when no handlers
            // but by adding a handler, we prevent that
            // and if no eio thing handles the upgrade
            // then the socket needs to die!
            setTimeout(function () {
              // @ts-ignore
              if (socket.writable && socket.bytesWritten <= 0) {
                return socket.end();
              }
            }, destroyUpgradeTimeout);
          }
        });
      }
    }
  }]);

  return Server;
}(BaseServer);

exports.Server = Server;
/**
 * Close the HTTP long-polling request
 *
 * @param res - the response object
 * @param errorCode - the error code
 * @param errorContext - additional error context
 *
 * @api private
 */

function abortRequest(res, errorCode, errorContext) {
  var statusCode = errorCode === Server.errors.FORBIDDEN ? 403 : 400;
  var message = errorContext && errorContext.message ? errorContext.message : Server.errorMessages[errorCode];
  res.writeHead(statusCode, {
    "Content-Type": "application/json"
  });
  res.end(JSON.stringify({
    code: errorCode,
    message: message
  }));
}
/**
 * Close the WebSocket connection
 *
 * @param {net.Socket} socket
 * @param {string} errorCode - the error code
 * @param {object} errorContext - additional error context
 *
 * @api private
 */


function abortUpgrade(socket, errorCode) {
  var errorContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  socket.on("error", function () {
    debug("ignoring error from closed connection");
  });

  if (socket.writable) {
    var message = errorContext.message || Server.errorMessages[errorCode];
    var length = Buffer.byteLength(message);
    socket.write("HTTP/1.1 400 Bad Request\r\n" + "Connection: close\r\n" + "Content-type: text/html\r\n" + "Content-Length: " + length + "\r\n" + "\r\n" + message);
  }

  socket.destroy();
}
/* eslint-disable */

/**
 * From https://github.com/nodejs/node/blob/v8.4.0/lib/_http_common.js#L303-L354
 *
 * True if val contains an invalid field-vchar
 *  field-value    = *( field-content / obs-fold )
 *  field-content  = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 *  field-vchar    = VCHAR / obs-text
 *
 * checkInvalidHeaderChar() is currently designed to be inlinable by v8,
 * so take care when making changes to the implementation so that the source
 * code size does not exceed v8's default max_inlined_source_size setting.
 **/
// prettier-ignore


var validHdrChars = [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 // ... 255
];

function checkInvalidHeaderChar(val) {
  val += "";
  if (val.length < 1) return false;

  if (!validHdrChars[val.charCodeAt(0)]) {
    debug('invalid header, index 0, char "%s"', val.charCodeAt(0));
    return true;
  }

  if (val.length < 2) return false;

  if (!validHdrChars[val.charCodeAt(1)]) {
    debug('invalid header, index 1, char "%s"', val.charCodeAt(1));
    return true;
  }

  if (val.length < 3) return false;

  if (!validHdrChars[val.charCodeAt(2)]) {
    debug('invalid header, index 2, char "%s"', val.charCodeAt(2));
    return true;
  }

  if (val.length < 4) return false;

  if (!validHdrChars[val.charCodeAt(3)]) {
    debug('invalid header, index 3, char "%s"', val.charCodeAt(3));
    return true;
  }

  for (var i = 4; i < val.length; ++i) {
    if (!validHdrChars[val.charCodeAt(i)]) {
      debug('invalid header, index "%i", char "%s"', i, val.charCodeAt(i));
      return true;
    }
  }

  return false;
}

/***/ }),

/***/ "./node_modules/engine.io/build/socket.js":
/*!************************************************!*\
  !*** ./node_modules/engine.io/build/socket.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Socket = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var timers_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'timers'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var debug = (0, debug_1["default"])("engine:socket");

var Socket = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Socket, _events_1$EventEmitte);

  var _super = _createSuper(Socket);

  /**
   * Client class (abstract).
   *
   * @api private
   */
  function Socket(id, server, transport, req, protocol) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.id = id;
    _this.server = server;
    _this.upgrading = false;
    _this.upgraded = false;
    _this.readyState = "opening";
    _this.writeBuffer = [];
    _this.packetsFn = [];
    _this.sentCallbackFn = [];
    _this.cleanupFn = [];
    _this.request = req;
    _this.protocol = protocol; // Cache IP since it might not be in the req later

    if (req.websocket && req.websocket._socket) {
      _this.remoteAddress = req.websocket._socket.remoteAddress;
    } else {
      _this.remoteAddress = req.connection.remoteAddress;
    }

    _this.checkIntervalTimer = null;
    _this.upgradeTimeoutTimer = null;
    _this.pingTimeoutTimer = null;
    _this.pingIntervalTimer = null;

    _this.setTransport(transport);

    _this.onOpen();

    return _this;
  }

  _createClass(Socket, [{
    key: "readyState",
    get: function get() {
      return this._readyState;
    },
    set: function set(state) {
      debug("readyState updated from %s to %s", this._readyState, state);
      this._readyState = state;
    }
    /**
     * Called upon transport considered open.
     *
     * @api private
     */

  }, {
    key: "onOpen",
    value: function onOpen() {
      this.readyState = "open"; // sends an `open` packet

      this.transport.sid = this.id;
      this.sendPacket("open", JSON.stringify({
        sid: this.id,
        upgrades: this.getAvailableUpgrades(),
        pingInterval: this.server.opts.pingInterval,
        pingTimeout: this.server.opts.pingTimeout
      }));

      if (this.server.opts.initialPacket) {
        this.sendPacket("message", this.server.opts.initialPacket);
      }

      this.emit("open");

      if (this.protocol === 3) {
        // in protocol v3, the client sends a ping, and the server answers with a pong
        this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);
      } else {
        // in protocol v4, the server sends a ping, and the client answers with a pong
        this.schedulePing();
      }
    }
    /**
     * Called upon transport packet.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      if ("open" !== this.readyState) {
        return debug("packet received with closed socket");
      } // export packet event


      debug("received packet ".concat(packet.type));
      this.emit("packet", packet); // Reset ping timeout on any packet, incoming data is a good sign of
      // other side's liveness

      this.resetPingTimeout(this.server.opts.pingInterval + this.server.opts.pingTimeout);

      switch (packet.type) {
        case "ping":
          if (this.transport.protocol !== 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got ping");
          this.sendPacket("pong");
          this.emit("heartbeat");
          break;

        case "pong":
          if (this.transport.protocol === 3) {
            this.onError("invalid heartbeat direction");
            return;
          }

          debug("got pong");
          this.pingIntervalTimer.refresh();
          this.emit("heartbeat");
          break;

        case "error":
          this.onClose("parse error");
          break;

        case "message":
          this.emit("data", packet.data);
          this.emit("message", packet.data);
          break;
      }
    }
    /**
     * Called upon transport error.
     *
     * @param {Error} error object
     * @api private
     */

  }, {
    key: "onError",
    value: function onError(err) {
      debug("transport error");
      this.onClose("transport error", err);
    }
    /**
     * Pings client every `this.pingInterval` and expects response
     * within `this.pingTimeout` or closes connection.
     *
     * @api private
     */

  }, {
    key: "schedulePing",
    value: function schedulePing() {
      var _this2 = this;

      this.pingIntervalTimer = (0, timers_1.setTimeout)(function () {
        debug("writing ping packet - expecting pong within %sms", _this2.server.opts.pingTimeout);

        _this2.sendPacket("ping");

        _this2.resetPingTimeout(_this2.server.opts.pingTimeout);
      }, this.server.opts.pingInterval);
    }
    /**
     * Resets ping timeout.
     *
     * @api private
     */

  }, {
    key: "resetPingTimeout",
    value: function resetPingTimeout(timeout) {
      var _this3 = this;

      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
      this.pingTimeoutTimer = (0, timers_1.setTimeout)(function () {
        if (_this3.readyState === "closed") return;

        _this3.onClose("ping timeout");
      }, timeout);
    }
    /**
     * Attaches handlers for the given transport.
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "setTransport",
    value: function setTransport(transport) {
      var onError = this.onError.bind(this);
      var onPacket = this.onPacket.bind(this);
      var flush = this.flush.bind(this);
      var onClose = this.onClose.bind(this, "transport close");
      this.transport = transport;
      this.transport.once("error", onError);
      this.transport.on("packet", onPacket);
      this.transport.on("drain", flush);
      this.transport.once("close", onClose); // this function will manage packet events (also message callbacks)

      this.setupSendCallback();
      this.cleanupFn.push(function () {
        transport.removeListener("error", onError);
        transport.removeListener("packet", onPacket);
        transport.removeListener("drain", flush);
        transport.removeListener("close", onClose);
      });
    }
    /**
     * Upgrades socket to the given transport
     *
     * @param {Transport} transport
     * @api private
     */

  }, {
    key: "maybeUpgrade",
    value: function maybeUpgrade(transport) {
      var _this4 = this;

      debug('might upgrade socket transport from "%s" to "%s"', this.transport.name, transport.name);
      this.upgrading = true; // set transport upgrade timer

      this.upgradeTimeoutTimer = (0, timers_1.setTimeout)(function () {
        debug("client did not complete upgrade - closing transport");
        cleanup();

        if ("open" === transport.readyState) {
          transport.close();
        }
      }, this.server.opts.upgradeTimeout);

      var onPacket = function onPacket(packet) {
        if ("ping" === packet.type && "probe" === packet.data) {
          debug("got probe ping packet, sending pong");
          transport.send([{
            type: "pong",
            data: "probe"
          }]);

          _this4.emit("upgrading", transport);

          clearInterval(_this4.checkIntervalTimer);
          _this4.checkIntervalTimer = setInterval(check, 100);
        } else if ("upgrade" === packet.type && _this4.readyState !== "closed") {
          debug("got upgrade packet - upgrading");
          cleanup();

          _this4.transport.discard();

          _this4.upgraded = true;

          _this4.clearTransport();

          _this4.setTransport(transport);

          _this4.emit("upgrade", transport);

          _this4.flush();

          if (_this4.readyState === "closing") {
            transport.close(function () {
              _this4.onClose("forced close");
            });
          }
        } else {
          cleanup();
          transport.close();
        }
      }; // we force a polling cycle to ensure a fast upgrade


      var check = function check() {
        if ("polling" === _this4.transport.name && _this4.transport.writable) {
          debug("writing a noop packet to polling for fast upgrade");

          _this4.transport.send([{
            type: "noop"
          }]);
        }
      };

      var cleanup = function cleanup() {
        _this4.upgrading = false;
        clearInterval(_this4.checkIntervalTimer);
        _this4.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(_this4.upgradeTimeoutTimer);
        _this4.upgradeTimeoutTimer = null;
        transport.removeListener("packet", onPacket);
        transport.removeListener("close", onTransportClose);
        transport.removeListener("error", onError);

        _this4.removeListener("close", onClose);
      };

      var onError = function onError(err) {
        debug("client did not complete upgrade - %s", err);
        cleanup();
        transport.close();
        transport = null;
      };

      var onTransportClose = function onTransportClose() {
        onError("transport closed");
      };

      var onClose = function onClose() {
        onError("socket closed");
      };

      transport.on("packet", onPacket);
      transport.once("close", onTransportClose);
      transport.once("error", onError);
      this.once("close", onClose);
    }
    /**
     * Clears listeners and timers associated with current transport.
     *
     * @api private
     */

  }, {
    key: "clearTransport",
    value: function clearTransport() {
      var cleanup;
      var toCleanUp = this.cleanupFn.length;

      for (var i = 0; i < toCleanUp; i++) {
        cleanup = this.cleanupFn.shift();
        cleanup();
      } // silence further transport errors and prevent uncaught exceptions


      this.transport.on("error", function () {
        debug("error triggered by discarded transport");
      }); // ensure transport won't stay open

      this.transport.close();
      (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
    }
    /**
     * Called upon transport considered closed.
     * Possible reasons: `ping timeout`, `client error`, `parse error`,
     * `transport error`, `server close`, `transport close`
     */

  }, {
    key: "onClose",
    value: function onClose(reason, description) {
      var _this5 = this;

      if ("closed" !== this.readyState) {
        this.readyState = "closed"; // clear timers

        (0, timers_1.clearTimeout)(this.pingIntervalTimer);
        (0, timers_1.clearTimeout)(this.pingTimeoutTimer);
        clearInterval(this.checkIntervalTimer);
        this.checkIntervalTimer = null;
        (0, timers_1.clearTimeout)(this.upgradeTimeoutTimer); // clean writeBuffer in next tick, so developers can still
        // grab the writeBuffer on 'close' event

        process.nextTick(function () {
          _this5.writeBuffer = [];
        });
        this.packetsFn = [];
        this.sentCallbackFn = [];
        this.clearTransport();
        this.emit("close", reason, description);
      }
    }
    /**
     * Setup and manage send callback
     *
     * @api private
     */

  }, {
    key: "setupSendCallback",
    value: function setupSendCallback() {
      var _this6 = this;

      // the message was sent successfully, execute the callback
      var onDrain = function onDrain() {
        if (_this6.sentCallbackFn.length > 0) {
          var seqFn = _this6.sentCallbackFn.splice(0, 1)[0];

          if ("function" === typeof seqFn) {
            debug("executing send callback");
            seqFn(_this6.transport);
          } else if (Array.isArray(seqFn)) {
            debug("executing batch send callback");
            var l = seqFn.length;
            var i = 0;

            for (; i < l; i++) {
              if ("function" === typeof seqFn[i]) {
                seqFn[i](_this6.transport);
              }
            }
          }
        }
      };

      this.transport.on("drain", onDrain);
      this.cleanupFn.push(function () {
        _this6.transport.removeListener("drain", onDrain);
      });
    }
    /**
     * Sends a message packet.
     *
     * @param {Object} data
     * @param {Object} options
     * @param {Function} callback
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "send",
    value: function send(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
  }, {
    key: "write",
    value: function write(data, options, callback) {
      this.sendPacket("message", data, options, callback);
      return this;
    }
    /**
     * Sends a packet.
     *
     * @param {String} type - packet type
     * @param {String} data
     * @param {Object} options
     * @param {Function} callback
     *
     * @api private
     */

  }, {
    key: "sendPacket",
    value: function sendPacket(type, data, options, callback) {
      if ("function" === typeof options) {
        callback = options;
        options = null;
      }

      options = options || {};
      options.compress = false !== options.compress;

      if ("closing" !== this.readyState && "closed" !== this.readyState) {
        debug('sending packet "%s" (%s)', type, data);
        var packet = {
          type: type,
          options: options
        };
        if (data) packet.data = data; // exports packetCreate event

        this.emit("packetCreate", packet);
        this.writeBuffer.push(packet); // add send callback to object, if defined

        if (callback) this.packetsFn.push(callback);
        this.flush();
      }
    }
    /**
     * Attempts to flush the packets buffer.
     *
     * @api private
     */

  }, {
    key: "flush",
    value: function flush() {
      if ("closed" !== this.readyState && this.transport.writable && this.writeBuffer.length) {
        debug("flushing buffer to transport");
        this.emit("flush", this.writeBuffer);
        this.server.emit("flush", this, this.writeBuffer);
        var wbuf = this.writeBuffer;
        this.writeBuffer = [];

        if (!this.transport.supportsFraming) {
          this.sentCallbackFn.push(this.packetsFn);
        } else {
          this.sentCallbackFn.push.apply(this.sentCallbackFn, this.packetsFn);
        }

        this.packetsFn = [];
        this.transport.send(wbuf);
        this.emit("drain");
        this.server.emit("drain", this);
      }
    }
    /**
     * Get available upgrades for this socket.
     *
     * @api private
     */

  }, {
    key: "getAvailableUpgrades",
    value: function getAvailableUpgrades() {
      var availableUpgrades = [];
      var allUpgrades = this.server.upgrades(this.transport.name);
      var i = 0;
      var l = allUpgrades.length;

      for (; i < l; ++i) {
        var upg = allUpgrades[i];

        if (this.server.opts.transports.indexOf(upg) !== -1) {
          availableUpgrades.push(upg);
        }
      }

      return availableUpgrades;
    }
    /**
     * Closes the socket and underlying transport.
     *
     * @param {Boolean} discard - optional, discard the transport
     * @return {Socket} for chaining
     * @api public
     */

  }, {
    key: "close",
    value: function close(discard) {
      if ("open" !== this.readyState) return;
      this.readyState = "closing";

      if (this.writeBuffer.length) {
        this.once("drain", this.closeTransport.bind(this, discard));
        return;
      }

      this.closeTransport(discard);
    }
    /**
     * Closes the underlying transport.
     *
     * @param {Boolean} discard
     * @api private
     */

  }, {
    key: "closeTransport",
    value: function closeTransport(discard) {
      if (discard) this.transport.discard();
      this.transport.close(this.onClose.bind(this, "forced close"));
    }
  }]);

  return Socket;
}(events_1.EventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./node_modules/engine.io/build/transport.js":
/*!***************************************************!*\
  !*** ./node_modules/engine.io/build/transport.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Transport = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var parser_v4 = __webpack_require__(/*! engine.io-parser */ "./node_modules/engine.io-parser/build/cjs/index.js");

var parser_v3 = __webpack_require__(/*! ./parser-v3/index */ "./node_modules/engine.io/build/parser-v3/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:transport");
/**
 * Noop function.
 *
 * @api private
 */

function noop() {}

var Transport = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(Transport, _events_1$EventEmitte);

  var _super = _createSuper(Transport);

  /**
   * Transport constructor.
   *
   * @param {http.IncomingMessage} request
   * @api public
   */
  function Transport(req) {
    var _this;

    _classCallCheck(this, Transport);

    _this = _super.call(this);
    _this.readyState = "open";
    _this.discarded = false;
    _this.protocol = req._query.EIO === "4" ? 4 : 3; // 3rd revision by default

    _this.parser = _this.protocol === 4 ? parser_v4 : parser_v3;
    return _this;
  }

  _createClass(Transport, [{
    key: "readyState",
    get: function get() {
      return this._readyState;
    },
    set: function set(state) {
      debug("readyState updated from %s to %s (%s)", this._readyState, state, this.name);
      this._readyState = state;
    }
    /**
     * Flags the transport as discarded.
     *
     * @api private
     */

  }, {
    key: "discard",
    value: function discard() {
      this.discarded = true;
    }
    /**
     * Called with an incoming HTTP request.
     *
     * @param {http.IncomingMessage} request
     * @api protected
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      debug("setting request");
      this.req = req;
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "close",
    value: function close(fn) {
      if ("closed" === this.readyState || "closing" === this.readyState) return;
      this.readyState = "closing";
      this.doClose(fn || noop);
    }
    /**
     * Called with a transport error.
     *
     * @param {String} message error
     * @param {Object} error description
     * @api protected
     */

  }, {
    key: "onError",
    value: function onError(msg, desc) {
      if (this.listeners("error").length) {
        var err = new Error(msg); // @ts-ignore

        err.type = "TransportError"; // @ts-ignore

        err.description = desc;
        this.emit("error", err);
      } else {
        debug("ignored transport error %s (%s)", msg, desc);
      }
    }
    /**
     * Called with parsed out a packets from the data stream.
     *
     * @param {Object} packet
     * @api protected
     */

  }, {
    key: "onPacket",
    value: function onPacket(packet) {
      this.emit("packet", packet);
    }
    /**
     * Called with the encoded packet data.
     *
     * @param {String} data
     * @api protected
     */

  }, {
    key: "onData",
    value: function onData(data) {
      this.onPacket(this.parser.decodePacket(data));
    }
    /**
     * Called upon transport close.
     *
     * @api protected
     */

  }, {
    key: "onClose",
    value: function onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  }]);

  return Transport;
}(events_1.EventEmitter);

exports.Transport = Transport;

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports-uws/polling.js");

var websocket_1 = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io/build/transports-uws/websocket.js");

exports["default"] = {
  polling: polling_1.Polling,
  websocket: websocket_1.WebSocket
};

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/polling.js":
/*!****************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/polling.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Polling = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:polling");
var compressionMethods = {
  gzip: zlib_1.createGzip,
  deflate: zlib_1.createDeflate
};

var Polling = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(Polling, _transport_1$Transpor);

  var _super = _createSuper(Polling);

  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  function Polling(req) {
    var _this;

    _classCallCheck(this, Polling);

    _this = _super.call(this, req);
    _this.closeTimeout = 30 * 1000;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
  }, {
    key: "supportsFraming",
    get: function get() {
      return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param req
     *
     * @api private
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      var res = req.res;

      if (req.getMethod() === "get") {
        this.onPollRequest(req, res);
      } else if (req.getMethod() === "post") {
        this.onDataRequest(req, res);
      } else {
        res.writeStatus("500 Internal Server Error");
        res.end();
      }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */

  }, {
    key: "onPollRequest",
    value: function onPollRequest(req, res) {
      var _this2 = this;

      if (this.req) {
        debug("request overlap"); // assert: this.res, '.req and .res should be (un)set together'

        this.onError("overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }

      debug("setting request");
      this.req = req;
      this.res = res;

      var onClose = function onClose() {
        _this2.writable = false;

        _this2.onError("poll connection closed prematurely");
      };

      var cleanup = function cleanup() {
        _this2.req = _this2.res = null;
      };

      req.cleanup = cleanup;
      res.onAborted(onClose);
      this.writable = true;
      this.emit("drain"); // if we're still writable but had a pending close, trigger an empty send

      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{
          type: "noop"
        }]);
      }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */

  }, {
    key: "onDataRequest",
    value: function onDataRequest(req, res) {
      var _this3 = this;

      if (this.dataReq) {
        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
        this.onError("data request overlap from client");
        res.writeStatus("500 Internal Server Error");
        res.end();
        return;
      }

      var expectedContentLength = Number(req.headers["content-length"]);

      if (!expectedContentLength) {
        this.onError("content-length header required");
        res.writeStatus("411 Length Required").end();
        return;
      }

      if (expectedContentLength > this.maxHttpBufferSize) {
        this.onError("payload too large");
        res.writeStatus("413 Payload Too Large").end();
        return;
      }

      var isBinary = "application/octet-stream" === req.headers["content-type"];

      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }

      this.dataReq = req;
      this.dataRes = res;
      var buffer;
      var offset = 0;
      var headers = {
        // text/html is required instead of text/plain to avoid an
        // unwanted download dialog on certain user-agents (GH-43)
        "Content-Type": "text/html"
      };
      this.headers(req, headers);

      for (var key in headers) {
        res.writeHeader(key, String(headers[key]));
      }

      var onEnd = function onEnd(buffer) {
        _this3.onData(buffer.toString());

        _this3.onDataRequestCleanup();

        res.end("ok");
      };

      res.onAborted(function () {
        _this3.onDataRequestCleanup();

        _this3.onError("data request connection closed prematurely");
      });
      res.onData(function (arrayBuffer, isLast) {
        var totalLength = offset + arrayBuffer.byteLength;

        if (totalLength > expectedContentLength) {
          _this3.onError("content-length mismatch");

          res.close(); // calls onAborted

          return;
        }

        if (!buffer) {
          if (isLast) {
            onEnd(Buffer.from(arrayBuffer));
            return;
          }

          buffer = Buffer.allocUnsafe(expectedContentLength);
        }

        Buffer.from(arrayBuffer).copy(buffer, offset);

        if (isLast) {
          if (totalLength != expectedContentLength) {
            _this3.onError("content-length mismatch");

            res.writeStatus("400 Content-Length Mismatch").end();

            _this3.onDataRequestCleanup();

            return;
          }

          onEnd(buffer);
          return;
        }

        offset = totalLength;
      });
    }
    /**
     * Cleanup request.
     *
     * @api private
     */

  }, {
    key: "onDataRequestCleanup",
    value: function onDataRequestCleanup() {
      this.dataReq = this.dataRes = null;
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this4 = this;

      debug('received "%s"', data);

      var callback = function callback(packet) {
        if ("close" === packet.type) {
          debug("got xhr close packet");

          _this4.onClose();

          return false;
        }

        _this4.onPacket(packet);
      };

      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      if (this.writable) {
        // close pending poll request
        this.send([{
          type: "noop"
        }]);
      }

      _get(_getPrototypeOf(Polling.prototype), "onClose", this).call(this);
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this5 = this;

      this.writable = false;

      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({
          type: "close"
        });
        this.shouldClose();
        this.shouldClose = null;
      }

      var doWrite = function doWrite(data) {
        var compress = packets.some(function (packet) {
          return packet.options && packet.options.compress;
        });

        _this5.write(data, {
          compress: compress
        });
      };

      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "write",
    value: function write(data, options) {
      var _this6 = this;

      debug('writing "%s"', data);
      this.doWrite(data, options, function () {
        _this6.req.cleanup();
      });
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      var _this7 = this;

      // explicit UTF-8 is required for pages not served under utf
      var isString = typeof data === "string";
      var contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      var headers = {
        "Content-Type": contentType
      };

      var respond = function respond(data) {
        _this7.headers(_this7.req, headers);

        Object.keys(headers).forEach(function (key) {
          _this7.res.writeHeader(key, String(headers[key]));
        });

        _this7.res.end(data);

        callback();
      };

      if (!this.httpCompression || !options.compress) {
        respond(data);
        return;
      }

      var len = isString ? Buffer.byteLength(data) : data.length;

      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }

      var encoding = accepts(this.req).encodings(["gzip", "deflate"]);

      if (!encoding) {
        respond(data);
        return;
      }

      this.compress(data, encoding, function (err, data) {
        if (err) {
          _this7.res.writeStatus("500 Internal Server Error");

          _this7.res.end();

          callback(err);
          return;
        }

        headers["Content-Encoding"] = encoding;
        respond(data);
      });
    }
    /**
     * Compresses data.
     *
     * @api private
     */

  }, {
    key: "compress",
    value: function compress(data, encoding, callback) {
      debug("compressing");
      var buffers = [];
      var nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function (chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function () {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      var _this8 = this;

      debug("closing");
      var closeTimeoutTimer;

      var onClose = function onClose() {
        clearTimeout(closeTimeoutTimer);
        fn();

        _this8.onClose();
      };

      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{
          type: "close"
        }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    /**
     * Returns headers for a response.
     *
     * @param req - request
     * @param {Object} extra headers
     * @api private
     */

  }, {
    key: "headers",
    value: function headers(req, _headers) {
      _headers = _headers || {}; // prevent XSS warnings on IE
      // https://github.com/LearnBoost/socket.io/pull/1333

      var ua = req.headers["user-agent"];

      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        _headers["X-XSS-Protection"] = "0";
      }

      this.emit("headers", _headers, req);
      return _headers;
    }
  }]);

  return Polling;
}(transport_1.Transport);

exports.Polling = Polling;

/***/ }),

/***/ "./node_modules/engine.io/build/transports-uws/websocket.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports-uws/websocket.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:ws");

var WebSocket = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(WebSocket, _transport_1$Transpor);

  var _super = _createSuper(WebSocket);

  /**
   * WebSocket transport
   *
   * @param req
   * @api public
   */
  function WebSocket(req) {
    var _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this, req);
    _this.writable = false;
    _this.perMessageDeflate = null;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(WebSocket, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */

  }, {
    key: "handlesUpgrades",
    get: function get() {
      return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */

  }, {
    key: "supportsFraming",
    get: function get() {
      return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this2 = this;

      var packet = packets.shift();

      if (typeof packet === "undefined") {
        this.writable = true;
        this.emit("drain");
        return;
      } // always creates a new object since ws modifies it


      var opts = {};

      if (packet.options) {
        opts.compress = packet.options.compress;
      }

      var send = function send(data) {
        var isBinary = typeof data !== "string";

        var compress = _this2.perMessageDeflate && Buffer.byteLength(data) > _this2.perMessageDeflate.threshold;

        debug('writing "%s"', data);
        _this2.writable = false;

        _this2.socket.send(data, isBinary, compress);

        _this2.send(packets);
      };

      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send(packet.options.wsPreEncoded);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send);
      }
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      debug("closing");
      fn && fn(); // call fn first since socket.close() immediately emits a "close" event

      this.socket.close();
    }
  }]);

  return WebSocket;
}(transport_1.Transport);

exports.WebSocket = WebSocket;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/engine.io/build/transports/index.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports/polling.js");

var polling_jsonp_1 = __webpack_require__(/*! ./polling-jsonp */ "./node_modules/engine.io/build/transports/polling-jsonp.js");

var websocket_1 = __webpack_require__(/*! ./websocket */ "./node_modules/engine.io/build/transports/websocket.js");

exports["default"] = {
  polling: polling,
  websocket: websocket_1.WebSocket
};
/**
 * Polling polymorphic constructor.
 *
 * @api private
 */

function polling(req) {
  if ("string" === typeof req._query.j) {
    return new polling_jsonp_1.JSONP(req);
  } else {
    return new polling_1.Polling(req);
  }
}

polling.upgradesTo = ["websocket"];

/***/ }),

/***/ "./node_modules/engine.io/build/transports/polling-jsonp.js":
/*!******************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling-jsonp.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.JSONP = void 0;

var polling_1 = __webpack_require__(/*! ./polling */ "./node_modules/engine.io/build/transports/polling.js");

var qs = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

var rDoubleSlashes = /\\\\n/g;
var rSlashes = /(\\)?\\n/g;

var JSONP = /*#__PURE__*/function (_polling_1$Polling) {
  _inherits(JSONP, _polling_1$Polling);

  var _super = _createSuper(JSONP);

  /**
   * JSON-P polling transport.
   *
   * @api public
   */
  function JSONP(req) {
    var _this;

    _classCallCheck(this, JSONP);

    _this = _super.call(this, req);
    _this.head = "___eio[" + (req._query.j || "").replace(/[^0-9]/g, "") + "](";
    _this.foot = ");";
    return _this;
  }
  /**
   * Handles incoming data.
   * Due to a bug in \n handling by browsers, we expect a escaped string.
   *
   * @api private
   */


  _createClass(JSONP, [{
    key: "onData",
    value: function onData(data) {
      // we leverage the qs module so that we get built-in DoS protection
      // and the fast alternative to decodeURIComponent
      data = qs.parse(data).d;

      if ("string" === typeof data) {
        // client will send already escaped newlines as \\\\n and newlines as \\n
        // \\n must be replaced with \n and \\\\n with \\n
        data = data.replace(rSlashes, function (match, slashes) {
          return slashes ? match : "\n";
        });

        _get(_getPrototypeOf(JSONP.prototype), "onData", this).call(this, data.replace(rDoubleSlashes, "\\n"));
      }
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      // we must output valid javascript, not valid json
      // see: http://timelessrepo.com/json-isnt-a-javascript-subset
      var js = JSON.stringify(data).replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029"); // prepare response

      data = this.head + js + this.foot;

      _get(_getPrototypeOf(JSONP.prototype), "doWrite", this).call(this, data, options, callback);
    }
  }]);

  return JSONP;
}(polling_1.Polling);

exports.JSONP = JSONP;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/polling.js":
/*!************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/polling.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Polling = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:polling");
var compressionMethods = {
  gzip: zlib_1.createGzip,
  deflate: zlib_1.createDeflate
};

var Polling = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(Polling, _transport_1$Transpor);

  var _super = _createSuper(Polling);

  /**
   * HTTP polling constructor.
   *
   * @api public.
   */
  function Polling(req) {
    var _this;

    _classCallCheck(this, Polling);

    _this = _super.call(this, req);
    _this.closeTimeout = 30 * 1000;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(Polling, [{
    key: "name",
    get: function get() {
      return "polling";
    }
  }, {
    key: "supportsFraming",
    get: function get() {
      return false;
    }
    /**
     * Overrides onRequest.
     *
     * @param {http.IncomingMessage}
     * @api private
     */

  }, {
    key: "onRequest",
    value: function onRequest(req) {
      var res = req.res;

      if ("GET" === req.method) {
        this.onPollRequest(req, res);
      } else if ("POST" === req.method) {
        this.onDataRequest(req, res);
      } else {
        res.writeHead(500);
        res.end();
      }
    }
    /**
     * The client sends a request awaiting for us to send data.
     *
     * @api private
     */

  }, {
    key: "onPollRequest",
    value: function onPollRequest(req, res) {
      var _this2 = this;

      if (this.req) {
        debug("request overlap"); // assert: this.res, '.req and .res should be (un)set together'

        this.onError("overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      debug("setting request");
      this.req = req;
      this.res = res;

      var onClose = function onClose() {
        _this2.onError("poll connection closed prematurely");
      };

      var cleanup = function cleanup() {
        req.removeListener("close", onClose);
        _this2.req = _this2.res = null;
      };

      req.cleanup = cleanup;
      req.on("close", onClose);
      this.writable = true;
      this.emit("drain"); // if we're still writable but had a pending close, trigger an empty send

      if (this.writable && this.shouldClose) {
        debug("triggering empty send to append close packet");
        this.send([{
          type: "noop"
        }]);
      }
    }
    /**
     * The client sends a request with data.
     *
     * @api private
     */

  }, {
    key: "onDataRequest",
    value: function onDataRequest(req, res) {
      var _this3 = this;

      if (this.dataReq) {
        // assert: this.dataRes, '.dataReq and .dataRes should be (un)set together'
        this.onError("data request overlap from client");
        res.writeHead(500);
        res.end();
        return;
      }

      var isBinary = "application/octet-stream" === req.headers["content-type"];

      if (isBinary && this.protocol === 4) {
        return this.onError("invalid content");
      }

      this.dataReq = req;
      this.dataRes = res;
      var chunks = isBinary ? Buffer.concat([]) : "";

      var cleanup = function cleanup() {
        req.removeListener("data", onData);
        req.removeListener("end", onEnd);
        req.removeListener("close", onClose);
        _this3.dataReq = _this3.dataRes = chunks = null;
      };

      var onClose = function onClose() {
        cleanup();

        _this3.onError("data request connection closed prematurely");
      };

      var onData = function onData(data) {
        var contentLength;

        if (isBinary) {
          chunks = Buffer.concat([chunks, data]);
          contentLength = chunks.length;
        } else {
          chunks += data;
          contentLength = Buffer.byteLength(chunks);
        }

        if (contentLength > _this3.maxHttpBufferSize) {
          chunks = isBinary ? Buffer.concat([]) : "";
          req.connection.destroy();
        }
      };

      var onEnd = function onEnd() {
        _this3.onData(chunks);

        var headers = {
          // text/html is required instead of text/plain to avoid an
          // unwanted download dialog on certain user-agents (GH-43)
          "Content-Type": "text/html",
          "Content-Length": 2
        };
        res.writeHead(200, _this3.headers(req, headers));
        res.end("ok");
        cleanup();
      };

      req.on("close", onClose);
      if (!isBinary) req.setEncoding("utf8");
      req.on("data", onData);
      req.on("end", onEnd);
    }
    /**
     * Processes the incoming data payload.
     *
     * @param {String} encoded payload
     * @api private
     */

  }, {
    key: "onData",
    value: function onData(data) {
      var _this4 = this;

      debug('received "%s"', data);

      var callback = function callback(packet) {
        if ("close" === packet.type) {
          debug("got xhr close packet");

          _this4.onClose();

          return false;
        }

        _this4.onPacket(packet);
      };

      if (this.protocol === 3) {
        this.parser.decodePayload(data, callback);
      } else {
        this.parser.decodePayload(data).forEach(callback);
      }
    }
    /**
     * Overrides onClose.
     *
     * @api private
     */

  }, {
    key: "onClose",
    value: function onClose() {
      if (this.writable) {
        // close pending poll request
        this.send([{
          type: "noop"
        }]);
      }

      _get(_getPrototypeOf(Polling.prototype), "onClose", this).call(this);
    }
    /**
     * Writes a packet payload.
     *
     * @param {Object} packet
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this5 = this;

      this.writable = false;

      if (this.shouldClose) {
        debug("appending close packet to payload");
        packets.push({
          type: "close"
        });
        this.shouldClose();
        this.shouldClose = null;
      }

      var doWrite = function doWrite(data) {
        var compress = packets.some(function (packet) {
          return packet.options && packet.options.compress;
        });

        _this5.write(data, {
          compress: compress
        });
      };

      if (this.protocol === 3) {
        this.parser.encodePayload(packets, this.supportsBinary, doWrite);
      } else {
        this.parser.encodePayload(packets, doWrite);
      }
    }
    /**
     * Writes data as response to poll request.
     *
     * @param {String} data
     * @param {Object} options
     * @api private
     */

  }, {
    key: "write",
    value: function write(data, options) {
      var _this6 = this;

      debug('writing "%s"', data);
      this.doWrite(data, options, function () {
        _this6.req.cleanup();
      });
    }
    /**
     * Performs the write.
     *
     * @api private
     */

  }, {
    key: "doWrite",
    value: function doWrite(data, options, callback) {
      var _this7 = this;

      // explicit UTF-8 is required for pages not served under utf
      var isString = typeof data === "string";
      var contentType = isString ? "text/plain; charset=UTF-8" : "application/octet-stream";
      var headers = {
        "Content-Type": contentType
      };

      var respond = function respond(data) {
        headers["Content-Length"] = "string" === typeof data ? Buffer.byteLength(data) : data.length;

        _this7.res.writeHead(200, _this7.headers(_this7.req, headers));

        _this7.res.end(data);

        callback();
      };

      if (!this.httpCompression || !options.compress) {
        respond(data);
        return;
      }

      var len = isString ? Buffer.byteLength(data) : data.length;

      if (len < this.httpCompression.threshold) {
        respond(data);
        return;
      }

      var encoding = accepts(this.req).encodings(["gzip", "deflate"]);

      if (!encoding) {
        respond(data);
        return;
      }

      this.compress(data, encoding, function (err, data) {
        if (err) {
          _this7.res.writeHead(500);

          _this7.res.end();

          callback(err);
          return;
        }

        headers["Content-Encoding"] = encoding;
        respond(data);
      });
    }
    /**
     * Compresses data.
     *
     * @api private
     */

  }, {
    key: "compress",
    value: function compress(data, encoding, callback) {
      debug("compressing");
      var buffers = [];
      var nread = 0;
      compressionMethods[encoding](this.httpCompression).on("error", callback).on("data", function (chunk) {
        buffers.push(chunk);
        nread += chunk.length;
      }).on("end", function () {
        callback(null, Buffer.concat(buffers, nread));
      }).end(data);
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      var _this8 = this;

      debug("closing");
      var closeTimeoutTimer;

      if (this.dataReq) {
        debug("aborting ongoing data request");
        this.dataReq.destroy();
      }

      var onClose = function onClose() {
        clearTimeout(closeTimeoutTimer);
        fn();

        _this8.onClose();
      };

      if (this.writable) {
        debug("transport writable - closing right away");
        this.send([{
          type: "close"
        }]);
        onClose();
      } else if (this.discarded) {
        debug("transport discarded - closing right away");
        onClose();
      } else {
        debug("transport not writable - buffering orderly close");
        this.shouldClose = onClose;
        closeTimeoutTimer = setTimeout(onClose, this.closeTimeout);
      }
    }
    /**
     * Returns headers for a response.
     *
     * @param {http.IncomingMessage} request
     * @param {Object} extra headers
     * @api private
     */

  }, {
    key: "headers",
    value: function headers(req, _headers) {
      _headers = _headers || {}; // prevent XSS warnings on IE
      // https://github.com/LearnBoost/socket.io/pull/1333

      var ua = req.headers["user-agent"];

      if (ua && (~ua.indexOf(";MSIE") || ~ua.indexOf("Trident/"))) {
        _headers["X-XSS-Protection"] = "0";
      }

      this.emit("headers", _headers, req);
      return _headers;
    }
  }]);

  return Polling;
}(transport_1.Transport);

exports.Polling = Polling;

/***/ }),

/***/ "./node_modules/engine.io/build/transports/websocket.js":
/*!**************************************************************!*\
  !*** ./node_modules/engine.io/build/transports/websocket.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.WebSocket = void 0;

var transport_1 = __webpack_require__(/*! ../transport */ "./node_modules/engine.io/build/transport.js");

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var debug = (0, debug_1["default"])("engine:ws");

var WebSocket = /*#__PURE__*/function (_transport_1$Transpor) {
  _inherits(WebSocket, _transport_1$Transpor);

  var _super = _createSuper(WebSocket);

  /**
   * WebSocket transport
   *
   * @param {http.IncomingMessage}
   * @api public
   */
  function WebSocket(req) {
    var _thisSuper, _this;

    _classCallCheck(this, WebSocket);

    _this = _super.call(this, req);
    _this.socket = req.websocket;

    _this.socket.on("message", function (data, isBinary) {
      var message = isBinary ? data : data.toString();
      debug('received "%s"', message);

      _get((_thisSuper = _assertThisInitialized(_this), _getPrototypeOf(WebSocket.prototype)), "onData", _thisSuper).call(_thisSuper, message);
    });

    _this.socket.once("close", _this.onClose.bind(_assertThisInitialized(_this)));

    _this.socket.on("error", _this.onError.bind(_assertThisInitialized(_this)));

    _this.writable = true;
    _this.perMessageDeflate = null;
    return _this;
  }
  /**
   * Transport name
   *
   * @api public
   */


  _createClass(WebSocket, [{
    key: "name",
    get: function get() {
      return "websocket";
    }
    /**
     * Advertise upgrade support.
     *
     * @api public
     */

  }, {
    key: "handlesUpgrades",
    get: function get() {
      return true;
    }
    /**
     * Advertise framing support.
     *
     * @api public
     */

  }, {
    key: "supportsFraming",
    get: function get() {
      return true;
    }
    /**
     * Writes a packet payload.
     *
     * @param {Array} packets
     * @api private
     */

  }, {
    key: "send",
    value: function send(packets) {
      var _this2 = this;

      var packet = packets.shift();

      if (typeof packet === "undefined") {
        this.writable = true;
        this.emit("drain");
        return;
      } // always creates a new object since ws modifies it


      var opts = {};

      if (packet.options) {
        opts.compress = packet.options.compress;
      }

      var send = function send(data) {
        if (_this2.perMessageDeflate) {
          var len = "string" === typeof data ? Buffer.byteLength(data) : data.length;

          if (len < _this2.perMessageDeflate.threshold) {
            opts.compress = false;
          }
        }

        debug('writing "%s"', data);
        _this2.writable = false;

        _this2.socket.send(data, opts, function (err) {
          if (err) return _this2.onError("write error", err.stack);

          _this2.send(packets);
        });
      };

      if (packet.options && typeof packet.options.wsPreEncoded === "string") {
        send(packet.options.wsPreEncoded);
      } else {
        this.parser.encodePacket(packet, this.supportsBinary, send);
      }
    }
    /**
     * Closes the transport.
     *
     * @api private
     */

  }, {
    key: "doClose",
    value: function doClose(fn) {
      debug("closing");
      this.socket.close();
      fn && fn();
    }
  }]);

  return WebSocket;
}(transport_1.Transport);

exports.WebSocket = WebSocket;

/***/ }),

/***/ "./node_modules/engine.io/build/userver.js":
/*!*************************************************!*\
  !*** ./node_modules/engine.io/build/userver.js ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.uServer = void 0;

var debug_1 = __webpack_require__(/*! debug */ "./node_modules/engine.io/node_modules/debug/src/browser.js");

var server_1 = __webpack_require__(/*! ./server */ "./node_modules/engine.io/build/server.js");

var transports_uws_1 = __webpack_require__(/*! ./transports-uws */ "./node_modules/engine.io/build/transports-uws/index.js");

var debug = (0, debug_1["default"])("engine:uws");

var uServer = /*#__PURE__*/function (_server_1$BaseServer) {
  _inherits(uServer, _server_1$BaseServer);

  var _super = _createSuper(uServer);

  function uServer() {
    _classCallCheck(this, uServer);

    return _super.apply(this, arguments);
  }

  _createClass(uServer, [{
    key: "init",
    value: function init() {}
  }, {
    key: "cleanup",
    value: function cleanup() {}
    /**
     * Prepares a request by processing the query string.
     *
     * @api private
     */

  }, {
    key: "prepare",
    value: function prepare(req, res) {
      req.method = req.getMethod().toUpperCase();
      var params = new URLSearchParams(req.getQuery());
      req._query = Object.fromEntries(params.entries());
      req.headers = {};
      req.forEach(function (key, value) {
        req.headers[key] = value;
      });
      req.connection = {
        remoteAddress: Buffer.from(res.getRemoteAddressAsText()).toString()
      };
      res.onAborted(function () {
        debug("response has been aborted");
      });
    }
  }, {
    key: "createTransport",
    value: function createTransport(transportName, req) {
      return new transports_uws_1["default"][transportName](req);
    }
    /**
     * Attach the engine to a WebSockets.js server
     * @param app
     * @param options
     */

  }, {
    key: "attach",
    value: function attach(app
    /* : TemplatedApp */
    ) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var path = (options.path || "/engine.io").replace(/\/$/, "") + "/";
      app.any(path, this.handleRequest.bind(this)) //
      .ws(path, {
        compression: options.compression,
        idleTimeout: options.idleTimeout,
        maxBackpressure: options.maxBackpressure,
        maxPayloadLength: this.opts.maxHttpBufferSize,
        upgrade: this.handleUpgrade.bind(this),
        open: function open(ws) {
          ws.transport.socket = ws;
          ws.transport.writable = true;
          ws.transport.emit("drain");
        },
        message: function message(ws, _message, isBinary) {
          ws.transport.onData(isBinary ? _message : Buffer.from(_message).toString());
        },
        close: function close(ws, code, message) {
          ws.transport.onClose(code, message);
        }
      });
    }
  }, {
    key: "handleRequest",
    value: function handleRequest(res, req) {
      var _this = this;

      debug('handling "%s" http request "%s"', req.getMethod(), req.getUrl());
      this.prepare(req, res);
      req.res = res;

      var callback = function callback(errorCode, errorContext) {
        if (errorCode !== undefined) {
          _this.emit("connection_error", {
            req: req,
            code: errorCode,
            message: server_1.Server.errorMessages[errorCode],
            context: errorContext
          });

          _this.abortRequest(req.res, errorCode, errorContext);

          return;
        }

        if (req._query.sid) {
          debug("setting new request for existing client");

          _this.clients[req._query.sid].transport.onRequest(req);
        } else {
          var closeConnection = function closeConnection(errorCode, errorContext) {
            return _this.abortRequest(res, errorCode, errorContext);
          };

          _this.handshake(req._query.transport, req, closeConnection);
        }
      };

      if (this.corsMiddleware) {
        // needed to buffer headers until the status is computed
        req.res = new ResponseWrapper(res);
        this.corsMiddleware.call(null, req, req.res, function () {
          _this.verify(req, false, callback);
        });
      } else {
        this.verify(req, false, callback);
      }
    }
  }, {
    key: "handleUpgrade",
    value: function handleUpgrade(res, req, context) {
      var _this2 = this;

      debug("on upgrade");
      this.prepare(req, res); // @ts-ignore

      req.res = res;
      this.verify(req, true, /*#__PURE__*/function () {
        var _ref = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(errorCode, errorContext) {
          var id, transport, client;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  if (!errorCode) {
                    _context.next = 4;
                    break;
                  }

                  _this2.emit("connection_error", {
                    req: req,
                    code: errorCode,
                    message: server_1.Server.errorMessages[errorCode],
                    context: errorContext
                  });

                  _this2.abortRequest(res, errorCode, errorContext);

                  return _context.abrupt("return");

                case 4:
                  id = req._query.sid;

                  if (!id) {
                    _context.next = 10;
                    break;
                  }

                  client = _this2.clients[id];

                  if (!client) {
                    debug("upgrade attempt for closed client");
                    res.close();
                  } else if (client.upgrading) {
                    debug("transport has already been trying to upgrade");
                    res.close();
                  } else if (client.upgraded) {
                    debug("transport had already been upgraded");
                    res.close();
                  } else {
                    debug("upgrading existing transport");
                    transport = _this2.createTransport(req._query.transport, req);
                    client.maybeUpgrade(transport);
                  }

                  _context.next = 15;
                  break;

                case 10:
                  _context.next = 12;
                  return _this2.handshake(req._query.transport, req, function (errorCode, errorContext) {
                    return _this2.abortRequest(res, errorCode, errorContext);
                  });

                case 12:
                  transport = _context.sent;

                  if (transport) {
                    _context.next = 15;
                    break;
                  }

                  return _context.abrupt("return");

                case 15:
                  res.upgrade({
                    transport: transport
                  }, req.getHeader("sec-websocket-key"), req.getHeader("sec-websocket-protocol"), req.getHeader("sec-websocket-extensions"), context);

                case 16:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        return function (_x, _x2) {
          return _ref.apply(this, arguments);
        };
      }());
    }
  }, {
    key: "abortRequest",
    value: function abortRequest(res, errorCode, errorContext) {
      var statusCode = errorCode === server_1.Server.errors.FORBIDDEN ? "403 Forbidden" : "400 Bad Request";
      var message = errorContext && errorContext.message ? errorContext.message : server_1.Server.errorMessages[errorCode];
      res.writeStatus(statusCode);
      res.writeHeader("Content-Type", "application/json");
      res.end(JSON.stringify({
        code: errorCode,
        message: message
      }));
    }
  }]);

  return uServer;
}(server_1.BaseServer);

exports.uServer = uServer;

var ResponseWrapper = /*#__PURE__*/function () {
  function ResponseWrapper(res) {
    _classCallCheck(this, ResponseWrapper);

    this.res = res;
    this.statusWritten = false;
    this.headers = [];
  }

  _createClass(ResponseWrapper, [{
    key: "statusCode",
    set: function set(status) {
      this.writeStatus(status === 200 ? "200 OK" : "204 No Content");
    }
  }, {
    key: "setHeader",
    value: function setHeader(key, value) {
      this.writeHeader(key, value);
    } // needed by vary: https://github.com/jshttp/vary/blob/5d725d059b3871025cf753e9dfa08924d0bcfa8f/index.js#L134

  }, {
    key: "getHeader",
    value: function getHeader() {}
  }, {
    key: "writeStatus",
    value: function writeStatus(status) {
      this.res.writeStatus(status);
      this.statusWritten = true;
      this.writeBufferedHeaders();
    }
  }, {
    key: "writeHeader",
    value: function writeHeader(key, value) {
      if (key === "Content-Length") {
        // the content length is automatically added by uWebSockets.js
        return;
      }

      if (this.statusWritten) {
        this.res.writeHeader(key, value);
      } else {
        this.headers.push([key, value]);
      }
    }
  }, {
    key: "writeBufferedHeaders",
    value: function writeBufferedHeaders() {
      var _this3 = this;

      this.headers.forEach(function (_ref2) {
        var _ref3 = _slicedToArray(_ref2, 2),
            key = _ref3[0],
            value = _ref3[1];

        _this3.res.writeHeader(key, value);
      });
    }
  }, {
    key: "end",
    value: function end(data) {
      if (!this.statusWritten) {
        // status will be inferred as "200 OK"
        this.writeBufferedHeaders();
      }

      this.res.end(data);
    }
  }, {
    key: "onData",
    value: function onData(fn) {
      this.res.onData(fn);
    }
  }, {
    key: "onAborted",
    value: function onAborted(fn) {
      this.res.onAborted(fn);
    }
  }]);

  return ResponseWrapper;
}();

/***/ }),

/***/ "./node_modules/socket.io/dist/broadcast-operator.js":
/*!***********************************************************!*\
  !*** ./node_modules/socket.io/dist/broadcast-operator.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.RemoteSocket = exports.BroadcastOperator = void 0;

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var BroadcastOperator = /*#__PURE__*/function () {
  function BroadcastOperator(adapter) {
    var rooms = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Set();
    var exceptRooms = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Set();
    var flags = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, BroadcastOperator);

    this.adapter = adapter;
    this.rooms = rooms;
    this.exceptRooms = exceptRooms;
    this.flags = flags;
  }
  /**
   * Targets a room when emitting.
   *
   * @param room
   * @return a new BroadcastOperator instance
   * @public
   */


  _createClass(BroadcastOperator, [{
    key: "to",
    value: function to(room) {
      var rooms = new Set(this.rooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return rooms.add(r);
        });
      } else {
        rooms.add(room);
      }

      return new BroadcastOperator(this.adapter, rooms, this.exceptRooms, this.flags);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.to(room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      var exceptRooms = new Set(this.exceptRooms);

      if (Array.isArray(room)) {
        room.forEach(function (r) {
          return exceptRooms.add(r);
        });
      } else {
        exceptRooms.add(room);
      }

      return new BroadcastOperator(this.adapter, this.rooms, exceptRooms, this.flags);
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      var flags = _extends({}, this.flags, {
        compress: _compress
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      var flags = _extends({}, this.flags, {
        "volatile": true
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return a new BroadcastOperator instance
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      var flags = _extends({}, this.flags, {
        local: true
      });

      return new BroadcastOperator(this.adapter, this.rooms, this.exceptRooms, flags);
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (socket_1.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      } // set up packet object


      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      };

      if ("function" == typeof data[data.length - 1]) {
        throw new Error("Callbacks are not supported when broadcasting");
      }

      this.adapter.broadcast(packet, {
        rooms: this.rooms,
        except: this.exceptRooms,
        flags: this.flags
      });
      return true;
    }
    /**
     * Gets a list of clients.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      if (!this.adapter) {
        throw new Error("No adapter for this namespace, are you trying to get the list of clients of a dynamic namespace?");
      }

      return this.adapter.sockets(this.rooms);
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      var _this = this;

      return this.adapter.fetchSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }).then(function (sockets) {
        return sockets.map(function (socket) {
          if (socket instanceof socket_1.Socket) {
            // FIXME the TypeScript compiler complains about missing private properties
            return socket;
          } else {
            return new RemoteSocket(_this.adapter, socket);
          }
        });
      });
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      this.adapter.addSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      this.adapter.delSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, Array.isArray(room) ? room : [room]);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.adapter.disconnectSockets({
        rooms: this.rooms,
        except: this.exceptRooms
      }, close);
    }
  }]);

  return BroadcastOperator;
}();

exports.BroadcastOperator = BroadcastOperator;
/**
 * Expose of subset of the attributes and methods of the Socket class
 */

var RemoteSocket = /*#__PURE__*/function () {
  function RemoteSocket(adapter, details) {
    _classCallCheck(this, RemoteSocket);

    this.id = details.id;
    this.handshake = details.handshake;
    this.rooms = new Set(details.rooms);
    this.data = details.data;
    this.operator = new BroadcastOperator(adapter, new Set([this.id]));
  }

  _createClass(RemoteSocket, [{
    key: "emit",
    value: function emit(ev) {
      var _this$operator;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_this$operator = this.operator).emit.apply(_this$operator, [ev].concat(args));
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} room - room or array of rooms
     * @public
     */

  }, {
    key: "join",
    value: function join(room) {
      return this.operator.socketsJoin(room);
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     * @public
     */

  }, {
    key: "leave",
    value: function leave(room) {
      return this.operator.socketsLeave(room);
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     *
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      this.operator.disconnectSockets(close);
      return this;
    }
  }]);

  return RemoteSocket;
}();

exports.RemoteSocket = RemoteSocket;

/***/ }),

/***/ "./node_modules/socket.io/dist/client.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/client.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Client = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var debugModule = __webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var debug = debugModule("socket.io:client");

var Client = /*#__PURE__*/function () {
  /**
   * Client constructor.
   *
   * @param server instance
   * @param conn
   * @package
   */
  function Client(server, conn) {
    _classCallCheck(this, Client);

    this.sockets = new Map();
    this.nsps = new Map();
    this.server = server;
    this.conn = conn;
    this.encoder = server.encoder;
    this.decoder = new server._parser.Decoder();
    this.id = conn.id;
    this.setup();
  }
  /**
   * @return the reference to the request that originated the Engine.IO connection
   *
   * @public
   */


  _createClass(Client, [{
    key: "request",
    get: function get() {
      return this.conn.request;
    }
    /**
     * Sets up event listeners.
     *
     * @private
     */

  }, {
    key: "setup",
    value: function setup() {
      var _this = this;

      this.onclose = this.onclose.bind(this);
      this.ondata = this.ondata.bind(this);
      this.onerror = this.onerror.bind(this);
      this.ondecoded = this.ondecoded.bind(this); // @ts-ignore

      this.decoder.on("decoded", this.ondecoded);
      this.conn.on("data", this.ondata);
      this.conn.on("error", this.onerror);
      this.conn.on("close", this.onclose);
      this.connectTimeout = setTimeout(function () {
        if (_this.nsps.size === 0) {
          debug("no namespace joined yet, close the client");

          _this.close();
        } else {
          debug("the client has already joined a namespace, nothing to do");
        }
      }, this.server._connectTimeout);
    }
    /**
     * Connects a client to a namespace.
     *
     * @param {String} name - the namespace
     * @param {Object} auth - the auth parameters
     * @private
     */

  }, {
    key: "connect",
    value: function connect(name) {
      var _this2 = this;

      var auth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.server._nsps.has(name)) {
        debug("connecting to namespace %s", name);
        return this.doConnect(name, auth);
      }

      this.server._checkNamespace(name, auth, function (dynamicNspName) {
        if (dynamicNspName) {
          _this2.doConnect(name, auth);
        } else {
          debug("creation of namespace %s was denied", name);

          _this2._packet({
            type: socket_io_parser_1.PacketType.CONNECT_ERROR,
            nsp: name,
            data: {
              message: "Invalid namespace"
            }
          });
        }
      });
    }
    /**
     * Connects a client to a namespace.
     *
     * @param name - the namespace
     * @param {Object} auth - the auth parameters
     *
     * @private
     */

  }, {
    key: "doConnect",
    value: function doConnect(name, auth) {
      var _this3 = this;

      var nsp = this.server.of(name);

      var socket = nsp._add(this, auth, function () {
        _this3.sockets.set(socket.id, socket);

        _this3.nsps.set(nsp.name, socket);

        if (_this3.connectTimeout) {
          clearTimeout(_this3.connectTimeout);
          _this3.connectTimeout = undefined;
        }
      });
    }
    /**
     * Disconnects from all namespaces and closes transport.
     *
     * @private
     */

  }, {
    key: "_disconnect",
    value: function _disconnect() {
      var _iterator = _createForOfIteratorHelper(this.sockets.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var socket = _step.value;
          socket.disconnect();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      this.sockets.clear();
      this.close();
    }
    /**
     * Removes a socket. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        var nsp = this.sockets.get(socket.id).nsp.name;
        this.sockets["delete"](socket.id);
        this.nsps["delete"](nsp);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Closes the underlying connection.
     *
     * @private
     */

  }, {
    key: "close",
    value: function close() {
      if ("open" === this.conn.readyState) {
        debug("forcing transport close");
        this.conn.close();
        this.onclose("forced server close");
      }
    }
    /**
     * Writes a packet to the transport.
     *
     * @param {Object} packet object
     * @param {Object} opts
     * @private
     */

  }, {
    key: "_packet",
    value: function _packet(packet) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (this.conn.readyState !== "open") {
        debug("ignoring packet write %j", packet);
        return;
      }

      var encodedPackets = opts.preEncoded ? packet // previous versions of the adapter incorrectly used socket.packet() instead of writeToEngine()
      : this.encoder.encode(packet);
      this.writeToEngine(encodedPackets, opts);
    }
  }, {
    key: "writeToEngine",
    value: function writeToEngine(encodedPackets, opts) {
      if (opts["volatile"] && !this.conn.transport.writable) {
        debug("volatile packet is discarded since the transport is not currently writable");
        return;
      }

      var packets = Array.isArray(encodedPackets) ? encodedPackets : [encodedPackets];

      var _iterator2 = _createForOfIteratorHelper(packets),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var encodedPacket = _step2.value;
          this.conn.write(encodedPacket, opts);
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
    }
    /**
     * Called with incoming transport data.
     *
     * @private
     */

  }, {
    key: "ondata",
    value: function ondata(data) {
      // try/catch is needed for protocol violations (GH-1880)
      try {
        this.decoder.add(data);
      } catch (e) {
        this.onerror(e);
      }
    }
    /**
     * Called when parser fully decodes a packet.
     *
     * @private
     */

  }, {
    key: "ondecoded",
    value: function ondecoded(packet) {
      if (socket_io_parser_1.PacketType.CONNECT === packet.type) {
        if (this.conn.protocol === 3) {
          var parsed = url.parse(packet.nsp, true);
          this.connect(parsed.pathname, parsed.query);
        } else {
          this.connect(packet.nsp, packet.data);
        }
      } else {
        var socket = this.nsps.get(packet.nsp);

        if (socket) {
          process.nextTick(function () {
            socket._onpacket(packet);
          });
        } else {
          debug("no socket for namespace %s", packet.nsp);
        }
      }
    }
    /**
     * Handles an error.
     *
     * @param {Object} err object
     * @private
     */

  }, {
    key: "onerror",
    value: function onerror(err) {
      var _iterator3 = _createForOfIteratorHelper(this.sockets.values()),
          _step3;

      try {
        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {
          var socket = _step3.value;

          socket._onerror(err);
        }
      } catch (err) {
        _iterator3.e(err);
      } finally {
        _iterator3.f();
      }

      this.conn.close();
    }
    /**
     * Called upon transport close.
     *
     * @param reason
     * @private
     */

  }, {
    key: "onclose",
    value: function onclose(reason) {
      debug("client close with reason %s", reason); // ignore a potential subsequent `close` event

      this.destroy(); // `nsps` and `sockets` are cleaned up seamlessly

      var _iterator4 = _createForOfIteratorHelper(this.sockets.values()),
          _step4;

      try {
        for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {
          var socket = _step4.value;

          socket._onclose(reason);
        }
      } catch (err) {
        _iterator4.e(err);
      } finally {
        _iterator4.f();
      }

      this.sockets.clear();
      this.decoder.destroy(); // clean up decoder
    }
    /**
     * Cleans up event listeners.
     * @private
     */

  }, {
    key: "destroy",
    value: function destroy() {
      this.conn.removeListener("data", this.ondata);
      this.conn.removeListener("error", this.onerror);
      this.conn.removeListener("close", this.onclose); // @ts-ignore

      this.decoder.removeListener("decoded", this.ondecoded);

      if (this.connectTimeout) {
        clearTimeout(this.connectTimeout);
        this.connectTimeout = undefined;
      }
    }
  }]);

  return Client;
}();

exports.Client = Client;

/***/ }),

/***/ "./node_modules/socket.io/dist/index.js":
/*!**********************************************!*\
  !*** ./node_modules/socket.io/dist/index.js ***!
  \**********************************************/
/***/ (function(module, exports, __webpack_require__) {

var __dirname = "/";


function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  Object.defineProperty(o, k2, {
    enumerable: true,
    get: function get() {
      return m[k];
    }
  });
} : function (o, m, k, k2) {
  if (k2 === undefined) k2 = k;
  o[k2] = m[k];
});

var __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {
  Object.defineProperty(o, "default", {
    enumerable: true,
    value: v
  });
} : function (o, v) {
  o["default"] = v;
});

var __importStar = this && this.__importStar || function (mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) for (var k in mod) {
    if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }

  __setModuleDefault(result, mod);

  return result;
};

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Namespace = exports.Socket = exports.Server = void 0;

var http = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'http'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var zlib_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'zlib'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var accepts = __webpack_require__(/*! accepts */ "./node_modules/accepts/index.js");

var stream_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'stream'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var path = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'path'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var engine_io_1 = __webpack_require__(/*! engine.io */ "./node_modules/engine.io/build/engine.io.js");

var client_1 = __webpack_require__(/*! ./client */ "./node_modules/socket.io/dist/client.js");

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");

var namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/socket.io/dist/namespace.js");

Object.defineProperty(exports, "Namespace", ({
  enumerable: true,
  get: function get() {
    return namespace_1.Namespace;
  }
}));

var parent_namespace_1 = __webpack_require__(/*! ./parent-namespace */ "./node_modules/socket.io/dist/parent-namespace.js");

var socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "./node_modules/socket.io-adapter/dist/index.js");

var parser = __importStar(__webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js"));

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

Object.defineProperty(exports, "Socket", ({
  enumerable: true,
  get: function get() {
    return socket_1.Socket;
  }
}));

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var uws_js_1 = __webpack_require__(/*! ./uws.js */ "./node_modules/socket.io/dist/uws.js");

var debug = (0, debug_1["default"])("socket.io:server");

var clientVersion = (__webpack_require__(/*! ../package.json */ "./node_modules/socket.io/package.json").version);

var dotMapRegex = /\.map/;

var Server = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Server, _typed_events_1$Stric);

  var _super = _createSuper(Server);

  function Server(srv) {
    var _this;

    var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    _classCallCheck(this, Server);

    _this = _super.call(this);
    /**
     * @private
     */

    _this._nsps = new Map();
    _this.parentNsps = new Map();

    if ("object" === _typeof(srv) && srv instanceof Object && !srv.listen) {
      opts = srv;
      srv = undefined;
    }

    _this.path(opts.path || "/socket.io");

    _this.connectTimeout(opts.connectTimeout || 45000);

    _this.serveClient(false !== opts.serveClient);

    _this._parser = opts.parser || parser;
    _this.encoder = new _this._parser.Encoder();

    _this.adapter(opts.adapter || socket_io_adapter_1.Adapter);

    _this.sockets = _this.of("/");
    _this.opts = opts;
    if (srv || typeof srv == "number") _this.attach(srv);
    return _this;
  }

  _createClass(Server, [{
    key: "serveClient",
    value: function serveClient(v) {
      if (!arguments.length) return this._serveClient;
      this._serveClient = v;
      return this;
    }
    /**
     * Executes the middleware for an incoming namespace not already created on the server.
     *
     * @param name - name of incoming namespace
     * @param auth - the auth parameters
     * @param fn - callback
     *
     * @private
     */

  }, {
    key: "_checkNamespace",
    value: function _checkNamespace(name, auth, fn) {
      var _this2 = this;

      if (this.parentNsps.size === 0) return fn(false);
      var keysIterator = this.parentNsps.keys();

      var run = function run() {
        var nextFn = keysIterator.next();

        if (nextFn.done) {
          return fn(false);
        }

        nextFn.value(name, auth, function (err, allow) {
          if (err || !allow) {
            return run();
          }

          if (_this2._nsps.has(name)) {
            // the namespace was created in the meantime
            debug("dynamic namespace %s already exists", name);
            return fn(_this2._nsps.get(name));
          }

          var namespace = _this2.parentNsps.get(nextFn.value).createChild(name);

          debug("dynamic namespace %s was created", name); // @ts-ignore

          _this2.sockets.emitReserved("new_namespace", namespace);

          fn(namespace);
        });
      };

      run();
    }
  }, {
    key: "path",
    value: function path(v) {
      if (!arguments.length) return this._path;
      this._path = v.replace(/\/$/, "");

      var escapedPath = this._path.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");

      this.clientPathRegex = new RegExp("^" + escapedPath + "/socket\\.io(\\.msgpack|\\.esm)?(\\.min)?\\.js(\\.map)?(?:\\?|$)");
      return this;
    }
  }, {
    key: "connectTimeout",
    value: function connectTimeout(v) {
      if (v === undefined) return this._connectTimeout;
      this._connectTimeout = v;
      return this;
    }
  }, {
    key: "adapter",
    value: function adapter(v) {
      if (!arguments.length) return this._adapter;
      this._adapter = v;

      var _iterator = _createForOfIteratorHelper(this._nsps.values()),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var nsp = _step.value;

          nsp._initAdapter();
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }

      return this;
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "listen",
    value: function listen(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.attach(srv, opts);
    }
    /**
     * Attaches socket.io to a server or port.
     *
     * @param srv - server or port
     * @param opts - options passed to engine.io
     * @return self
     * @public
     */

  }, {
    key: "attach",
    value: function attach(srv) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if ("function" == typeof srv) {
        var msg = "You are trying to attach socket.io to an express " + "request handler function. Please pass a http.Server instance.";
        throw new Error(msg);
      } // handle a port as a string


      if (Number(srv) == srv) {
        srv = Number(srv);
      }

      if ("number" == typeof srv) {
        debug("creating http server and binding to %d", srv);
        var port = srv;
        srv = http.createServer(function (req, res) {
          res.writeHead(404);
          res.end();
        });
        srv.listen(port);
      } // merge the options passed to the Socket.IO server


      _extends(opts, this.opts); // set engine.io path to `/socket.io`


      opts.path = opts.path || this._path;
      this.initEngine(srv, opts);
      return this;
    }
  }, {
    key: "attachApp",
    value: function attachApp(app
    /*: TemplatedApp */
    ) {
      var _this3 = this;

      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      // merge the options passed to the Socket.IO server
      _extends(opts, this.opts); // set engine.io path to `/socket.io`


      opts.path = opts.path || this._path; // initialize engine

      debug("creating uWebSockets.js-based engine with opts %j", opts);
      var engine = new engine_io_1.uServer(opts);
      engine.attach(app, opts); // bind to engine events

      this.bind(engine);

      if (this._serveClient) {
        // attach static file serving
        app.get("".concat(this._path, "/*"), function (res, req) {
          if (!_this3.clientPathRegex.test(req.getUrl())) {
            req.setYield(true);
            return;
          }

          var filename = req.getUrl().replace(_this3._path, "").replace(/\?.*$/, "").replace(/^\//, "");
          var isMap = dotMapRegex.test(filename);
          var type = isMap ? "map" : "source"; // Per the standard, ETags must be quoted:
          // https://tools.ietf.org/html/rfc7232#section-2.3

          var expectedEtag = '"' + clientVersion + '"';
          var weakEtag = "W/" + expectedEtag;
          var etag = req.getHeader("if-none-match");

          if (etag) {
            if (expectedEtag === etag || weakEtag === etag) {
              debug("serve client %s 304", type);
              res.writeStatus("304 Not Modified");
              res.end();
              return;
            }
          }

          debug("serve client %s", type);
          res.writeHeader("cache-control", "public, max-age=0");
          res.writeHeader("content-type", "application/" + (isMap ? "json" : "javascript"));
          res.writeHeader("etag", expectedEtag);
          var filepath = path.join(__dirname, "../client-dist/", filename);
          (0, uws_js_1.serveFile)(res, filepath);
        });
      }

      (0, uws_js_1.patchAdapter)(app);
    }
    /**
     * Initialize engine
     *
     * @param srv - the server to attach to
     * @param opts - options passed to engine.io
     * @private
     */

  }, {
    key: "initEngine",
    value: function initEngine(srv, opts) {
      // initialize engine
      debug("creating engine.io instance with opts %j", opts);
      this.eio = (0, engine_io_1.attach)(srv, opts); // attach static file serving

      if (this._serveClient) this.attachServe(srv); // Export http server

      this.httpServer = srv; // bind to engine events

      this.bind(this.eio);
    }
    /**
     * Attaches the static file serving.
     *
     * @param srv http server
     * @private
     */

  }, {
    key: "attachServe",
    value: function attachServe(srv) {
      var _this4 = this;

      debug("attaching client serving req handler");
      var evs = srv.listeners("request").slice(0);
      srv.removeAllListeners("request");
      srv.on("request", function (req, res) {
        if (_this4.clientPathRegex.test(req.url)) {
          _this4.serve(req, res);
        } else {
          for (var i = 0; i < evs.length; i++) {
            evs[i].call(srv, req, res);
          }
        }
      });
    }
    /**
     * Handles a request serving of client source and map
     *
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "serve",
    value: function serve(req, res) {
      var filename = req.url.replace(this._path, "").replace(/\?.*$/, "");
      var isMap = dotMapRegex.test(filename);
      var type = isMap ? "map" : "source"; // Per the standard, ETags must be quoted:
      // https://tools.ietf.org/html/rfc7232#section-2.3

      var expectedEtag = '"' + clientVersion + '"';
      var weakEtag = "W/" + expectedEtag;
      var etag = req.headers["if-none-match"];

      if (etag) {
        if (expectedEtag === etag || weakEtag === etag) {
          debug("serve client %s 304", type);
          res.writeHead(304);
          res.end();
          return;
        }
      }

      debug("serve client %s", type);
      res.setHeader("Cache-Control", "public, max-age=0");
      res.setHeader("Content-Type", "application/" + (isMap ? "json" : "javascript"));
      res.setHeader("ETag", expectedEtag);
      Server.sendFile(filename, req, res);
    }
    /**
     * @param filename
     * @param req
     * @param res
     * @private
     */

  }, {
    key: "bind",
    value:
    /**
     * Binds socket.io to an engine.io instance.
     *
     * @param {engine.Server} engine engine.io (or compatible) server
     * @return self
     * @public
     */
    function bind(engine) {
      this.engine = engine;
      this.engine.on("connection", this.onconnection.bind(this));
      return this;
    }
    /**
     * Called with each incoming transport connection.
     *
     * @param {engine.Socket} conn
     * @return self
     * @private
     */

  }, {
    key: "onconnection",
    value: function onconnection(conn) {
      debug("incoming connection with id %s", conn.id);
      var client = new client_1.Client(this, conn);

      if (conn.protocol === 3) {
        // @ts-ignore
        client.connect("/");
      }

      return this;
    }
    /**
     * Looks up a namespace.
     *
     * @param {String|RegExp|Function} name nsp name
     * @param fn optional, nsp `connection` ev handler
     * @public
     */

  }, {
    key: "of",
    value: function of(name, fn) {
      if (typeof name === "function" || name instanceof RegExp) {
        var parentNsp = new parent_namespace_1.ParentNamespace(this);
        debug("initializing parent namespace %s", parentNsp.name);

        if (typeof name === "function") {
          this.parentNsps.set(name, parentNsp);
        } else {
          this.parentNsps.set(function (nsp, conn, next) {
            return next(null, name.test(nsp));
          }, parentNsp);
        }

        if (fn) {
          // @ts-ignore
          parentNsp.on("connect", fn);
        }

        return parentNsp;
      }

      if (String(name)[0] !== "/") name = "/" + name;

      var nsp = this._nsps.get(name);

      if (!nsp) {
        debug("initializing namespace %s", name);
        nsp = new namespace_1.Namespace(this, name);

        this._nsps.set(name, nsp);

        if (name !== "/") {
          // @ts-ignore
          this.sockets.emitReserved("new_namespace", nsp);
        }
      }

      if (fn) nsp.on("connect", fn);
      return nsp;
    }
    /**
     * Closes server connection
     *
     * @param [fn] optional, called as `fn([err])` on error OR all conns closed
     * @public
     */

  }, {
    key: "close",
    value: function close(fn) {
      var _iterator2 = _createForOfIteratorHelper(this.sockets.sockets.values()),
          _step2;

      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
          var socket = _step2.value;

          socket._onclose("server shutting down");
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }

      this.engine.close(); // restore the Adapter prototype

      (0, uws_js_1.restoreAdapter)();

      if (this.httpServer) {
        this.httpServer.close(fn);
      } else {
        fn && fn();
      }
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.sockets.use(fn);
      return this;
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return this.sockets.to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.sockets["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param name
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(name) {
      return this.sockets.except(name);
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      var _this$sockets;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      (_this$sockets = this.sockets).emit.apply(_this$sockets, ["message"].concat(args));

      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      var _this$sockets2;

      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      (_this$sockets2 = this.sockets).emit.apply(_this$sockets2, ["message"].concat(args));

      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      var _this$sockets3;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_this$sockets3 = this.sockets).serverSideEmit.apply(_this$sockets3, [ev].concat(args));
    }
    /**
     * Gets a list of socket ids.
     *
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return this.sockets.allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return this.sockets.compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      return this.sockets["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return this.sockets.local;
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      return this.sockets.fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return this.sockets.socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return this.sockets.socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.sockets.disconnectSockets(close);
    }
  }], [{
    key: "sendFile",
    value: function sendFile(filename, req, res) {
      var readStream = (0, fs_1.createReadStream)(path.join(__dirname, "../client-dist/", filename));
      var encoding = accepts(req).encodings(["br", "gzip", "deflate"]);

      var onError = function onError(err) {
        if (err) {
          res.end();
        }
      };

      switch (encoding) {
        case "br":
          res.writeHead(200, {
            "content-encoding": "br"
          });
          readStream.pipe((0, zlib_1.createBrotliCompress)()).pipe(res);
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createBrotliCompress)(), res, onError);
          break;

        case "gzip":
          res.writeHead(200, {
            "content-encoding": "gzip"
          });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createGzip)(), res, onError);
          break;

        case "deflate":
          res.writeHead(200, {
            "content-encoding": "deflate"
          });
          (0, stream_1.pipeline)(readStream, (0, zlib_1.createDeflate)(), res, onError);
          break;

        default:
          res.writeHead(200);
          (0, stream_1.pipeline)(readStream, res, onError);
      }
    }
  }]);

  return Server;
}(typed_events_1.StrictEventEmitter);

exports.Server = Server;
/**
 * Expose main namespace (/).
 */

var emitterMethods = Object.keys(events_1.EventEmitter.prototype).filter(function (key) {
  return typeof events_1.EventEmitter.prototype[key] === "function";
});
emitterMethods.forEach(function (fn) {
  Server.prototype[fn] = function () {
    return this.sockets[fn].apply(this.sockets, arguments);
  };
});

module.exports = function (srv, opts) {
  return new Server(srv, opts);
};

module.exports.Server = Server;
module.exports.Namespace = namespace_1.Namespace;
module.exports.Socket = socket_1.Socket;

/***/ }),

/***/ "./node_modules/socket.io/dist/namespace.js":
/*!**************************************************!*\
  !*** ./node_modules/socket.io/dist/namespace.js ***!
  \**************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Namespace = exports.RESERVED_EVENTS = void 0;

var socket_1 = __webpack_require__(/*! ./socket */ "./node_modules/socket.io/dist/socket.js");

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "./node_modules/socket.io/dist/broadcast-operator.js");

var debug = (0, debug_1["default"])("socket.io:namespace");
exports.RESERVED_EVENTS = new Set(["connect", "connection", "new_namespace"]);

var Namespace = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Namespace, _typed_events_1$Stric);

  var _super = _createSuper(Namespace);

  /**
   * Namespace constructor.
   *
   * @param server instance
   * @param name
   */
  function Namespace(server, name) {
    var _this;

    _classCallCheck(this, Namespace);

    _this = _super.call(this);
    _this.sockets = new Map();
    /** @private */

    _this._fns = [];
    /** @private */

    _this._ids = 0;
    _this.server = server;
    _this.name = name;

    _this._initAdapter();

    return _this;
  }
  /**
   * Initializes the `Adapter` for this nsp.
   * Run upon changing adapter by `Server#adapter`
   * in addition to the constructor.
   *
   * @private
   */


  _createClass(Namespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      // @ts-ignore
      this.adapter = new (this.server.adapter())(this);
    }
    /**
     * Sets up namespace middleware.
     *
     * @return self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this._fns.push(fn);

      return this;
    }
    /**
     * Executes the middleware for an incoming client.
     *
     * @param socket - the socket that will get added
     * @param fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(socket, fn) {
      var fns = this._fns.slice(0);

      if (!fns.length) return fn(null);

      function run(i) {
        fns[i](socket, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(null); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).to(room);
    }
    /**
     * Targets a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["in"](room);
    }
    /**
     * Excludes a room when emitting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).except(room);
    }
    /**
     * Adds a new client.
     *
     * @return {Socket}
     * @private
     */

  }, {
    key: "_add",
    value: function _add(client, query, fn) {
      var _this2 = this;

      debug("adding socket to nsp %s", this.name);
      var socket = new socket_1.Socket(this, client, query);
      this.run(socket, function (err) {
        process.nextTick(function () {
          if ("open" == client.conn.readyState) {
            if (err) {
              if (client.conn.protocol === 3) {
                return socket._error(err.data || err.message);
              } else {
                return socket._error({
                  message: err.message,
                  data: err.data
                });
              }
            } // track socket


            _this2.sockets.set(socket.id, socket); // it's paramount that the internal `onconnect` logic
            // fires before user-set events to prevent state order
            // violations (such as a disconnection before the connection
            // logic is complete)


            socket._onconnect();

            if (fn) fn(); // fire user-set events

            _this2.emitReserved("connect", socket);

            _this2.emitReserved("connection", socket);
          } else {
            debug("next called after client was closed - ignoring socket");
          }
        });
      });
      return socket;
    }
    /**
     * Removes a client. Called by each `Socket`.
     *
     * @private
     */

  }, {
    key: "_remove",
    value: function _remove(socket) {
      if (this.sockets.has(socket.id)) {
        this.sockets["delete"](socket.id);
      } else {
        debug("ignoring remove for %s", socket.id);
      }
    }
    /**
     * Emits to all clients.
     *
     * @return Always true
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _broadcast_operator_;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_broadcast_operator_ = new broadcast_operator_1.BroadcastOperator(this.adapter)).emit.apply(_broadcast_operator_, [ev].concat(args));
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event to all clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Emit a packet to other Socket.IO servers
     *
     * @param ev - the event name
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     * @public
     */

  }, {
    key: "serverSideEmit",
    value: function serverSideEmit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      }

      for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        args[_key4 - 1] = arguments[_key4];
      }

      args.unshift(ev);
      this.adapter.serverSideEmit(args);
      return true;
    }
    /**
     * Called when a packet is received from another Socket.IO server
     *
     * @param args - an array of arguments, which may include an acknowledgement callback at the end
     *
     * @private
     */

  }, {
    key: "_onServerSideEmit",
    value: function _onServerSideEmit(args) {
      _get(_getPrototypeOf(Namespace.prototype), "emitUntyped", this).apply(this, args);
    }
    /**
     * Gets a list of clients.
     *
     * @return self
     * @public
     */

  }, {
    key: "allSockets",
    value: function allSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).allSockets();
    }
    /**
     * Sets the compress flag.
     *
     * @param compress - if `true`, compresses the sending data
     * @return self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).compress(_compress);
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter)["volatile"];
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).local;
    }
    /**
     * Returns the matching socket instances
     *
     * @public
     */

  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).fetchSockets();
    }
    /**
     * Makes the matching socket instances join the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsJoin",
    value: function socketsJoin(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsJoin(room);
    }
    /**
     * Makes the matching socket instances leave the specified rooms
     *
     * @param room
     * @public
     */

  }, {
    key: "socketsLeave",
    value: function socketsLeave(room) {
      return new broadcast_operator_1.BroadcastOperator(this.adapter).socketsLeave(room);
    }
    /**
     * Makes the matching socket instances disconnect
     *
     * @param close - whether to close the underlying connection
     * @public
     */

  }, {
    key: "disconnectSockets",
    value: function disconnectSockets() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return new broadcast_operator_1.BroadcastOperator(this.adapter).disconnectSockets(close);
    }
  }]);

  return Namespace;
}(typed_events_1.StrictEventEmitter);

exports.Namespace = Namespace;

/***/ }),

/***/ "./node_modules/socket.io/dist/parent-namespace.js":
/*!*********************************************************!*\
  !*** ./node_modules/socket.io/dist/parent-namespace.js ***!
  \*********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.ParentNamespace = void 0;

var namespace_1 = __webpack_require__(/*! ./namespace */ "./node_modules/socket.io/dist/namespace.js");

var ParentNamespace = /*#__PURE__*/function (_namespace_1$Namespac) {
  _inherits(ParentNamespace, _namespace_1$Namespac);

  var _super = _createSuper(ParentNamespace);

  function ParentNamespace(server) {
    var _this;

    _classCallCheck(this, ParentNamespace);

    _this = _super.call(this, server, "/_" + ParentNamespace.count++);
    _this.children = new Set();
    return _this;
  }
  /**
   * @private
   */


  _createClass(ParentNamespace, [{
    key: "_initAdapter",
    value: function _initAdapter() {
      var _this2 = this;

      var broadcast = function broadcast(packet, opts) {
        _this2.children.forEach(function (nsp) {
          nsp.adapter.broadcast(packet, opts);
        });
      }; // @ts-ignore FIXME is there a way to declare an inner class in TypeScript?


      this.adapter = {
        broadcast: broadcast
      };
    }
  }, {
    key: "emit",
    value: function emit(ev) {
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      this.children.forEach(function (nsp) {
        nsp.emit.apply(nsp, [ev].concat(args));
      });
      return true;
    }
  }, {
    key: "createChild",
    value: function createChild(name) {
      var namespace = new namespace_1.Namespace(this.server, name);
      namespace._fns = this._fns.slice(0);
      this.listeners("connect").forEach(function (listener) {
        return namespace.on("connect", listener);
      });
      this.listeners("connection").forEach(function (listener) {
        return namespace.on("connection", listener);
      });
      this.children.add(namespace);

      this.server._nsps.set(name, namespace);

      return namespace;
    }
  }, {
    key: "fetchSockets",
    value: function fetchSockets() {
      // note: we could make the fetchSockets() method work for dynamic namespaces created with a regex (by sending the
      // regex to the other Socket.IO servers, and returning the sockets of each matching namespace for example), but
      // the behavior for namespaces created with a function is less clear
      // note: we cannot loop over each children namespace, because with multiple Socket.IO servers, a given namespace
      // may exist on one node but not exist on another (since it is created upon client connection)
      throw new Error("fetchSockets() is not supported on parent namespaces");
    }
  }]);

  return ParentNamespace;
}(namespace_1.Namespace);

exports.ParentNamespace = ParentNamespace;
ParentNamespace.count = 0;

/***/ }),

/***/ "./node_modules/socket.io/dist/socket.js":
/*!***********************************************!*\
  !*** ./node_modules/socket.io/dist/socket.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.Socket = exports.RESERVED_EVENTS = void 0;

var socket_io_parser_1 = __webpack_require__(/*! socket.io-parser */ "./node_modules/socket.io-parser/dist/index.js");

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var typed_events_1 = __webpack_require__(/*! ./typed-events */ "./node_modules/socket.io/dist/typed-events.js");

var base64id_1 = __importDefault(__webpack_require__(/*! base64id */ "./node_modules/base64id/lib/base64id.js"));

var broadcast_operator_1 = __webpack_require__(/*! ./broadcast-operator */ "./node_modules/socket.io/dist/broadcast-operator.js");

var debug = (0, debug_1["default"])("socket.io:socket");
exports.RESERVED_EVENTS = new Set(["connect", "connect_error", "disconnect", "disconnecting", "newListener", "removeListener"]);

var Socket = /*#__PURE__*/function (_typed_events_1$Stric) {
  _inherits(Socket, _typed_events_1$Stric);

  var _super = _createSuper(Socket);

  /**
   * Interface to a `Client` for a given `Namespace`.
   *
   * @param {Namespace} nsp
   * @param {Client} client
   * @param {Object} auth
   * @package
   */
  function Socket(nsp, client, auth) {
    var _this;

    _classCallCheck(this, Socket);

    _this = _super.call(this);
    _this.nsp = nsp;
    _this.client = client;
    /**
     * Additional information that can be attached to the Socket instance and which will be used in the fetchSockets method
     */

    _this.data = {};
    _this.connected = false;
    _this.acks = new Map();
    _this.fns = [];
    _this.flags = {};
    _this.server = nsp.server;
    _this.adapter = _this.nsp.adapter;

    if (client.conn.protocol === 3) {
      // @ts-ignore
      _this.id = nsp.name !== "/" ? nsp.name + "#" + client.id : client.id;
    } else {
      _this.id = base64id_1["default"].generateId(); // don't reuse the Engine.IO id because it's sensitive information
    }

    _this.handshake = _this.buildHandshake(auth);
    return _this;
  }
  /**
   * Builds the `handshake` BC object
   *
   * @private
   */


  _createClass(Socket, [{
    key: "buildHandshake",
    value: function buildHandshake(auth) {
      return {
        headers: this.request.headers,
        time: new Date() + "",
        address: this.conn.remoteAddress,
        xdomain: !!this.request.headers.origin,
        // @ts-ignore
        secure: !!this.request.connection.encrypted,
        issued: +new Date(),
        url: this.request.url,
        // @ts-ignore
        query: this.request._query,
        auth: auth
      };
    }
    /**
     * Emits to this client.
     *
     * @return Always returns `true`.
     * @public
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      if (exports.RESERVED_EVENTS.has(ev)) {
        throw new Error("\"".concat(ev, "\" is a reserved event name"));
      }

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      var data = [ev].concat(args);
      var packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: data
      }; // access last argument to see if it's an ACK callback

      if (typeof data[data.length - 1] === "function") {
        var id = this.nsp._ids++;
        debug("emitting packet with ack id %d", id);
        this.registerAckCallback(id, data.pop());
        packet.id = id;
      }

      var flags = _extends({}, this.flags);

      this.flags = {};
      this.packet(packet, flags);
      return true;
    }
    /**
     * @private
     */

  }, {
    key: "registerAckCallback",
    value: function registerAckCallback(id, ack) {
      var _this2 = this;

      var timeout = this.flags.timeout;

      if (timeout === undefined) {
        this.acks.set(id, ack);
        return;
      }

      var timer = setTimeout(function () {
        debug("event with ack id %d has timed out after %d ms", id, timeout);

        _this2.acks["delete"](id);

        ack.call(_this2, new Error("operation has timed out"));
      }, timeout);
      this.acks.set(id, function () {
        clearTimeout(timer);

        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        ack.apply(_this2, [null].concat(args));
      });
    }
    /**
     * Targets a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "to",
    value: function to(room) {
      return this.newBroadcastOperator().to(room);
    }
    /**
     * Targets a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "in",
    value: function _in(room) {
      return this.newBroadcastOperator()["in"](room);
    }
    /**
     * Excludes a room when broadcasting.
     *
     * @param room
     * @return self
     * @public
     */

  }, {
    key: "except",
    value: function except(room) {
      return this.newBroadcastOperator().except(room);
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "send",
    value: function send() {
      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
        args[_key3] = arguments[_key3];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Sends a `message` event.
     *
     * @return self
     * @public
     */

  }, {
    key: "write",
    value: function write() {
      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
        args[_key4] = arguments[_key4];
      }

      this.emit.apply(this, ["message"].concat(args));
      return this;
    }
    /**
     * Writes a packet.
     *
     * @param {Object} packet - packet object
     * @param {Object} opts - options
     * @private
     */

  }, {
    key: "packet",
    value: function packet(_packet) {
      var opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      _packet.nsp = this.nsp.name;
      opts.compress = false !== opts.compress;

      this.client._packet(_packet, opts);
    }
    /**
     * Joins a room.
     *
     * @param {String|Array} rooms - room or array of rooms
     * @return a Promise or nothing, depending on the adapter
     * @public
     */

  }, {
    key: "join",
    value: function join(rooms) {
      debug("join room %s", rooms);
      return this.adapter.addAll(this.id, new Set(Array.isArray(rooms) ? rooms : [rooms]));
    }
    /**
     * Leaves a room.
     *
     * @param {String} room
     * @return a Promise or nothing, depending on the adapter
     * @public
     */

  }, {
    key: "leave",
    value: function leave(room) {
      debug("leave room %s", room);
      return this.adapter.del(this.id, room);
    }
    /**
     * Leave all rooms.
     *
     * @private
     */

  }, {
    key: "leaveAll",
    value: function leaveAll() {
      this.adapter.delAll(this.id);
    }
    /**
     * Called by `Namespace` upon successful
     * middleware execution (ie: authorization).
     * Socket is added to namespace array before
     * call to join, so adapters can access it.
     *
     * @private
     */

  }, {
    key: "_onconnect",
    value: function _onconnect() {
      debug("socket connected - writing packet");
      this.connected = true;
      this.join(this.id);

      if (this.conn.protocol === 3) {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT
        });
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.CONNECT,
          data: {
            sid: this.id
          }
        });
      }
    }
    /**
     * Called with each packet. Called by `Client`.
     *
     * @param {Object} packet
     * @private
     */

  }, {
    key: "_onpacket",
    value: function _onpacket(packet) {
      debug("got packet %j", packet);

      switch (packet.type) {
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;

        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;

        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;

        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          this._onerror(new Error(packet.data));

      }
    }
    /**
     * Called upon event packet.
     *
     * @param {Packet} packet - packet object
     * @private
     */

  }, {
    key: "onevent",
    value: function onevent(packet) {
      var args = packet.data || [];
      debug("emitting event %j", args);

      if (null != packet.id) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }

      if (this._anyListeners && this._anyListeners.length) {
        var listeners = this._anyListeners.slice();

        var _iterator = _createForOfIteratorHelper(listeners),
            _step;

        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var listener = _step.value;
            listener.apply(this, args);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }

      this.dispatch(args);
    }
    /**
     * Produces an ack callback to emit with an event.
     *
     * @param {Number} id - packet id
     * @private
     */

  }, {
    key: "ack",
    value: function ack(id) {
      var self = this;
      var sent = false;
      return function () {
        // prevent double callbacks
        if (sent) return;
        var args = Array.prototype.slice.call(arguments);
        debug("sending ack %j", args);
        self.packet({
          id: id,
          type: socket_io_parser_1.PacketType.ACK,
          data: args
        });
        sent = true;
      };
    }
    /**
     * Called upon ack packet.
     *
     * @private
     */

  }, {
    key: "onack",
    value: function onack(packet) {
      var ack = this.acks.get(packet.id);

      if ("function" == typeof ack) {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        this.acks["delete"](packet.id);
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    /**
     * Called upon client disconnect packet.
     *
     * @private
     */

  }, {
    key: "ondisconnect",
    value: function ondisconnect() {
      debug("got disconnect packet");

      this._onclose("client namespace disconnect");
    }
    /**
     * Handles a client error.
     *
     * @private
     */

  }, {
    key: "_onerror",
    value: function _onerror(err) {
      if (this.listeners("error").length) {
        this.emitReserved("error", err);
      } else {
        console.error("Missing error handler on `socket`.");
        console.error(err.stack);
      }
    }
    /**
     * Called upon closing. Called by `Client`.
     *
     * @param {String} reason
     * @throw {Error} optional error object
     *
     * @private
     */

  }, {
    key: "_onclose",
    value: function _onclose(reason) {
      if (!this.connected) return this;
      debug("closing socket - reason %s", reason);
      this.emitReserved("disconnecting", reason);
      this.leaveAll();

      this.nsp._remove(this);

      this.client._remove(this);

      this.connected = false;
      this.emitReserved("disconnect", reason);
      return;
    }
    /**
     * Produces an `error` packet.
     *
     * @param {Object} err - error object
     *
     * @private
     */

  }, {
    key: "_error",
    value: function _error(err) {
      this.packet({
        type: socket_io_parser_1.PacketType.CONNECT_ERROR,
        data: err
      });
    }
    /**
     * Disconnects this client.
     *
     * @param {Boolean} close - if `true`, closes the underlying connection
     * @return {Socket} self
     *
     * @public
     */

  }, {
    key: "disconnect",
    value: function disconnect() {
      var close = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      if (!this.connected) return this;

      if (close) {
        this.client._disconnect();
      } else {
        this.packet({
          type: socket_io_parser_1.PacketType.DISCONNECT
        });

        this._onclose("server namespace disconnect");
      }

      return this;
    }
    /**
     * Sets the compress flag.
     *
     * @param {Boolean} compress - if `true`, compresses the sending data
     * @return {Socket} self
     * @public
     */

  }, {
    key: "compress",
    value: function compress(_compress) {
      this.flags.compress = _compress;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data may be lost if the client is not ready to
     * receive messages (because of network slowness or other issues, or because theyre connected through long polling
     * and is in the middle of a request-response cycle).
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "volatile",
    get: function get() {
      this.flags["volatile"] = true;
      return this;
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to every sockets but the
     * sender.
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "broadcast",
    get: function get() {
      return this.newBroadcastOperator();
    }
    /**
     * Sets a modifier for a subsequent event emission that the event data will only be broadcast to the current node.
     *
     * @return {Socket} self
     * @public
     */

  }, {
    key: "local",
    get: function get() {
      return this.newBroadcastOperator().local;
    }
    /**
     * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
     * given number of milliseconds have elapsed without an acknowledgement from the client:
     *
     * ```
     * socket.timeout(5000).emit("my-event", (err) => {
     *   if (err) {
     *     // the client did not acknowledge the event in the given delay
     *   }
     * });
     * ```
     *
     * @returns self
     * @public
     */

  }, {
    key: "timeout",
    value: function timeout(_timeout) {
      this.flags.timeout = _timeout;
      return this;
    }
    /**
     * Dispatch incoming event to socket listeners.
     *
     * @param {Array} event - event that will get emitted
     * @private
     */

  }, {
    key: "dispatch",
    value: function dispatch(event) {
      var _this3 = this;

      debug("dispatching an event %j", event);
      this.run(event, function (err) {
        process.nextTick(function () {
          if (err) {
            return _this3._onerror(err);
          }

          if (_this3.connected) {
            _get(_getPrototypeOf(Socket.prototype), "emitUntyped", _this3).apply(_this3, event);
          } else {
            debug("ignore packet received after disconnection");
          }
        });
      });
    }
    /**
     * Sets up socket middleware.
     *
     * @param {Function} fn - middleware function (event, next)
     * @return {Socket} self
     * @public
     */

  }, {
    key: "use",
    value: function use(fn) {
      this.fns.push(fn);
      return this;
    }
    /**
     * Executes the middleware for an incoming event.
     *
     * @param {Array} event - event that will get emitted
     * @param {Function} fn - last fn call in the middleware
     * @private
     */

  }, {
    key: "run",
    value: function run(event, fn) {
      var fns = this.fns.slice(0);
      if (!fns.length) return fn(null);

      function run(i) {
        fns[i](event, function (err) {
          // upon error, short-circuit
          if (err) return fn(err); // if no middleware left, summon callback

          if (!fns[i + 1]) return fn(null); // go on to next

          run(i + 1);
        });
      }

      run(0);
    }
    /**
     * Whether the socket is currently disconnected
     */

  }, {
    key: "disconnected",
    get: function get() {
      return !this.connected;
    }
    /**
     * A reference to the request that originated the underlying Engine.IO Socket.
     *
     * @public
     */

  }, {
    key: "request",
    get: function get() {
      return this.client.request;
    }
    /**
     * A reference to the underlying Client transport connection (Engine.IO Socket object).
     *
     * @public
     */

  }, {
    key: "conn",
    get: function get() {
      return this.client.conn;
    }
    /**
     * @public
     */

  }, {
    key: "rooms",
    get: function get() {
      return this.adapter.socketRooms(this.id) || new Set();
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback.
     *
     * @param listener
     * @public
     */

  }, {
    key: "onAny",
    value: function onAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.push(listener);

      return this;
    }
    /**
     * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
     * callback. The listener is added to the beginning of the listeners array.
     *
     * @param listener
     * @public
     */

  }, {
    key: "prependAny",
    value: function prependAny(listener) {
      this._anyListeners = this._anyListeners || [];

      this._anyListeners.unshift(listener);

      return this;
    }
    /**
     * Removes the listener that will be fired when any event is emitted.
     *
     * @param listener
     * @public
     */

  }, {
    key: "offAny",
    value: function offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }

      if (listener) {
        var listeners = this._anyListeners;

        for (var i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }

      return this;
    }
    /**
     * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
     * e.g. to remove listeners.
     *
     * @public
     */

  }, {
    key: "listenersAny",
    value: function listenersAny() {
      return this._anyListeners || [];
    }
  }, {
    key: "newBroadcastOperator",
    value: function newBroadcastOperator() {
      var flags = _extends({}, this.flags);

      this.flags = {};
      return new broadcast_operator_1.BroadcastOperator(this.adapter, new Set(), new Set([this.id]), flags);
    }
  }]);

  return Socket;
}(typed_events_1.StrictEventEmitter);

exports.Socket = Socket;

/***/ }),

/***/ "./node_modules/socket.io/dist/typed-events.js":
/*!*****************************************************!*\
  !*** ./node_modules/socket.io/dist/typed-events.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }

function _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.StrictEventEmitter = void 0;

var events_1 = __webpack_require__(/*! events */ "./node_modules/events/events.js");
/**
 * Strictly typed version of an `EventEmitter`. A `TypedEventEmitter` takes type
 * parameters for mappings of event names to event data types, and strictly
 * types method calls to the `EventEmitter` according to these event maps.
 *
 * @typeParam ListenEvents - `EventsMap` of user-defined events that can be
 * listened to with `on` or `once`
 * @typeParam EmitEvents - `EventsMap` of user-defined events that can be
 * emitted with `emit`
 * @typeParam ReservedEvents - `EventsMap` of reserved events, that can be
 * emitted by socket.io with `emitReserved`, and can be listened to with
 * `listen`.
 */


var StrictEventEmitter = /*#__PURE__*/function (_events_1$EventEmitte) {
  _inherits(StrictEventEmitter, _events_1$EventEmitte);

  var _super = _createSuper(StrictEventEmitter);

  function StrictEventEmitter() {
    _classCallCheck(this, StrictEventEmitter);

    return _super.apply(this, arguments);
  }

  _createClass(StrictEventEmitter, [{
    key: "on",
    value:
    /**
     * Adds the `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */
    function on(ev, listener) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "on", this).call(this, ev, listener);
    }
    /**
     * Adds a one-time `listener` function as an event listener for `ev`.
     *
     * @param ev Name of the event
     * @param listener Callback function
     */

  }, {
    key: "once",
    value: function once(ev, listener) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "once", this).call(this, ev, listener);
    }
    /**
     * Emits an event.
     *
     * @param ev Name of the event
     * @param args Values to send to listeners of this event
     */

  }, {
    key: "emit",
    value: function emit(ev) {
      var _get2;

      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      return (_get2 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get2, [this, ev].concat(args));
    }
    /**
     * Emits a reserved event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can emit its own reserved events.
     *
     * @param ev Reserved event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitReserved",
    value: function emitReserved(ev) {
      var _get3;

      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        args[_key2 - 1] = arguments[_key2];
      }

      return (_get3 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get3, [this, ev].concat(args));
    }
    /**
     * Emits an event.
     *
     * This method is `protected`, so that only a class extending
     * `StrictEventEmitter` can get around the strict typing. This is useful for
     * calling `emit.apply`, which can be called as `emitUntyped.apply`.
     *
     * @param ev Event name
     * @param args Arguments to emit along with the event
     */

  }, {
    key: "emitUntyped",
    value: function emitUntyped(ev) {
      var _get4;

      for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        args[_key3 - 1] = arguments[_key3];
      }

      return (_get4 = _get(_getPrototypeOf(StrictEventEmitter.prototype), "emit", this)).call.apply(_get4, [this, ev].concat(args));
    }
    /**
     * Returns the listeners listening to an event.
     *
     * @param event Event name
     * @returns Array of listeners subscribed to `event`
     */

  }, {
    key: "listeners",
    value: function listeners(event) {
      return _get(_getPrototypeOf(StrictEventEmitter.prototype), "listeners", this).call(this, event);
    }
  }]);

  return StrictEventEmitter;
}(events_1.EventEmitter);

exports.StrictEventEmitter = StrictEventEmitter;

/***/ }),

/***/ "./node_modules/socket.io/dist/uws.js":
/*!********************************************!*\
  !*** ./node_modules/socket.io/dist/uws.js ***!
  \********************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.serveFile = exports.restoreAdapter = exports.patchAdapter = void 0;

var socket_io_adapter_1 = __webpack_require__(/*! socket.io-adapter */ "./node_modules/socket.io-adapter/dist/index.js");

var fs_1 = __webpack_require__(Object(function webpackMissingModule() { var e = new Error("Cannot find module 'fs'"); e.code = 'MODULE_NOT_FOUND'; throw e; }()));

var debug_1 = __importDefault(__webpack_require__(/*! debug */ "./node_modules/socket.io/node_modules/debug/src/browser.js"));

var debug = (0, debug_1["default"])("socket.io:adapter-uws");
var SEPARATOR = "\x1f"; // see https://en.wikipedia.org/wiki/Delimiter#ASCII_delimited_text

var _socket_io_adapter_1$ = socket_io_adapter_1.Adapter.prototype,
    addAll = _socket_io_adapter_1$.addAll,
    del = _socket_io_adapter_1$.del,
    broadcast = _socket_io_adapter_1$.broadcast;

function patchAdapter(app
/* : TemplatedApp */
) {
  socket_io_adapter_1.Adapter.prototype.addAll = function (id, rooms) {
    var _this = this;

    var isNew = !this.sids.has(id);
    addAll.call(this, id, rooms);
    var socket = this.nsp.sockets.get(id);

    if (!socket) {
      return;
    }

    if (socket.conn.transport.name === "websocket") {
      subscribe(this.nsp.name, socket, isNew, rooms);
      return;
    }

    if (isNew) {
      socket.conn.on("upgrade", function () {
        var rooms = _this.sids.get(id);

        subscribe(_this.nsp.name, socket, isNew, rooms);
      });
    }
  };

  socket_io_adapter_1.Adapter.prototype.del = function (id, room) {
    del.call(this, id, room);
    var socket = this.nsp.sockets.get(id);

    if (socket && socket.conn.transport.name === "websocket") {
      // @ts-ignore
      var sessionId = socket.conn.id; // @ts-ignore

      var websocket = socket.conn.transport.socket;
      var topic = "".concat(this.nsp.name).concat(SEPARATOR).concat(room);
      debug("unsubscribe connection %s from topic %s", sessionId, topic);
      websocket.unsubscribe(topic);
    }
  };

  socket_io_adapter_1.Adapter.prototype.broadcast = function (packet, opts) {
    var useFastPublish = opts.rooms.size <= 1 && opts.except.size === 0;

    if (!useFastPublish) {
      broadcast.call(this, packet, opts);
      return;
    }

    var flags = opts.flags || {};
    var basePacketOpts = {
      preEncoded: true,
      "volatile": flags["volatile"],
      compress: flags.compress
    };
    packet.nsp = this.nsp.name;
    var encodedPackets = this.encoder.encode(packet);
    var topic = opts.rooms.size === 0 ? this.nsp.name : "".concat(this.nsp.name).concat(SEPARATOR).concat(opts.rooms.keys().next().value);
    debug("fast publish to %s", topic); // fast publish for clients connected with WebSocket

    encodedPackets.forEach(function (encodedPacket) {
      var isBinary = typeof encodedPacket !== "string"; // "4" being the message type in the Engine.IO protocol, see https://github.com/socketio/engine.io-protocol

      app.publish(topic, isBinary ? encodedPacket : "4" + encodedPacket, isBinary);
    });
    this.apply(opts, function (socket) {
      if (socket.conn.transport.name !== "websocket") {
        // classic publish for clients connected with HTTP long-polling
        socket.client.writeToEngine(encodedPackets, basePacketOpts);
      }
    });
  };
}

exports.patchAdapter = patchAdapter;

function subscribe(namespaceName, socket, isNew, rooms) {
  // @ts-ignore
  var sessionId = socket.conn.id; // @ts-ignore

  var websocket = socket.conn.transport.socket;

  if (isNew) {
    debug("subscribe connection %s to topic %s", sessionId, namespaceName);
    websocket.subscribe(namespaceName);
  }

  rooms.forEach(function (room) {
    var topic = "".concat(namespaceName).concat(SEPARATOR).concat(room); // '#' can be used as wildcard

    debug("subscribe connection %s to topic %s", sessionId, topic);
    websocket.subscribe(topic);
  });
}

function restoreAdapter() {
  socket_io_adapter_1.Adapter.prototype.addAll = addAll;
  socket_io_adapter_1.Adapter.prototype.del = del;
  socket_io_adapter_1.Adapter.prototype.broadcast = broadcast;
}

exports.restoreAdapter = restoreAdapter;

var toArrayBuffer = function toArrayBuffer(buffer) {
  var arrayBuffer = buffer.buffer,
      byteOffset = buffer.byteOffset,
      byteLength = buffer.byteLength;
  return arrayBuffer.slice(byteOffset, byteOffset + byteLength);
}; // imported from https://github.com/kolodziejczak-sz/uwebsocket-serve


function serveFile(res
/* : HttpResponse */
, filepath) {
  var _ref = (0, fs_1.statSync)(filepath),
      size = _ref.size;

  var readStream = (0, fs_1.createReadStream)(filepath);

  var destroyReadStream = function destroyReadStream() {
    return !readStream.destroyed && readStream.destroy();
  };

  var onError = function onError(error) {
    destroyReadStream();
    throw error;
  };

  var onDataChunk = function onDataChunk(chunk) {
    var arrayBufferChunk = toArrayBuffer(chunk);
    var lastOffset = res.getWriteOffset();

    var _res$tryEnd = res.tryEnd(arrayBufferChunk, size),
        _res$tryEnd2 = _slicedToArray(_res$tryEnd, 2),
        ok = _res$tryEnd2[0],
        done = _res$tryEnd2[1];

    if (!done && !ok) {
      readStream.pause();
      res.onWritable(function (offset) {
        var _res$tryEnd3 = res.tryEnd(arrayBufferChunk.slice(offset - lastOffset), size),
            _res$tryEnd4 = _slicedToArray(_res$tryEnd3, 2),
            ok = _res$tryEnd4[0],
            done = _res$tryEnd4[1];

        if (!done && ok) {
          readStream.resume();
        }

        return ok;
      });
    }
  };

  res.onAborted(destroyReadStream);
  readStream.on("data", onDataChunk).on("error", onError).on("end", destroyReadStream);
}

exports.serveFile = serveFile;

/***/ }),

/***/ "./node_modules/socket.io/wrapper.mjs":
/*!********************************************!*\
  !*** ./node_modules/socket.io/wrapper.mjs ***!
  \********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Namespace": () => (/* binding */ Namespace),
/* harmony export */   "Server": () => (/* binding */ Server),
/* harmony export */   "Socket": () => (/* binding */ Socket)
/* harmony export */ });
/* harmony import */ var _dist_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./dist/index.js */ "./node_modules/socket.io/dist/index.js");

var Server = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Server,
    Namespace = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Namespace,
    Socket = _dist_index_js__WEBPACK_IMPORTED_MODULE_0__.Socket;


/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"_from":"axios@^0.21.1","_id":"axios@0.21.4","_inBundle":false,"_integrity":"sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==","_location":"/axios","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"axios@^0.21.1","name":"axios","escapedName":"axios","rawSpec":"^0.21.1","saveSpec":null,"fetchSpec":"^0.21.1"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/axios/-/axios-0.21.4.tgz","_shasum":"c67b90dc0568e5c1cf2b0b858c43ba28e2eda575","_spec":"axios@^0.21.1","_where":"C:\\\\xampp2\\\\htdocs\\\\FM-Wallet-Connector","author":{"name":"Matt Zabriskie"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"bugs":{"url":"https://github.com/axios/axios/issues"},"bundleDependencies":false,"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}],"dependencies":{"follow-redirects":"^1.14.0"},"deprecated":false,"description":"Promise based HTTP client for the browser and node.js","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"homepage":"https://axios-http.com","jsdelivr":"dist/axios.min.js","keywords":["xhr","http","ajax","promise","node"],"license":"MIT","main":"index.js","name":"axios","repository":{"type":"git","url":"git+https://github.com/axios/axios.git"},"scripts":{"build":"NODE_ENV=production grunt build","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","examples":"node ./examples/server.js","fix":"eslint --fix lib/**/*.js","postversion":"git push && git push --tags","preversion":"npm test","start":"node ./sandbox/server.js","test":"grunt test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"},"typings":"./index.d.ts","unpkg":"dist/axios.min.js","version":"0.21.4"}');

/***/ }),

/***/ "./node_modules/mime-db/db.json":
/*!**************************************!*\
  !*** ./node_modules/mime-db/db.json ***!
  \**************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"application/1d-interleaved-parityfec":{"source":"iana"},"application/3gpdash-qoe-report+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/3gpp-ims+xml":{"source":"iana","compressible":true},"application/3gpphal+json":{"source":"iana","compressible":true},"application/3gpphalforms+json":{"source":"iana","compressible":true},"application/a2l":{"source":"iana"},"application/ace+cbor":{"source":"iana"},"application/activemessage":{"source":"iana"},"application/activity+json":{"source":"iana","compressible":true},"application/alto-costmap+json":{"source":"iana","compressible":true},"application/alto-costmapfilter+json":{"source":"iana","compressible":true},"application/alto-directory+json":{"source":"iana","compressible":true},"application/alto-endpointcost+json":{"source":"iana","compressible":true},"application/alto-endpointcostparams+json":{"source":"iana","compressible":true},"application/alto-endpointprop+json":{"source":"iana","compressible":true},"application/alto-endpointpropparams+json":{"source":"iana","compressible":true},"application/alto-error+json":{"source":"iana","compressible":true},"application/alto-networkmap+json":{"source":"iana","compressible":true},"application/alto-networkmapfilter+json":{"source":"iana","compressible":true},"application/alto-updatestreamcontrol+json":{"source":"iana","compressible":true},"application/alto-updatestreamparams+json":{"source":"iana","compressible":true},"application/aml":{"source":"iana"},"application/andrew-inset":{"source":"iana","extensions":["ez"]},"application/applefile":{"source":"iana"},"application/applixware":{"source":"apache","extensions":["aw"]},"application/at+jwt":{"source":"iana"},"application/atf":{"source":"iana"},"application/atfx":{"source":"iana"},"application/atom+xml":{"source":"iana","compressible":true,"extensions":["atom"]},"application/atomcat+xml":{"source":"iana","compressible":true,"extensions":["atomcat"]},"application/atomdeleted+xml":{"source":"iana","compressible":true,"extensions":["atomdeleted"]},"application/atomicmail":{"source":"iana"},"application/atomsvc+xml":{"source":"iana","compressible":true,"extensions":["atomsvc"]},"application/atsc-dwd+xml":{"source":"iana","compressible":true,"extensions":["dwd"]},"application/atsc-dynamic-event-message":{"source":"iana"},"application/atsc-held+xml":{"source":"iana","compressible":true,"extensions":["held"]},"application/atsc-rdt+json":{"source":"iana","compressible":true},"application/atsc-rsat+xml":{"source":"iana","compressible":true,"extensions":["rsat"]},"application/atxml":{"source":"iana"},"application/auth-policy+xml":{"source":"iana","compressible":true},"application/bacnet-xdd+zip":{"source":"iana","compressible":false},"application/batch-smtp":{"source":"iana"},"application/bdoc":{"compressible":false,"extensions":["bdoc"]},"application/beep+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/calendar+json":{"source":"iana","compressible":true},"application/calendar+xml":{"source":"iana","compressible":true,"extensions":["xcs"]},"application/call-completion":{"source":"iana"},"application/cals-1840":{"source":"iana"},"application/captive+json":{"source":"iana","compressible":true},"application/cbor":{"source":"iana"},"application/cbor-seq":{"source":"iana"},"application/cccex":{"source":"iana"},"application/ccmp+xml":{"source":"iana","compressible":true},"application/ccxml+xml":{"source":"iana","compressible":true,"extensions":["ccxml"]},"application/cdfx+xml":{"source":"iana","compressible":true,"extensions":["cdfx"]},"application/cdmi-capability":{"source":"iana","extensions":["cdmia"]},"application/cdmi-container":{"source":"iana","extensions":["cdmic"]},"application/cdmi-domain":{"source":"iana","extensions":["cdmid"]},"application/cdmi-object":{"source":"iana","extensions":["cdmio"]},"application/cdmi-queue":{"source":"iana","extensions":["cdmiq"]},"application/cdni":{"source":"iana"},"application/cea":{"source":"iana"},"application/cea-2018+xml":{"source":"iana","compressible":true},"application/cellml+xml":{"source":"iana","compressible":true},"application/cfw":{"source":"iana"},"application/city+json":{"source":"iana","compressible":true},"application/clr":{"source":"iana"},"application/clue+xml":{"source":"iana","compressible":true},"application/clue_info+xml":{"source":"iana","compressible":true},"application/cms":{"source":"iana"},"application/cnrp+xml":{"source":"iana","compressible":true},"application/coap-group+json":{"source":"iana","compressible":true},"application/coap-payload":{"source":"iana"},"application/commonground":{"source":"iana"},"application/conference-info+xml":{"source":"iana","compressible":true},"application/cose":{"source":"iana"},"application/cose-key":{"source":"iana"},"application/cose-key-set":{"source":"iana"},"application/cpl+xml":{"source":"iana","compressible":true,"extensions":["cpl"]},"application/csrattrs":{"source":"iana"},"application/csta+xml":{"source":"iana","compressible":true},"application/cstadata+xml":{"source":"iana","compressible":true},"application/csvm+json":{"source":"iana","compressible":true},"application/cu-seeme":{"source":"apache","extensions":["cu"]},"application/cwt":{"source":"iana"},"application/cybercash":{"source":"iana"},"application/dart":{"compressible":true},"application/dash+xml":{"source":"iana","compressible":true,"extensions":["mpd"]},"application/dash-patch+xml":{"source":"iana","compressible":true,"extensions":["mpp"]},"application/dashdelta":{"source":"iana"},"application/davmount+xml":{"source":"iana","compressible":true,"extensions":["davmount"]},"application/dca-rft":{"source":"iana"},"application/dcd":{"source":"iana"},"application/dec-dx":{"source":"iana"},"application/dialog-info+xml":{"source":"iana","compressible":true},"application/dicom":{"source":"iana"},"application/dicom+json":{"source":"iana","compressible":true},"application/dicom+xml":{"source":"iana","compressible":true},"application/dii":{"source":"iana"},"application/dit":{"source":"iana"},"application/dns":{"source":"iana"},"application/dns+json":{"source":"iana","compressible":true},"application/dns-message":{"source":"iana"},"application/docbook+xml":{"source":"apache","compressible":true,"extensions":["dbk"]},"application/dots+cbor":{"source":"iana"},"application/dskpp+xml":{"source":"iana","compressible":true},"application/dssc+der":{"source":"iana","extensions":["dssc"]},"application/dssc+xml":{"source":"iana","compressible":true,"extensions":["xdssc"]},"application/dvcs":{"source":"iana"},"application/ecmascript":{"source":"iana","compressible":true,"extensions":["es","ecma"]},"application/edi-consent":{"source":"iana"},"application/edi-x12":{"source":"iana","compressible":false},"application/edifact":{"source":"iana","compressible":false},"application/efi":{"source":"iana"},"application/elm+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/elm+xml":{"source":"iana","compressible":true},"application/emergencycalldata.cap+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/emergencycalldata.comment+xml":{"source":"iana","compressible":true},"application/emergencycalldata.control+xml":{"source":"iana","compressible":true},"application/emergencycalldata.deviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.ecall.msd":{"source":"iana"},"application/emergencycalldata.providerinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.serviceinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.subscriberinfo+xml":{"source":"iana","compressible":true},"application/emergencycalldata.veds+xml":{"source":"iana","compressible":true},"application/emma+xml":{"source":"iana","compressible":true,"extensions":["emma"]},"application/emotionml+xml":{"source":"iana","compressible":true,"extensions":["emotionml"]},"application/encaprtp":{"source":"iana"},"application/epp+xml":{"source":"iana","compressible":true},"application/epub+zip":{"source":"iana","compressible":false,"extensions":["epub"]},"application/eshop":{"source":"iana"},"application/exi":{"source":"iana","extensions":["exi"]},"application/expect-ct-report+json":{"source":"iana","compressible":true},"application/express":{"source":"iana","extensions":["exp"]},"application/fastinfoset":{"source":"iana"},"application/fastsoap":{"source":"iana"},"application/fdt+xml":{"source":"iana","compressible":true,"extensions":["fdt"]},"application/fhir+json":{"source":"iana","charset":"UTF-8","compressible":true},"application/fhir+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/fido.trusted-apps+json":{"compressible":true},"application/fits":{"source":"iana"},"application/flexfec":{"source":"iana"},"application/font-sfnt":{"source":"iana"},"application/font-tdpfr":{"source":"iana","extensions":["pfr"]},"application/font-woff":{"source":"iana","compressible":false},"application/framework-attributes+xml":{"source":"iana","compressible":true},"application/geo+json":{"source":"iana","compressible":true,"extensions":["geojson"]},"application/geo+json-seq":{"source":"iana"},"application/geopackage+sqlite3":{"source":"iana"},"application/geoxacml+xml":{"source":"iana","compressible":true},"application/gltf-buffer":{"source":"iana"},"application/gml+xml":{"source":"iana","compressible":true,"extensions":["gml"]},"application/gpx+xml":{"source":"apache","compressible":true,"extensions":["gpx"]},"application/gxf":{"source":"apache","extensions":["gxf"]},"application/gzip":{"source":"iana","compressible":false,"extensions":["gz"]},"application/h224":{"source":"iana"},"application/held+xml":{"source":"iana","compressible":true},"application/hjson":{"extensions":["hjson"]},"application/http":{"source":"iana"},"application/hyperstudio":{"source":"iana","extensions":["stk"]},"application/ibe-key-request+xml":{"source":"iana","compressible":true},"application/ibe-pkg-reply+xml":{"source":"iana","compressible":true},"application/ibe-pp-data":{"source":"iana"},"application/iges":{"source":"iana"},"application/im-iscomposing+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/index":{"source":"iana"},"application/index.cmd":{"source":"iana"},"application/index.obj":{"source":"iana"},"application/index.response":{"source":"iana"},"application/index.vnd":{"source":"iana"},"application/inkml+xml":{"source":"iana","compressible":true,"extensions":["ink","inkml"]},"application/iotp":{"source":"iana"},"application/ipfix":{"source":"iana","extensions":["ipfix"]},"application/ipp":{"source":"iana"},"application/isup":{"source":"iana"},"application/its+xml":{"source":"iana","compressible":true,"extensions":["its"]},"application/java-archive":{"source":"apache","compressible":false,"extensions":["jar","war","ear"]},"application/java-serialized-object":{"source":"apache","compressible":false,"extensions":["ser"]},"application/java-vm":{"source":"apache","compressible":false,"extensions":["class"]},"application/javascript":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["js","mjs"]},"application/jf2feed+json":{"source":"iana","compressible":true},"application/jose":{"source":"iana"},"application/jose+json":{"source":"iana","compressible":true},"application/jrd+json":{"source":"iana","compressible":true},"application/jscalendar+json":{"source":"iana","compressible":true},"application/json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["json","map"]},"application/json-patch+json":{"source":"iana","compressible":true},"application/json-seq":{"source":"iana"},"application/json5":{"extensions":["json5"]},"application/jsonml+json":{"source":"apache","compressible":true,"extensions":["jsonml"]},"application/jwk+json":{"source":"iana","compressible":true},"application/jwk-set+json":{"source":"iana","compressible":true},"application/jwt":{"source":"iana"},"application/kpml-request+xml":{"source":"iana","compressible":true},"application/kpml-response+xml":{"source":"iana","compressible":true},"application/ld+json":{"source":"iana","compressible":true,"extensions":["jsonld"]},"application/lgr+xml":{"source":"iana","compressible":true,"extensions":["lgr"]},"application/link-format":{"source":"iana"},"application/load-control+xml":{"source":"iana","compressible":true},"application/lost+xml":{"source":"iana","compressible":true,"extensions":["lostxml"]},"application/lostsync+xml":{"source":"iana","compressible":true},"application/lpf+zip":{"source":"iana","compressible":false},"application/lxf":{"source":"iana"},"application/mac-binhex40":{"source":"iana","extensions":["hqx"]},"application/mac-compactpro":{"source":"apache","extensions":["cpt"]},"application/macwriteii":{"source":"iana"},"application/mads+xml":{"source":"iana","compressible":true,"extensions":["mads"]},"application/manifest+json":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["webmanifest"]},"application/marc":{"source":"iana","extensions":["mrc"]},"application/marcxml+xml":{"source":"iana","compressible":true,"extensions":["mrcx"]},"application/mathematica":{"source":"iana","extensions":["ma","nb","mb"]},"application/mathml+xml":{"source":"iana","compressible":true,"extensions":["mathml"]},"application/mathml-content+xml":{"source":"iana","compressible":true},"application/mathml-presentation+xml":{"source":"iana","compressible":true},"application/mbms-associated-procedure-description+xml":{"source":"iana","compressible":true},"application/mbms-deregister+xml":{"source":"iana","compressible":true},"application/mbms-envelope+xml":{"source":"iana","compressible":true},"application/mbms-msk+xml":{"source":"iana","compressible":true},"application/mbms-msk-response+xml":{"source":"iana","compressible":true},"application/mbms-protection-description+xml":{"source":"iana","compressible":true},"application/mbms-reception-report+xml":{"source":"iana","compressible":true},"application/mbms-register+xml":{"source":"iana","compressible":true},"application/mbms-register-response+xml":{"source":"iana","compressible":true},"application/mbms-schedule+xml":{"source":"iana","compressible":true},"application/mbms-user-service-description+xml":{"source":"iana","compressible":true},"application/mbox":{"source":"iana","extensions":["mbox"]},"application/media-policy-dataset+xml":{"source":"iana","compressible":true,"extensions":["mpf"]},"application/media_control+xml":{"source":"iana","compressible":true},"application/mediaservercontrol+xml":{"source":"iana","compressible":true,"extensions":["mscml"]},"application/merge-patch+json":{"source":"iana","compressible":true},"application/metalink+xml":{"source":"apache","compressible":true,"extensions":["metalink"]},"application/metalink4+xml":{"source":"iana","compressible":true,"extensions":["meta4"]},"application/mets+xml":{"source":"iana","compressible":true,"extensions":["mets"]},"application/mf4":{"source":"iana"},"application/mikey":{"source":"iana"},"application/mipc":{"source":"iana"},"application/missing-blocks+cbor-seq":{"source":"iana"},"application/mmt-aei+xml":{"source":"iana","compressible":true,"extensions":["maei"]},"application/mmt-usd+xml":{"source":"iana","compressible":true,"extensions":["musd"]},"application/mods+xml":{"source":"iana","compressible":true,"extensions":["mods"]},"application/moss-keys":{"source":"iana"},"application/moss-signature":{"source":"iana"},"application/mosskey-data":{"source":"iana"},"application/mosskey-request":{"source":"iana"},"application/mp21":{"source":"iana","extensions":["m21","mp21"]},"application/mp4":{"source":"iana","extensions":["mp4s","m4p"]},"application/mpeg4-generic":{"source":"iana"},"application/mpeg4-iod":{"source":"iana"},"application/mpeg4-iod-xmt":{"source":"iana"},"application/mrb-consumer+xml":{"source":"iana","compressible":true},"application/mrb-publish+xml":{"source":"iana","compressible":true},"application/msc-ivr+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msc-mixer+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/msword":{"source":"iana","compressible":false,"extensions":["doc","dot"]},"application/mud+json":{"source":"iana","compressible":true},"application/multipart-core":{"source":"iana"},"application/mxf":{"source":"iana","extensions":["mxf"]},"application/n-quads":{"source":"iana","extensions":["nq"]},"application/n-triples":{"source":"iana","extensions":["nt"]},"application/nasdata":{"source":"iana"},"application/news-checkgroups":{"source":"iana","charset":"US-ASCII"},"application/news-groupinfo":{"source":"iana","charset":"US-ASCII"},"application/news-transmission":{"source":"iana"},"application/nlsml+xml":{"source":"iana","compressible":true},"application/node":{"source":"iana","extensions":["cjs"]},"application/nss":{"source":"iana"},"application/oauth-authz-req+jwt":{"source":"iana"},"application/oblivious-dns-message":{"source":"iana"},"application/ocsp-request":{"source":"iana"},"application/ocsp-response":{"source":"iana"},"application/octet-stream":{"source":"iana","compressible":false,"extensions":["bin","dms","lrf","mar","so","dist","distz","pkg","bpk","dump","elc","deploy","exe","dll","deb","dmg","iso","img","msi","msp","msm","buffer"]},"application/oda":{"source":"iana","extensions":["oda"]},"application/odm+xml":{"source":"iana","compressible":true},"application/odx":{"source":"iana"},"application/oebps-package+xml":{"source":"iana","compressible":true,"extensions":["opf"]},"application/ogg":{"source":"iana","compressible":false,"extensions":["ogx"]},"application/omdoc+xml":{"source":"apache","compressible":true,"extensions":["omdoc"]},"application/onenote":{"source":"apache","extensions":["onetoc","onetoc2","onetmp","onepkg"]},"application/opc-nodeset+xml":{"source":"iana","compressible":true},"application/oscore":{"source":"iana"},"application/oxps":{"source":"iana","extensions":["oxps"]},"application/p21":{"source":"iana"},"application/p21+zip":{"source":"iana","compressible":false},"application/p2p-overlay+xml":{"source":"iana","compressible":true,"extensions":["relo"]},"application/parityfec":{"source":"iana"},"application/passport":{"source":"iana"},"application/patch-ops-error+xml":{"source":"iana","compressible":true,"extensions":["xer"]},"application/pdf":{"source":"iana","compressible":false,"extensions":["pdf"]},"application/pdx":{"source":"iana"},"application/pem-certificate-chain":{"source":"iana"},"application/pgp-encrypted":{"source":"iana","compressible":false,"extensions":["pgp"]},"application/pgp-keys":{"source":"iana","extensions":["asc"]},"application/pgp-signature":{"source":"iana","extensions":["asc","sig"]},"application/pics-rules":{"source":"apache","extensions":["prf"]},"application/pidf+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pidf-diff+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/pkcs10":{"source":"iana","extensions":["p10"]},"application/pkcs12":{"source":"iana"},"application/pkcs7-mime":{"source":"iana","extensions":["p7m","p7c"]},"application/pkcs7-signature":{"source":"iana","extensions":["p7s"]},"application/pkcs8":{"source":"iana","extensions":["p8"]},"application/pkcs8-encrypted":{"source":"iana"},"application/pkix-attr-cert":{"source":"iana","extensions":["ac"]},"application/pkix-cert":{"source":"iana","extensions":["cer"]},"application/pkix-crl":{"source":"iana","extensions":["crl"]},"application/pkix-pkipath":{"source":"iana","extensions":["pkipath"]},"application/pkixcmp":{"source":"iana","extensions":["pki"]},"application/pls+xml":{"source":"iana","compressible":true,"extensions":["pls"]},"application/poc-settings+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/postscript":{"source":"iana","compressible":true,"extensions":["ai","eps","ps"]},"application/ppsp-tracker+json":{"source":"iana","compressible":true},"application/problem+json":{"source":"iana","compressible":true},"application/problem+xml":{"source":"iana","compressible":true},"application/provenance+xml":{"source":"iana","compressible":true,"extensions":["provx"]},"application/prs.alvestrand.titrax-sheet":{"source":"iana"},"application/prs.cww":{"source":"iana","extensions":["cww"]},"application/prs.cyn":{"source":"iana","charset":"7-BIT"},"application/prs.hpub+zip":{"source":"iana","compressible":false},"application/prs.nprend":{"source":"iana"},"application/prs.plucker":{"source":"iana"},"application/prs.rdf-xml-crypt":{"source":"iana"},"application/prs.xsf+xml":{"source":"iana","compressible":true},"application/pskc+xml":{"source":"iana","compressible":true,"extensions":["pskcxml"]},"application/pvd+json":{"source":"iana","compressible":true},"application/qsig":{"source":"iana"},"application/raml+yaml":{"compressible":true,"extensions":["raml"]},"application/raptorfec":{"source":"iana"},"application/rdap+json":{"source":"iana","compressible":true},"application/rdf+xml":{"source":"iana","compressible":true,"extensions":["rdf","owl"]},"application/reginfo+xml":{"source":"iana","compressible":true,"extensions":["rif"]},"application/relax-ng-compact-syntax":{"source":"iana","extensions":["rnc"]},"application/remote-printing":{"source":"iana"},"application/reputon+json":{"source":"iana","compressible":true},"application/resource-lists+xml":{"source":"iana","compressible":true,"extensions":["rl"]},"application/resource-lists-diff+xml":{"source":"iana","compressible":true,"extensions":["rld"]},"application/rfc+xml":{"source":"iana","compressible":true},"application/riscos":{"source":"iana"},"application/rlmi+xml":{"source":"iana","compressible":true},"application/rls-services+xml":{"source":"iana","compressible":true,"extensions":["rs"]},"application/route-apd+xml":{"source":"iana","compressible":true,"extensions":["rapd"]},"application/route-s-tsid+xml":{"source":"iana","compressible":true,"extensions":["sls"]},"application/route-usd+xml":{"source":"iana","compressible":true,"extensions":["rusd"]},"application/rpki-ghostbusters":{"source":"iana","extensions":["gbr"]},"application/rpki-manifest":{"source":"iana","extensions":["mft"]},"application/rpki-publication":{"source":"iana"},"application/rpki-roa":{"source":"iana","extensions":["roa"]},"application/rpki-updown":{"source":"iana"},"application/rsd+xml":{"source":"apache","compressible":true,"extensions":["rsd"]},"application/rss+xml":{"source":"apache","compressible":true,"extensions":["rss"]},"application/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"application/rtploopback":{"source":"iana"},"application/rtx":{"source":"iana"},"application/samlassertion+xml":{"source":"iana","compressible":true},"application/samlmetadata+xml":{"source":"iana","compressible":true},"application/sarif+json":{"source":"iana","compressible":true},"application/sarif-external-properties+json":{"source":"iana","compressible":true},"application/sbe":{"source":"iana"},"application/sbml+xml":{"source":"iana","compressible":true,"extensions":["sbml"]},"application/scaip+xml":{"source":"iana","compressible":true},"application/scim+json":{"source":"iana","compressible":true},"application/scvp-cv-request":{"source":"iana","extensions":["scq"]},"application/scvp-cv-response":{"source":"iana","extensions":["scs"]},"application/scvp-vp-request":{"source":"iana","extensions":["spq"]},"application/scvp-vp-response":{"source":"iana","extensions":["spp"]},"application/sdp":{"source":"iana","extensions":["sdp"]},"application/secevent+jwt":{"source":"iana"},"application/senml+cbor":{"source":"iana"},"application/senml+json":{"source":"iana","compressible":true},"application/senml+xml":{"source":"iana","compressible":true,"extensions":["senmlx"]},"application/senml-etch+cbor":{"source":"iana"},"application/senml-etch+json":{"source":"iana","compressible":true},"application/senml-exi":{"source":"iana"},"application/sensml+cbor":{"source":"iana"},"application/sensml+json":{"source":"iana","compressible":true},"application/sensml+xml":{"source":"iana","compressible":true,"extensions":["sensmlx"]},"application/sensml-exi":{"source":"iana"},"application/sep+xml":{"source":"iana","compressible":true},"application/sep-exi":{"source":"iana"},"application/session-info":{"source":"iana"},"application/set-payment":{"source":"iana"},"application/set-payment-initiation":{"source":"iana","extensions":["setpay"]},"application/set-registration":{"source":"iana"},"application/set-registration-initiation":{"source":"iana","extensions":["setreg"]},"application/sgml":{"source":"iana"},"application/sgml-open-catalog":{"source":"iana"},"application/shf+xml":{"source":"iana","compressible":true,"extensions":["shf"]},"application/sieve":{"source":"iana","extensions":["siv","sieve"]},"application/simple-filter+xml":{"source":"iana","compressible":true},"application/simple-message-summary":{"source":"iana"},"application/simplesymbolcontainer":{"source":"iana"},"application/sipc":{"source":"iana"},"application/slate":{"source":"iana"},"application/smil":{"source":"iana"},"application/smil+xml":{"source":"iana","compressible":true,"extensions":["smi","smil"]},"application/smpte336m":{"source":"iana"},"application/soap+fastinfoset":{"source":"iana"},"application/soap+xml":{"source":"iana","compressible":true},"application/sparql-query":{"source":"iana","extensions":["rq"]},"application/sparql-results+xml":{"source":"iana","compressible":true,"extensions":["srx"]},"application/spdx+json":{"source":"iana","compressible":true},"application/spirits-event+xml":{"source":"iana","compressible":true},"application/sql":{"source":"iana"},"application/srgs":{"source":"iana","extensions":["gram"]},"application/srgs+xml":{"source":"iana","compressible":true,"extensions":["grxml"]},"application/sru+xml":{"source":"iana","compressible":true,"extensions":["sru"]},"application/ssdl+xml":{"source":"apache","compressible":true,"extensions":["ssdl"]},"application/ssml+xml":{"source":"iana","compressible":true,"extensions":["ssml"]},"application/stix+json":{"source":"iana","compressible":true},"application/swid+xml":{"source":"iana","compressible":true,"extensions":["swidtag"]},"application/tamp-apex-update":{"source":"iana"},"application/tamp-apex-update-confirm":{"source":"iana"},"application/tamp-community-update":{"source":"iana"},"application/tamp-community-update-confirm":{"source":"iana"},"application/tamp-error":{"source":"iana"},"application/tamp-sequence-adjust":{"source":"iana"},"application/tamp-sequence-adjust-confirm":{"source":"iana"},"application/tamp-status-query":{"source":"iana"},"application/tamp-status-response":{"source":"iana"},"application/tamp-update":{"source":"iana"},"application/tamp-update-confirm":{"source":"iana"},"application/tar":{"compressible":true},"application/taxii+json":{"source":"iana","compressible":true},"application/td+json":{"source":"iana","compressible":true},"application/tei+xml":{"source":"iana","compressible":true,"extensions":["tei","teicorpus"]},"application/tetra_isi":{"source":"iana"},"application/thraud+xml":{"source":"iana","compressible":true,"extensions":["tfi"]},"application/timestamp-query":{"source":"iana"},"application/timestamp-reply":{"source":"iana"},"application/timestamped-data":{"source":"iana","extensions":["tsd"]},"application/tlsrpt+gzip":{"source":"iana"},"application/tlsrpt+json":{"source":"iana","compressible":true},"application/tnauthlist":{"source":"iana"},"application/token-introspection+jwt":{"source":"iana"},"application/toml":{"compressible":true,"extensions":["toml"]},"application/trickle-ice-sdpfrag":{"source":"iana"},"application/trig":{"source":"iana","extensions":["trig"]},"application/ttml+xml":{"source":"iana","compressible":true,"extensions":["ttml"]},"application/tve-trigger":{"source":"iana"},"application/tzif":{"source":"iana"},"application/tzif-leap":{"source":"iana"},"application/ubjson":{"compressible":false,"extensions":["ubj"]},"application/ulpfec":{"source":"iana"},"application/urc-grpsheet+xml":{"source":"iana","compressible":true},"application/urc-ressheet+xml":{"source":"iana","compressible":true,"extensions":["rsheet"]},"application/urc-targetdesc+xml":{"source":"iana","compressible":true,"extensions":["td"]},"application/urc-uisocketdesc+xml":{"source":"iana","compressible":true},"application/vcard+json":{"source":"iana","compressible":true},"application/vcard+xml":{"source":"iana","compressible":true},"application/vemmi":{"source":"iana"},"application/vividence.scriptfile":{"source":"apache"},"application/vnd.1000minds.decision-model+xml":{"source":"iana","compressible":true,"extensions":["1km"]},"application/vnd.3gpp-prose+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-prose-pc3ch+xml":{"source":"iana","compressible":true},"application/vnd.3gpp-v2x-local-service-information":{"source":"iana"},"application/vnd.3gpp.5gnas":{"source":"iana"},"application/vnd.3gpp.access-transfer-events+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.bsf+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gmop+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.gtpc":{"source":"iana"},"application/vnd.3gpp.interworking-data":{"source":"iana"},"application/vnd.3gpp.lpp":{"source":"iana"},"application/vnd.3gpp.mc-signalling-ear":{"source":"iana"},"application/vnd.3gpp.mcdata-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-payload":{"source":"iana"},"application/vnd.3gpp.mcdata-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-signalling":{"source":"iana"},"application/vnd.3gpp.mcdata-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcdata-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-floor-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-signed+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-ue-init-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcptt-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-command+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-affiliation-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-location-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-mbms-usage-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-service-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-transmission-request+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-ue-config+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mcvideo-user-profile+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.mid-call+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ngap":{"source":"iana"},"application/vnd.3gpp.pfcp":{"source":"iana"},"application/vnd.3gpp.pic-bw-large":{"source":"iana","extensions":["plb"]},"application/vnd.3gpp.pic-bw-small":{"source":"iana","extensions":["psb"]},"application/vnd.3gpp.pic-bw-var":{"source":"iana","extensions":["pvb"]},"application/vnd.3gpp.s1ap":{"source":"iana"},"application/vnd.3gpp.sms":{"source":"iana"},"application/vnd.3gpp.sms+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-ext+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.srvcc-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.state-and-event-info+xml":{"source":"iana","compressible":true},"application/vnd.3gpp.ussd+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.bcmcsinfo+xml":{"source":"iana","compressible":true},"application/vnd.3gpp2.sms":{"source":"iana"},"application/vnd.3gpp2.tcap":{"source":"iana","extensions":["tcap"]},"application/vnd.3lightssoftware.imagescal":{"source":"iana"},"application/vnd.3m.post-it-notes":{"source":"iana","extensions":["pwn"]},"application/vnd.accpac.simply.aso":{"source":"iana","extensions":["aso"]},"application/vnd.accpac.simply.imp":{"source":"iana","extensions":["imp"]},"application/vnd.acucobol":{"source":"iana","extensions":["acu"]},"application/vnd.acucorp":{"source":"iana","extensions":["atc","acutc"]},"application/vnd.adobe.air-application-installer-package+zip":{"source":"apache","compressible":false,"extensions":["air"]},"application/vnd.adobe.flash.movie":{"source":"iana"},"application/vnd.adobe.formscentral.fcdt":{"source":"iana","extensions":["fcdt"]},"application/vnd.adobe.fxp":{"source":"iana","extensions":["fxp","fxpl"]},"application/vnd.adobe.partial-upload":{"source":"iana"},"application/vnd.adobe.xdp+xml":{"source":"iana","compressible":true,"extensions":["xdp"]},"application/vnd.adobe.xfdf":{"source":"iana","extensions":["xfdf"]},"application/vnd.aether.imp":{"source":"iana"},"application/vnd.afpc.afplinedata":{"source":"iana"},"application/vnd.afpc.afplinedata-pagedef":{"source":"iana"},"application/vnd.afpc.cmoca-cmresource":{"source":"iana"},"application/vnd.afpc.foca-charset":{"source":"iana"},"application/vnd.afpc.foca-codedfont":{"source":"iana"},"application/vnd.afpc.foca-codepage":{"source":"iana"},"application/vnd.afpc.modca":{"source":"iana"},"application/vnd.afpc.modca-cmtable":{"source":"iana"},"application/vnd.afpc.modca-formdef":{"source":"iana"},"application/vnd.afpc.modca-mediummap":{"source":"iana"},"application/vnd.afpc.modca-objectcontainer":{"source":"iana"},"application/vnd.afpc.modca-overlay":{"source":"iana"},"application/vnd.afpc.modca-pagesegment":{"source":"iana"},"application/vnd.age":{"source":"iana","extensions":["age"]},"application/vnd.ah-barcode":{"source":"iana"},"application/vnd.ahead.space":{"source":"iana","extensions":["ahead"]},"application/vnd.airzip.filesecure.azf":{"source":"iana","extensions":["azf"]},"application/vnd.airzip.filesecure.azs":{"source":"iana","extensions":["azs"]},"application/vnd.amadeus+json":{"source":"iana","compressible":true},"application/vnd.amazon.ebook":{"source":"apache","extensions":["azw"]},"application/vnd.amazon.mobi8-ebook":{"source":"iana"},"application/vnd.americandynamics.acc":{"source":"iana","extensions":["acc"]},"application/vnd.amiga.ami":{"source":"iana","extensions":["ami"]},"application/vnd.amundsen.maze+xml":{"source":"iana","compressible":true},"application/vnd.android.ota":{"source":"iana"},"application/vnd.android.package-archive":{"source":"apache","compressible":false,"extensions":["apk"]},"application/vnd.anki":{"source":"iana"},"application/vnd.anser-web-certificate-issue-initiation":{"source":"iana","extensions":["cii"]},"application/vnd.anser-web-funds-transfer-initiation":{"source":"apache","extensions":["fti"]},"application/vnd.antix.game-component":{"source":"iana","extensions":["atx"]},"application/vnd.apache.arrow.file":{"source":"iana"},"application/vnd.apache.arrow.stream":{"source":"iana"},"application/vnd.apache.thrift.binary":{"source":"iana"},"application/vnd.apache.thrift.compact":{"source":"iana"},"application/vnd.apache.thrift.json":{"source":"iana"},"application/vnd.api+json":{"source":"iana","compressible":true},"application/vnd.aplextor.warrp+json":{"source":"iana","compressible":true},"application/vnd.apothekende.reservation+json":{"source":"iana","compressible":true},"application/vnd.apple.installer+xml":{"source":"iana","compressible":true,"extensions":["mpkg"]},"application/vnd.apple.keynote":{"source":"iana","extensions":["key"]},"application/vnd.apple.mpegurl":{"source":"iana","extensions":["m3u8"]},"application/vnd.apple.numbers":{"source":"iana","extensions":["numbers"]},"application/vnd.apple.pages":{"source":"iana","extensions":["pages"]},"application/vnd.apple.pkpass":{"compressible":false,"extensions":["pkpass"]},"application/vnd.arastra.swi":{"source":"iana"},"application/vnd.aristanetworks.swi":{"source":"iana","extensions":["swi"]},"application/vnd.artisan+json":{"source":"iana","compressible":true},"application/vnd.artsquare":{"source":"iana"},"application/vnd.astraea-software.iota":{"source":"iana","extensions":["iota"]},"application/vnd.audiograph":{"source":"iana","extensions":["aep"]},"application/vnd.autopackage":{"source":"iana"},"application/vnd.avalon+json":{"source":"iana","compressible":true},"application/vnd.avistar+xml":{"source":"iana","compressible":true},"application/vnd.balsamiq.bmml+xml":{"source":"iana","compressible":true,"extensions":["bmml"]},"application/vnd.balsamiq.bmpr":{"source":"iana"},"application/vnd.banana-accounting":{"source":"iana"},"application/vnd.bbf.usp.error":{"source":"iana"},"application/vnd.bbf.usp.msg":{"source":"iana"},"application/vnd.bbf.usp.msg+json":{"source":"iana","compressible":true},"application/vnd.bekitzur-stech+json":{"source":"iana","compressible":true},"application/vnd.bint.med-content":{"source":"iana"},"application/vnd.biopax.rdf+xml":{"source":"iana","compressible":true},"application/vnd.blink-idb-value-wrapper":{"source":"iana"},"application/vnd.blueice.multipass":{"source":"iana","extensions":["mpm"]},"application/vnd.bluetooth.ep.oob":{"source":"iana"},"application/vnd.bluetooth.le.oob":{"source":"iana"},"application/vnd.bmi":{"source":"iana","extensions":["bmi"]},"application/vnd.bpf":{"source":"iana"},"application/vnd.bpf3":{"source":"iana"},"application/vnd.businessobjects":{"source":"iana","extensions":["rep"]},"application/vnd.byu.uapi+json":{"source":"iana","compressible":true},"application/vnd.cab-jscript":{"source":"iana"},"application/vnd.canon-cpdl":{"source":"iana"},"application/vnd.canon-lips":{"source":"iana"},"application/vnd.capasystems-pg+json":{"source":"iana","compressible":true},"application/vnd.cendio.thinlinc.clientconf":{"source":"iana"},"application/vnd.century-systems.tcp_stream":{"source":"iana"},"application/vnd.chemdraw+xml":{"source":"iana","compressible":true,"extensions":["cdxml"]},"application/vnd.chess-pgn":{"source":"iana"},"application/vnd.chipnuts.karaoke-mmd":{"source":"iana","extensions":["mmd"]},"application/vnd.ciedi":{"source":"iana"},"application/vnd.cinderella":{"source":"iana","extensions":["cdy"]},"application/vnd.cirpack.isdn-ext":{"source":"iana"},"application/vnd.citationstyles.style+xml":{"source":"iana","compressible":true,"extensions":["csl"]},"application/vnd.claymore":{"source":"iana","extensions":["cla"]},"application/vnd.cloanto.rp9":{"source":"iana","extensions":["rp9"]},"application/vnd.clonk.c4group":{"source":"iana","extensions":["c4g","c4d","c4f","c4p","c4u"]},"application/vnd.cluetrust.cartomobile-config":{"source":"iana","extensions":["c11amc"]},"application/vnd.cluetrust.cartomobile-config-pkg":{"source":"iana","extensions":["c11amz"]},"application/vnd.coffeescript":{"source":"iana"},"application/vnd.collabio.xodocuments.document":{"source":"iana"},"application/vnd.collabio.xodocuments.document-template":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation":{"source":"iana"},"application/vnd.collabio.xodocuments.presentation-template":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet":{"source":"iana"},"application/vnd.collabio.xodocuments.spreadsheet-template":{"source":"iana"},"application/vnd.collection+json":{"source":"iana","compressible":true},"application/vnd.collection.doc+json":{"source":"iana","compressible":true},"application/vnd.collection.next+json":{"source":"iana","compressible":true},"application/vnd.comicbook+zip":{"source":"iana","compressible":false},"application/vnd.comicbook-rar":{"source":"iana"},"application/vnd.commerce-battelle":{"source":"iana"},"application/vnd.commonspace":{"source":"iana","extensions":["csp"]},"application/vnd.contact.cmsg":{"source":"iana","extensions":["cdbcmsg"]},"application/vnd.coreos.ignition+json":{"source":"iana","compressible":true},"application/vnd.cosmocaller":{"source":"iana","extensions":["cmc"]},"application/vnd.crick.clicker":{"source":"iana","extensions":["clkx"]},"application/vnd.crick.clicker.keyboard":{"source":"iana","extensions":["clkk"]},"application/vnd.crick.clicker.palette":{"source":"iana","extensions":["clkp"]},"application/vnd.crick.clicker.template":{"source":"iana","extensions":["clkt"]},"application/vnd.crick.clicker.wordbank":{"source":"iana","extensions":["clkw"]},"application/vnd.criticaltools.wbs+xml":{"source":"iana","compressible":true,"extensions":["wbs"]},"application/vnd.cryptii.pipe+json":{"source":"iana","compressible":true},"application/vnd.crypto-shade-file":{"source":"iana"},"application/vnd.cryptomator.encrypted":{"source":"iana"},"application/vnd.cryptomator.vault":{"source":"iana"},"application/vnd.ctc-posml":{"source":"iana","extensions":["pml"]},"application/vnd.ctct.ws+xml":{"source":"iana","compressible":true},"application/vnd.cups-pdf":{"source":"iana"},"application/vnd.cups-postscript":{"source":"iana"},"application/vnd.cups-ppd":{"source":"iana","extensions":["ppd"]},"application/vnd.cups-raster":{"source":"iana"},"application/vnd.cups-raw":{"source":"iana"},"application/vnd.curl":{"source":"iana"},"application/vnd.curl.car":{"source":"apache","extensions":["car"]},"application/vnd.curl.pcurl":{"source":"apache","extensions":["pcurl"]},"application/vnd.cyan.dean.root+xml":{"source":"iana","compressible":true},"application/vnd.cybank":{"source":"iana"},"application/vnd.cyclonedx+json":{"source":"iana","compressible":true},"application/vnd.cyclonedx+xml":{"source":"iana","compressible":true},"application/vnd.d2l.coursepackage1p0+zip":{"source":"iana","compressible":false},"application/vnd.d3m-dataset":{"source":"iana"},"application/vnd.d3m-problem":{"source":"iana"},"application/vnd.dart":{"source":"iana","compressible":true,"extensions":["dart"]},"application/vnd.data-vision.rdz":{"source":"iana","extensions":["rdz"]},"application/vnd.datapackage+json":{"source":"iana","compressible":true},"application/vnd.dataresource+json":{"source":"iana","compressible":true},"application/vnd.dbf":{"source":"iana","extensions":["dbf"]},"application/vnd.debian.binary-package":{"source":"iana"},"application/vnd.dece.data":{"source":"iana","extensions":["uvf","uvvf","uvd","uvvd"]},"application/vnd.dece.ttml+xml":{"source":"iana","compressible":true,"extensions":["uvt","uvvt"]},"application/vnd.dece.unspecified":{"source":"iana","extensions":["uvx","uvvx"]},"application/vnd.dece.zip":{"source":"iana","extensions":["uvz","uvvz"]},"application/vnd.denovo.fcselayout-link":{"source":"iana","extensions":["fe_launch"]},"application/vnd.desmume.movie":{"source":"iana"},"application/vnd.dir-bi.plate-dl-nosuffix":{"source":"iana"},"application/vnd.dm.delegation+xml":{"source":"iana","compressible":true},"application/vnd.dna":{"source":"iana","extensions":["dna"]},"application/vnd.document+json":{"source":"iana","compressible":true},"application/vnd.dolby.mlp":{"source":"apache","extensions":["mlp"]},"application/vnd.dolby.mobile.1":{"source":"iana"},"application/vnd.dolby.mobile.2":{"source":"iana"},"application/vnd.doremir.scorecloud-binary-document":{"source":"iana"},"application/vnd.dpgraph":{"source":"iana","extensions":["dpg"]},"application/vnd.dreamfactory":{"source":"iana","extensions":["dfac"]},"application/vnd.drive+json":{"source":"iana","compressible":true},"application/vnd.ds-keypoint":{"source":"apache","extensions":["kpxx"]},"application/vnd.dtg.local":{"source":"iana"},"application/vnd.dtg.local.flash":{"source":"iana"},"application/vnd.dtg.local.html":{"source":"iana"},"application/vnd.dvb.ait":{"source":"iana","extensions":["ait"]},"application/vnd.dvb.dvbisl+xml":{"source":"iana","compressible":true},"application/vnd.dvb.dvbj":{"source":"iana"},"application/vnd.dvb.esgcontainer":{"source":"iana"},"application/vnd.dvb.ipdcdftnotifaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess":{"source":"iana"},"application/vnd.dvb.ipdcesgaccess2":{"source":"iana"},"application/vnd.dvb.ipdcesgpdd":{"source":"iana"},"application/vnd.dvb.ipdcroaming":{"source":"iana"},"application/vnd.dvb.iptv.alfec-base":{"source":"iana"},"application/vnd.dvb.iptv.alfec-enhancement":{"source":"iana"},"application/vnd.dvb.notif-aggregate-root+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-container+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-generic+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-msglist+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-request+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-ia-registration-response+xml":{"source":"iana","compressible":true},"application/vnd.dvb.notif-init+xml":{"source":"iana","compressible":true},"application/vnd.dvb.pfr":{"source":"iana"},"application/vnd.dvb.service":{"source":"iana","extensions":["svc"]},"application/vnd.dxr":{"source":"iana"},"application/vnd.dynageo":{"source":"iana","extensions":["geo"]},"application/vnd.dzr":{"source":"iana"},"application/vnd.easykaraoke.cdgdownload":{"source":"iana"},"application/vnd.ecdis-update":{"source":"iana"},"application/vnd.ecip.rlp":{"source":"iana"},"application/vnd.eclipse.ditto+json":{"source":"iana","compressible":true},"application/vnd.ecowin.chart":{"source":"iana","extensions":["mag"]},"application/vnd.ecowin.filerequest":{"source":"iana"},"application/vnd.ecowin.fileupdate":{"source":"iana"},"application/vnd.ecowin.series":{"source":"iana"},"application/vnd.ecowin.seriesrequest":{"source":"iana"},"application/vnd.ecowin.seriesupdate":{"source":"iana"},"application/vnd.efi.img":{"source":"iana"},"application/vnd.efi.iso":{"source":"iana"},"application/vnd.emclient.accessrequest+xml":{"source":"iana","compressible":true},"application/vnd.enliven":{"source":"iana","extensions":["nml"]},"application/vnd.enphase.envoy":{"source":"iana"},"application/vnd.eprints.data+xml":{"source":"iana","compressible":true},"application/vnd.epson.esf":{"source":"iana","extensions":["esf"]},"application/vnd.epson.msf":{"source":"iana","extensions":["msf"]},"application/vnd.epson.quickanime":{"source":"iana","extensions":["qam"]},"application/vnd.epson.salt":{"source":"iana","extensions":["slt"]},"application/vnd.epson.ssf":{"source":"iana","extensions":["ssf"]},"application/vnd.ericsson.quickcall":{"source":"iana"},"application/vnd.espass-espass+zip":{"source":"iana","compressible":false},"application/vnd.eszigno3+xml":{"source":"iana","compressible":true,"extensions":["es3","et3"]},"application/vnd.etsi.aoc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.asic-e+zip":{"source":"iana","compressible":false},"application/vnd.etsi.asic-s+zip":{"source":"iana","compressible":false},"application/vnd.etsi.cug+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvcommand+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-bc+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-cod+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsad-npvr+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvservice+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvsync+xml":{"source":"iana","compressible":true},"application/vnd.etsi.iptvueprofile+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mcid+xml":{"source":"iana","compressible":true},"application/vnd.etsi.mheg5":{"source":"iana"},"application/vnd.etsi.overload-control-policy-dataset+xml":{"source":"iana","compressible":true},"application/vnd.etsi.pstn+xml":{"source":"iana","compressible":true},"application/vnd.etsi.sci+xml":{"source":"iana","compressible":true},"application/vnd.etsi.simservs+xml":{"source":"iana","compressible":true},"application/vnd.etsi.timestamp-token":{"source":"iana"},"application/vnd.etsi.tsl+xml":{"source":"iana","compressible":true},"application/vnd.etsi.tsl.der":{"source":"iana"},"application/vnd.eu.kasparian.car+json":{"source":"iana","compressible":true},"application/vnd.eudora.data":{"source":"iana"},"application/vnd.evolv.ecig.profile":{"source":"iana"},"application/vnd.evolv.ecig.settings":{"source":"iana"},"application/vnd.evolv.ecig.theme":{"source":"iana"},"application/vnd.exstream-empower+zip":{"source":"iana","compressible":false},"application/vnd.exstream-package":{"source":"iana"},"application/vnd.ezpix-album":{"source":"iana","extensions":["ez2"]},"application/vnd.ezpix-package":{"source":"iana","extensions":["ez3"]},"application/vnd.f-secure.mobile":{"source":"iana"},"application/vnd.familysearch.gedcom+zip":{"source":"iana","compressible":false},"application/vnd.fastcopy-disk-image":{"source":"iana"},"application/vnd.fdf":{"source":"iana","extensions":["fdf"]},"application/vnd.fdsn.mseed":{"source":"iana","extensions":["mseed"]},"application/vnd.fdsn.seed":{"source":"iana","extensions":["seed","dataless"]},"application/vnd.ffsns":{"source":"iana"},"application/vnd.ficlab.flb+zip":{"source":"iana","compressible":false},"application/vnd.filmit.zfc":{"source":"iana"},"application/vnd.fints":{"source":"iana"},"application/vnd.firemonkeys.cloudcell":{"source":"iana"},"application/vnd.flographit":{"source":"iana","extensions":["gph"]},"application/vnd.fluxtime.clip":{"source":"iana","extensions":["ftc"]},"application/vnd.font-fontforge-sfd":{"source":"iana"},"application/vnd.framemaker":{"source":"iana","extensions":["fm","frame","maker","book"]},"application/vnd.frogans.fnc":{"source":"iana","extensions":["fnc"]},"application/vnd.frogans.ltf":{"source":"iana","extensions":["ltf"]},"application/vnd.fsc.weblaunch":{"source":"iana","extensions":["fsc"]},"application/vnd.fujifilm.fb.docuworks":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.binder":{"source":"iana"},"application/vnd.fujifilm.fb.docuworks.container":{"source":"iana"},"application/vnd.fujifilm.fb.jfi+xml":{"source":"iana","compressible":true},"application/vnd.fujitsu.oasys":{"source":"iana","extensions":["oas"]},"application/vnd.fujitsu.oasys2":{"source":"iana","extensions":["oa2"]},"application/vnd.fujitsu.oasys3":{"source":"iana","extensions":["oa3"]},"application/vnd.fujitsu.oasysgp":{"source":"iana","extensions":["fg5"]},"application/vnd.fujitsu.oasysprs":{"source":"iana","extensions":["bh2"]},"application/vnd.fujixerox.art-ex":{"source":"iana"},"application/vnd.fujixerox.art4":{"source":"iana"},"application/vnd.fujixerox.ddd":{"source":"iana","extensions":["ddd"]},"application/vnd.fujixerox.docuworks":{"source":"iana","extensions":["xdw"]},"application/vnd.fujixerox.docuworks.binder":{"source":"iana","extensions":["xbd"]},"application/vnd.fujixerox.docuworks.container":{"source":"iana"},"application/vnd.fujixerox.hbpl":{"source":"iana"},"application/vnd.fut-misnet":{"source":"iana"},"application/vnd.futoin+cbor":{"source":"iana"},"application/vnd.futoin+json":{"source":"iana","compressible":true},"application/vnd.fuzzysheet":{"source":"iana","extensions":["fzs"]},"application/vnd.genomatix.tuxedo":{"source":"iana","extensions":["txd"]},"application/vnd.gentics.grd+json":{"source":"iana","compressible":true},"application/vnd.geo+json":{"source":"iana","compressible":true},"application/vnd.geocube+xml":{"source":"iana","compressible":true},"application/vnd.geogebra.file":{"source":"iana","extensions":["ggb"]},"application/vnd.geogebra.slides":{"source":"iana"},"application/vnd.geogebra.tool":{"source":"iana","extensions":["ggt"]},"application/vnd.geometry-explorer":{"source":"iana","extensions":["gex","gre"]},"application/vnd.geonext":{"source":"iana","extensions":["gxt"]},"application/vnd.geoplan":{"source":"iana","extensions":["g2w"]},"application/vnd.geospace":{"source":"iana","extensions":["g3w"]},"application/vnd.gerber":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt":{"source":"iana"},"application/vnd.globalplatform.card-content-mgt-response":{"source":"iana"},"application/vnd.gmx":{"source":"iana","extensions":["gmx"]},"application/vnd.google-apps.document":{"compressible":false,"extensions":["gdoc"]},"application/vnd.google-apps.presentation":{"compressible":false,"extensions":["gslides"]},"application/vnd.google-apps.spreadsheet":{"compressible":false,"extensions":["gsheet"]},"application/vnd.google-earth.kml+xml":{"source":"iana","compressible":true,"extensions":["kml"]},"application/vnd.google-earth.kmz":{"source":"iana","compressible":false,"extensions":["kmz"]},"application/vnd.gov.sk.e-form+xml":{"source":"iana","compressible":true},"application/vnd.gov.sk.e-form+zip":{"source":"iana","compressible":false},"application/vnd.gov.sk.xmldatacontainer+xml":{"source":"iana","compressible":true},"application/vnd.grafeq":{"source":"iana","extensions":["gqf","gqs"]},"application/vnd.gridmp":{"source":"iana"},"application/vnd.groove-account":{"source":"iana","extensions":["gac"]},"application/vnd.groove-help":{"source":"iana","extensions":["ghf"]},"application/vnd.groove-identity-message":{"source":"iana","extensions":["gim"]},"application/vnd.groove-injector":{"source":"iana","extensions":["grv"]},"application/vnd.groove-tool-message":{"source":"iana","extensions":["gtm"]},"application/vnd.groove-tool-template":{"source":"iana","extensions":["tpl"]},"application/vnd.groove-vcard":{"source":"iana","extensions":["vcg"]},"application/vnd.hal+json":{"source":"iana","compressible":true},"application/vnd.hal+xml":{"source":"iana","compressible":true,"extensions":["hal"]},"application/vnd.handheld-entertainment+xml":{"source":"iana","compressible":true,"extensions":["zmm"]},"application/vnd.hbci":{"source":"iana","extensions":["hbci"]},"application/vnd.hc+json":{"source":"iana","compressible":true},"application/vnd.hcl-bireports":{"source":"iana"},"application/vnd.hdt":{"source":"iana"},"application/vnd.heroku+json":{"source":"iana","compressible":true},"application/vnd.hhe.lesson-player":{"source":"iana","extensions":["les"]},"application/vnd.hl7cda+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hl7v2+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.hp-hpgl":{"source":"iana","extensions":["hpgl"]},"application/vnd.hp-hpid":{"source":"iana","extensions":["hpid"]},"application/vnd.hp-hps":{"source":"iana","extensions":["hps"]},"application/vnd.hp-jlyt":{"source":"iana","extensions":["jlt"]},"application/vnd.hp-pcl":{"source":"iana","extensions":["pcl"]},"application/vnd.hp-pclxl":{"source":"iana","extensions":["pclxl"]},"application/vnd.httphone":{"source":"iana"},"application/vnd.hydrostatix.sof-data":{"source":"iana","extensions":["sfd-hdstx"]},"application/vnd.hyper+json":{"source":"iana","compressible":true},"application/vnd.hyper-item+json":{"source":"iana","compressible":true},"application/vnd.hyperdrive+json":{"source":"iana","compressible":true},"application/vnd.hzn-3d-crossword":{"source":"iana"},"application/vnd.ibm.afplinedata":{"source":"iana"},"application/vnd.ibm.electronic-media":{"source":"iana"},"application/vnd.ibm.minipay":{"source":"iana","extensions":["mpy"]},"application/vnd.ibm.modcap":{"source":"iana","extensions":["afp","listafp","list3820"]},"application/vnd.ibm.rights-management":{"source":"iana","extensions":["irm"]},"application/vnd.ibm.secure-container":{"source":"iana","extensions":["sc"]},"application/vnd.iccprofile":{"source":"iana","extensions":["icc","icm"]},"application/vnd.ieee.1905":{"source":"iana"},"application/vnd.igloader":{"source":"iana","extensions":["igl"]},"application/vnd.imagemeter.folder+zip":{"source":"iana","compressible":false},"application/vnd.imagemeter.image+zip":{"source":"iana","compressible":false},"application/vnd.immervision-ivp":{"source":"iana","extensions":["ivp"]},"application/vnd.immervision-ivu":{"source":"iana","extensions":["ivu"]},"application/vnd.ims.imsccv1p1":{"source":"iana"},"application/vnd.ims.imsccv1p2":{"source":"iana"},"application/vnd.ims.imsccv1p3":{"source":"iana"},"application/vnd.ims.lis.v2.result+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolconsumerprofile+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolproxy.id+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings+json":{"source":"iana","compressible":true},"application/vnd.ims.lti.v2.toolsettings.simple+json":{"source":"iana","compressible":true},"application/vnd.informedcontrol.rms+xml":{"source":"iana","compressible":true},"application/vnd.informix-visionary":{"source":"iana"},"application/vnd.infotech.project":{"source":"iana"},"application/vnd.infotech.project+xml":{"source":"iana","compressible":true},"application/vnd.innopath.wamp.notification":{"source":"iana"},"application/vnd.insors.igm":{"source":"iana","extensions":["igm"]},"application/vnd.intercon.formnet":{"source":"iana","extensions":["xpw","xpx"]},"application/vnd.intergeo":{"source":"iana","extensions":["i2g"]},"application/vnd.intertrust.digibox":{"source":"iana"},"application/vnd.intertrust.nncp":{"source":"iana"},"application/vnd.intu.qbo":{"source":"iana","extensions":["qbo"]},"application/vnd.intu.qfx":{"source":"iana","extensions":["qfx"]},"application/vnd.iptc.g2.catalogitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.conceptitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.knowledgeitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.newsmessage+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.packageitem+xml":{"source":"iana","compressible":true},"application/vnd.iptc.g2.planningitem+xml":{"source":"iana","compressible":true},"application/vnd.ipunplugged.rcprofile":{"source":"iana","extensions":["rcprofile"]},"application/vnd.irepository.package+xml":{"source":"iana","compressible":true,"extensions":["irp"]},"application/vnd.is-xpr":{"source":"iana","extensions":["xpr"]},"application/vnd.isac.fcs":{"source":"iana","extensions":["fcs"]},"application/vnd.iso11783-10+zip":{"source":"iana","compressible":false},"application/vnd.jam":{"source":"iana","extensions":["jam"]},"application/vnd.japannet-directory-service":{"source":"iana"},"application/vnd.japannet-jpnstore-wakeup":{"source":"iana"},"application/vnd.japannet-payment-wakeup":{"source":"iana"},"application/vnd.japannet-registration":{"source":"iana"},"application/vnd.japannet-registration-wakeup":{"source":"iana"},"application/vnd.japannet-setstore-wakeup":{"source":"iana"},"application/vnd.japannet-verification":{"source":"iana"},"application/vnd.japannet-verification-wakeup":{"source":"iana"},"application/vnd.jcp.javame.midlet-rms":{"source":"iana","extensions":["rms"]},"application/vnd.jisp":{"source":"iana","extensions":["jisp"]},"application/vnd.joost.joda-archive":{"source":"iana","extensions":["joda"]},"application/vnd.jsk.isdn-ngn":{"source":"iana"},"application/vnd.kahootz":{"source":"iana","extensions":["ktz","ktr"]},"application/vnd.kde.karbon":{"source":"iana","extensions":["karbon"]},"application/vnd.kde.kchart":{"source":"iana","extensions":["chrt"]},"application/vnd.kde.kformula":{"source":"iana","extensions":["kfo"]},"application/vnd.kde.kivio":{"source":"iana","extensions":["flw"]},"application/vnd.kde.kontour":{"source":"iana","extensions":["kon"]},"application/vnd.kde.kpresenter":{"source":"iana","extensions":["kpr","kpt"]},"application/vnd.kde.kspread":{"source":"iana","extensions":["ksp"]},"application/vnd.kde.kword":{"source":"iana","extensions":["kwd","kwt"]},"application/vnd.kenameaapp":{"source":"iana","extensions":["htke"]},"application/vnd.kidspiration":{"source":"iana","extensions":["kia"]},"application/vnd.kinar":{"source":"iana","extensions":["kne","knp"]},"application/vnd.koan":{"source":"iana","extensions":["skp","skd","skt","skm"]},"application/vnd.kodak-descriptor":{"source":"iana","extensions":["sse"]},"application/vnd.las":{"source":"iana"},"application/vnd.las.las+json":{"source":"iana","compressible":true},"application/vnd.las.las+xml":{"source":"iana","compressible":true,"extensions":["lasxml"]},"application/vnd.laszip":{"source":"iana"},"application/vnd.leap+json":{"source":"iana","compressible":true},"application/vnd.liberty-request+xml":{"source":"iana","compressible":true},"application/vnd.llamagraphics.life-balance.desktop":{"source":"iana","extensions":["lbd"]},"application/vnd.llamagraphics.life-balance.exchange+xml":{"source":"iana","compressible":true,"extensions":["lbe"]},"application/vnd.logipipe.circuit+zip":{"source":"iana","compressible":false},"application/vnd.loom":{"source":"iana"},"application/vnd.lotus-1-2-3":{"source":"iana","extensions":["123"]},"application/vnd.lotus-approach":{"source":"iana","extensions":["apr"]},"application/vnd.lotus-freelance":{"source":"iana","extensions":["pre"]},"application/vnd.lotus-notes":{"source":"iana","extensions":["nsf"]},"application/vnd.lotus-organizer":{"source":"iana","extensions":["org"]},"application/vnd.lotus-screencam":{"source":"iana","extensions":["scm"]},"application/vnd.lotus-wordpro":{"source":"iana","extensions":["lwp"]},"application/vnd.macports.portpkg":{"source":"iana","extensions":["portpkg"]},"application/vnd.mapbox-vector-tile":{"source":"iana","extensions":["mvt"]},"application/vnd.marlin.drm.actiontoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.conftoken+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.license+xml":{"source":"iana","compressible":true},"application/vnd.marlin.drm.mdcf":{"source":"iana"},"application/vnd.mason+json":{"source":"iana","compressible":true},"application/vnd.maxar.archive.3tz+zip":{"source":"iana","compressible":false},"application/vnd.maxmind.maxmind-db":{"source":"iana"},"application/vnd.mcd":{"source":"iana","extensions":["mcd"]},"application/vnd.medcalcdata":{"source":"iana","extensions":["mc1"]},"application/vnd.mediastation.cdkey":{"source":"iana","extensions":["cdkey"]},"application/vnd.meridian-slingshot":{"source":"iana"},"application/vnd.mfer":{"source":"iana","extensions":["mwf"]},"application/vnd.mfmp":{"source":"iana","extensions":["mfm"]},"application/vnd.micro+json":{"source":"iana","compressible":true},"application/vnd.micrografx.flo":{"source":"iana","extensions":["flo"]},"application/vnd.micrografx.igx":{"source":"iana","extensions":["igx"]},"application/vnd.microsoft.portable-executable":{"source":"iana"},"application/vnd.microsoft.windows.thumbnail-cache":{"source":"iana"},"application/vnd.miele+json":{"source":"iana","compressible":true},"application/vnd.mif":{"source":"iana","extensions":["mif"]},"application/vnd.minisoft-hp3000-save":{"source":"iana"},"application/vnd.mitsubishi.misty-guard.trustweb":{"source":"iana"},"application/vnd.mobius.daf":{"source":"iana","extensions":["daf"]},"application/vnd.mobius.dis":{"source":"iana","extensions":["dis"]},"application/vnd.mobius.mbk":{"source":"iana","extensions":["mbk"]},"application/vnd.mobius.mqy":{"source":"iana","extensions":["mqy"]},"application/vnd.mobius.msl":{"source":"iana","extensions":["msl"]},"application/vnd.mobius.plc":{"source":"iana","extensions":["plc"]},"application/vnd.mobius.txf":{"source":"iana","extensions":["txf"]},"application/vnd.mophun.application":{"source":"iana","extensions":["mpn"]},"application/vnd.mophun.certificate":{"source":"iana","extensions":["mpc"]},"application/vnd.motorola.flexsuite":{"source":"iana"},"application/vnd.motorola.flexsuite.adsi":{"source":"iana"},"application/vnd.motorola.flexsuite.fis":{"source":"iana"},"application/vnd.motorola.flexsuite.gotap":{"source":"iana"},"application/vnd.motorola.flexsuite.kmr":{"source":"iana"},"application/vnd.motorola.flexsuite.ttc":{"source":"iana"},"application/vnd.motorola.flexsuite.wem":{"source":"iana"},"application/vnd.motorola.iprm":{"source":"iana"},"application/vnd.mozilla.xul+xml":{"source":"iana","compressible":true,"extensions":["xul"]},"application/vnd.ms-3mfdocument":{"source":"iana"},"application/vnd.ms-artgalry":{"source":"iana","extensions":["cil"]},"application/vnd.ms-asf":{"source":"iana"},"application/vnd.ms-cab-compressed":{"source":"iana","extensions":["cab"]},"application/vnd.ms-color.iccprofile":{"source":"apache"},"application/vnd.ms-excel":{"source":"iana","compressible":false,"extensions":["xls","xlm","xla","xlc","xlt","xlw"]},"application/vnd.ms-excel.addin.macroenabled.12":{"source":"iana","extensions":["xlam"]},"application/vnd.ms-excel.sheet.binary.macroenabled.12":{"source":"iana","extensions":["xlsb"]},"application/vnd.ms-excel.sheet.macroenabled.12":{"source":"iana","extensions":["xlsm"]},"application/vnd.ms-excel.template.macroenabled.12":{"source":"iana","extensions":["xltm"]},"application/vnd.ms-fontobject":{"source":"iana","compressible":true,"extensions":["eot"]},"application/vnd.ms-htmlhelp":{"source":"iana","extensions":["chm"]},"application/vnd.ms-ims":{"source":"iana","extensions":["ims"]},"application/vnd.ms-lrm":{"source":"iana","extensions":["lrm"]},"application/vnd.ms-office.activex+xml":{"source":"iana","compressible":true},"application/vnd.ms-officetheme":{"source":"iana","extensions":["thmx"]},"application/vnd.ms-opentype":{"source":"apache","compressible":true},"application/vnd.ms-outlook":{"compressible":false,"extensions":["msg"]},"application/vnd.ms-package.obfuscated-opentype":{"source":"apache"},"application/vnd.ms-pki.seccat":{"source":"apache","extensions":["cat"]},"application/vnd.ms-pki.stl":{"source":"apache","extensions":["stl"]},"application/vnd.ms-playready.initiator+xml":{"source":"iana","compressible":true},"application/vnd.ms-powerpoint":{"source":"iana","compressible":false,"extensions":["ppt","pps","pot"]},"application/vnd.ms-powerpoint.addin.macroenabled.12":{"source":"iana","extensions":["ppam"]},"application/vnd.ms-powerpoint.presentation.macroenabled.12":{"source":"iana","extensions":["pptm"]},"application/vnd.ms-powerpoint.slide.macroenabled.12":{"source":"iana","extensions":["sldm"]},"application/vnd.ms-powerpoint.slideshow.macroenabled.12":{"source":"iana","extensions":["ppsm"]},"application/vnd.ms-powerpoint.template.macroenabled.12":{"source":"iana","extensions":["potm"]},"application/vnd.ms-printdevicecapabilities+xml":{"source":"iana","compressible":true},"application/vnd.ms-printing.printticket+xml":{"source":"apache","compressible":true},"application/vnd.ms-printschematicket+xml":{"source":"iana","compressible":true},"application/vnd.ms-project":{"source":"iana","extensions":["mpp","mpt"]},"application/vnd.ms-tnef":{"source":"iana"},"application/vnd.ms-windows.devicepairing":{"source":"iana"},"application/vnd.ms-windows.nwprinting.oob":{"source":"iana"},"application/vnd.ms-windows.printerpairing":{"source":"iana"},"application/vnd.ms-windows.wsd.oob":{"source":"iana"},"application/vnd.ms-wmdrm.lic-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.lic-resp":{"source":"iana"},"application/vnd.ms-wmdrm.meter-chlg-req":{"source":"iana"},"application/vnd.ms-wmdrm.meter-resp":{"source":"iana"},"application/vnd.ms-word.document.macroenabled.12":{"source":"iana","extensions":["docm"]},"application/vnd.ms-word.template.macroenabled.12":{"source":"iana","extensions":["dotm"]},"application/vnd.ms-works":{"source":"iana","extensions":["wps","wks","wcm","wdb"]},"application/vnd.ms-wpl":{"source":"iana","extensions":["wpl"]},"application/vnd.ms-xpsdocument":{"source":"iana","compressible":false,"extensions":["xps"]},"application/vnd.msa-disk-image":{"source":"iana"},"application/vnd.mseq":{"source":"iana","extensions":["mseq"]},"application/vnd.msign":{"source":"iana"},"application/vnd.multiad.creator":{"source":"iana"},"application/vnd.multiad.creator.cif":{"source":"iana"},"application/vnd.music-niff":{"source":"iana"},"application/vnd.musician":{"source":"iana","extensions":["mus"]},"application/vnd.muvee.style":{"source":"iana","extensions":["msty"]},"application/vnd.mynfc":{"source":"iana","extensions":["taglet"]},"application/vnd.nacamar.ybrid+json":{"source":"iana","compressible":true},"application/vnd.ncd.control":{"source":"iana"},"application/vnd.ncd.reference":{"source":"iana"},"application/vnd.nearst.inv+json":{"source":"iana","compressible":true},"application/vnd.nebumind.line":{"source":"iana"},"application/vnd.nervana":{"source":"iana"},"application/vnd.netfpx":{"source":"iana"},"application/vnd.neurolanguage.nlu":{"source":"iana","extensions":["nlu"]},"application/vnd.nimn":{"source":"iana"},"application/vnd.nintendo.nitro.rom":{"source":"iana"},"application/vnd.nintendo.snes.rom":{"source":"iana"},"application/vnd.nitf":{"source":"iana","extensions":["ntf","nitf"]},"application/vnd.noblenet-directory":{"source":"iana","extensions":["nnd"]},"application/vnd.noblenet-sealer":{"source":"iana","extensions":["nns"]},"application/vnd.noblenet-web":{"source":"iana","extensions":["nnw"]},"application/vnd.nokia.catalogs":{"source":"iana"},"application/vnd.nokia.conml+wbxml":{"source":"iana"},"application/vnd.nokia.conml+xml":{"source":"iana","compressible":true},"application/vnd.nokia.iptv.config+xml":{"source":"iana","compressible":true},"application/vnd.nokia.isds-radio-presets":{"source":"iana"},"application/vnd.nokia.landmark+wbxml":{"source":"iana"},"application/vnd.nokia.landmark+xml":{"source":"iana","compressible":true},"application/vnd.nokia.landmarkcollection+xml":{"source":"iana","compressible":true},"application/vnd.nokia.n-gage.ac+xml":{"source":"iana","compressible":true,"extensions":["ac"]},"application/vnd.nokia.n-gage.data":{"source":"iana","extensions":["ngdat"]},"application/vnd.nokia.n-gage.symbian.install":{"source":"iana","extensions":["n-gage"]},"application/vnd.nokia.ncd":{"source":"iana"},"application/vnd.nokia.pcd+wbxml":{"source":"iana"},"application/vnd.nokia.pcd+xml":{"source":"iana","compressible":true},"application/vnd.nokia.radio-preset":{"source":"iana","extensions":["rpst"]},"application/vnd.nokia.radio-presets":{"source":"iana","extensions":["rpss"]},"application/vnd.novadigm.edm":{"source":"iana","extensions":["edm"]},"application/vnd.novadigm.edx":{"source":"iana","extensions":["edx"]},"application/vnd.novadigm.ext":{"source":"iana","extensions":["ext"]},"application/vnd.ntt-local.content-share":{"source":"iana"},"application/vnd.ntt-local.file-transfer":{"source":"iana"},"application/vnd.ntt-local.ogw_remote-access":{"source":"iana"},"application/vnd.ntt-local.sip-ta_remote":{"source":"iana"},"application/vnd.ntt-local.sip-ta_tcp_stream":{"source":"iana"},"application/vnd.oasis.opendocument.chart":{"source":"iana","extensions":["odc"]},"application/vnd.oasis.opendocument.chart-template":{"source":"iana","extensions":["otc"]},"application/vnd.oasis.opendocument.database":{"source":"iana","extensions":["odb"]},"application/vnd.oasis.opendocument.formula":{"source":"iana","extensions":["odf"]},"application/vnd.oasis.opendocument.formula-template":{"source":"iana","extensions":["odft"]},"application/vnd.oasis.opendocument.graphics":{"source":"iana","compressible":false,"extensions":["odg"]},"application/vnd.oasis.opendocument.graphics-template":{"source":"iana","extensions":["otg"]},"application/vnd.oasis.opendocument.image":{"source":"iana","extensions":["odi"]},"application/vnd.oasis.opendocument.image-template":{"source":"iana","extensions":["oti"]},"application/vnd.oasis.opendocument.presentation":{"source":"iana","compressible":false,"extensions":["odp"]},"application/vnd.oasis.opendocument.presentation-template":{"source":"iana","extensions":["otp"]},"application/vnd.oasis.opendocument.spreadsheet":{"source":"iana","compressible":false,"extensions":["ods"]},"application/vnd.oasis.opendocument.spreadsheet-template":{"source":"iana","extensions":["ots"]},"application/vnd.oasis.opendocument.text":{"source":"iana","compressible":false,"extensions":["odt"]},"application/vnd.oasis.opendocument.text-master":{"source":"iana","extensions":["odm"]},"application/vnd.oasis.opendocument.text-template":{"source":"iana","extensions":["ott"]},"application/vnd.oasis.opendocument.text-web":{"source":"iana","extensions":["oth"]},"application/vnd.obn":{"source":"iana"},"application/vnd.ocf+cbor":{"source":"iana"},"application/vnd.oci.image.manifest.v1+json":{"source":"iana","compressible":true},"application/vnd.oftn.l10n+json":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessdownload+xml":{"source":"iana","compressible":true},"application/vnd.oipf.contentaccessstreaming+xml":{"source":"iana","compressible":true},"application/vnd.oipf.cspg-hexbinary":{"source":"iana"},"application/vnd.oipf.dae.svg+xml":{"source":"iana","compressible":true},"application/vnd.oipf.dae.xhtml+xml":{"source":"iana","compressible":true},"application/vnd.oipf.mippvcontrolmessage+xml":{"source":"iana","compressible":true},"application/vnd.oipf.pae.gem":{"source":"iana"},"application/vnd.oipf.spdiscovery+xml":{"source":"iana","compressible":true},"application/vnd.oipf.spdlist+xml":{"source":"iana","compressible":true},"application/vnd.oipf.ueprofile+xml":{"source":"iana","compressible":true},"application/vnd.oipf.userprofile+xml":{"source":"iana","compressible":true},"application/vnd.olpc-sugar":{"source":"iana","extensions":["xo"]},"application/vnd.oma-scws-config":{"source":"iana"},"application/vnd.oma-scws-http-request":{"source":"iana"},"application/vnd.oma-scws-http-response":{"source":"iana"},"application/vnd.oma.bcast.associated-procedure-parameter+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.drm-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.imd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.ltkm":{"source":"iana"},"application/vnd.oma.bcast.notification+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.provisioningtrigger":{"source":"iana"},"application/vnd.oma.bcast.sgboot":{"source":"iana"},"application/vnd.oma.bcast.sgdd+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sgdu":{"source":"iana"},"application/vnd.oma.bcast.simple-symbol-container":{"source":"iana"},"application/vnd.oma.bcast.smartcard-trigger+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.sprov+xml":{"source":"iana","compressible":true},"application/vnd.oma.bcast.stkm":{"source":"iana"},"application/vnd.oma.cab-address-book+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-feature-handler+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-pcc+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-subs-invite+xml":{"source":"iana","compressible":true},"application/vnd.oma.cab-user-prefs+xml":{"source":"iana","compressible":true},"application/vnd.oma.dcd":{"source":"iana"},"application/vnd.oma.dcdc":{"source":"iana"},"application/vnd.oma.dd2+xml":{"source":"iana","compressible":true,"extensions":["dd2"]},"application/vnd.oma.drm.risd+xml":{"source":"iana","compressible":true},"application/vnd.oma.group-usage-list+xml":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+cbor":{"source":"iana"},"application/vnd.oma.lwm2m+json":{"source":"iana","compressible":true},"application/vnd.oma.lwm2m+tlv":{"source":"iana"},"application/vnd.oma.pal+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.detailed-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.final-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.groups+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.invocation-descriptor+xml":{"source":"iana","compressible":true},"application/vnd.oma.poc.optimized-progress-report+xml":{"source":"iana","compressible":true},"application/vnd.oma.push":{"source":"iana"},"application/vnd.oma.scidm.messages+xml":{"source":"iana","compressible":true},"application/vnd.oma.xcap-directory+xml":{"source":"iana","compressible":true},"application/vnd.omads-email+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-file+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omads-folder+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.omaloc-supl-init":{"source":"iana"},"application/vnd.onepager":{"source":"iana"},"application/vnd.onepagertamp":{"source":"iana"},"application/vnd.onepagertamx":{"source":"iana"},"application/vnd.onepagertat":{"source":"iana"},"application/vnd.onepagertatp":{"source":"iana"},"application/vnd.onepagertatx":{"source":"iana"},"application/vnd.openblox.game+xml":{"source":"iana","compressible":true,"extensions":["obgx"]},"application/vnd.openblox.game-binary":{"source":"iana"},"application/vnd.openeye.oeb":{"source":"iana"},"application/vnd.openofficeorg.extension":{"source":"apache","extensions":["oxt"]},"application/vnd.openstreetmap.data+xml":{"source":"iana","compressible":true,"extensions":["osm"]},"application/vnd.opentimestamps.ots":{"source":"iana"},"application/vnd.openxmlformats-officedocument.custom-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.customxmlproperties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawing+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chart+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.extended-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presentation":{"source":"iana","compressible":false,"extensions":["pptx"]},"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slide":{"source":"iana","extensions":["sldx"]},"application/vnd.openxmlformats-officedocument.presentationml.slide+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideshow":{"source":"iana","extensions":["ppsx"]},"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.tags+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.template":{"source":"iana","extensions":["potx"]},"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet":{"source":"iana","compressible":false,"extensions":["xlsx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.template":{"source":"iana","extensions":["xltx"]},"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.theme+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.themeoverride+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.vmldrawing":{"source":"iana"},"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document":{"source":"iana","compressible":false,"extensions":["docx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.template":{"source":"iana","extensions":["dotx"]},"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.core-properties+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml":{"source":"iana","compressible":true},"application/vnd.openxmlformats-package.relationships+xml":{"source":"iana","compressible":true},"application/vnd.oracle.resource+json":{"source":"iana","compressible":true},"application/vnd.orange.indata":{"source":"iana"},"application/vnd.osa.netdeploy":{"source":"iana"},"application/vnd.osgeo.mapguide.package":{"source":"iana","extensions":["mgp"]},"application/vnd.osgi.bundle":{"source":"iana"},"application/vnd.osgi.dp":{"source":"iana","extensions":["dp"]},"application/vnd.osgi.subsystem":{"source":"iana","extensions":["esa"]},"application/vnd.otps.ct-kip+xml":{"source":"iana","compressible":true},"application/vnd.oxli.countgraph":{"source":"iana"},"application/vnd.pagerduty+json":{"source":"iana","compressible":true},"application/vnd.palm":{"source":"iana","extensions":["pdb","pqa","oprc"]},"application/vnd.panoply":{"source":"iana"},"application/vnd.paos.xml":{"source":"iana"},"application/vnd.patentdive":{"source":"iana"},"application/vnd.patientecommsdoc":{"source":"iana"},"application/vnd.pawaafile":{"source":"iana","extensions":["paw"]},"application/vnd.pcos":{"source":"iana"},"application/vnd.pg.format":{"source":"iana","extensions":["str"]},"application/vnd.pg.osasli":{"source":"iana","extensions":["ei6"]},"application/vnd.piaccess.application-licence":{"source":"iana"},"application/vnd.picsel":{"source":"iana","extensions":["efif"]},"application/vnd.pmi.widget":{"source":"iana","extensions":["wg"]},"application/vnd.poc.group-advertisement+xml":{"source":"iana","compressible":true},"application/vnd.pocketlearn":{"source":"iana","extensions":["plf"]},"application/vnd.powerbuilder6":{"source":"iana","extensions":["pbd"]},"application/vnd.powerbuilder6-s":{"source":"iana"},"application/vnd.powerbuilder7":{"source":"iana"},"application/vnd.powerbuilder7-s":{"source":"iana"},"application/vnd.powerbuilder75":{"source":"iana"},"application/vnd.powerbuilder75-s":{"source":"iana"},"application/vnd.preminet":{"source":"iana"},"application/vnd.previewsystems.box":{"source":"iana","extensions":["box"]},"application/vnd.proteus.magazine":{"source":"iana","extensions":["mgz"]},"application/vnd.psfs":{"source":"iana"},"application/vnd.publishare-delta-tree":{"source":"iana","extensions":["qps"]},"application/vnd.pvi.ptid1":{"source":"iana","extensions":["ptid"]},"application/vnd.pwg-multiplexed":{"source":"iana"},"application/vnd.pwg-xhtml-print+xml":{"source":"iana","compressible":true},"application/vnd.qualcomm.brew-app-res":{"source":"iana"},"application/vnd.quarantainenet":{"source":"iana"},"application/vnd.quark.quarkxpress":{"source":"iana","extensions":["qxd","qxt","qwd","qwt","qxl","qxb"]},"application/vnd.quobject-quoxdocument":{"source":"iana"},"application/vnd.radisys.moml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-conn+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-audit-stream+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-conf+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-base+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-detect+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-fax-sendrecv+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-group+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-speech+xml":{"source":"iana","compressible":true},"application/vnd.radisys.msml-dialog-transform+xml":{"source":"iana","compressible":true},"application/vnd.rainstor.data":{"source":"iana"},"application/vnd.rapid":{"source":"iana"},"application/vnd.rar":{"source":"iana","extensions":["rar"]},"application/vnd.realvnc.bed":{"source":"iana","extensions":["bed"]},"application/vnd.recordare.musicxml":{"source":"iana","extensions":["mxl"]},"application/vnd.recordare.musicxml+xml":{"source":"iana","compressible":true,"extensions":["musicxml"]},"application/vnd.renlearn.rlprint":{"source":"iana"},"application/vnd.resilient.logic":{"source":"iana"},"application/vnd.restful+json":{"source":"iana","compressible":true},"application/vnd.rig.cryptonote":{"source":"iana","extensions":["cryptonote"]},"application/vnd.rim.cod":{"source":"apache","extensions":["cod"]},"application/vnd.rn-realmedia":{"source":"apache","extensions":["rm"]},"application/vnd.rn-realmedia-vbr":{"source":"apache","extensions":["rmvb"]},"application/vnd.route66.link66+xml":{"source":"iana","compressible":true,"extensions":["link66"]},"application/vnd.rs-274x":{"source":"iana"},"application/vnd.ruckus.download":{"source":"iana"},"application/vnd.s3sms":{"source":"iana"},"application/vnd.sailingtracker.track":{"source":"iana","extensions":["st"]},"application/vnd.sar":{"source":"iana"},"application/vnd.sbm.cid":{"source":"iana"},"application/vnd.sbm.mid2":{"source":"iana"},"application/vnd.scribus":{"source":"iana"},"application/vnd.sealed.3df":{"source":"iana"},"application/vnd.sealed.csf":{"source":"iana"},"application/vnd.sealed.doc":{"source":"iana"},"application/vnd.sealed.eml":{"source":"iana"},"application/vnd.sealed.mht":{"source":"iana"},"application/vnd.sealed.net":{"source":"iana"},"application/vnd.sealed.ppt":{"source":"iana"},"application/vnd.sealed.tiff":{"source":"iana"},"application/vnd.sealed.xls":{"source":"iana"},"application/vnd.sealedmedia.softseal.html":{"source":"iana"},"application/vnd.sealedmedia.softseal.pdf":{"source":"iana"},"application/vnd.seemail":{"source":"iana","extensions":["see"]},"application/vnd.seis+json":{"source":"iana","compressible":true},"application/vnd.sema":{"source":"iana","extensions":["sema"]},"application/vnd.semd":{"source":"iana","extensions":["semd"]},"application/vnd.semf":{"source":"iana","extensions":["semf"]},"application/vnd.shade-save-file":{"source":"iana"},"application/vnd.shana.informed.formdata":{"source":"iana","extensions":["ifm"]},"application/vnd.shana.informed.formtemplate":{"source":"iana","extensions":["itp"]},"application/vnd.shana.informed.interchange":{"source":"iana","extensions":["iif"]},"application/vnd.shana.informed.package":{"source":"iana","extensions":["ipk"]},"application/vnd.shootproof+json":{"source":"iana","compressible":true},"application/vnd.shopkick+json":{"source":"iana","compressible":true},"application/vnd.shp":{"source":"iana"},"application/vnd.shx":{"source":"iana"},"application/vnd.sigrok.session":{"source":"iana"},"application/vnd.simtech-mindmapper":{"source":"iana","extensions":["twd","twds"]},"application/vnd.siren+json":{"source":"iana","compressible":true},"application/vnd.smaf":{"source":"iana","extensions":["mmf"]},"application/vnd.smart.notebook":{"source":"iana"},"application/vnd.smart.teacher":{"source":"iana","extensions":["teacher"]},"application/vnd.snesdev-page-table":{"source":"iana"},"application/vnd.software602.filler.form+xml":{"source":"iana","compressible":true,"extensions":["fo"]},"application/vnd.software602.filler.form-xml-zip":{"source":"iana"},"application/vnd.solent.sdkm+xml":{"source":"iana","compressible":true,"extensions":["sdkm","sdkd"]},"application/vnd.spotfire.dxp":{"source":"iana","extensions":["dxp"]},"application/vnd.spotfire.sfs":{"source":"iana","extensions":["sfs"]},"application/vnd.sqlite3":{"source":"iana"},"application/vnd.sss-cod":{"source":"iana"},"application/vnd.sss-dtf":{"source":"iana"},"application/vnd.sss-ntf":{"source":"iana"},"application/vnd.stardivision.calc":{"source":"apache","extensions":["sdc"]},"application/vnd.stardivision.draw":{"source":"apache","extensions":["sda"]},"application/vnd.stardivision.impress":{"source":"apache","extensions":["sdd"]},"application/vnd.stardivision.math":{"source":"apache","extensions":["smf"]},"application/vnd.stardivision.writer":{"source":"apache","extensions":["sdw","vor"]},"application/vnd.stardivision.writer-global":{"source":"apache","extensions":["sgl"]},"application/vnd.stepmania.package":{"source":"iana","extensions":["smzip"]},"application/vnd.stepmania.stepchart":{"source":"iana","extensions":["sm"]},"application/vnd.street-stream":{"source":"iana"},"application/vnd.sun.wadl+xml":{"source":"iana","compressible":true,"extensions":["wadl"]},"application/vnd.sun.xml.calc":{"source":"apache","extensions":["sxc"]},"application/vnd.sun.xml.calc.template":{"source":"apache","extensions":["stc"]},"application/vnd.sun.xml.draw":{"source":"apache","extensions":["sxd"]},"application/vnd.sun.xml.draw.template":{"source":"apache","extensions":["std"]},"application/vnd.sun.xml.impress":{"source":"apache","extensions":["sxi"]},"application/vnd.sun.xml.impress.template":{"source":"apache","extensions":["sti"]},"application/vnd.sun.xml.math":{"source":"apache","extensions":["sxm"]},"application/vnd.sun.xml.writer":{"source":"apache","extensions":["sxw"]},"application/vnd.sun.xml.writer.global":{"source":"apache","extensions":["sxg"]},"application/vnd.sun.xml.writer.template":{"source":"apache","extensions":["stw"]},"application/vnd.sus-calendar":{"source":"iana","extensions":["sus","susp"]},"application/vnd.svd":{"source":"iana","extensions":["svd"]},"application/vnd.swiftview-ics":{"source":"iana"},"application/vnd.sycle+xml":{"source":"iana","compressible":true},"application/vnd.syft+json":{"source":"iana","compressible":true},"application/vnd.symbian.install":{"source":"apache","extensions":["sis","sisx"]},"application/vnd.syncml+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xsm"]},"application/vnd.syncml.dm+wbxml":{"source":"iana","charset":"UTF-8","extensions":["bdm"]},"application/vnd.syncml.dm+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["xdm"]},"application/vnd.syncml.dm.notification":{"source":"iana"},"application/vnd.syncml.dmddf+wbxml":{"source":"iana"},"application/vnd.syncml.dmddf+xml":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["ddf"]},"application/vnd.syncml.dmtnds+wbxml":{"source":"iana"},"application/vnd.syncml.dmtnds+xml":{"source":"iana","charset":"UTF-8","compressible":true},"application/vnd.syncml.ds.notification":{"source":"iana"},"application/vnd.tableschema+json":{"source":"iana","compressible":true},"application/vnd.tao.intent-module-archive":{"source":"iana","extensions":["tao"]},"application/vnd.tcpdump.pcap":{"source":"iana","extensions":["pcap","cap","dmp"]},"application/vnd.think-cell.ppttc+json":{"source":"iana","compressible":true},"application/vnd.tmd.mediaflex.api+xml":{"source":"iana","compressible":true},"application/vnd.tml":{"source":"iana"},"application/vnd.tmobile-livetv":{"source":"iana","extensions":["tmo"]},"application/vnd.tri.onesource":{"source":"iana"},"application/vnd.trid.tpt":{"source":"iana","extensions":["tpt"]},"application/vnd.triscape.mxs":{"source":"iana","extensions":["mxs"]},"application/vnd.trueapp":{"source":"iana","extensions":["tra"]},"application/vnd.truedoc":{"source":"iana"},"application/vnd.ubisoft.webplayer":{"source":"iana"},"application/vnd.ufdl":{"source":"iana","extensions":["ufd","ufdl"]},"application/vnd.uiq.theme":{"source":"iana","extensions":["utz"]},"application/vnd.umajin":{"source":"iana","extensions":["umj"]},"application/vnd.unity":{"source":"iana","extensions":["unityweb"]},"application/vnd.uoml+xml":{"source":"iana","compressible":true,"extensions":["uoml"]},"application/vnd.uplanet.alert":{"source":"iana"},"application/vnd.uplanet.alert-wbxml":{"source":"iana"},"application/vnd.uplanet.bearer-choice":{"source":"iana"},"application/vnd.uplanet.bearer-choice-wbxml":{"source":"iana"},"application/vnd.uplanet.cacheop":{"source":"iana"},"application/vnd.uplanet.cacheop-wbxml":{"source":"iana"},"application/vnd.uplanet.channel":{"source":"iana"},"application/vnd.uplanet.channel-wbxml":{"source":"iana"},"application/vnd.uplanet.list":{"source":"iana"},"application/vnd.uplanet.list-wbxml":{"source":"iana"},"application/vnd.uplanet.listcmd":{"source":"iana"},"application/vnd.uplanet.listcmd-wbxml":{"source":"iana"},"application/vnd.uplanet.signal":{"source":"iana"},"application/vnd.uri-map":{"source":"iana"},"application/vnd.valve.source.material":{"source":"iana"},"application/vnd.vcx":{"source":"iana","extensions":["vcx"]},"application/vnd.vd-study":{"source":"iana"},"application/vnd.vectorworks":{"source":"iana"},"application/vnd.vel+json":{"source":"iana","compressible":true},"application/vnd.verimatrix.vcas":{"source":"iana"},"application/vnd.veritone.aion+json":{"source":"iana","compressible":true},"application/vnd.veryant.thin":{"source":"iana"},"application/vnd.ves.encrypted":{"source":"iana"},"application/vnd.vidsoft.vidconference":{"source":"iana"},"application/vnd.visio":{"source":"iana","extensions":["vsd","vst","vss","vsw"]},"application/vnd.visionary":{"source":"iana","extensions":["vis"]},"application/vnd.vividence.scriptfile":{"source":"iana"},"application/vnd.vsf":{"source":"iana","extensions":["vsf"]},"application/vnd.wap.sic":{"source":"iana"},"application/vnd.wap.slc":{"source":"iana"},"application/vnd.wap.wbxml":{"source":"iana","charset":"UTF-8","extensions":["wbxml"]},"application/vnd.wap.wmlc":{"source":"iana","extensions":["wmlc"]},"application/vnd.wap.wmlscriptc":{"source":"iana","extensions":["wmlsc"]},"application/vnd.webturbo":{"source":"iana","extensions":["wtb"]},"application/vnd.wfa.dpp":{"source":"iana"},"application/vnd.wfa.p2p":{"source":"iana"},"application/vnd.wfa.wsc":{"source":"iana"},"application/vnd.windows.devicepairing":{"source":"iana"},"application/vnd.wmc":{"source":"iana"},"application/vnd.wmf.bootstrap":{"source":"iana"},"application/vnd.wolfram.mathematica":{"source":"iana"},"application/vnd.wolfram.mathematica.package":{"source":"iana"},"application/vnd.wolfram.player":{"source":"iana","extensions":["nbp"]},"application/vnd.wordperfect":{"source":"iana","extensions":["wpd"]},"application/vnd.wqd":{"source":"iana","extensions":["wqd"]},"application/vnd.wrq-hp3000-labelled":{"source":"iana"},"application/vnd.wt.stf":{"source":"iana","extensions":["stf"]},"application/vnd.wv.csp+wbxml":{"source":"iana"},"application/vnd.wv.csp+xml":{"source":"iana","compressible":true},"application/vnd.wv.ssp+xml":{"source":"iana","compressible":true},"application/vnd.xacml+json":{"source":"iana","compressible":true},"application/vnd.xara":{"source":"iana","extensions":["xar"]},"application/vnd.xfdl":{"source":"iana","extensions":["xfdl"]},"application/vnd.xfdl.webform":{"source":"iana"},"application/vnd.xmi+xml":{"source":"iana","compressible":true},"application/vnd.xmpie.cpkg":{"source":"iana"},"application/vnd.xmpie.dpkg":{"source":"iana"},"application/vnd.xmpie.plan":{"source":"iana"},"application/vnd.xmpie.ppkg":{"source":"iana"},"application/vnd.xmpie.xlim":{"source":"iana"},"application/vnd.yamaha.hv-dic":{"source":"iana","extensions":["hvd"]},"application/vnd.yamaha.hv-script":{"source":"iana","extensions":["hvs"]},"application/vnd.yamaha.hv-voice":{"source":"iana","extensions":["hvp"]},"application/vnd.yamaha.openscoreformat":{"source":"iana","extensions":["osf"]},"application/vnd.yamaha.openscoreformat.osfpvg+xml":{"source":"iana","compressible":true,"extensions":["osfpvg"]},"application/vnd.yamaha.remote-setup":{"source":"iana"},"application/vnd.yamaha.smaf-audio":{"source":"iana","extensions":["saf"]},"application/vnd.yamaha.smaf-phrase":{"source":"iana","extensions":["spf"]},"application/vnd.yamaha.through-ngn":{"source":"iana"},"application/vnd.yamaha.tunnel-udpencap":{"source":"iana"},"application/vnd.yaoweme":{"source":"iana"},"application/vnd.yellowriver-custom-menu":{"source":"iana","extensions":["cmp"]},"application/vnd.youtube.yt":{"source":"iana"},"application/vnd.zul":{"source":"iana","extensions":["zir","zirz"]},"application/vnd.zzazz.deck+xml":{"source":"iana","compressible":true,"extensions":["zaz"]},"application/voicexml+xml":{"source":"iana","compressible":true,"extensions":["vxml"]},"application/voucher-cms+json":{"source":"iana","compressible":true},"application/vq-rtcpxr":{"source":"iana"},"application/wasm":{"source":"iana","compressible":true,"extensions":["wasm"]},"application/watcherinfo+xml":{"source":"iana","compressible":true,"extensions":["wif"]},"application/webpush-options+json":{"source":"iana","compressible":true},"application/whoispp-query":{"source":"iana"},"application/whoispp-response":{"source":"iana"},"application/widget":{"source":"iana","extensions":["wgt"]},"application/winhlp":{"source":"apache","extensions":["hlp"]},"application/wita":{"source":"iana"},"application/wordperfect5.1":{"source":"iana"},"application/wsdl+xml":{"source":"iana","compressible":true,"extensions":["wsdl"]},"application/wspolicy+xml":{"source":"iana","compressible":true,"extensions":["wspolicy"]},"application/x-7z-compressed":{"source":"apache","compressible":false,"extensions":["7z"]},"application/x-abiword":{"source":"apache","extensions":["abw"]},"application/x-ace-compressed":{"source":"apache","extensions":["ace"]},"application/x-amf":{"source":"apache"},"application/x-apple-diskimage":{"source":"apache","extensions":["dmg"]},"application/x-arj":{"compressible":false,"extensions":["arj"]},"application/x-authorware-bin":{"source":"apache","extensions":["aab","x32","u32","vox"]},"application/x-authorware-map":{"source":"apache","extensions":["aam"]},"application/x-authorware-seg":{"source":"apache","extensions":["aas"]},"application/x-bcpio":{"source":"apache","extensions":["bcpio"]},"application/x-bdoc":{"compressible":false,"extensions":["bdoc"]},"application/x-bittorrent":{"source":"apache","extensions":["torrent"]},"application/x-blorb":{"source":"apache","extensions":["blb","blorb"]},"application/x-bzip":{"source":"apache","compressible":false,"extensions":["bz"]},"application/x-bzip2":{"source":"apache","compressible":false,"extensions":["bz2","boz"]},"application/x-cbr":{"source":"apache","extensions":["cbr","cba","cbt","cbz","cb7"]},"application/x-cdlink":{"source":"apache","extensions":["vcd"]},"application/x-cfs-compressed":{"source":"apache","extensions":["cfs"]},"application/x-chat":{"source":"apache","extensions":["chat"]},"application/x-chess-pgn":{"source":"apache","extensions":["pgn"]},"application/x-chrome-extension":{"extensions":["crx"]},"application/x-cocoa":{"source":"nginx","extensions":["cco"]},"application/x-compress":{"source":"apache"},"application/x-conference":{"source":"apache","extensions":["nsc"]},"application/x-cpio":{"source":"apache","extensions":["cpio"]},"application/x-csh":{"source":"apache","extensions":["csh"]},"application/x-deb":{"compressible":false},"application/x-debian-package":{"source":"apache","extensions":["deb","udeb"]},"application/x-dgc-compressed":{"source":"apache","extensions":["dgc"]},"application/x-director":{"source":"apache","extensions":["dir","dcr","dxr","cst","cct","cxt","w3d","fgd","swa"]},"application/x-doom":{"source":"apache","extensions":["wad"]},"application/x-dtbncx+xml":{"source":"apache","compressible":true,"extensions":["ncx"]},"application/x-dtbook+xml":{"source":"apache","compressible":true,"extensions":["dtb"]},"application/x-dtbresource+xml":{"source":"apache","compressible":true,"extensions":["res"]},"application/x-dvi":{"source":"apache","compressible":false,"extensions":["dvi"]},"application/x-envoy":{"source":"apache","extensions":["evy"]},"application/x-eva":{"source":"apache","extensions":["eva"]},"application/x-font-bdf":{"source":"apache","extensions":["bdf"]},"application/x-font-dos":{"source":"apache"},"application/x-font-framemaker":{"source":"apache"},"application/x-font-ghostscript":{"source":"apache","extensions":["gsf"]},"application/x-font-libgrx":{"source":"apache"},"application/x-font-linux-psf":{"source":"apache","extensions":["psf"]},"application/x-font-pcf":{"source":"apache","extensions":["pcf"]},"application/x-font-snf":{"source":"apache","extensions":["snf"]},"application/x-font-speedo":{"source":"apache"},"application/x-font-sunos-news":{"source":"apache"},"application/x-font-type1":{"source":"apache","extensions":["pfa","pfb","pfm","afm"]},"application/x-font-vfont":{"source":"apache"},"application/x-freearc":{"source":"apache","extensions":["arc"]},"application/x-futuresplash":{"source":"apache","extensions":["spl"]},"application/x-gca-compressed":{"source":"apache","extensions":["gca"]},"application/x-glulx":{"source":"apache","extensions":["ulx"]},"application/x-gnumeric":{"source":"apache","extensions":["gnumeric"]},"application/x-gramps-xml":{"source":"apache","extensions":["gramps"]},"application/x-gtar":{"source":"apache","extensions":["gtar"]},"application/x-gzip":{"source":"apache"},"application/x-hdf":{"source":"apache","extensions":["hdf"]},"application/x-httpd-php":{"compressible":true,"extensions":["php"]},"application/x-install-instructions":{"source":"apache","extensions":["install"]},"application/x-iso9660-image":{"source":"apache","extensions":["iso"]},"application/x-iwork-keynote-sffkey":{"extensions":["key"]},"application/x-iwork-numbers-sffnumbers":{"extensions":["numbers"]},"application/x-iwork-pages-sffpages":{"extensions":["pages"]},"application/x-java-archive-diff":{"source":"nginx","extensions":["jardiff"]},"application/x-java-jnlp-file":{"source":"apache","compressible":false,"extensions":["jnlp"]},"application/x-javascript":{"compressible":true},"application/x-keepass2":{"extensions":["kdbx"]},"application/x-latex":{"source":"apache","compressible":false,"extensions":["latex"]},"application/x-lua-bytecode":{"extensions":["luac"]},"application/x-lzh-compressed":{"source":"apache","extensions":["lzh","lha"]},"application/x-makeself":{"source":"nginx","extensions":["run"]},"application/x-mie":{"source":"apache","extensions":["mie"]},"application/x-mobipocket-ebook":{"source":"apache","extensions":["prc","mobi"]},"application/x-mpegurl":{"compressible":false},"application/x-ms-application":{"source":"apache","extensions":["application"]},"application/x-ms-shortcut":{"source":"apache","extensions":["lnk"]},"application/x-ms-wmd":{"source":"apache","extensions":["wmd"]},"application/x-ms-wmz":{"source":"apache","extensions":["wmz"]},"application/x-ms-xbap":{"source":"apache","extensions":["xbap"]},"application/x-msaccess":{"source":"apache","extensions":["mdb"]},"application/x-msbinder":{"source":"apache","extensions":["obd"]},"application/x-mscardfile":{"source":"apache","extensions":["crd"]},"application/x-msclip":{"source":"apache","extensions":["clp"]},"application/x-msdos-program":{"extensions":["exe"]},"application/x-msdownload":{"source":"apache","extensions":["exe","dll","com","bat","msi"]},"application/x-msmediaview":{"source":"apache","extensions":["mvb","m13","m14"]},"application/x-msmetafile":{"source":"apache","extensions":["wmf","wmz","emf","emz"]},"application/x-msmoney":{"source":"apache","extensions":["mny"]},"application/x-mspublisher":{"source":"apache","extensions":["pub"]},"application/x-msschedule":{"source":"apache","extensions":["scd"]},"application/x-msterminal":{"source":"apache","extensions":["trm"]},"application/x-mswrite":{"source":"apache","extensions":["wri"]},"application/x-netcdf":{"source":"apache","extensions":["nc","cdf"]},"application/x-ns-proxy-autoconfig":{"compressible":true,"extensions":["pac"]},"application/x-nzb":{"source":"apache","extensions":["nzb"]},"application/x-perl":{"source":"nginx","extensions":["pl","pm"]},"application/x-pilot":{"source":"nginx","extensions":["prc","pdb"]},"application/x-pkcs12":{"source":"apache","compressible":false,"extensions":["p12","pfx"]},"application/x-pkcs7-certificates":{"source":"apache","extensions":["p7b","spc"]},"application/x-pkcs7-certreqresp":{"source":"apache","extensions":["p7r"]},"application/x-pki-message":{"source":"iana"},"application/x-rar-compressed":{"source":"apache","compressible":false,"extensions":["rar"]},"application/x-redhat-package-manager":{"source":"nginx","extensions":["rpm"]},"application/x-research-info-systems":{"source":"apache","extensions":["ris"]},"application/x-sea":{"source":"nginx","extensions":["sea"]},"application/x-sh":{"source":"apache","compressible":true,"extensions":["sh"]},"application/x-shar":{"source":"apache","extensions":["shar"]},"application/x-shockwave-flash":{"source":"apache","compressible":false,"extensions":["swf"]},"application/x-silverlight-app":{"source":"apache","extensions":["xap"]},"application/x-sql":{"source":"apache","extensions":["sql"]},"application/x-stuffit":{"source":"apache","compressible":false,"extensions":["sit"]},"application/x-stuffitx":{"source":"apache","extensions":["sitx"]},"application/x-subrip":{"source":"apache","extensions":["srt"]},"application/x-sv4cpio":{"source":"apache","extensions":["sv4cpio"]},"application/x-sv4crc":{"source":"apache","extensions":["sv4crc"]},"application/x-t3vm-image":{"source":"apache","extensions":["t3"]},"application/x-tads":{"source":"apache","extensions":["gam"]},"application/x-tar":{"source":"apache","compressible":true,"extensions":["tar"]},"application/x-tcl":{"source":"apache","extensions":["tcl","tk"]},"application/x-tex":{"source":"apache","extensions":["tex"]},"application/x-tex-tfm":{"source":"apache","extensions":["tfm"]},"application/x-texinfo":{"source":"apache","extensions":["texinfo","texi"]},"application/x-tgif":{"source":"apache","extensions":["obj"]},"application/x-ustar":{"source":"apache","extensions":["ustar"]},"application/x-virtualbox-hdd":{"compressible":true,"extensions":["hdd"]},"application/x-virtualbox-ova":{"compressible":true,"extensions":["ova"]},"application/x-virtualbox-ovf":{"compressible":true,"extensions":["ovf"]},"application/x-virtualbox-vbox":{"compressible":true,"extensions":["vbox"]},"application/x-virtualbox-vbox-extpack":{"compressible":false,"extensions":["vbox-extpack"]},"application/x-virtualbox-vdi":{"compressible":true,"extensions":["vdi"]},"application/x-virtualbox-vhd":{"compressible":true,"extensions":["vhd"]},"application/x-virtualbox-vmdk":{"compressible":true,"extensions":["vmdk"]},"application/x-wais-source":{"source":"apache","extensions":["src"]},"application/x-web-app-manifest+json":{"compressible":true,"extensions":["webapp"]},"application/x-www-form-urlencoded":{"source":"iana","compressible":true},"application/x-x509-ca-cert":{"source":"iana","extensions":["der","crt","pem"]},"application/x-x509-ca-ra-cert":{"source":"iana"},"application/x-x509-next-ca-cert":{"source":"iana"},"application/x-xfig":{"source":"apache","extensions":["fig"]},"application/x-xliff+xml":{"source":"apache","compressible":true,"extensions":["xlf"]},"application/x-xpinstall":{"source":"apache","compressible":false,"extensions":["xpi"]},"application/x-xz":{"source":"apache","extensions":["xz"]},"application/x-zmachine":{"source":"apache","extensions":["z1","z2","z3","z4","z5","z6","z7","z8"]},"application/x400-bp":{"source":"iana"},"application/xacml+xml":{"source":"iana","compressible":true},"application/xaml+xml":{"source":"apache","compressible":true,"extensions":["xaml"]},"application/xcap-att+xml":{"source":"iana","compressible":true,"extensions":["xav"]},"application/xcap-caps+xml":{"source":"iana","compressible":true,"extensions":["xca"]},"application/xcap-diff+xml":{"source":"iana","compressible":true,"extensions":["xdf"]},"application/xcap-el+xml":{"source":"iana","compressible":true,"extensions":["xel"]},"application/xcap-error+xml":{"source":"iana","compressible":true},"application/xcap-ns+xml":{"source":"iana","compressible":true,"extensions":["xns"]},"application/xcon-conference-info+xml":{"source":"iana","compressible":true},"application/xcon-conference-info-diff+xml":{"source":"iana","compressible":true},"application/xenc+xml":{"source":"iana","compressible":true,"extensions":["xenc"]},"application/xhtml+xml":{"source":"iana","compressible":true,"extensions":["xhtml","xht"]},"application/xhtml-voice+xml":{"source":"apache","compressible":true},"application/xliff+xml":{"source":"iana","compressible":true,"extensions":["xlf"]},"application/xml":{"source":"iana","compressible":true,"extensions":["xml","xsl","xsd","rng"]},"application/xml-dtd":{"source":"iana","compressible":true,"extensions":["dtd"]},"application/xml-external-parsed-entity":{"source":"iana"},"application/xml-patch+xml":{"source":"iana","compressible":true},"application/xmpp+xml":{"source":"iana","compressible":true},"application/xop+xml":{"source":"iana","compressible":true,"extensions":["xop"]},"application/xproc+xml":{"source":"apache","compressible":true,"extensions":["xpl"]},"application/xslt+xml":{"source":"iana","compressible":true,"extensions":["xsl","xslt"]},"application/xspf+xml":{"source":"apache","compressible":true,"extensions":["xspf"]},"application/xv+xml":{"source":"iana","compressible":true,"extensions":["mxml","xhvml","xvml","xvm"]},"application/yang":{"source":"iana","extensions":["yang"]},"application/yang-data+json":{"source":"iana","compressible":true},"application/yang-data+xml":{"source":"iana","compressible":true},"application/yang-patch+json":{"source":"iana","compressible":true},"application/yang-patch+xml":{"source":"iana","compressible":true},"application/yin+xml":{"source":"iana","compressible":true,"extensions":["yin"]},"application/zip":{"source":"iana","compressible":false,"extensions":["zip"]},"application/zlib":{"source":"iana"},"application/zstd":{"source":"iana"},"audio/1d-interleaved-parityfec":{"source":"iana"},"audio/32kadpcm":{"source":"iana"},"audio/3gpp":{"source":"iana","compressible":false,"extensions":["3gpp"]},"audio/3gpp2":{"source":"iana"},"audio/aac":{"source":"iana"},"audio/ac3":{"source":"iana"},"audio/adpcm":{"source":"apache","extensions":["adp"]},"audio/amr":{"source":"iana","extensions":["amr"]},"audio/amr-wb":{"source":"iana"},"audio/amr-wb+":{"source":"iana"},"audio/aptx":{"source":"iana"},"audio/asc":{"source":"iana"},"audio/atrac-advanced-lossless":{"source":"iana"},"audio/atrac-x":{"source":"iana"},"audio/atrac3":{"source":"iana"},"audio/basic":{"source":"iana","compressible":false,"extensions":["au","snd"]},"audio/bv16":{"source":"iana"},"audio/bv32":{"source":"iana"},"audio/clearmode":{"source":"iana"},"audio/cn":{"source":"iana"},"audio/dat12":{"source":"iana"},"audio/dls":{"source":"iana"},"audio/dsr-es201108":{"source":"iana"},"audio/dsr-es202050":{"source":"iana"},"audio/dsr-es202211":{"source":"iana"},"audio/dsr-es202212":{"source":"iana"},"audio/dv":{"source":"iana"},"audio/dvi4":{"source":"iana"},"audio/eac3":{"source":"iana"},"audio/encaprtp":{"source":"iana"},"audio/evrc":{"source":"iana"},"audio/evrc-qcp":{"source":"iana"},"audio/evrc0":{"source":"iana"},"audio/evrc1":{"source":"iana"},"audio/evrcb":{"source":"iana"},"audio/evrcb0":{"source":"iana"},"audio/evrcb1":{"source":"iana"},"audio/evrcnw":{"source":"iana"},"audio/evrcnw0":{"source":"iana"},"audio/evrcnw1":{"source":"iana"},"audio/evrcwb":{"source":"iana"},"audio/evrcwb0":{"source":"iana"},"audio/evrcwb1":{"source":"iana"},"audio/evs":{"source":"iana"},"audio/flexfec":{"source":"iana"},"audio/fwdred":{"source":"iana"},"audio/g711-0":{"source":"iana"},"audio/g719":{"source":"iana"},"audio/g722":{"source":"iana"},"audio/g7221":{"source":"iana"},"audio/g723":{"source":"iana"},"audio/g726-16":{"source":"iana"},"audio/g726-24":{"source":"iana"},"audio/g726-32":{"source":"iana"},"audio/g726-40":{"source":"iana"},"audio/g728":{"source":"iana"},"audio/g729":{"source":"iana"},"audio/g7291":{"source":"iana"},"audio/g729d":{"source":"iana"},"audio/g729e":{"source":"iana"},"audio/gsm":{"source":"iana"},"audio/gsm-efr":{"source":"iana"},"audio/gsm-hr-08":{"source":"iana"},"audio/ilbc":{"source":"iana"},"audio/ip-mr_v2.5":{"source":"iana"},"audio/isac":{"source":"apache"},"audio/l16":{"source":"iana"},"audio/l20":{"source":"iana"},"audio/l24":{"source":"iana","compressible":false},"audio/l8":{"source":"iana"},"audio/lpc":{"source":"iana"},"audio/melp":{"source":"iana"},"audio/melp1200":{"source":"iana"},"audio/melp2400":{"source":"iana"},"audio/melp600":{"source":"iana"},"audio/mhas":{"source":"iana"},"audio/midi":{"source":"apache","extensions":["mid","midi","kar","rmi"]},"audio/mobile-xmf":{"source":"iana","extensions":["mxmf"]},"audio/mp3":{"compressible":false,"extensions":["mp3"]},"audio/mp4":{"source":"iana","compressible":false,"extensions":["m4a","mp4a"]},"audio/mp4a-latm":{"source":"iana"},"audio/mpa":{"source":"iana"},"audio/mpa-robust":{"source":"iana"},"audio/mpeg":{"source":"iana","compressible":false,"extensions":["mpga","mp2","mp2a","mp3","m2a","m3a"]},"audio/mpeg4-generic":{"source":"iana"},"audio/musepack":{"source":"apache"},"audio/ogg":{"source":"iana","compressible":false,"extensions":["oga","ogg","spx","opus"]},"audio/opus":{"source":"iana"},"audio/parityfec":{"source":"iana"},"audio/pcma":{"source":"iana"},"audio/pcma-wb":{"source":"iana"},"audio/pcmu":{"source":"iana"},"audio/pcmu-wb":{"source":"iana"},"audio/prs.sid":{"source":"iana"},"audio/qcelp":{"source":"iana"},"audio/raptorfec":{"source":"iana"},"audio/red":{"source":"iana"},"audio/rtp-enc-aescm128":{"source":"iana"},"audio/rtp-midi":{"source":"iana"},"audio/rtploopback":{"source":"iana"},"audio/rtx":{"source":"iana"},"audio/s3m":{"source":"apache","extensions":["s3m"]},"audio/scip":{"source":"iana"},"audio/silk":{"source":"apache","extensions":["sil"]},"audio/smv":{"source":"iana"},"audio/smv-qcp":{"source":"iana"},"audio/smv0":{"source":"iana"},"audio/sofa":{"source":"iana"},"audio/sp-midi":{"source":"iana"},"audio/speex":{"source":"iana"},"audio/t140c":{"source":"iana"},"audio/t38":{"source":"iana"},"audio/telephone-event":{"source":"iana"},"audio/tetra_acelp":{"source":"iana"},"audio/tetra_acelp_bb":{"source":"iana"},"audio/tone":{"source":"iana"},"audio/tsvcis":{"source":"iana"},"audio/uemclip":{"source":"iana"},"audio/ulpfec":{"source":"iana"},"audio/usac":{"source":"iana"},"audio/vdvi":{"source":"iana"},"audio/vmr-wb":{"source":"iana"},"audio/vnd.3gpp.iufp":{"source":"iana"},"audio/vnd.4sb":{"source":"iana"},"audio/vnd.audiokoz":{"source":"iana"},"audio/vnd.celp":{"source":"iana"},"audio/vnd.cisco.nse":{"source":"iana"},"audio/vnd.cmles.radio-events":{"source":"iana"},"audio/vnd.cns.anp1":{"source":"iana"},"audio/vnd.cns.inf1":{"source":"iana"},"audio/vnd.dece.audio":{"source":"iana","extensions":["uva","uvva"]},"audio/vnd.digital-winds":{"source":"iana","extensions":["eol"]},"audio/vnd.dlna.adts":{"source":"iana"},"audio/vnd.dolby.heaac.1":{"source":"iana"},"audio/vnd.dolby.heaac.2":{"source":"iana"},"audio/vnd.dolby.mlp":{"source":"iana"},"audio/vnd.dolby.mps":{"source":"iana"},"audio/vnd.dolby.pl2":{"source":"iana"},"audio/vnd.dolby.pl2x":{"source":"iana"},"audio/vnd.dolby.pl2z":{"source":"iana"},"audio/vnd.dolby.pulse.1":{"source":"iana"},"audio/vnd.dra":{"source":"iana","extensions":["dra"]},"audio/vnd.dts":{"source":"iana","extensions":["dts"]},"audio/vnd.dts.hd":{"source":"iana","extensions":["dtshd"]},"audio/vnd.dts.uhd":{"source":"iana"},"audio/vnd.dvb.file":{"source":"iana"},"audio/vnd.everad.plj":{"source":"iana"},"audio/vnd.hns.audio":{"source":"iana"},"audio/vnd.lucent.voice":{"source":"iana","extensions":["lvp"]},"audio/vnd.ms-playready.media.pya":{"source":"iana","extensions":["pya"]},"audio/vnd.nokia.mobile-xmf":{"source":"iana"},"audio/vnd.nortel.vbk":{"source":"iana"},"audio/vnd.nuera.ecelp4800":{"source":"iana","extensions":["ecelp4800"]},"audio/vnd.nuera.ecelp7470":{"source":"iana","extensions":["ecelp7470"]},"audio/vnd.nuera.ecelp9600":{"source":"iana","extensions":["ecelp9600"]},"audio/vnd.octel.sbc":{"source":"iana"},"audio/vnd.presonus.multitrack":{"source":"iana"},"audio/vnd.qcelp":{"source":"iana"},"audio/vnd.rhetorex.32kadpcm":{"source":"iana"},"audio/vnd.rip":{"source":"iana","extensions":["rip"]},"audio/vnd.rn-realaudio":{"compressible":false},"audio/vnd.sealedmedia.softseal.mpeg":{"source":"iana"},"audio/vnd.vmx.cvsd":{"source":"iana"},"audio/vnd.wave":{"compressible":false},"audio/vorbis":{"source":"iana","compressible":false},"audio/vorbis-config":{"source":"iana"},"audio/wav":{"compressible":false,"extensions":["wav"]},"audio/wave":{"compressible":false,"extensions":["wav"]},"audio/webm":{"source":"apache","compressible":false,"extensions":["weba"]},"audio/x-aac":{"source":"apache","compressible":false,"extensions":["aac"]},"audio/x-aiff":{"source":"apache","extensions":["aif","aiff","aifc"]},"audio/x-caf":{"source":"apache","compressible":false,"extensions":["caf"]},"audio/x-flac":{"source":"apache","extensions":["flac"]},"audio/x-m4a":{"source":"nginx","extensions":["m4a"]},"audio/x-matroska":{"source":"apache","extensions":["mka"]},"audio/x-mpegurl":{"source":"apache","extensions":["m3u"]},"audio/x-ms-wax":{"source":"apache","extensions":["wax"]},"audio/x-ms-wma":{"source":"apache","extensions":["wma"]},"audio/x-pn-realaudio":{"source":"apache","extensions":["ram","ra"]},"audio/x-pn-realaudio-plugin":{"source":"apache","extensions":["rmp"]},"audio/x-realaudio":{"source":"nginx","extensions":["ra"]},"audio/x-tta":{"source":"apache"},"audio/x-wav":{"source":"apache","extensions":["wav"]},"audio/xm":{"source":"apache","extensions":["xm"]},"chemical/x-cdx":{"source":"apache","extensions":["cdx"]},"chemical/x-cif":{"source":"apache","extensions":["cif"]},"chemical/x-cmdf":{"source":"apache","extensions":["cmdf"]},"chemical/x-cml":{"source":"apache","extensions":["cml"]},"chemical/x-csml":{"source":"apache","extensions":["csml"]},"chemical/x-pdb":{"source":"apache"},"chemical/x-xyz":{"source":"apache","extensions":["xyz"]},"font/collection":{"source":"iana","extensions":["ttc"]},"font/otf":{"source":"iana","compressible":true,"extensions":["otf"]},"font/sfnt":{"source":"iana"},"font/ttf":{"source":"iana","compressible":true,"extensions":["ttf"]},"font/woff":{"source":"iana","extensions":["woff"]},"font/woff2":{"source":"iana","extensions":["woff2"]},"image/aces":{"source":"iana","extensions":["exr"]},"image/apng":{"compressible":false,"extensions":["apng"]},"image/avci":{"source":"iana","extensions":["avci"]},"image/avcs":{"source":"iana","extensions":["avcs"]},"image/avif":{"source":"iana","compressible":false,"extensions":["avif"]},"image/bmp":{"source":"iana","compressible":true,"extensions":["bmp"]},"image/cgm":{"source":"iana","extensions":["cgm"]},"image/dicom-rle":{"source":"iana","extensions":["drle"]},"image/emf":{"source":"iana","extensions":["emf"]},"image/fits":{"source":"iana","extensions":["fits"]},"image/g3fax":{"source":"iana","extensions":["g3"]},"image/gif":{"source":"iana","compressible":false,"extensions":["gif"]},"image/heic":{"source":"iana","extensions":["heic"]},"image/heic-sequence":{"source":"iana","extensions":["heics"]},"image/heif":{"source":"iana","extensions":["heif"]},"image/heif-sequence":{"source":"iana","extensions":["heifs"]},"image/hej2k":{"source":"iana","extensions":["hej2"]},"image/hsj2":{"source":"iana","extensions":["hsj2"]},"image/ief":{"source":"iana","extensions":["ief"]},"image/jls":{"source":"iana","extensions":["jls"]},"image/jp2":{"source":"iana","compressible":false,"extensions":["jp2","jpg2"]},"image/jpeg":{"source":"iana","compressible":false,"extensions":["jpeg","jpg","jpe"]},"image/jph":{"source":"iana","extensions":["jph"]},"image/jphc":{"source":"iana","extensions":["jhc"]},"image/jpm":{"source":"iana","compressible":false,"extensions":["jpm"]},"image/jpx":{"source":"iana","compressible":false,"extensions":["jpx","jpf"]},"image/jxr":{"source":"iana","extensions":["jxr"]},"image/jxra":{"source":"iana","extensions":["jxra"]},"image/jxrs":{"source":"iana","extensions":["jxrs"]},"image/jxs":{"source":"iana","extensions":["jxs"]},"image/jxsc":{"source":"iana","extensions":["jxsc"]},"image/jxsi":{"source":"iana","extensions":["jxsi"]},"image/jxss":{"source":"iana","extensions":["jxss"]},"image/ktx":{"source":"iana","extensions":["ktx"]},"image/ktx2":{"source":"iana","extensions":["ktx2"]},"image/naplps":{"source":"iana"},"image/pjpeg":{"compressible":false},"image/png":{"source":"iana","compressible":false,"extensions":["png"]},"image/prs.btif":{"source":"iana","extensions":["btif"]},"image/prs.pti":{"source":"iana","extensions":["pti"]},"image/pwg-raster":{"source":"iana"},"image/sgi":{"source":"apache","extensions":["sgi"]},"image/svg+xml":{"source":"iana","compressible":true,"extensions":["svg","svgz"]},"image/t38":{"source":"iana","extensions":["t38"]},"image/tiff":{"source":"iana","compressible":false,"extensions":["tif","tiff"]},"image/tiff-fx":{"source":"iana","extensions":["tfx"]},"image/vnd.adobe.photoshop":{"source":"iana","compressible":true,"extensions":["psd"]},"image/vnd.airzip.accelerator.azv":{"source":"iana","extensions":["azv"]},"image/vnd.cns.inf2":{"source":"iana"},"image/vnd.dece.graphic":{"source":"iana","extensions":["uvi","uvvi","uvg","uvvg"]},"image/vnd.djvu":{"source":"iana","extensions":["djvu","djv"]},"image/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"image/vnd.dwg":{"source":"iana","extensions":["dwg"]},"image/vnd.dxf":{"source":"iana","extensions":["dxf"]},"image/vnd.fastbidsheet":{"source":"iana","extensions":["fbs"]},"image/vnd.fpx":{"source":"iana","extensions":["fpx"]},"image/vnd.fst":{"source":"iana","extensions":["fst"]},"image/vnd.fujixerox.edmics-mmr":{"source":"iana","extensions":["mmr"]},"image/vnd.fujixerox.edmics-rlc":{"source":"iana","extensions":["rlc"]},"image/vnd.globalgraphics.pgb":{"source":"iana"},"image/vnd.microsoft.icon":{"source":"iana","compressible":true,"extensions":["ico"]},"image/vnd.mix":{"source":"iana"},"image/vnd.mozilla.apng":{"source":"iana"},"image/vnd.ms-dds":{"compressible":true,"extensions":["dds"]},"image/vnd.ms-modi":{"source":"iana","extensions":["mdi"]},"image/vnd.ms-photo":{"source":"apache","extensions":["wdp"]},"image/vnd.net-fpx":{"source":"iana","extensions":["npx"]},"image/vnd.pco.b16":{"source":"iana","extensions":["b16"]},"image/vnd.radiance":{"source":"iana"},"image/vnd.sealed.png":{"source":"iana"},"image/vnd.sealedmedia.softseal.gif":{"source":"iana"},"image/vnd.sealedmedia.softseal.jpg":{"source":"iana"},"image/vnd.svf":{"source":"iana"},"image/vnd.tencent.tap":{"source":"iana","extensions":["tap"]},"image/vnd.valve.source.texture":{"source":"iana","extensions":["vtf"]},"image/vnd.wap.wbmp":{"source":"iana","extensions":["wbmp"]},"image/vnd.xiff":{"source":"iana","extensions":["xif"]},"image/vnd.zbrush.pcx":{"source":"iana","extensions":["pcx"]},"image/webp":{"source":"apache","extensions":["webp"]},"image/wmf":{"source":"iana","extensions":["wmf"]},"image/x-3ds":{"source":"apache","extensions":["3ds"]},"image/x-cmu-raster":{"source":"apache","extensions":["ras"]},"image/x-cmx":{"source":"apache","extensions":["cmx"]},"image/x-freehand":{"source":"apache","extensions":["fh","fhc","fh4","fh5","fh7"]},"image/x-icon":{"source":"apache","compressible":true,"extensions":["ico"]},"image/x-jng":{"source":"nginx","extensions":["jng"]},"image/x-mrsid-image":{"source":"apache","extensions":["sid"]},"image/x-ms-bmp":{"source":"nginx","compressible":true,"extensions":["bmp"]},"image/x-pcx":{"source":"apache","extensions":["pcx"]},"image/x-pict":{"source":"apache","extensions":["pic","pct"]},"image/x-portable-anymap":{"source":"apache","extensions":["pnm"]},"image/x-portable-bitmap":{"source":"apache","extensions":["pbm"]},"image/x-portable-graymap":{"source":"apache","extensions":["pgm"]},"image/x-portable-pixmap":{"source":"apache","extensions":["ppm"]},"image/x-rgb":{"source":"apache","extensions":["rgb"]},"image/x-tga":{"source":"apache","extensions":["tga"]},"image/x-xbitmap":{"source":"apache","extensions":["xbm"]},"image/x-xcf":{"compressible":false},"image/x-xpixmap":{"source":"apache","extensions":["xpm"]},"image/x-xwindowdump":{"source":"apache","extensions":["xwd"]},"message/cpim":{"source":"iana"},"message/delivery-status":{"source":"iana"},"message/disposition-notification":{"source":"iana","extensions":["disposition-notification"]},"message/external-body":{"source":"iana"},"message/feedback-report":{"source":"iana"},"message/global":{"source":"iana","extensions":["u8msg"]},"message/global-delivery-status":{"source":"iana","extensions":["u8dsn"]},"message/global-disposition-notification":{"source":"iana","extensions":["u8mdn"]},"message/global-headers":{"source":"iana","extensions":["u8hdr"]},"message/http":{"source":"iana","compressible":false},"message/imdn+xml":{"source":"iana","compressible":true},"message/news":{"source":"iana"},"message/partial":{"source":"iana","compressible":false},"message/rfc822":{"source":"iana","compressible":true,"extensions":["eml","mime"]},"message/s-http":{"source":"iana"},"message/sip":{"source":"iana"},"message/sipfrag":{"source":"iana"},"message/tracking-status":{"source":"iana"},"message/vnd.si.simp":{"source":"iana"},"message/vnd.wfa.wsc":{"source":"iana","extensions":["wsc"]},"model/3mf":{"source":"iana","extensions":["3mf"]},"model/e57":{"source":"iana"},"model/gltf+json":{"source":"iana","compressible":true,"extensions":["gltf"]},"model/gltf-binary":{"source":"iana","compressible":true,"extensions":["glb"]},"model/iges":{"source":"iana","compressible":false,"extensions":["igs","iges"]},"model/mesh":{"source":"iana","compressible":false,"extensions":["msh","mesh","silo"]},"model/mtl":{"source":"iana","extensions":["mtl"]},"model/obj":{"source":"iana","extensions":["obj"]},"model/step":{"source":"iana"},"model/step+xml":{"source":"iana","compressible":true,"extensions":["stpx"]},"model/step+zip":{"source":"iana","compressible":false,"extensions":["stpz"]},"model/step-xml+zip":{"source":"iana","compressible":false,"extensions":["stpxz"]},"model/stl":{"source":"iana","extensions":["stl"]},"model/vnd.collada+xml":{"source":"iana","compressible":true,"extensions":["dae"]},"model/vnd.dwf":{"source":"iana","extensions":["dwf"]},"model/vnd.flatland.3dml":{"source":"iana"},"model/vnd.gdl":{"source":"iana","extensions":["gdl"]},"model/vnd.gs-gdl":{"source":"apache"},"model/vnd.gs.gdl":{"source":"iana"},"model/vnd.gtw":{"source":"iana","extensions":["gtw"]},"model/vnd.moml+xml":{"source":"iana","compressible":true},"model/vnd.mts":{"source":"iana","extensions":["mts"]},"model/vnd.opengex":{"source":"iana","extensions":["ogex"]},"model/vnd.parasolid.transmit.binary":{"source":"iana","extensions":["x_b"]},"model/vnd.parasolid.transmit.text":{"source":"iana","extensions":["x_t"]},"model/vnd.pytha.pyox":{"source":"iana"},"model/vnd.rosette.annotated-data-model":{"source":"iana"},"model/vnd.sap.vds":{"source":"iana","extensions":["vds"]},"model/vnd.usdz+zip":{"source":"iana","compressible":false,"extensions":["usdz"]},"model/vnd.valve.source.compiled-map":{"source":"iana","extensions":["bsp"]},"model/vnd.vtu":{"source":"iana","extensions":["vtu"]},"model/vrml":{"source":"iana","compressible":false,"extensions":["wrl","vrml"]},"model/x3d+binary":{"source":"apache","compressible":false,"extensions":["x3db","x3dbz"]},"model/x3d+fastinfoset":{"source":"iana","extensions":["x3db"]},"model/x3d+vrml":{"source":"apache","compressible":false,"extensions":["x3dv","x3dvz"]},"model/x3d+xml":{"source":"iana","compressible":true,"extensions":["x3d","x3dz"]},"model/x3d-vrml":{"source":"iana","extensions":["x3dv"]},"multipart/alternative":{"source":"iana","compressible":false},"multipart/appledouble":{"source":"iana"},"multipart/byteranges":{"source":"iana"},"multipart/digest":{"source":"iana"},"multipart/encrypted":{"source":"iana","compressible":false},"multipart/form-data":{"source":"iana","compressible":false},"multipart/header-set":{"source":"iana"},"multipart/mixed":{"source":"iana"},"multipart/multilingual":{"source":"iana"},"multipart/parallel":{"source":"iana"},"multipart/related":{"source":"iana","compressible":false},"multipart/report":{"source":"iana"},"multipart/signed":{"source":"iana","compressible":false},"multipart/vnd.bint.med-plus":{"source":"iana"},"multipart/voice-message":{"source":"iana"},"multipart/x-mixed-replace":{"source":"iana"},"text/1d-interleaved-parityfec":{"source":"iana"},"text/cache-manifest":{"source":"iana","compressible":true,"extensions":["appcache","manifest"]},"text/calendar":{"source":"iana","extensions":["ics","ifb"]},"text/calender":{"compressible":true},"text/cmd":{"compressible":true},"text/coffeescript":{"extensions":["coffee","litcoffee"]},"text/cql":{"source":"iana"},"text/cql-expression":{"source":"iana"},"text/cql-identifier":{"source":"iana"},"text/css":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["css"]},"text/csv":{"source":"iana","compressible":true,"extensions":["csv"]},"text/csv-schema":{"source":"iana"},"text/directory":{"source":"iana"},"text/dns":{"source":"iana"},"text/ecmascript":{"source":"iana"},"text/encaprtp":{"source":"iana"},"text/enriched":{"source":"iana"},"text/fhirpath":{"source":"iana"},"text/flexfec":{"source":"iana"},"text/fwdred":{"source":"iana"},"text/gff3":{"source":"iana"},"text/grammar-ref-list":{"source":"iana"},"text/html":{"source":"iana","compressible":true,"extensions":["html","htm","shtml"]},"text/jade":{"extensions":["jade"]},"text/javascript":{"source":"iana","compressible":true},"text/jcr-cnd":{"source":"iana"},"text/jsx":{"compressible":true,"extensions":["jsx"]},"text/less":{"compressible":true,"extensions":["less"]},"text/markdown":{"source":"iana","compressible":true,"extensions":["markdown","md"]},"text/mathml":{"source":"nginx","extensions":["mml"]},"text/mdx":{"compressible":true,"extensions":["mdx"]},"text/mizar":{"source":"iana"},"text/n3":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["n3"]},"text/parameters":{"source":"iana","charset":"UTF-8"},"text/parityfec":{"source":"iana"},"text/plain":{"source":"iana","compressible":true,"extensions":["txt","text","conf","def","list","log","in","ini"]},"text/provenance-notation":{"source":"iana","charset":"UTF-8"},"text/prs.fallenstein.rst":{"source":"iana"},"text/prs.lines.tag":{"source":"iana","extensions":["dsc"]},"text/prs.prop.logic":{"source":"iana"},"text/raptorfec":{"source":"iana"},"text/red":{"source":"iana"},"text/rfc822-headers":{"source":"iana"},"text/richtext":{"source":"iana","compressible":true,"extensions":["rtx"]},"text/rtf":{"source":"iana","compressible":true,"extensions":["rtf"]},"text/rtp-enc-aescm128":{"source":"iana"},"text/rtploopback":{"source":"iana"},"text/rtx":{"source":"iana"},"text/sgml":{"source":"iana","extensions":["sgml","sgm"]},"text/shaclc":{"source":"iana"},"text/shex":{"source":"iana","extensions":["shex"]},"text/slim":{"extensions":["slim","slm"]},"text/spdx":{"source":"iana","extensions":["spdx"]},"text/strings":{"source":"iana"},"text/stylus":{"extensions":["stylus","styl"]},"text/t140":{"source":"iana"},"text/tab-separated-values":{"source":"iana","compressible":true,"extensions":["tsv"]},"text/troff":{"source":"iana","extensions":["t","tr","roff","man","me","ms"]},"text/turtle":{"source":"iana","charset":"UTF-8","extensions":["ttl"]},"text/ulpfec":{"source":"iana"},"text/uri-list":{"source":"iana","compressible":true,"extensions":["uri","uris","urls"]},"text/vcard":{"source":"iana","compressible":true,"extensions":["vcard"]},"text/vnd.a":{"source":"iana"},"text/vnd.abc":{"source":"iana"},"text/vnd.ascii-art":{"source":"iana"},"text/vnd.curl":{"source":"iana","extensions":["curl"]},"text/vnd.curl.dcurl":{"source":"apache","extensions":["dcurl"]},"text/vnd.curl.mcurl":{"source":"apache","extensions":["mcurl"]},"text/vnd.curl.scurl":{"source":"apache","extensions":["scurl"]},"text/vnd.debian.copyright":{"source":"iana","charset":"UTF-8"},"text/vnd.dmclientscript":{"source":"iana"},"text/vnd.dvb.subtitle":{"source":"iana","extensions":["sub"]},"text/vnd.esmertec.theme-descriptor":{"source":"iana","charset":"UTF-8"},"text/vnd.familysearch.gedcom":{"source":"iana","extensions":["ged"]},"text/vnd.ficlab.flt":{"source":"iana"},"text/vnd.fly":{"source":"iana","extensions":["fly"]},"text/vnd.fmi.flexstor":{"source":"iana","extensions":["flx"]},"text/vnd.gml":{"source":"iana"},"text/vnd.graphviz":{"source":"iana","extensions":["gv"]},"text/vnd.hans":{"source":"iana"},"text/vnd.hgl":{"source":"iana"},"text/vnd.in3d.3dml":{"source":"iana","extensions":["3dml"]},"text/vnd.in3d.spot":{"source":"iana","extensions":["spot"]},"text/vnd.iptc.newsml":{"source":"iana"},"text/vnd.iptc.nitf":{"source":"iana"},"text/vnd.latex-z":{"source":"iana"},"text/vnd.motorola.reflex":{"source":"iana"},"text/vnd.ms-mediapackage":{"source":"iana"},"text/vnd.net2phone.commcenter.command":{"source":"iana"},"text/vnd.radisys.msml-basic-layout":{"source":"iana"},"text/vnd.senx.warpscript":{"source":"iana"},"text/vnd.si.uricatalogue":{"source":"iana"},"text/vnd.sosi":{"source":"iana"},"text/vnd.sun.j2me.app-descriptor":{"source":"iana","charset":"UTF-8","extensions":["jad"]},"text/vnd.trolltech.linguist":{"source":"iana","charset":"UTF-8"},"text/vnd.wap.si":{"source":"iana"},"text/vnd.wap.sl":{"source":"iana"},"text/vnd.wap.wml":{"source":"iana","extensions":["wml"]},"text/vnd.wap.wmlscript":{"source":"iana","extensions":["wmls"]},"text/vtt":{"source":"iana","charset":"UTF-8","compressible":true,"extensions":["vtt"]},"text/x-asm":{"source":"apache","extensions":["s","asm"]},"text/x-c":{"source":"apache","extensions":["c","cc","cxx","cpp","h","hh","dic"]},"text/x-component":{"source":"nginx","extensions":["htc"]},"text/x-fortran":{"source":"apache","extensions":["f","for","f77","f90"]},"text/x-gwt-rpc":{"compressible":true},"text/x-handlebars-template":{"extensions":["hbs"]},"text/x-java-source":{"source":"apache","extensions":["java"]},"text/x-jquery-tmpl":{"compressible":true},"text/x-lua":{"extensions":["lua"]},"text/x-markdown":{"compressible":true,"extensions":["mkd"]},"text/x-nfo":{"source":"apache","extensions":["nfo"]},"text/x-opml":{"source":"apache","extensions":["opml"]},"text/x-org":{"compressible":true,"extensions":["org"]},"text/x-pascal":{"source":"apache","extensions":["p","pas"]},"text/x-processing":{"compressible":true,"extensions":["pde"]},"text/x-sass":{"extensions":["sass"]},"text/x-scss":{"extensions":["scss"]},"text/x-setext":{"source":"apache","extensions":["etx"]},"text/x-sfv":{"source":"apache","extensions":["sfv"]},"text/x-suse-ymp":{"compressible":true,"extensions":["ymp"]},"text/x-uuencode":{"source":"apache","extensions":["uu"]},"text/x-vcalendar":{"source":"apache","extensions":["vcs"]},"text/x-vcard":{"source":"apache","extensions":["vcf"]},"text/xml":{"source":"iana","compressible":true,"extensions":["xml"]},"text/xml-external-parsed-entity":{"source":"iana"},"text/yaml":{"compressible":true,"extensions":["yaml","yml"]},"video/1d-interleaved-parityfec":{"source":"iana"},"video/3gpp":{"source":"iana","extensions":["3gp","3gpp"]},"video/3gpp-tt":{"source":"iana"},"video/3gpp2":{"source":"iana","extensions":["3g2"]},"video/av1":{"source":"iana"},"video/bmpeg":{"source":"iana"},"video/bt656":{"source":"iana"},"video/celb":{"source":"iana"},"video/dv":{"source":"iana"},"video/encaprtp":{"source":"iana"},"video/ffv1":{"source":"iana"},"video/flexfec":{"source":"iana"},"video/h261":{"source":"iana","extensions":["h261"]},"video/h263":{"source":"iana","extensions":["h263"]},"video/h263-1998":{"source":"iana"},"video/h263-2000":{"source":"iana"},"video/h264":{"source":"iana","extensions":["h264"]},"video/h264-rcdo":{"source":"iana"},"video/h264-svc":{"source":"iana"},"video/h265":{"source":"iana"},"video/iso.segment":{"source":"iana","extensions":["m4s"]},"video/jpeg":{"source":"iana","extensions":["jpgv"]},"video/jpeg2000":{"source":"iana"},"video/jpm":{"source":"apache","extensions":["jpm","jpgm"]},"video/jxsv":{"source":"iana"},"video/mj2":{"source":"iana","extensions":["mj2","mjp2"]},"video/mp1s":{"source":"iana"},"video/mp2p":{"source":"iana"},"video/mp2t":{"source":"iana","extensions":["ts"]},"video/mp4":{"source":"iana","compressible":false,"extensions":["mp4","mp4v","mpg4"]},"video/mp4v-es":{"source":"iana"},"video/mpeg":{"source":"iana","compressible":false,"extensions":["mpeg","mpg","mpe","m1v","m2v"]},"video/mpeg4-generic":{"source":"iana"},"video/mpv":{"source":"iana"},"video/nv":{"source":"iana"},"video/ogg":{"source":"iana","compressible":false,"extensions":["ogv"]},"video/parityfec":{"source":"iana"},"video/pointer":{"source":"iana"},"video/quicktime":{"source":"iana","compressible":false,"extensions":["qt","mov"]},"video/raptorfec":{"source":"iana"},"video/raw":{"source":"iana"},"video/rtp-enc-aescm128":{"source":"iana"},"video/rtploopback":{"source":"iana"},"video/rtx":{"source":"iana"},"video/scip":{"source":"iana"},"video/smpte291":{"source":"iana"},"video/smpte292m":{"source":"iana"},"video/ulpfec":{"source":"iana"},"video/vc1":{"source":"iana"},"video/vc2":{"source":"iana"},"video/vnd.cctv":{"source":"iana"},"video/vnd.dece.hd":{"source":"iana","extensions":["uvh","uvvh"]},"video/vnd.dece.mobile":{"source":"iana","extensions":["uvm","uvvm"]},"video/vnd.dece.mp4":{"source":"iana"},"video/vnd.dece.pd":{"source":"iana","extensions":["uvp","uvvp"]},"video/vnd.dece.sd":{"source":"iana","extensions":["uvs","uvvs"]},"video/vnd.dece.video":{"source":"iana","extensions":["uvv","uvvv"]},"video/vnd.directv.mpeg":{"source":"iana"},"video/vnd.directv.mpeg-tts":{"source":"iana"},"video/vnd.dlna.mpeg-tts":{"source":"iana"},"video/vnd.dvb.file":{"source":"iana","extensions":["dvb"]},"video/vnd.fvt":{"source":"iana","extensions":["fvt"]},"video/vnd.hns.video":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.1dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-1010":{"source":"iana"},"video/vnd.iptvforum.2dparityfec-2005":{"source":"iana"},"video/vnd.iptvforum.ttsavc":{"source":"iana"},"video/vnd.iptvforum.ttsmpeg2":{"source":"iana"},"video/vnd.motorola.video":{"source":"iana"},"video/vnd.motorola.videop":{"source":"iana"},"video/vnd.mpegurl":{"source":"iana","extensions":["mxu","m4u"]},"video/vnd.ms-playready.media.pyv":{"source":"iana","extensions":["pyv"]},"video/vnd.nokia.interleaved-multimedia":{"source":"iana"},"video/vnd.nokia.mp4vr":{"source":"iana"},"video/vnd.nokia.videovoip":{"source":"iana"},"video/vnd.objectvideo":{"source":"iana"},"video/vnd.radgamettools.bink":{"source":"iana"},"video/vnd.radgamettools.smacker":{"source":"iana"},"video/vnd.sealed.mpeg1":{"source":"iana"},"video/vnd.sealed.mpeg4":{"source":"iana"},"video/vnd.sealed.swf":{"source":"iana"},"video/vnd.sealedmedia.softseal.mov":{"source":"iana"},"video/vnd.uvvu.mp4":{"source":"iana","extensions":["uvu","uvvu"]},"video/vnd.vivo":{"source":"iana","extensions":["viv"]},"video/vnd.youtube.yt":{"source":"iana"},"video/vp8":{"source":"iana"},"video/vp9":{"source":"iana"},"video/webm":{"source":"apache","compressible":false,"extensions":["webm"]},"video/x-f4v":{"source":"apache","extensions":["f4v"]},"video/x-fli":{"source":"apache","extensions":["fli"]},"video/x-flv":{"source":"apache","compressible":false,"extensions":["flv"]},"video/x-m4v":{"source":"apache","extensions":["m4v"]},"video/x-matroska":{"source":"apache","compressible":false,"extensions":["mkv","mk3d","mks"]},"video/x-mng":{"source":"apache","extensions":["mng"]},"video/x-ms-asf":{"source":"apache","extensions":["asf","asx"]},"video/x-ms-vob":{"source":"apache","extensions":["vob"]},"video/x-ms-wm":{"source":"apache","extensions":["wm"]},"video/x-ms-wmv":{"source":"apache","compressible":false,"extensions":["wmv"]},"video/x-ms-wmx":{"source":"apache","extensions":["wmx"]},"video/x-ms-wvx":{"source":"apache","extensions":["wvx"]},"video/x-msvideo":{"source":"apache","extensions":["avi"]},"video/x-sgi-movie":{"source":"apache","extensions":["movie"]},"video/x-smv":{"source":"apache","extensions":["smv"]},"x-conference/x-cooltalk":{"source":"apache","extensions":["ice"]},"x-shader/x-fragment":{"compressible":true},"x-shader/x-vertex":{"compressible":true}}');

/***/ }),

/***/ "./node_modules/socket.io/package.json":
/*!*********************************************!*\
  !*** ./node_modules/socket.io/package.json ***!
  \*********************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"_from":"socket.io@^4.4.1","_id":"socket.io@4.4.1","_inBundle":false,"_integrity":"sha512-s04vrBswdQBUmuWJuuNTmXUVJhP0cVky8bBDhdkf8y0Ptsu7fKU2LuLbts9g+pdmAdyMMn8F/9Mf1/wbtUN0fg==","_location":"/socket.io","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"socket.io@^4.4.1","name":"socket.io","escapedName":"socket.io","rawSpec":"^4.4.1","saveSpec":null,"fetchSpec":"^4.4.1"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/socket.io/-/socket.io-4.4.1.tgz","_shasum":"cd6de29e277a161d176832bb24f64ee045c56ab8","_spec":"socket.io@^4.4.1","_where":"C:\\\\xampp2\\\\htdocs\\\\FM-Wallet-Connector","bugs":{"url":"https://github.com/socketio/socket.io/issues"},"bundleDependencies":false,"contributors":[{"name":"Guillermo Rauch","email":"rauchg@gmail.com"},{"name":"Arnout Kazemier","email":"info@3rd-eden.com"},{"name":"Vladimir Dronnikov","email":"dronnikov@gmail.com"},{"name":"Einar Otto Stangvik","email":"einaros@gmail.com"}],"dependencies":{"accepts":"~1.3.4","base64id":"~2.0.0","debug":"~4.3.2","engine.io":"~6.1.0","socket.io-adapter":"~2.3.3","socket.io-parser":"~4.0.4"},"deprecated":false,"description":"node.js realtime framework server","devDependencies":{"@types/mocha":"^9.0.0","expect.js":"0.3.1","mocha":"^3.5.3","nyc":"^15.1.0","prettier":"^2.3.2","rimraf":"^3.0.2","socket.io-client":"4.4.1","socket.io-client-v2":"npm:socket.io-client@^2.4.0","superagent":"^6.1.0","supertest":"^6.1.6","ts-node":"^10.2.1","tsd":"^0.17.0","typescript":"^4.4.2","uWebSockets.js":"github:uNetworking/uWebSockets.js#v20.0.0"},"directories":{"doc":"docs/","example":"example/","lib":"lib/","test":"test/"},"engines":{"node":">=10.0.0"},"exports":{"import":"./wrapper.mjs","require":"./dist/index.js","types":"./dist/index.d.ts"},"files":["dist/","client-dist/","wrapper.mjs","!**/*.tsbuildinfo"],"homepage":"https://github.com/socketio/socket.io#readme","keywords":["realtime","framework","websocket","tcp","events","socket","io"],"license":"MIT","main":"./dist/index.js","name":"socket.io","repository":{"type":"git","url":"git://github.com/socketio/socket.io.git"},"scripts":{"compile":"rimraf ./dist && tsc","format:check":"prettier --check \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","format:fix":"prettier --write \\"lib/**/*.ts\\" \\"test/**/*.ts\\"","prepack":"npm run compile","test":"npm run format:check && npm run compile && npm run test:types && npm run test:unit","test:types":"tsd","test:unit":"nyc mocha --require ts-node/register --reporter spec --slow 200 --bail --timeout 10000 test/socket.io.ts"},"tsd":{"directory":"test"},"type":"commonjs","types":"./dist/index.d.ts","version":"4.4.1"}');

/***/ })

}])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZW11cmdvX2NpcDE0LWpzX2luZGV4X2pzLW5vZGVfbW9kdWxlc19heGlvc19pbmRleF9qcy1ub2RlX21vZHVsZXNfZm9ybS1kLWVlYmUyNC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiLElBQUlBLGVBQWUsR0FBSSxRQUFRLEtBQUtBLGVBQWQsSUFBa0MsVUFBVUMsR0FBVixFQUFlO0FBQ25FLFNBQVFBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFaLEdBQTBCRCxHQUExQixHQUFnQztBQUFFLGVBQVdBO0FBQWIsR0FBdkM7QUFDSCxDQUZEOztBQUdBRSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTUMsU0FBUyxHQUFHUCxlQUFlLENBQUNRLG1CQUFPLENBQUMsZ0RBQUQsQ0FBUixDQUFqQzs7QUFDQSxJQUFNQyxRQUFRLEdBQUdELG1CQUFPLENBQUMsbURBQUQsQ0FBeEIsRUFDQTs7O0FBQ0EsSUFBTUUsSUFBSSxHQUFHLE9BQWI7O0lBQ01DO0FBQ0YsNEJBQVlDLE9BQVosRUFBcUI7QUFBQTs7QUFDakIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0g7Ozs7V0FtQkQsdUJBQWM7QUFDVixVQUFNQyxLQUFLLEdBQUdKLFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkMsT0FBaEIsQ0FBd0IsS0FBS0gsT0FBN0IsQ0FBZDtBQUNBLGFBQU9ILFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkUsTUFBaEIsQ0FBdUJOLElBQXZCLEVBQTZCRyxLQUE3QixDQUFQO0FBQ0g7OztXQUNELGdCQUFPO0FBQ0gsYUFBT0ksTUFBTSxDQUFDQyxJQUFQLENBQVksS0FBS04sT0FBakIsRUFBMEJPLFFBQTFCLENBQW1DLEtBQW5DLENBQVA7QUFDSDs7O1dBQ0Qsa0JBQVM7QUFDTCxhQUFPVCxJQUFQO0FBQ0gsTUFDRDs7OztXQUNBLG9CQUFXO0FBQ1AsYUFBTyxLQUFL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bGVzL0BlbXVyZ28vY2lwMTQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi4vc3JjL2luZGV4LnRzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2FjY2VwdHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2Jhc2U2NGlkL2xpYi9iYXNlNjRpZC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9iZWNoMzIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vYmxha2UyYi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ibGFrZTJiLXdhc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYmxha2UyYi9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYnVmZmVydXRpbC9mYWxsYmFjay5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9idWZmZXJ1dGlsL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2NvbXBvbmVudC1lbWl0dGVyL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2Nvb2tpZS9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9jb3JzL2xpYi9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9ub2RlX21vZHVsZXMvZGVidWcvc3JjL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vbm9kZV9tb2R1bGVzL21zL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvbWltZS1kYi9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9taW1lLXR5cGVzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL25hbm9hc3NlcnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvbmVnb3RpYXRvci9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uZWdvdGlhdG9yL2xpYi9jaGFyc2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL2VuY29kaW5nLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL2xhbmd1YWdlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL25lZ290aWF0b3IvbGliL21lZGlhVHlwZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ub2RlLWd5cC1idWlsZC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLWFkYXB0ZXIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvYmluYXJ5LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvZGlzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8tcGFyc2VyL2Rpc3QvaXMtYmluYXJ5LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby1wYXJzZXIvbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvLXBhcnNlci9ub2RlX21vZHVsZXMvbXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vbm9kZV9tb2R1bGVzL2RlYnVnL3NyYy9jb21tb24uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL25vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRmLTgtdmFsaWRhdGUvZmFsbGJhY2suanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRmLTgtdmFsaWRhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdmFyeS9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvYnVmZmVyLXV0aWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvZXZlbnQtdGFyZ2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL2xpbWl0ZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvcmVjZWl2ZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvd3MvbGliL3NlbmRlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvc3RyZWFtLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby1wYXJzZXIvYnVpbGQvY2pzL2NvbW1vbnMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvZGVjb2RlUGFja2V0LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvZW5jb2RlUGFja2V0LmJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvLXBhcnNlci9idWlsZC9janMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL2VuZ2luZS5pby5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvcGFyc2VyLXYzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9wYXJzZXItdjMvdXRmOC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvc2VydmVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC9zb2NrZXQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy11d3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMtdXdzL3dlYnNvY2tldC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9lbmdpbmUuaW8vYnVpbGQvdHJhbnNwb3J0cy9wb2xsaW5nLWpzb25wLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC90cmFuc3BvcnRzL3BvbGxpbmcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZW5naW5lLmlvL2J1aWxkL3RyYW5zcG9ydHMvd2Vic29ja2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2VuZ2luZS5pby9idWlsZC91c2VydmVyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L2Jyb2FkY2FzdC1vcGVyYXRvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC9jbGllbnQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3QvbmFtZXNwYWNlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3BhcmVudC1uYW1lc3BhY2UuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL2Rpc3Qvc29ja2V0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3NvY2tldC5pby9kaXN0L3R5cGVkLWV2ZW50cy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9zb2NrZXQuaW8vZGlzdC91d3MuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc29ja2V0LmlvL3dyYXBwZXIubWpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgYmxha2UyYl8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJibGFrZTJiXCIpKTtcbmNvbnN0IGJlY2gzMl8xID0gcmVxdWlyZShcImJlY2gzMlwiKTtcbi8vLyBub3RlOiB0aGlzIGZ1bmN0aW9uIGNhbid0IGJlIGludmVydGVkIGR1ZSB0byB0aGUgaGFzaFxuY29uc3QgREFUQSA9IFwiYXNzZXRcIjtcbmNsYXNzIEFzc2V0RmluZ2VycHJpbnQge1xuICAgIGNvbnN0cnVjdG9yKGhhc2hCdWYpIHtcbiAgICAgICAgdGhpcy5oYXNoQnVmID0gaGFzaEJ1ZjtcbiAgICB9XG4gICAgc3RhdGljIGZyb21IYXNoKGhhc2gpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3NldEZpbmdlcnByaW50KGhhc2gpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVBhcnRzKHBvbGljeUlkLCBhc3NldE5hbWUpIHtcbiAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9jYXJkYW5vLWZvdW5kYXRpb24vQ0lQcy9wdWxsLzY0XG4gICAgICAgIGNvbnN0IGhhc2hCdWYgPSAoMCwgYmxha2UyYl8xLmRlZmF1bHQpKDIwKVxuICAgICAgICAgICAgLnVwZGF0ZShuZXcgVWludDhBcnJheShbLi4ucG9saWN5SWQsIC4uLmFzc2V0TmFtZV0pKVxuICAgICAgICAgICAgLmRpZ2VzdChcImJpbmFyeVwiKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0RmluZ2VycHJpbnQuZnJvbUhhc2goaGFzaEJ1Zik7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQmVjaDMyKGZpbmdlcnByaW50KSB7XG4gICAgICAgIGNvbnN0IHsgcHJlZml4LCB3b3JkcyB9ID0gYmVjaDMyXzEuYmVjaDMyLmRlY29kZShmaW5nZXJwcmludCk7XG4gICAgICAgIGlmIChwcmVmaXggIT09IERBVEEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXNzZXQgZmluZ2VycHJpbnRcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzaEJ1ZiA9IEJ1ZmZlci5mcm9tKGJlY2gzMl8xLmJlY2gzMi5mcm9tV29yZHMod29yZHMpKTtcbiAgICAgICAgcmV0dXJuIEFzc2V0RmluZ2VycHJpbnQuZnJvbUhhc2goaGFzaEJ1Zik7XG4gICAgfVxuICAgIGZpbmdlcnByaW50KCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IGJlY2gzMl8xLmJlY2gzMi50b1dvcmRzKHRoaXMuaGFzaEJ1Zik7XG4gICAgICAgIHJldHVybiBiZWNoMzJfMS5iZWNoMzIuZW5jb2RlKERBVEEsIHdvcmRzKTtcbiAgICB9XG4gICAgaGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKHRoaXMuaGFzaEJ1ZikudG9TdHJpbmcoXCJoZXhcIik7XG4gICAgfVxuICAgIHByZWZpeCgpIHtcbiAgICAgICAgcmV0dXJuIERBVEE7XG4gICAgfVxuICAgIC8vIFRoZSBsYXN0IHNpeCBjaGFyYWN0ZXJzIG9mIHRoZSBkYXRhIHBhcnQgZm9ybSBhIGNoZWNrc3VtIGFuZCBjb250YWluIG5vIGluZm9ybWF0aW9uXG4gICAgY2hlY2tzdW0oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZpbmdlcnByaW50KCkuc2xpY2UoLTYpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IEFzc2V0RmluZ2VycHJpbnQ7XG4iLG51bGwsIi8qIVxuICogYWNjZXB0c1xuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIE5lZ290aWF0b3IgPSByZXF1aXJlKCduZWdvdGlhdG9yJylcbnZhciBtaW1lID0gcmVxdWlyZSgnbWltZS10eXBlcycpXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBBY2NlcHRzXG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IEFjY2VwdHMgb2JqZWN0IGZvciB0aGUgZ2l2ZW4gcmVxLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSByZXFcbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBBY2NlcHRzIChyZXEpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFjY2VwdHMpKSB7XG4gICAgcmV0dXJuIG5ldyBBY2NlcHRzKHJlcSlcbiAgfVxuXG4gIHRoaXMuaGVhZGVycyA9IHJlcS5oZWFkZXJzXG4gIHRoaXMubmVnb3RpYXRvciA9IG5ldyBOZWdvdGlhdG9yKHJlcSlcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gYHR5cGUocylgIGlzIGFjY2VwdGFibGUsIHJldHVybmluZ1xuICogdGhlIGJlc3QgbWF0Y2ggd2hlbiB0cnVlLCBvdGhlcndpc2UgYHVuZGVmaW5lZGAsIGluIHdoaWNoXG4gKiBjYXNlIHlvdSBzaG91bGQgcmVzcG9uZCB3aXRoIDQwNiBcIk5vdCBBY2NlcHRhYmxlXCIuXG4gKlxuICogVGhlIGB0eXBlYCB2YWx1ZSBtYXkgYmUgYSBzaW5nbGUgbWltZSB0eXBlIHN0cmluZ1xuICogc3VjaCBhcyBcImFwcGxpY2F0aW9uL2pzb25cIiwgdGhlIGV4dGVuc2lvbiBuYW1lXG4gKiBzdWNoIGFzIFwianNvblwiIG9yIGFuIGFycmF5IGBbXCJqc29uXCIsIFwiaHRtbFwiLCBcInRleHQvcGxhaW5cIl1gLiBXaGVuIGEgbGlzdFxuICogb3IgYXJyYXkgaXMgZ2l2ZW4gdGhlIF9iZXN0XyBtYXRjaCwgaWYgYW55IGlzIHJldHVybmVkLlxuICpcbiAqIEV4YW1wbGVzOlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvaHRtbFxuICogICAgIHRoaXMudHlwZXMoJ2h0bWwnKTtcbiAqICAgICAvLyA9PiBcImh0bWxcIlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKiwgYXBwbGljYXRpb24vanNvblxuICogICAgIHRoaXMudHlwZXMoJ2h0bWwnKTtcbiAqICAgICAvLyA9PiBcImh0bWxcIlxuICogICAgIHRoaXMudHlwZXMoJ3RleHQvaHRtbCcpO1xuICogICAgIC8vID0+IFwidGV4dC9odG1sXCJcbiAqICAgICB0aGlzLnR5cGVzKCdqc29uJywgJ3RleHQnKTtcbiAqICAgICAvLyA9PiBcImpzb25cIlxuICogICAgIHRoaXMudHlwZXMoJ2FwcGxpY2F0aW9uL2pzb24nKTtcbiAqICAgICAvLyA9PiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKiwgYXBwbGljYXRpb24vanNvblxuICogICAgIHRoaXMudHlwZXMoJ2ltYWdlL3BuZycpO1xuICogICAgIHRoaXMudHlwZXMoJ3BuZycpO1xuICogICAgIC8vID0+IHVuZGVmaW5lZFxuICpcbiAqICAgICAvLyBBY2NlcHQ6IHRleHQvKjtxPS41LCBhcHBsaWNhdGlvbi9qc29uXG4gKiAgICAgdGhpcy50eXBlcyhbJ2h0bWwnLCAnanNvbiddKTtcbiAqICAgICB0aGlzLnR5cGVzKCdodG1sJywgJ2pzb24nKTtcbiAqICAgICAvLyA9PiBcImpzb25cIlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSB0eXBlcy4uLlxuICogQHJldHVybiB7U3RyaW5nfEFycmF5fEJvb2xlYW59XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUudHlwZSA9XG5BY2NlcHRzLnByb3RvdHlwZS50eXBlcyA9IGZ1bmN0aW9uICh0eXBlc18pIHtcbiAgdmFyIHR5cGVzID0gdHlwZXNfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmICh0eXBlcyAmJiAhQXJyYXkuaXNBcnJheSh0eXBlcykpIHtcbiAgICB0eXBlcyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHlwZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHR5cGVzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gdHlwZXMsIHJldHVybiBhbGwgcmVxdWVzdGVkIHR5cGVzXG4gIGlmICghdHlwZXMgfHwgdHlwZXMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5tZWRpYVR5cGVzKClcbiAgfVxuXG4gIC8vIG5vIGFjY2VwdCBoZWFkZXIsIHJldHVybiBmaXJzdCBnaXZlbiB0eXBlXG4gIGlmICghdGhpcy5oZWFkZXJzLmFjY2VwdCkge1xuICAgIHJldHVybiB0eXBlc1swXVxuICB9XG5cbiAgdmFyIG1pbWVzID0gdHlwZXMubWFwKGV4dFRvTWltZSlcbiAgdmFyIGFjY2VwdHMgPSB0aGlzLm5lZ290aWF0b3IubWVkaWFUeXBlcyhtaW1lcy5maWx0ZXIodmFsaWRNaW1lKSlcbiAgdmFyIGZpcnN0ID0gYWNjZXB0c1swXVxuXG4gIHJldHVybiBmaXJzdFxuICAgID8gdHlwZXNbbWltZXMuaW5kZXhPZihmaXJzdCldXG4gICAgOiBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBlbmNvZGluZ3Mgb3IgYmVzdCBmaXQgYmFzZWQgb24gYGVuY29kaW5nc2AuXG4gKlxuICogR2l2ZW4gYEFjY2VwdC1FbmNvZGluZzogZ3ppcCwgZGVmbGF0ZWBcbiAqIGFuIGFycmF5IHNvcnRlZCBieSBxdWFsaXR5IGlzIHJldHVybmVkOlxuICpcbiAqICAgICBbJ2d6aXAnLCAnZGVmbGF0ZSddXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGVuY29kaW5ncy4uLlxuICogQHJldHVybiB7U3RyaW5nfEFycmF5fVxuICogQHB1YmxpY1xuICovXG5cbkFjY2VwdHMucHJvdG90eXBlLmVuY29kaW5nID1cbkFjY2VwdHMucHJvdG90eXBlLmVuY29kaW5ncyA9IGZ1bmN0aW9uIChlbmNvZGluZ3NfKSB7XG4gIHZhciBlbmNvZGluZ3MgPSBlbmNvZGluZ3NfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmIChlbmNvZGluZ3MgJiYgIUFycmF5LmlzQXJyYXkoZW5jb2RpbmdzKSkge1xuICAgIGVuY29kaW5ncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBlbmNvZGluZ3NbaV0gPSBhcmd1bWVudHNbaV1cbiAgICB9XG4gIH1cblxuICAvLyBubyBlbmNvZGluZ3MsIHJldHVybiBhbGwgcmVxdWVzdGVkIGVuY29kaW5nc1xuICBpZiAoIWVuY29kaW5ncyB8fCBlbmNvZGluZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5lbmNvZGluZ3MoKVxuICB9XG5cbiAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5lbmNvZGluZ3MoZW5jb2RpbmdzKVswXSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBjaGFyc2V0cyBvciBiZXN0IGZpdCBiYXNlZCBvbiBgY2hhcnNldHNgLlxuICpcbiAqIEdpdmVuIGBBY2NlcHQtQ2hhcnNldDogdXRmLTgsIGlzby04ODU5LTE7cT0wLjIsIHV0Zi03O3E9MC41YFxuICogYW4gYXJyYXkgc29ydGVkIGJ5IHF1YWxpdHkgaXMgcmV0dXJuZWQ6XG4gKlxuICogICAgIFsndXRmLTgnLCAndXRmLTcnLCAnaXNvLTg4NTktMSddXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IGNoYXJzZXRzLi4uXG4gKiBAcmV0dXJuIHtTdHJpbmd8QXJyYXl9XG4gKiBAcHVibGljXG4gKi9cblxuQWNjZXB0cy5wcm90b3R5cGUuY2hhcnNldCA9XG5BY2NlcHRzLnByb3RvdHlwZS5jaGFyc2V0cyA9IGZ1bmN0aW9uIChjaGFyc2V0c18pIHtcbiAgdmFyIGNoYXJzZXRzID0gY2hhcnNldHNfXG5cbiAgLy8gc3VwcG9ydCBmbGF0dGVuZWQgYXJndW1lbnRzXG4gIGlmIChjaGFyc2V0cyAmJiAhQXJyYXkuaXNBcnJheShjaGFyc2V0cykpIHtcbiAgICBjaGFyc2V0cyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhcnNldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNoYXJzZXRzW2ldID0gYXJndW1lbnRzW2ldXG4gICAgfVxuICB9XG5cbiAgLy8gbm8gY2hhcnNldHMsIHJldHVybiBhbGwgcmVxdWVzdGVkIGNoYXJzZXRzXG4gIGlmICghY2hhcnNldHMgfHwgY2hhcnNldHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIHRoaXMubmVnb3RpYXRvci5jaGFyc2V0cygpXG4gIH1cblxuICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmNoYXJzZXRzKGNoYXJzZXRzKVswXSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIFJldHVybiBhY2NlcHRlZCBsYW5ndWFnZXMgb3IgYmVzdCBmaXQgYmFzZWQgb24gYGxhbmdzYC5cbiAqXG4gKiBHaXZlbiBgQWNjZXB0LUxhbmd1YWdlOiBlbjtxPTAuOCwgZXMsIHB0YFxuICogYW4gYXJyYXkgc29ydGVkIGJ5IHF1YWxpdHkgaXMgcmV0dXJuZWQ6XG4gKlxuICogICAgIFsnZXMnLCAncHQnLCAnZW4nXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBsYW5ncy4uLlxuICogQHJldHVybiB7QXJyYXl8U3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbkFjY2VwdHMucHJvdG90eXBlLmxhbmcgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3MgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3VhZ2UgPVxuQWNjZXB0cy5wcm90b3R5cGUubGFuZ3VhZ2VzID0gZnVuY3Rpb24gKGxhbmd1YWdlc18pIHtcbiAgdmFyIGxhbmd1YWdlcyA9IGxhbmd1YWdlc19cblxuICAvLyBzdXBwb3J0IGZsYXR0ZW5lZCBhcmd1bWVudHNcbiAgaWYgKGxhbmd1YWdlcyAmJiAhQXJyYXkuaXNBcnJheShsYW5ndWFnZXMpKSB7XG4gICAgbGFuZ3VhZ2VzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYW5ndWFnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGxhbmd1YWdlc1tpXSA9IGFyZ3VtZW50c1tpXVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vIGxhbmd1YWdlcywgcmV0dXJuIGFsbCByZXF1ZXN0ZWQgbGFuZ3VhZ2VzXG4gIGlmICghbGFuZ3VhZ2VzIHx8IGxhbmd1YWdlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmxhbmd1YWdlcygpXG4gIH1cblxuICByZXR1cm4gdGhpcy5uZWdvdGlhdG9yLmxhbmd1YWdlcyhsYW5ndWFnZXMpWzBdIHx8IGZhbHNlXG59XG5cbi8qKlxuICogQ29udmVydCBleHRuYW1lcyB0byBtaW1lLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGV4dFRvTWltZSAodHlwZSkge1xuICByZXR1cm4gdHlwZS5pbmRleE9mKCcvJykgPT09IC0xXG4gICAgPyBtaW1lLmxvb2t1cCh0eXBlKVxuICAgIDogdHlwZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIG1pbWUgaXMgdmFsaWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdmFsaWRNaW1lICh0eXBlKSB7XG4gIHJldHVybiB0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZydcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNvbmZpZy50cmFuc2l0aW9uYWwgJiYgY29uZmlnLnRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJylcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHtcbiAgICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxuICB9LFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgKGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPT09ICdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG52YXIgY3VycmVudFZlckFyciA9IHBrZy52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cbi8qKlxuICogQ29tcGFyZSBwYWNrYWdlIHZlcnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSB0aGFuVmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24sIHRoYW5WZXJzaW9uKSB7XG4gIHZhciBwa2dWZXJzaW9uQXJyID0gdGhhblZlcnNpb24gPyB0aGFuVmVyc2lvbi5zcGxpdCgnLicpIDogY3VycmVudFZlckFycjtcbiAgdmFyIGRlc3RWZXIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPiBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPCBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICB2YXIgaXNEZXByZWNhdGVkID0gdmVyc2lvbiAmJiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uKTtcblxuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgcGtnLnZlcnNpb24gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQgaW4gJyArIHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09sZGVyVmVyc2lvbjogaXNPbGRlclZlcnNpb24sXG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIi8qIVxuICogYmFzZTY0aWQgdjAuMS4wXG4gKi9cblxuLyoqXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzXG4gKi9cblxudmFyIGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yXG4gKi9cblxudmFyIEJhc2U2NElkID0gZnVuY3Rpb24oKSB7IH07XG5cbi8qKlxuICogR2V0IHJhbmRvbSBieXRlc1xuICpcbiAqIFVzZXMgYSBidWZmZXIgaWYgYXZhaWxhYmxlLCBmYWxscyBiYWNrIHRvIGNyeXB0by5yYW5kb21CeXRlc1xuICovXG5cbkJhc2U2NElkLnByb3RvdHlwZS5nZXRSYW5kb21CeXRlcyA9IGZ1bmN0aW9uKGJ5dGVzKSB7XG5cbiAgdmFyIEJVRkZFUl9TSVpFID0gNDA5NlxuICB2YXIgc2VsZiA9IHRoaXM7ICBcbiAgXG4gIGJ5dGVzID0gYnl0ZXMgfHwgMTI7XG5cbiAgaWYgKGJ5dGVzID4gQlVGRkVSX1NJWkUpIHtcbiAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzKTtcbiAgfVxuICBcbiAgdmFyIGJ5dGVzSW5CdWZmZXIgPSBwYXJzZUludChCVUZGRVJfU0laRS9ieXRlcyk7XG4gIHZhciB0aHJlc2hvbGQgPSBwYXJzZUludChieXRlc0luQnVmZmVyKjAuODUpO1xuXG4gIGlmICghdGhyZXNob2xkKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21CeXRlcyhieXRlcyk7XG4gIH1cblxuICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IG51bGwpIHtcbiAgICAgdGhpcy5ieXRlc0J1ZmZlckluZGV4ID0gLTE7XG4gIH1cblxuICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IGJ5dGVzSW5CdWZmZXIpIHtcbiAgICB0aGlzLmJ5dGVzQnVmZmVyID0gbnVsbDtcbiAgICB0aGlzLmJ5dGVzQnVmZmVySW5kZXggPSAtMTtcbiAgfVxuXG4gIC8vIE5vIGJ1ZmZlcmVkIGJ5dGVzIGF2YWlsYWJsZSBvciBpbmRleCBhYm92ZSB0aHJlc2hvbGRcbiAgaWYgKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCA9PSAtMSB8fCB0aGlzLmJ5dGVzQnVmZmVySW5kZXggPiB0aHJlc2hvbGQpIHtcbiAgICAgXG4gICAgaWYgKCF0aGlzLmlzR2VuZXJhdGluZ0J5dGVzKSB7XG4gICAgICB0aGlzLmlzR2VuZXJhdGluZ0J5dGVzID0gdHJ1ZTtcbiAgICAgIGNyeXB0by5yYW5kb21CeXRlcyhCVUZGRVJfU0laRSwgZnVuY3Rpb24oZXJyLCBieXRlcykge1xuICAgICAgICBzZWxmLmJ5dGVzQnVmZmVyID0gYnl0ZXM7XG4gICAgICAgIHNlbGYuYnl0ZXNCdWZmZXJJbmRleCA9IDA7XG4gICAgICAgIHNlbGYuaXNHZW5lcmF0aW5nQnl0ZXMgPSBmYWxzZTtcbiAgICAgIH0pOyBcbiAgICB9XG4gICAgXG4gICAgLy8gRmFsbCBiYWNrIHRvIHN5bmMgY2FsbCB3aGVuIG5vIGJ1ZmZlcmVkIGJ5dGVzIGFyZSBhdmFpbGFibGVcbiAgICBpZiAodGhpcy5ieXRlc0J1ZmZlckluZGV4ID09IC0xKSB7XG4gICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKGJ5dGVzKTtcbiAgICB9XG4gIH1cbiAgXG4gIHZhciByZXN1bHQgPSB0aGlzLmJ5dGVzQnVmZmVyLnNsaWNlKGJ5dGVzKnRoaXMuYnl0ZXNCdWZmZXJJbmRleCwgYnl0ZXMqKHRoaXMuYnl0ZXNCdWZmZXJJbmRleCsxKSk7IFxuICB0aGlzLmJ5dGVzQnVmZmVySW5kZXgrKzsgXG4gIFxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEdlbmVyYXRlcyBhIGJhc2U2NCBpZFxuICpcbiAqIChPcmlnaW5hbCB2ZXJzaW9uIGZyb20gc29ja2V0LmlvIDxodHRwOi8vc29ja2V0LmlvPilcbiAqL1xuXG5CYXNlNjRJZC5wcm90b3R5cGUuZ2VuZXJhdGVJZCA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHJhbmQgPSBCdWZmZXIuYWxsb2MoMTUpOyAvLyBtdWx0aXBsZSBvZiAzIGZvciBiYXNlNjRcbiAgaWYgKCFyYW5kLndyaXRlSW50MzJCRSkge1xuICAgIHJldHVybiBNYXRoLmFicyhNYXRoLnJhbmRvbSgpICogTWF0aC5yYW5kb20oKSAqIERhdGUubm93KCkgfCAwKS50b1N0cmluZygpXG4gICAgICArIE1hdGguYWJzKE1hdGgucmFuZG9tKCkgKiBNYXRoLnJhbmRvbSgpICogRGF0ZS5ub3coKSB8IDApLnRvU3RyaW5nKCk7XG4gIH1cbiAgdGhpcy5zZXF1ZW5jZU51bWJlciA9ICh0aGlzLnNlcXVlbmNlTnVtYmVyICsgMSkgfCAwO1xuICByYW5kLndyaXRlSW50MzJCRSh0aGlzLnNlcXVlbmNlTnVtYmVyLCAxMSk7XG4gIGlmIChjcnlwdG8ucmFuZG9tQnl0ZXMpIHtcbiAgICB0aGlzLmdldFJhbmRvbUJ5dGVzKDEyKS5jb3B5KHJhbmQpO1xuICB9IGVsc2Uge1xuICAgIC8vIG5vdCBzZWN1cmUgZm9yIG5vZGUgMC40XG4gICAgWzAsIDQsIDhdLmZvckVhY2goZnVuY3Rpb24oaSkge1xuICAgICAgcmFuZC53cml0ZUludDMyQkUoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIDMyKSB8IDAsIGkpO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiByYW5kLnRvU3RyaW5nKCdiYXNlNjQnKS5yZXBsYWNlKC9cXC8vZywgJ18nKS5yZXBsYWNlKC9cXCsvZywgJy0nKTtcbn07XG5cbi8qKlxuICogRXhwb3J0XG4gKi9cblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gbmV3IEJhc2U2NElkKCk7XG4iLCIndXNlIHN0cmljdCc7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmJlY2gzMm0gPSBleHBvcnRzLmJlY2gzMiA9IHZvaWQgMDtcbmNvbnN0IEFMUEhBQkVUID0gJ3FwenJ5OXg4Z2YydHZkdzBzM2puNTRraGNlNm11YTdsJztcbmNvbnN0IEFMUEhBQkVUX01BUCA9IHt9O1xuZm9yIChsZXQgeiA9IDA7IHogPCBBTFBIQUJFVC5sZW5ndGg7IHorKykge1xuICAgIGNvbnN0IHggPSBBTFBIQUJFVC5jaGFyQXQoeik7XG4gICAgQUxQSEFCRVRfTUFQW3hdID0gejtcbn1cbmZ1bmN0aW9uIHBvbHltb2RTdGVwKHByZSkge1xuICAgIGNvbnN0IGIgPSBwcmUgPj4gMjU7XG4gICAgcmV0dXJuICgoKHByZSAmIDB4MWZmZmZmZikgPDwgNSkgXlxuICAgICAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuICAgICAgICAoLSgoYiA+PiAxKSAmIDEpICYgMHgyNjUwOGU2ZCkgXlxuICAgICAgICAoLSgoYiA+PiAyKSAmIDEpICYgMHgxZWExMTlmYSkgXlxuICAgICAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuICAgICAgICAoLSgoYiA+PiA0KSAmIDEpICYgMHgyYTE0NjJiMykpO1xufVxuZnVuY3Rpb24gcHJlZml4Q2hrKHByZWZpeCkge1xuICAgIGxldCBjaGsgPSAxO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGMgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAzMyB8fCBjID4gMTI2KVxuICAgICAgICAgICAgcmV0dXJuICdJbnZhbGlkIHByZWZpeCAoJyArIHByZWZpeCArICcpJztcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIChjID4+IDUpO1xuICAgIH1cbiAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHYgPSBwcmVmaXguY2hhckNvZGVBdChpKTtcbiAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeICh2ICYgMHgxZik7XG4gICAgfVxuICAgIHJldHVybiBjaGs7XG59XG5mdW5jdGlvbiBjb252ZXJ0KGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG4gICAgbGV0IHZhbHVlID0gMDtcbiAgICBsZXQgYml0cyA9IDA7XG4gICAgY29uc3QgbWF4ViA9ICgxIDw8IG91dEJpdHMpIC0gMTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFsdWUgPSAodmFsdWUgPDwgaW5CaXRzKSB8IGRhdGFbaV07XG4gICAgICAgIGJpdHMgKz0gaW5CaXRzO1xuICAgICAgICB3aGlsZSAoYml0cyA+PSBvdXRCaXRzKSB7XG4gICAgICAgICAgICBiaXRzIC09IG91dEJpdHM7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPj4gYml0cykgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGFkKSB7XG4gICAgICAgIGlmIChiaXRzID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4Vik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChiaXRzID49IGluQml0cylcbiAgICAgICAgICAgIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnO1xuICAgICAgICBpZiAoKHZhbHVlIDw8IChvdXRCaXRzIC0gYml0cykpICYgbWF4VilcbiAgICAgICAgICAgIHJldHVybiAnTm9uLXplcm8gcGFkZGluZyc7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiB0b1dvcmRzKGJ5dGVzKSB7XG4gICAgcmV0dXJuIGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpO1xufVxuZnVuY3Rpb24gZnJvbVdvcmRzVW5zYWZlKHdvcmRzKSB7XG4gICAgY29uc3QgcmVzID0gY29udmVydCh3b3JkcywgNSwgOCwgZmFsc2UpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHJlcykpXG4gICAgICAgIHJldHVybiByZXM7XG59XG5mdW5jdGlvbiBmcm9tV29yZHMod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbiAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbn1cbmZ1bmN0aW9uIGdldExpYnJhcnlGcm9tRW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgICBsZXQgRU5DT0RJTkdfQ09OU1Q7XG4gICAgaWYgKGVuY29kaW5nID09PSAnYmVjaDMyJykge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDE7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBFTkNPRElOR19DT05TVCA9IDB4MmJjODMwYTM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVuY29kZShwcmVmaXgsIHdvcmRzLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAocHJlZml4Lmxlbmd0aCArIDcgKyB3b3Jkcy5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0Jyk7XG4gICAgICAgIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBkZXRlcm1pbmUgY2hrIG1vZFxuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihjaGspO1xuICAgICAgICBsZXQgcmVzdWx0ID0gcHJlZml4ICsgJzEnO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHdvcmRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB4ID0gd29yZHNbaV07XG4gICAgICAgICAgICBpZiAoeCA+PiA1ICE9PSAwKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTm9uIDUtYml0IHdvcmQnKTtcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4O1xuICAgICAgICAgICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDY7ICsraSkge1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKTtcbiAgICAgICAgfVxuICAgICAgICBjaGsgXj0gRU5DT0RJTkdfQ09OU1Q7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCB2ID0gKGNoayA+PiAoKDUgLSBpKSAqIDUpKSAmIDB4MWY7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHYpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIF9fZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgTElNSVQgPSBMSU1JVCB8fCA5MDtcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPCA4KVxuICAgICAgICAgICAgcmV0dXJuIHN0ciArICcgdG9vIHNob3J0JztcbiAgICAgICAgaWYgKHN0ci5sZW5ndGggPiBMSU1JVClcbiAgICAgICAgICAgIHJldHVybiAnRXhjZWVkcyBsZW5ndGggbGltaXQnO1xuICAgICAgICAvLyBkb24ndCBhbGxvdyBtaXhlZCBjYXNlXG4gICAgICAgIGNvbnN0IGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgY29uc3QgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBpZiAoc3RyICE9PSBsb3dlcmVkICYmIHN0ciAhPT0gdXBwZXJlZClcbiAgICAgICAgICAgIHJldHVybiAnTWl4ZWQtY2FzZSBzdHJpbmcgJyArIHN0cjtcbiAgICAgICAgc3RyID0gbG93ZXJlZDtcbiAgICAgICAgY29uc3Qgc3BsaXQgPSBzdHIubGFzdEluZGV4T2YoJzEnKTtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAtMSlcbiAgICAgICAgICAgIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0cjtcbiAgICAgICAgaWYgKHNwbGl0ID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuICdNaXNzaW5nIHByZWZpeCBmb3IgJyArIHN0cjtcbiAgICAgICAgY29uc3QgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KTtcbiAgICAgICAgY29uc3Qgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSk7XG4gICAgICAgIGlmICh3b3JkQ2hhcnMubGVuZ3RoIDwgNilcbiAgICAgICAgICAgIHJldHVybiAnRGF0YSB0b28gc2hvcnQnO1xuICAgICAgICBsZXQgY2hrID0gcHJlZml4Q2hrKHByZWZpeCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHJldHVybiBjaGs7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZENoYXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBjb25zdCBjID0gd29yZENoYXJzLmNoYXJBdChpKTtcbiAgICAgICAgICAgIGNvbnN0IHYgPSBBTFBIQUJFVF9NQVBbY107XG4gICAgICAgICAgICBpZiAodiA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgICAgIHJldHVybiAnVW5rbm93biBjaGFyYWN0ZXIgJyArIGM7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gdjtcbiAgICAgICAgICAgIC8vIG5vdCBpbiB0aGUgY2hlY2tzdW0/XG4gICAgICAgICAgICBpZiAoaSArIDYgPj0gd29yZENoYXJzLmxlbmd0aClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIHdvcmRzLnB1c2godik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoayAhPT0gRU5DT0RJTkdfQ09OU1QpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgY2hlY2tzdW0gZm9yICcgKyBzdHI7XG4gICAgICAgIHJldHVybiB7IHByZWZpeCwgd29yZHMgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlVW5zYWZlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRlY29kZShzdHIsIExJTUlUKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IF9fZGVjb2RlKHN0ciwgTElNSVQpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyA9PT0gJ29iamVjdCcpXG4gICAgICAgICAgICByZXR1cm4gcmVzO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IocmVzKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVjb2RlVW5zYWZlLFxuICAgICAgICBkZWNvZGUsXG4gICAgICAgIGVuY29kZSxcbiAgICAgICAgdG9Xb3JkcyxcbiAgICAgICAgZnJvbVdvcmRzVW5zYWZlLFxuICAgICAgICBmcm9tV29yZHMsXG4gICAgfTtcbn1cbmV4cG9ydHMuYmVjaDMyID0gZ2V0TGlicmFyeUZyb21FbmNvZGluZygnYmVjaDMyJyk7XG5leHBvcnRzLmJlY2gzMm0gPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzJtJyk7XG4iLCJcbm1vZHVsZS5leHBvcnRzID0gbG9hZFdlYkFzc2VtYmx5XG5cbmxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQgPSB0eXBlb2YgV2ViQXNzZW1ibHkgIT09ICd1bmRlZmluZWQnXG5cbmZ1bmN0aW9uIGxvYWRXZWJBc3NlbWJseSAob3B0cykge1xuICBpZiAoIWxvYWRXZWJBc3NlbWJseS5zdXBwb3J0ZWQpIHJldHVybiBudWxsXG5cbiAgdmFyIGltcCA9IG9wdHMgJiYgb3B0cy5pbXBvcnRzXG4gIHZhciB3YXNtID0gdG9VaW50OEFycmF5KCdBR0Z6YlFFQUFBQUJFQU5nQW45L0FHQURmMzkvQUdBQmZ3QURCUVFBQVFJQ0JRVUJBUXJvQndkTkJRWnRaVzF2Y25rQ0FBeGliR0ZyWlRKaVgybHVhWFFBQUE1aWJHRnJaVEppWDNWd1pHRjBaUUFCRFdKc1lXdGxNbUpmWm1sdVlXd0FBaEJpYkdGclpUSmlYMk52YlhCeVpYTnpBQU1LMDBBRWxnTUFJQUJDQURjREFDQUFRUWhxUWdBM0F3QWdBRUVRYWtJQU53TUFJQUJCR0dwQ0FEY0RBQ0FBUVNCcVFnQTNBd0FnQUVFb2FrSUFOd01BSUFCQk1HcENBRGNEQUNBQVFUaHFRZ0EzQXdBZ0FFSEFBR3BDQURjREFDQUFRY2dBYWtJQU53TUFJQUJCMEFCcVFnQTNBd0FnQUVIWUFHcENBRGNEQUNBQVFlQUFha0lBTndNQUlBQkI2QUJxUWdBM0F3QWdBRUh3QUdwQ0FEY0RBQ0FBUWZnQWFrSUFOd01BSUFCQmdBRnFRb2lTODUzL3pQbUU2Z0JCQUNrREFJVTNBd0FnQUVHSUFXcEN1ODZxcHRqUTY3TzdmMEVJS1FNQWhUY0RBQ0FBUVpBQmFrS3I4TlAwcis2OHR6eEJFQ2tEQUlVM0F3QWdBRUdZQVdwQzhlMzArS1duL2FlbGYwRVlLUU1BaFRjREFDQUFRYUFCYWtMUmhacnYrcytVaDlFQVFTQXBBd0NGTndNQUlBQkJxQUZxUXAvWStkbkNrZHFDbTM5QktDa0RBSVUzQXdBZ0FFR3dBV3BDNi9xRzJyKzE5c0VmUVRBcEF3Q0ZOd01BSUFCQnVBRnFRdm5DK0p1Um83UHcyd0JCT0NrREFJVTNBd0FnQUVIQUFXcENBRGNEQUNBQVFjZ0Jha0lBTndNQUlBQkIwQUZxUWdBM0F3QUxiUUVEZnlBQVFjQUJhaUVESUFCQnlBRnFJUVFnQkNrREFLY2hCUUpBQTBBZ0FTQUNSZzBCSUFWQmdBRkdCRUFnQXlBREtRTUFJQVd0ZkRjREFFRUFJUVVnQUJBREN5QUFJQVZxSUFFdEFBQTZBQUFnQlVFQmFpRUZJQUZCQVdvaEFRd0FDd3NnQkNBRnJUY0RBQXRrQVFOL0lBQkJ3QUZxSVFFZ0FFSElBV29oQWlBQklBRXBBd0FnQWlrREFIdzNBd0FnQUVIUUFXcENmemNEQUNBQ0tRTUFweUVEQWtBRFFDQURRWUFCUmcwQklBQWdBMnBCQURvQUFDQURRUUZxSVFNTUFBc0xJQUlnQTYwM0F3QWdBQkFEQytVN0FpQitDWDhnQUVHQUFXb2hJU0FBUVlnQmFpRWlJQUJCa0FGcUlTTWdBRUdZQVdvaEpDQUFRYUFCYWlFbElBQkJxQUZxSVNZZ0FFR3dBV29oSnlBQVFiZ0JhaUVvSUNFcEF3QWhBU0FpS1FNQUlRSWdJeWtEQUNFRElDUXBBd0FoQkNBbEtRTUFJUVVnSmlrREFDRUdJQ2NwQXdBaEJ5QW9LUU1BSVFoQ2lKTHpuZi9NK1lUcUFDRUpRcnZPcXFiWTBPdXp1MzhoQ2tLcjhOUDByKzY4dHp3aEMwTHg3ZlQ0cGFmOXA2Vi9JUXhDMFlXYTcvclBsSWZSQUNFTlFwL1krZG5Da2RxQ20zOGhEa0xyK29iYXY3WDJ3UjhoRDBMNXd2aWJrYU96OE5zQUlSQWdBQ2tEQUNFUklBQkJDR29wQXdBaEVpQUFRUkJxS1FNQUlSTWdBRUVZYWlrREFDRVVJQUJCSUdvcEF3QWhGU0FBUVNocUtRTUFJUllnQUVFd2Fpa0RBQ0VYSUFCQk9Hb3BBd0FoR0NBQVFjQUFhaWtEQUNFWklBQkJ5QUJxS1FNQUlSb2dBRUhRQUdvcEF3QWhHeUFBUWRnQWFpa0RBQ0VjSUFCQjRBQnFLUU1BSVIwZ0FFSG9BR29wQXdBaEhpQUFRZkFBYWlrREFDRWZJQUJCK0FCcUtRTUFJU0FnRFNBQVFjQUJhaWtEQUlVaERTQVBJQUJCMEFGcUtRTUFoU0VQSUFFZ0JTQVJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQk44ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFVZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnRlh4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJaOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBWGZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0dIeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCbDhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWFmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHM3g4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FkZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSG54OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI5OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBZ2ZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0gzeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCdDhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVZmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdHWHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQnA4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFnZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnSG54OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJkOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBU2ZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0hYeDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCRjhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QVRmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dISHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmg4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FXZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnRkh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBWmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0hYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCRjhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QVdmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dFM3g4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQ0I4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FlZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRzN4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUI5OGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBVWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCaDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVNmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdHbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlY4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FZZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnR254OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJSOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBU2ZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0hueDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCMThmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQWNmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dIM3g4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQk44ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFYZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRm54OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJ0OGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBVmZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0VYeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklDQjhmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQVpmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdHbng4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQkY4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFXZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnR0h4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUJOOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBVmZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0czeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlDQjhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQWZmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdFbng4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQng4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFkZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnRjN4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJsOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBVWZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0hueDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCTjhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWRmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdGM3g4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQnQ4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFSZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnSEh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUJsOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBVWZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0ZYeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCNThmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QVlmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dGbng4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQ0I4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FmZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRW54OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJwOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBZGZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0ZueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCSjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQWdmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dIM3g4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQjU4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FWZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnRzN4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJGOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBWWZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0YzeDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCUjhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQWFmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dFM3g4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQmw4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FjZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnSG54OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJ4OGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBWWZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0gzeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCMThmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVNmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dGSHg4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQnA4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFXZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnRVh4OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUNCOGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBVmZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0dYeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCZDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVRmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdHM3g4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQmQ4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FnZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnSDN4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJwOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBY2ZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0ZIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCRjhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVpmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdIWHg4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQk44ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFlZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnR0h4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJKOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBVmZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0czeDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCWjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQWJmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdFM3g4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQmw4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFWZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnR0h4OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUJkOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBU2ZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0ZueDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lDQjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQWNmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dHbng4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQjk4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FVZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnSFh4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUI1OGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBUmZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0VYeDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCSjhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVRmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdGSHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQlY4ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFXZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRjN4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUJoOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBWmZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0dueDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCdDhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QWNmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dIWHg4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQjU4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FmZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnSUh4OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUI5OGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBYmZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0ZYeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCbDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QWFmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dJSHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQjU4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FYZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRW54OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUIxOGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBUmZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0UzeDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlCeDhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQVlmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdGbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQlI4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklDRWdJU2tEQUNBQklBbUZoVGNEQUNBaUlDSXBBd0FnQWlBS2hZVTNBd0FnSXlBaktRTUFJQU1nQzRXRk53TUFJQ1FnSkNrREFDQUVJQXlGaFRjREFDQWxJQ1VwQXdBZ0JTQU5oWVUzQXdBZ0ppQW1LUU1BSUFZZ0RvV0ZOd01BSUNjZ0p5a0RBQ0FISUErRmhUY0RBQ0FvSUNncEF3QWdDQ0FRaFlVM0F3QUwnKVxuICB2YXIgcmVhZHkgPSBudWxsXG5cbiAgdmFyIG1vZCA9IHtcbiAgICBidWZmZXI6IHdhc20sXG4gICAgbWVtb3J5OiBudWxsLFxuICAgIGV4cG9ydHM6IG51bGwsXG4gICAgcmVhbGxvYzogcmVhbGxvYyxcbiAgICBvbmxvYWQ6IG9ubG9hZFxuICB9XG5cbiAgb25sb2FkKGZ1bmN0aW9uICgpIHt9KVxuXG4gIHJldHVybiBtb2RcblxuICBmdW5jdGlvbiByZWFsbG9jIChzaXplKSB7XG4gICAgbW9kLmV4cG9ydHMubWVtb3J5Lmdyb3coTWF0aC5jZWlsKE1hdGguYWJzKHNpemUgLSBtb2QubWVtb3J5Lmxlbmd0aCkgLyA2NTUzNikpXG4gICAgbW9kLm1lbW9yeSA9IG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cblxuICBmdW5jdGlvbiBvbmxvYWQgKGNiKSB7XG4gICAgaWYgKG1vZC5leHBvcnRzKSByZXR1cm4gY2IoKVxuXG4gICAgaWYgKHJlYWR5KSB7XG4gICAgICByZWFkeS50aGVuKGNiLmJpbmQobnVsbCwgbnVsbCkpLmNhdGNoKGNiKVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdHJ5IHtcbiAgICAgIGlmIChvcHRzICYmIG9wdHMuYXN5bmMpIHRocm93IG5ldyBFcnJvcignYXN5bmMnKVxuICAgICAgc2V0dXAoe2luc3RhbmNlOiBuZXcgV2ViQXNzZW1ibHkuSW5zdGFuY2UobmV3IFdlYkFzc2VtYmx5Lk1vZHVsZSh3YXNtKSwgaW1wKX0pXG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICByZWFkeSA9IFdlYkFzc2VtYmx5Lmluc3RhbnRpYXRlKHdhc20sIGltcCkudGhlbihzZXR1cClcbiAgICB9XG5cbiAgICBvbmxvYWQoY2IpXG4gIH1cblxuICBmdW5jdGlvbiBzZXR1cCAodykge1xuICAgIG1vZC5leHBvcnRzID0gdy5pbnN0YW5jZS5leHBvcnRzXG4gICAgbW9kLm1lbW9yeSA9IG1vZC5leHBvcnRzLm1lbW9yeSAmJiBtb2QuZXhwb3J0cy5tZW1vcnkuYnVmZmVyICYmIG5ldyBVaW50OEFycmF5KG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIpXG4gIH1cbn1cblxuZnVuY3Rpb24gdG9VaW50OEFycmF5IChzKSB7XG4gIGlmICh0eXBlb2YgYXRvYiA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG5ldyBVaW50OEFycmF5KGF0b2Iocykuc3BsaXQoJycpLm1hcChjaGFyQ29kZUF0KSlcbiAgcmV0dXJuIG5ldyAocmVxdWlyZSgnYnVmJyArICdmZXInKS5CdWZmZXIpKHMsICdiYXNlNjQnKVxufVxuXG5mdW5jdGlvbiBjaGFyQ29kZUF0IChjKSB7XG4gIHJldHVybiBjLmNoYXJDb2RlQXQoMClcbn1cbiIsInZhciBhc3NlcnQgPSByZXF1aXJlKCduYW5vYXNzZXJ0JylcbnZhciB3YXNtID0gcmVxdWlyZSgnLi9ibGFrZTJiJykoKVxuXG52YXIgaGVhZCA9IDY0XG52YXIgZnJlZUxpc3QgPSBbXVxuXG5tb2R1bGUuZXhwb3J0cyA9IEJsYWtlMmJcbnZhciBCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NSU4gPSAxNlxudmFyIEJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01BWCA9IDY0XG52YXIgQllURVMgPSBtb2R1bGUuZXhwb3J0cy5CWVRFUyA9IDMyXG52YXIgS0VZQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUlOID0gMTZcbnZhciBLRVlCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NQVggPSA2NFxudmFyIEtFWUJZVEVTID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVMgPSAzMlxudmFyIFNBTFRCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlNBTFRCWVRFUyA9IDE2XG52YXIgUEVSU09OQUxCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlBFUlNPTkFMQllURVMgPSAxNlxuXG5mdW5jdGlvbiBCbGFrZTJiIChkaWdlc3RMZW5ndGgsIGtleSwgc2FsdCwgcGVyc29uYWwsIG5vQXNzZXJ0KSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBCbGFrZTJiKSkgcmV0dXJuIG5ldyBCbGFrZTJiKGRpZ2VzdExlbmd0aCwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpXG4gIGlmICghKHdhc20gJiYgd2FzbS5leHBvcnRzKSkgdGhyb3cgbmV3IEVycm9yKCdXQVNNIG5vdCBsb2FkZWQuIFdhaXQgZm9yIEJsYWtlMmIucmVhZHkoY2IpJylcbiAgaWYgKCFkaWdlc3RMZW5ndGgpIGRpZ2VzdExlbmd0aCA9IDMyXG5cbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA+PSBCWVRFU19NSU4sICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBkaWdlc3RMZW5ndGgpXG4gICAgYXNzZXJ0KGRpZ2VzdExlbmd0aCA8PSBCWVRFU19NQVgsICdkaWdlc3RMZW5ndGggbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGRpZ2VzdExlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBsZWFzdCAnICsgS0VZQllURVNfTUFYICsgJywgd2FzIGdpdmVuICcgKyBrZXkubGVuZ3RoKVxuICAgIGlmIChzYWx0ICE9IG51bGwpIGFzc2VydChzYWx0Lmxlbmd0aCA9PT0gU0FMVEJZVEVTLCAnc2FsdCBtdXN0IGJlIGV4YWN0bHkgJyArIFNBTFRCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgc2FsdC5sZW5ndGgpXG4gICAgaWYgKHBlcnNvbmFsICE9IG51bGwpIGFzc2VydChwZXJzb25hbC5sZW5ndGggPT09IFBFUlNPTkFMQllURVMsICdwZXJzb25hbCBtdXN0IGJlIGV4YWN0bHkgJyArIFBFUlNPTkFMQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHBlcnNvbmFsLmxlbmd0aClcbiAgfVxuXG4gIGlmICghZnJlZUxpc3QubGVuZ3RoKSB7XG4gICAgZnJlZUxpc3QucHVzaChoZWFkKVxuICAgIGhlYWQgKz0gMjE2XG4gIH1cblxuICB0aGlzLmRpZ2VzdExlbmd0aCA9IGRpZ2VzdExlbmd0aFxuICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlXG4gIHRoaXMucG9pbnRlciA9IGZyZWVMaXN0LnBvcCgpXG5cbiAgd2FzbS5tZW1vcnkuZmlsbCgwLCAwLCA2NClcbiAgd2FzbS5tZW1vcnlbMF0gPSB0aGlzLmRpZ2VzdExlbmd0aFxuICB3YXNtLm1lbW9yeVsxXSA9IGtleSA/IGtleS5sZW5ndGggOiAwXG4gIHdhc20ubWVtb3J5WzJdID0gMSAvLyBmYW5vdXRcbiAgd2FzbS5tZW1vcnlbM10gPSAxIC8vIGRlcHRoXG5cbiAgaWYgKHNhbHQpIHdhc20ubWVtb3J5LnNldChzYWx0LCAzMilcbiAgaWYgKHBlcnNvbmFsKSB3YXNtLm1lbW9yeS5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIGlmICh0aGlzLnBvaW50ZXIgKyAyMTYgPiB3YXNtLm1lbW9yeS5sZW5ndGgpIHdhc20ucmVhbGxvYyh0aGlzLnBvaW50ZXIgKyAyMTYpIC8vIHdlIG5lZWQgMjE2IGJ5dGVzIGZvciB0aGUgc3RhdGVcbiAgd2FzbS5leHBvcnRzLmJsYWtlMmJfaW5pdCh0aGlzLnBvaW50ZXIsIHRoaXMuZGlnZXN0TGVuZ3RoKVxuXG4gIGlmIChrZXkpIHtcbiAgICB0aGlzLnVwZGF0ZShrZXkpXG4gICAgd2FzbS5tZW1vcnkuZmlsbCgwLCBoZWFkLCBoZWFkICsga2V5Lmxlbmd0aCkgLy8gd2hpdGVvdXQga2V5XG4gICAgd2FzbS5tZW1vcnlbdGhpcy5wb2ludGVyICsgMjAwXSA9IDEyOFxuICB9XG59XG5cblxuQmxha2UyYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIGFzc2VydChpbnB1dCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuXG4gIGlmIChoZWFkICsgaW5wdXQubGVuZ3RoID4gd2FzbS5tZW1vcnkubGVuZ3RoKSB3YXNtLnJlYWxsb2MoaGVhZCArIGlucHV0Lmxlbmd0aClcbiAgd2FzbS5tZW1vcnkuc2V0KGlucHV0LCBoZWFkKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl91cGRhdGUodGhpcy5wb2ludGVyLCBoZWFkLCBoZWFkICsgaW5wdXQubGVuZ3RoKVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGFzc2VydCh0aGlzLmZpbmFsaXplZCA9PT0gZmFsc2UsICdIYXNoIGluc3RhbmNlIGZpbmFsaXplZCcpXG4gIHRoaXMuZmluYWxpemVkID0gdHJ1ZVxuXG4gIGZyZWVMaXN0LnB1c2godGhpcy5wb2ludGVyKVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl9maW5hbCh0aGlzLnBvaW50ZXIpXG5cbiAgaWYgKCFlbmMgfHwgZW5jID09PSAnYmluYXJ5Jykge1xuICAgIHJldHVybiB3YXNtLm1lbW9yeS5zbGljZSh0aGlzLnBvaW50ZXIgKyAxMjgsIHRoaXMucG9pbnRlciArIDEyOCArIHRoaXMuZGlnZXN0TGVuZ3RoKVxuICB9XG5cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICByZXR1cm4gaGV4U2xpY2Uod2FzbS5tZW1vcnksIHRoaXMucG9pbnRlciArIDEyOCwgdGhpcy5kaWdlc3RMZW5ndGgpXG4gIH1cblxuICBhc3NlcnQoZW5jLmxlbmd0aCA+PSB0aGlzLmRpZ2VzdExlbmd0aCwgJ2lucHV0IG11c3QgYmUgVHlwZWRBcnJheSBvciBCdWZmZXInKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZGlnZXN0TGVuZ3RoOyBpKyspIHtcbiAgICBlbmNbaV0gPSB3YXNtLm1lbW9yeVt0aGlzLnBvaW50ZXIgKyAxMjggKyBpXVxuICB9XG5cbiAgcmV0dXJuIGVuY1xufVxuXG4vLyBsaWJzb2RpdW0gY29tcGF0XG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLldBU00gPSB3YXNtICYmIHdhc20uYnVmZmVyXG5CbGFrZTJiLlNVUFBPUlRFRCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuQmxha2UyYi5yZWFkeSA9IGZ1bmN0aW9uIChjYikge1xuICBpZiAoIWNiKSBjYiA9IG5vb3BcbiAgaWYgKCF3YXNtKSByZXR1cm4gY2IobmV3IEVycm9yKCdXZWJBc3NlbWJseSBub3Qgc3VwcG9ydGVkJykpXG5cbiAgLy8gYmFja3dhcmRzIGNvbXBhdCwgY2FuIGJlIHJlbW92ZWQgaW4gYSBuZXcgbWFqb3JcbiAgdmFyIHAgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVqZWN0LCByZXNvbHZlKSB7XG4gICAgd2FzbS5vbmxvYWQoZnVuY3Rpb24gKGVycikge1xuICAgICAgaWYgKGVycikgcmVzb2x2ZSgpXG4gICAgICBlbHNlIHJlamVjdCgpXG4gICAgICBjYihlcnIpXG4gICAgfSlcbiAgfSlcblxuICByZXR1cm4gcFxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5yZWFkeSA9IEJsYWtlMmIucmVhZHlcblxuZnVuY3Rpb24gbm9vcCAoKSB7fVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgbGVuKSB7XG4gIHZhciBzdHIgPSAnJ1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW3N0YXJ0ICsgaV0pXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIGIyd2FzbSA9IHJlcXVpcmUoJ2JsYWtlMmItd2FzbScpXG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSB2W2IsYisxXVxuLy8gdiBzaG91bGQgYmUgYSBVaW50MzJBcnJheVxuZnVuY3Rpb24gQURENjRBQSAodiwgYSwgYikge1xuICB2YXIgbzAgPSB2W2FdICsgdltiXVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIHZbYiArIDFdXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyA2NC1iaXQgdW5zaWduZWQgYWRkaXRpb25cbi8vIFNldHMgdlthLGErMV0gKz0gYlxuLy8gYjAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIGIsIGIxIHJlcHJlc2VudHMgdGhlIGhpZ2ggMzIgYml0c1xuZnVuY3Rpb24gQURENjRBQyAodiwgYSwgYjAsIGIxKSB7XG4gIHZhciBvMCA9IHZbYV0gKyBiMFxuICBpZiAoYjAgPCAwKSB7XG4gICAgbzAgKz0gMHgxMDAwMDAwMDBcbiAgfVxuICB2YXIgbzEgPSB2W2EgKyAxXSArIGIxXG4gIGlmIChvMCA+PSAweDEwMDAwMDAwMCkge1xuICAgIG8xKytcbiAgfVxuICB2W2FdID0gbzBcbiAgdlthICsgMV0gPSBvMVxufVxuXG4vLyBMaXR0bGUtZW5kaWFuIGJ5dGUgYWNjZXNzXG5mdW5jdGlvbiBCMkJfR0VUMzIgKGFyciwgaSkge1xuICByZXR1cm4gKGFycltpXSBeXG4gIChhcnJbaSArIDFdIDw8IDgpIF5cbiAgKGFycltpICsgMl0gPDwgMTYpIF5cbiAgKGFycltpICsgM10gPDwgMjQpKVxufVxuXG4vLyBHIE1peGluZyBmdW5jdGlvblxuLy8gVGhlIFJPVFJzIGFyZSBpbmxpbmVkIGZvciBzcGVlZFxuZnVuY3Rpb24gQjJCX0cgKGEsIGIsIGMsIGQsIGl4LCBpeSkge1xuICB2YXIgeDAgPSBtW2l4XVxuICB2YXIgeDEgPSBtW2l4ICsgMV1cbiAgdmFyIHkwID0gbVtpeV1cbiAgdmFyIHkxID0gbVtpeSArIDFdXG5cbiAgQURENjRBQSh2LCBhLCBiKSAvLyB2W2EsYSsxXSArPSB2W2IsYisxXSAuLi4gaW4gSlMgd2UgbXVzdCBzdG9yZSBhIHVpbnQ2NCBhcyB0d28gdWludDMyc1xuICBBREQ2NEFDKHYsIGEsIHgwLCB4MSkgLy8gdlthLCBhKzFdICs9IHggLi4uIHgwIGlzIHRoZSBsb3cgMzIgYml0cyBvZiB4LCB4MSBpcyB0aGUgaGlnaCAzMiBiaXRzXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHRvIHRoZSByaWdodCBieSAzMiBiaXRzXG4gIHZhciB4b3IwID0gdltkXSBeIHZbYV1cbiAgdmFyIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSB4b3IxXG4gIHZbZCArIDFdID0geG9yMFxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMjQgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IwID4+PiAyNCkgXiAoeG9yMSA8PCA4KVxuICB2W2IgKyAxXSA9ICh4b3IxID4+PiAyNCkgXiAoeG9yMCA8PCA4KVxuXG4gIEFERDY0QUEodiwgYSwgYilcbiAgQURENjRBQyh2LCBhLCB5MCwgeTEpXG5cbiAgLy8gdltkLGQrMV0gPSAodltkLGQrMV0geG9yIHZbYSxhKzFdKSByb3RhdGVkIHJpZ2h0IGJ5IDE2IGJpdHNcbiAgeG9yMCA9IHZbZF0gXiB2W2FdXG4gIHhvcjEgPSB2W2QgKyAxXSBeIHZbYSArIDFdXG4gIHZbZF0gPSAoeG9yMCA+Pj4gMTYpIF4gKHhvcjEgPDwgMTYpXG4gIHZbZCArIDFdID0gKHhvcjEgPj4+IDE2KSBeICh4b3IwIDw8IDE2KVxuXG4gIEFERDY0QUEodiwgYywgZClcblxuICAvLyB2W2IsYisxXSA9ICh2W2IsYisxXSB4b3IgdltjLGMrMV0pIHJvdGF0ZWQgcmlnaHQgYnkgNjMgYml0c1xuICB4b3IwID0gdltiXSBeIHZbY11cbiAgeG9yMSA9IHZbYiArIDFdIF4gdltjICsgMV1cbiAgdltiXSA9ICh4b3IxID4+PiAzMSkgXiAoeG9yMCA8PCAxKVxuICB2W2IgKyAxXSA9ICh4b3IwID4+PiAzMSkgXiAoeG9yMSA8PCAxKVxufVxuXG4vLyBJbml0aWFsaXphdGlvbiBWZWN0b3JcbnZhciBCTEFLRTJCX0lWMzIgPSBuZXcgVWludDMyQXJyYXkoW1xuICAweEYzQkNDOTA4LCAweDZBMDlFNjY3LCAweDg0Q0FBNzNCLCAweEJCNjdBRTg1LFxuICAweEZFOTRGODJCLCAweDNDNkVGMzcyLCAweDVGMUQzNkYxLCAweEE1NEZGNTNBLFxuICAweEFERTY4MkQxLCAweDUxMEU1MjdGLCAweDJCM0U2QzFGLCAweDlCMDU2ODhDLFxuICAweEZCNDFCRDZCLCAweDFGODNEOUFCLCAweDEzN0UyMTc5LCAweDVCRTBDRDE5XG5dKVxuXG52YXIgU0lHTUE4ID0gW1xuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzLFxuICAxMSwgOCwgMTIsIDAsIDUsIDIsIDE1LCAxMywgMTAsIDE0LCAzLCA2LCA3LCAxLCA5LCA0LFxuICA3LCA5LCAzLCAxLCAxMywgMTIsIDExLCAxNCwgMiwgNiwgNSwgMTAsIDQsIDAsIDE1LCA4LFxuICA5LCAwLCA1LCA3LCAyLCA0LCAxMCwgMTUsIDE0LCAxLCAxMSwgMTIsIDYsIDgsIDMsIDEzLFxuICAyLCAxMiwgNiwgMTAsIDAsIDExLCA4LCAzLCA0LCAxMywgNywgNSwgMTUsIDE0LCAxLCA5LFxuICAxMiwgNSwgMSwgMTUsIDE0LCAxMywgNCwgMTAsIDAsIDcsIDYsIDMsIDksIDIsIDgsIDExLFxuICAxMywgMTEsIDcsIDE0LCAxMiwgMSwgMywgOSwgNSwgMCwgMTUsIDQsIDgsIDYsIDIsIDEwLFxuICA2LCAxNSwgMTQsIDksIDExLCAzLCAwLCA4LCAxMiwgMiwgMTMsIDcsIDEsIDQsIDEwLCA1LFxuICAxMCwgMiwgOCwgNCwgNywgNiwgMSwgNSwgMTUsIDExLCA5LCAxNCwgMywgMTIsIDEzLCAwLFxuICAwLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMCwgMTEsIDEyLCAxMywgMTQsIDE1LFxuICAxNCwgMTAsIDQsIDgsIDksIDE1LCAxMywgNiwgMSwgMTIsIDAsIDIsIDExLCA3LCA1LCAzXG5dXG5cbi8vIFRoZXNlIGFyZSBvZmZzZXRzIGludG8gYSB1aW50NjQgYnVmZmVyLlxuLy8gTXVsdGlwbHkgdGhlbSBhbGwgYnkgMiB0byBtYWtlIHRoZW0gb2Zmc2V0cyBpbnRvIGEgdWludDMyIGJ1ZmZlcixcbi8vIGJlY2F1c2UgdGhpcyBpcyBKYXZhc2NyaXB0IGFuZCB3ZSBkb24ndCBoYXZlIHVpbnQ2NHNcbnZhciBTSUdNQTgyID0gbmV3IFVpbnQ4QXJyYXkoU0lHTUE4Lm1hcChmdW5jdGlvbiAoeCkgeyByZXR1cm4geCAqIDIgfSkpXG5cbi8vIENvbXByZXNzaW9uIGZ1bmN0aW9uLiAnbGFzdCcgZmxhZyBpbmRpY2F0ZXMgbGFzdCBibG9jay5cbi8vIE5vdGUgd2UncmUgcmVwcmVzZW50aW5nIDE2IHVpbnQ2NHMgYXMgMzIgdWludDMyc1xudmFyIHYgPSBuZXcgVWludDMyQXJyYXkoMzIpXG52YXIgbSA9IG5ldyBVaW50MzJBcnJheSgzMilcbmZ1bmN0aW9uIGJsYWtlMmJDb21wcmVzcyAoY3R4LCBsYXN0KSB7XG4gIHZhciBpID0gMFxuXG4gIC8vIGluaXQgd29yayB2YXJpYWJsZXNcbiAgZm9yIChpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB2W2ldID0gY3R4LmhbaV1cbiAgICB2W2kgKyAxNl0gPSBCTEFLRTJCX0lWMzJbaV1cbiAgfVxuXG4gIC8vIGxvdyA2NCBiaXRzIG9mIG9mZnNldFxuICB2WzI0XSA9IHZbMjRdIF4gY3R4LnRcbiAgdlsyNV0gPSB2WzI1XSBeIChjdHgudCAvIDB4MTAwMDAwMDAwKVxuICAvLyBoaWdoIDY0IGJpdHMgbm90IHN1cHBvcnRlZCwgb2Zmc2V0IG1heSBub3QgYmUgaGlnaGVyIHRoYW4gMioqNTMtMVxuXG4gIC8vIGxhc3QgYmxvY2sgZmxhZyBzZXQgP1xuICBpZiAobGFzdCkge1xuICAgIHZbMjhdID0gfnZbMjhdXG4gICAgdlsyOV0gPSB+dlsyOV1cbiAgfVxuXG4gIC8vIGdldCBsaXR0bGUtZW5kaWFuIHdvcmRzXG4gIGZvciAoaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgbVtpXSA9IEIyQl9HRVQzMihjdHguYiwgNCAqIGkpXG4gIH1cblxuICAvLyB0d2VsdmUgcm91bmRzIG9mIG1peGluZ1xuICBmb3IgKGkgPSAwOyBpIDwgMTI7IGkrKykge1xuICAgIEIyQl9HKDAsIDgsIDE2LCAyNCwgU0lHTUE4MltpICogMTYgKyAwXSwgU0lHTUE4MltpICogMTYgKyAxXSlcbiAgICBCMkJfRygyLCAxMCwgMTgsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDJdLCBTSUdNQTgyW2kgKiAxNiArIDNdKVxuICAgIEIyQl9HKDQsIDEyLCAyMCwgMjgsIFNJR01BODJbaSAqIDE2ICsgNF0sIFNJR01BODJbaSAqIDE2ICsgNV0pXG4gICAgQjJCX0coNiwgMTQsIDIyLCAzMCwgU0lHTUE4MltpICogMTYgKyA2XSwgU0lHTUE4MltpICogMTYgKyA3XSlcbiAgICBCMkJfRygwLCAxMCwgMjAsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDhdLCBTSUdNQTgyW2kgKiAxNiArIDldKVxuICAgIEIyQl9HKDIsIDEyLCAyMiwgMjQsIFNJR01BODJbaSAqIDE2ICsgMTBdLCBTSUdNQTgyW2kgKiAxNiArIDExXSlcbiAgICBCMkJfRyg0LCAxNCwgMTYsIDI2LCBTSUdNQTgyW2kgKiAxNiArIDEyXSwgU0lHTUE4MltpICogMTYgKyAxM10pXG4gICAgQjJCX0coNiwgOCwgMTgsIDI4LCBTSUdNQTgyW2kgKiAxNiArIDE0XSwgU0lHTUE4MltpICogMTYgKyAxNV0pXG4gIH1cblxuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIGN0eC5oW2ldID0gY3R4LmhbaV0gXiB2W2ldIF4gdltpICsgMTZdXG4gIH1cbn1cblxuLy8gcmV1c2FibGUgcGFyYW1ldGVyX2Jsb2NrXG52YXIgcGFyYW1ldGVyX2Jsb2NrID0gbmV3IFVpbnQ4QXJyYXkoW1xuICAwLCAwLCAwLCAwLCAgICAgIC8vICAwOiBvdXRsZW4sIGtleWxlbiwgZmFub3V0LCBkZXB0aFxuICAwLCAwLCAwLCAwLCAgICAgIC8vICA0OiBsZWFmIGxlbmd0aCwgc2VxdWVudGlhbCBtb2RlXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDg6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTI6IG5vZGUgb2Zmc2V0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMTY6IG5vZGUgZGVwdGgsIGlubmVyIGxlbmd0aCwgcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjA6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDI0OiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyODogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMzI6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAzNjogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQwOiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDQ6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0ODogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1MjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA1NjogcGVyc29uYWxcbiAgMCwgMCwgMCwgMCAgICAgICAvLyA2MDogcGVyc29uYWxcbl0pXG5cbi8vIENyZWF0ZXMgYSBCTEFLRTJiIGhhc2hpbmcgY29udGV4dFxuLy8gUmVxdWlyZXMgYW4gb3V0cHV0IGxlbmd0aCBiZXR3ZWVuIDEgYW5kIDY0IGJ5dGVzXG4vLyBUYWtlcyBhbiBvcHRpb25hbCBVaW50OEFycmF5IGtleVxuZnVuY3Rpb24gQmxha2UyYiAob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsKSB7XG4gIC8vIHplcm8gb3V0IHBhcmFtZXRlcl9ibG9jayBiZWZvcmUgdXNhZ2VcbiAgcGFyYW1ldGVyX2Jsb2NrLmZpbGwoMClcbiAgLy8gc3RhdGUsICdwYXJhbSBibG9jaydcblxuICB0aGlzLmIgPSBuZXcgVWludDhBcnJheSgxMjgpXG4gIHRoaXMuaCA9IG5ldyBVaW50MzJBcnJheSgxNilcbiAgdGhpcy50ID0gMCAvLyBpbnB1dCBjb3VudFxuICB0aGlzLmMgPSAwIC8vIHBvaW50ZXIgd2l0aGluIGJ1ZmZlclxuICB0aGlzLm91dGxlbiA9IG91dGxlbiAvLyBvdXRwdXQgbGVuZ3RoIGluIGJ5dGVzXG5cbiAgcGFyYW1ldGVyX2Jsb2NrWzBdID0gb3V0bGVuXG4gIGlmIChrZXkpIHBhcmFtZXRlcl9ibG9ja1sxXSA9IGtleS5sZW5ndGhcbiAgcGFyYW1ldGVyX2Jsb2NrWzJdID0gMSAvLyBmYW5vdXRcbiAgcGFyYW1ldGVyX2Jsb2NrWzNdID0gMSAvLyBkZXB0aFxuXG4gIGlmIChzYWx0KSBwYXJhbWV0ZXJfYmxvY2suc2V0KHNhbHQsIDMyKVxuICBpZiAocGVyc29uYWwpIHBhcmFtZXRlcl9ibG9jay5zZXQocGVyc29uYWwsIDQ4KVxuXG4gIC8vIGluaXRpYWxpemUgaGFzaCBzdGF0ZVxuICBmb3IgKHZhciBpID0gMDsgaSA8IDE2OyBpKyspIHtcbiAgICB0aGlzLmhbaV0gPSBCTEFLRTJCX0lWMzJbaV0gXiBCMkJfR0VUMzIocGFyYW1ldGVyX2Jsb2NrLCBpICogNClcbiAgfVxuXG4gIC8vIGtleSB0aGUgaGFzaCwgaWYgYXBwbGljYWJsZVxuICBpZiAoa2V5KSB7XG4gICAgYmxha2UyYlVwZGF0ZSh0aGlzLCBrZXkpXG4gICAgLy8gYXQgdGhlIGVuZFxuICAgIHRoaXMuYyA9IDEyOFxuICB9XG59XG5cbkJsYWtlMmIucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChpbnB1dCkge1xuICBhc3NlcnQoaW5wdXQgIT0gbnVsbCwgJ2lucHV0IG11c3QgYmUgVWludDhBcnJheSBvciBCdWZmZXInKVxuICBibGFrZTJiVXBkYXRlKHRoaXMsIGlucHV0KVxuICByZXR1cm4gdGhpc1xufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiAob3V0KSB7XG4gIHZhciBidWYgPSAoIW91dCB8fCBvdXQgPT09ICdiaW5hcnknIHx8IG91dCA9PT0gJ2hleCcpID8gbmV3IFVpbnQ4QXJyYXkodGhpcy5vdXRsZW4pIDogb3V0XG4gIGFzc2VydChidWYubGVuZ3RoID49IHRoaXMub3V0bGVuLCAnb3V0IG11c3QgaGF2ZSBhdCBsZWFzdCBvdXRsZW4gYnl0ZXMgb2Ygc3BhY2UnKVxuICBibGFrZTJiRmluYWwodGhpcywgYnVmKVxuICBpZiAob3V0ID09PSAnaGV4JykgcmV0dXJuIGhleFNsaWNlKGJ1ZilcbiAgcmV0dXJuIGJ1ZlxufVxuXG5CbGFrZTJiLnByb3RvdHlwZS5maW5hbCA9IEJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdFxuXG5CbGFrZTJiLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgY2IoKSAvLyBpZ25vcmUgdGhlIGVycm9yXG4gIH0pXG59XG5cbi8vIFVwZGF0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXF1aXJlcyBoYXNoIGNvbnRleHQgYW5kIFVpbnQ4QXJyYXkgKGJ5dGUgYXJyYXkpXG5mdW5jdGlvbiBibGFrZTJiVXBkYXRlIChjdHgsIGlucHV0KSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoY3R4LmMgPT09IDEyOCkgeyAvLyBidWZmZXIgZnVsbCA/XG4gICAgICBjdHgudCArPSBjdHguYyAvLyBhZGQgY291bnRlcnNcbiAgICAgIGJsYWtlMmJDb21wcmVzcyhjdHgsIGZhbHNlKSAvLyBjb21wcmVzcyAobm90IGxhc3QpXG4gICAgICBjdHguYyA9IDAgLy8gY291bnRlciB0byB6ZXJvXG4gICAgfVxuICAgIGN0eC5iW2N0eC5jKytdID0gaW5wdXRbaV1cbiAgfVxufVxuXG4vLyBDb21wbGV0ZXMgYSBCTEFLRTJiIHN0cmVhbWluZyBoYXNoXG4vLyBSZXR1cm5zIGEgVWludDhBcnJheSBjb250YWluaW5nIHRoZSBtZXNzYWdlIGRpZ2VzdFxuZnVuY3Rpb24gYmxha2UyYkZpbmFsIChjdHgsIG91dCkge1xuICBjdHgudCArPSBjdHguYyAvLyBtYXJrIGxhc3QgYmxvY2sgb2Zmc2V0XG5cbiAgd2hpbGUgKGN0eC5jIDwgMTI4KSB7IC8vIGZpbGwgdXAgd2l0aCB6ZXJvc1xuICAgIGN0eC5iW2N0eC5jKytdID0gMFxuICB9XG4gIGJsYWtlMmJDb21wcmVzcyhjdHgsIHRydWUpIC8vIGZpbmFsIGJsb2NrIGZsYWcgPSAxXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjdHgub3V0bGVuOyBpKyspIHtcbiAgICBvdXRbaV0gPSBjdHguaFtpID4+IDJdID4+ICg4ICogKGkgJiAzKSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSBzdHIgKz0gdG9IZXgoYnVmW2ldKVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxudmFyIFByb3RvID0gQmxha2UyYlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUhhc2ggKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpIHtcbiAgaWYgKG5vQXNzZXJ0ICE9PSB0cnVlKSB7XG4gICAgYXNzZXJ0KG91dGxlbiA+PSBCWVRFU19NSU4sICdvdXRsZW4gbXVzdCBiZSBhdCBsZWFzdCAnICsgQllURVNfTUlOICsgJywgd2FzIGdpdmVuICcgKyBvdXRsZW4pXG4gICAgYXNzZXJ0KG91dGxlbiA8PSBCWVRFU19NQVgsICdvdXRsZW4gbXVzdCBiZSBhdCBtb3N0ICcgKyBCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIG91dGxlbilcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoID49IEtFWUJZVEVTX01JTiwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKGtleSAhPSBudWxsKSBhc3NlcnQoa2V5Lmxlbmd0aCA8PSBLRVlCWVRFU19NQVgsICdrZXkgbXVzdCBiZSBhdCBtb3N0ICcgKyBLRVlCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKHNhbHQgIT0gbnVsbCkgYXNzZXJ0KHNhbHQubGVuZ3RoID09PSBTQUxUQllURVMsICdzYWx0IG11c3QgYmUgZXhhY3RseSAnICsgU0FMVEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBzYWx0Lmxlbmd0aClcbiAgICBpZiAocGVyc29uYWwgIT0gbnVsbCkgYXNzZXJ0KHBlcnNvbmFsLmxlbmd0aCA9PT0gUEVSU09OQUxCWVRFUywgJ3BlcnNvbmFsIG11c3QgYmUgZXhhY3RseSAnICsgUEVSU09OQUxCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgcGVyc29uYWwubGVuZ3RoKVxuICB9XG5cbiAgcmV0dXJuIG5ldyBQcm90byhvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpXG59XG5cbm1vZHVsZS5leHBvcnRzLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGIyd2FzbS5yZWFkeShmdW5jdGlvbiAoKSB7IC8vIGlnbm9yZSBlcnJvcnNcbiAgICBjYigpXG4gIH0pXG59XG5cbm1vZHVsZS5leHBvcnRzLldBU01fU1VQUE9SVEVEID0gYjJ3YXNtLlNVUFBPUlRFRFxubW9kdWxlLmV4cG9ydHMuV0FTTV9MT0FERUQgPSBmYWxzZVxuXG52YXIgQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUlOID0gMTZcbnZhciBCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NQVggPSA2NFxudmFyIEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuQllURVMgPSAzMlxudmFyIEtFWUJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01JTiA9IDE2XG52YXIgS0VZQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUFYID0gNjRcbnZhciBLRVlCWVRFUyA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTID0gMzJcbnZhciBTQUxUQllURVMgPSBtb2R1bGUuZXhwb3J0cy5TQUxUQllURVMgPSAxNlxudmFyIFBFUlNPTkFMQllURVMgPSBtb2R1bGUuZXhwb3J0cy5QRVJTT05BTEJZVEVTID0gMTZcblxuYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uIChlcnIpIHtcbiAgaWYgKCFlcnIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cy5XQVNNX0xPQURFRCA9IHRydWVcbiAgICBQcm90byA9IGIyd2FzbVxuICB9XG59KVxuIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxuY29uc3QgYmFzZTY0ID0gcmVxdWlyZSgnYmFzZTY0LWpzJylcbmNvbnN0IGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcbmNvbnN0IGN1c3RvbUluc3BlY3RTeW1ib2wgPVxuICAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgU3ltYm9sWydmb3InXSA9PT0gJ2Z1bmN0aW9uJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA/IFN5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJykgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICA6IG51bGxcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG5jb25zdCBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICBjb25zdCBhcnIgPSBuZXcgVWludDhBcnJheSgxKVxuICAgIGNvbnN0IHByb3RvID0geyBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH0gfVxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihwcm90bywgVWludDhBcnJheS5wcm90b3R5cGUpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGFyciwgcHJvdG8pXG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAncGFyZW50Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ1ZmZlclxuICB9XG59KVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLnByb3RvdHlwZSwgJ29mZnNldCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGhpcykpIHJldHVybiB1bmRlZmluZWRcbiAgICByZXR1cm4gdGhpcy5ieXRlT2Zmc2V0XG4gIH1cbn0pXG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJyArIGxlbmd0aCArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIGNvbnN0IGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGJ1ZiwgQnVmZmVyLnByb3RvdHlwZSlcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheVZpZXcodmFsdWUpXG4gIH1cblxuICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgICAnb3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdmFsdWUpXG4gICAgKVxuICB9XG5cbiAgaWYgKGlzSW5zdGFuY2UodmFsdWUsIEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBBcnJheUJ1ZmZlcikpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICAgIChpc0luc3RhbmNlKHZhbHVlLCBTaGFyZWRBcnJheUJ1ZmZlcikgfHxcbiAgICAgICh2YWx1ZSAmJiBpc0luc3RhbmNlKHZhbHVlLmJ1ZmZlciwgU2hhcmVkQXJyYXlCdWZmZXIpKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSBudW1iZXInXG4gICAgKVxuICB9XG5cbiAgY29uc3QgdmFsdWVPZiA9IHZhbHVlLnZhbHVlT2YgJiYgdmFsdWUudmFsdWVPZigpXG4gIGlmICh2YWx1ZU9mICE9IG51bGwgJiYgdmFsdWVPZiAhPT0gdmFsdWUpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVPZiwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgY29uc3QgYiA9IGZyb21PYmplY3QodmFsdWUpXG4gIGlmIChiKSByZXR1cm4gYlxuXG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9QcmltaXRpdmUgIT0gbnVsbCAmJlxuICAgICAgdHlwZW9mIHZhbHVlW1N5bWJvbC50b1ByaW1pdGl2ZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20odmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSgnc3RyaW5nJyksIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgJ1RoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksICcgK1xuICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSwgVWludDhBcnJheS5wcm90b3R5cGUpXG5PYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLCBVaW50OEFycmF5KVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgc2l6ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFsbG9jIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIGlmIChzaXplIDw9IDApIHtcbiAgICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUpXG4gIH1cbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9ubHkgcGF5IGF0dGVudGlvbiB0byBlbmNvZGluZyBpZiBpdCdzIGEgc3RyaW5nLiBUaGlzXG4gICAgLy8gcHJldmVudHMgYWNjaWRlbnRhbGx5IHNlbmRpbmcgaW4gYSBudW1iZXIgdGhhdCB3b3VsZFxuICAgIC8vIGJlIGludGVycHJldGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gIH1cblxuICBjb25zdCBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICBsZXQgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICBjb25zdCBhY3R1YWwgPSBidWYud3JpdGUoc3RyaW5nLCBlbmNvZGluZylcblxuICBpZiAoYWN0dWFsICE9PSBsZW5ndGgpIHtcbiAgICAvLyBXcml0aW5nIGEgaGV4IHN0cmluZywgZm9yIGV4YW1wbGUsIHRoYXQgY29udGFpbnMgaW52YWxpZCBjaGFyYWN0ZXJzIHdpbGxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxuICAgIC8vICdhYnh4Y2QnIHdpbGwgYmUgdHJlYXRlZCBhcyAnYWInKVxuICAgIGJ1ZiA9IGJ1Zi5zbGljZSgwLCBhY3R1YWwpXG4gIH1cblxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUxpa2UgKGFycmF5KSB7XG4gIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheVZpZXcgKGFycmF5Vmlldykge1xuICBpZiAoaXNJbnN0YW5jZShhcnJheVZpZXcsIFVpbnQ4QXJyYXkpKSB7XG4gICAgY29uc3QgY29weSA9IG5ldyBVaW50OEFycmF5KGFycmF5VmlldylcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKGNvcHkuYnVmZmVyLCBjb3B5LmJ5dGVPZmZzZXQsIGNvcHkuYnl0ZUxlbmd0aClcbiAgfVxuICByZXR1cm4gZnJvbUFycmF5TGlrZShhcnJheVZpZXcpXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJvZmZzZXRcIiBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcImxlbmd0aFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBsZXQgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIob2JqKSkge1xuICAgIGNvbnN0IGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgY29uc3QgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iai5sZW5ndGggIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgIHJldHVybiBjcmVhdGVCdWZmZXIoMClcbiAgICB9XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICB9XG5cbiAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZSAmJlxuICAgIGIgIT09IEJ1ZmZlci5wcm90b3R5cGUgLy8gc28gQnVmZmVyLmlzQnVmZmVyKEJ1ZmZlci5wcm90b3R5cGUpIHdpbGwgYmUgZmFsc2Vcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmIChpc0luc3RhbmNlKGEsIFVpbnQ4QXJyYXkpKSBhID0gQnVmZmVyLmZyb20oYSwgYS5vZmZzZXQsIGEuYnl0ZUxlbmd0aClcbiAgaWYgKGlzSW5zdGFuY2UoYiwgVWludDhBcnJheSkpIGIgPSBCdWZmZXIuZnJvbShiLCBiLm9mZnNldCwgYi5ieXRlTGVuZ3RoKVxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJidWYxXCIsIFwiYnVmMlwiIGFyZ3VtZW50cyBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5J1xuICAgIClcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIGxldCB4ID0gYS5sZW5ndGhcbiAgbGV0IHkgPSBiLmxlbmd0aFxuXG4gIGZvciAobGV0IGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICBjb25zdCBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICBsZXQgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIGxldCBidWYgPSBsaXN0W2ldXG4gICAgaWYgKGlzSW5zdGFuY2UoYnVmLCBVaW50OEFycmF5KSkge1xuICAgICAgaWYgKHBvcyArIGJ1Zi5sZW5ndGggPiBidWZmZXIubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIGJ1ZiA9IEJ1ZmZlci5mcm9tKGJ1ZilcbiAgICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgICAgICBidWZmZXIsXG4gICAgICAgICAgYnVmLFxuICAgICAgICAgIHBvc1xuICAgICAgICApXG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfSBlbHNlIHtcbiAgICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIH1cbiAgICBwb3MgKz0gYnVmLmxlbmd0aFxuICB9XG4gIHJldHVybiBidWZmZXJcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxuICB9XG4gIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcoc3RyaW5nKSB8fCBpc0luc3RhbmNlKHN0cmluZywgQXJyYXlCdWZmZXIpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBvciBBcnJheUJ1ZmZlci4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIHN0cmluZ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgY29uc3QgbXVzdE1hdGNoID0gKGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSA9PT0gdHJ1ZSlcbiAgaWYgKCFtdXN0TWF0Y2ggJiYgbGVuID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuICBmb3IgKDs7KSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsZW5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB7XG4gICAgICAgICAgcmV0dXJuIG11c3RNYXRjaCA/IC0xIDogdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgfVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuQnVmZmVyLmJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoXG5cbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcblxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFwidGhpcy5sZW5ndGggPD0gTUFYX1VJTlQzMlwiIHNpbmNlIGl0J3MgYSByZWFkLW9ubHlcbiAgLy8gcHJvcGVydHkgb2YgYSB0eXBlZCBhcnJheS5cblxuICAvLyBUaGlzIGJlaGF2ZXMgbmVpdGhlciBsaWtlIFN0cmluZyBub3IgVWludDhBcnJheSBpbiB0aGF0IHdlIHNldCBzdGFydC9lbmRcbiAgLy8gdG8gdGhlaXIgdXBwZXIvbG93ZXIgYm91bmRzIGlmIHRoZSB2YWx1ZSBwYXNzZWQgaXMgb3V0IG9mIHJhbmdlLlxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxuICAvLyBTZWN0aW9uIDEzLjMuMy43IFJ1bnRpbWUgU2VtYW50aWNzOiBLZXllZEJpbmRpbmdJbml0aWFsaXphdGlvbi5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQgfHwgc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgLy8gUmV0dXJuIGVhcmx5IGlmIHN0YXJ0ID4gdGhpcy5sZW5ndGguIERvbmUgaGVyZSB0byBwcmV2ZW50IHBvdGVudGlhbCB1aW50MzJcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cbiAgaWYgKHN0YXJ0ID4gdGhpcy5sZW5ndGgpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCB8fCBlbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoZW5kIDw9IDApIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIC8vIEZvcmNlIGNvZXJjaW9uIHRvIHVpbnQzMi4gVGhpcyB3aWxsIGFsc28gY29lcmNlIGZhbHNleS9OYU4gdmFsdWVzIHRvIDAuXG4gIGVuZCA+Pj49IDBcbiAgc3RhcnQgPj4+PSAwXG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcblxuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1dGYxNmxlU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbi8vIFRoaXMgcHJvcGVydHkgaXMgdXNlZCBieSBgQnVmZmVyLmlzQnVmZmVyYCAoYW5kIHRoZSBgaXMtYnVmZmVyYCBucG0gcGFja2FnZSlcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcbi8vIHJlbGlhYmx5IGluIGEgYnJvd3NlcmlmeSBjb250ZXh0IGJlY2F1c2UgdGhlcmUgY291bGQgYmUgbXVsdGlwbGUgZGlmZmVyZW50XG4vLyBjb3BpZXMgb2YgdGhlICdidWZmZXInIHBhY2thZ2UgaW4gdXNlLiBUaGlzIG1ldGhvZCB3b3JrcyBldmVuIGZvciBCdWZmZXJcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE1NFxuQnVmZmVyLnByb3RvdHlwZS5faXNCdWZmZXIgPSB0cnVlXG5cbmZ1bmN0aW9uIHN3YXAgKGIsIG4sIG0pIHtcbiAgY29uc3QgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgNCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gNCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDIpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgY29uc3QgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9Mb2NhbGVTdHJpbmcgPSBCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nXG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgbGV0IHN0ciA9ICcnXG4gIGNvbnN0IG1heCA9IGV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVNcbiAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5yZXBsYWNlKC8oLnsyfSkvZywgJyQxICcpLnRyaW0oKVxuICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIHJldHVybiAnPEJ1ZmZlciAnICsgc3RyICsgJz4nXG59XG5pZiAoY3VzdG9tSW5zcGVjdFN5bWJvbCkge1xuICBCdWZmZXIucHJvdG90eXBlW2N1c3RvbUluc3BlY3RTeW1ib2xdID0gQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKHRhcmdldCwgc3RhcnQsIGVuZCwgdGhpc1N0YXJ0LCB0aGlzRW5kKSB7XG4gIGlmIChpc0luc3RhbmNlKHRhcmdldCwgVWludDhBcnJheSkpIHtcbiAgICB0YXJnZXQgPSBCdWZmZXIuZnJvbSh0YXJnZXQsIHRhcmdldC5vZmZzZXQsIHRhcmdldC5ieXRlTGVuZ3RoKVxuICB9XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInRhcmdldFwiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXkuICcgK1xuICAgICAgJ1JlY2VpdmVkIHR5cGUgJyArICh0eXBlb2YgdGFyZ2V0KVxuICAgIClcbiAgfVxuXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgc3RhcnQgPSAwXG4gIH1cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5kID0gdGFyZ2V0ID8gdGFyZ2V0Lmxlbmd0aCA6IDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzU3RhcnQgPSAwXG4gIH1cbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNFbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKHN0YXJ0IDwgMCB8fCBlbmQgPiB0YXJnZXQubGVuZ3RoIHx8IHRoaXNTdGFydCA8IDAgfHwgdGhpc0VuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ291dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQgJiYgc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDBcbiAgfVxuICBpZiAodGhpc1N0YXJ0ID49IHRoaXNFbmQpIHtcbiAgICByZXR1cm4gLTFcbiAgfVxuICBpZiAoc3RhcnQgPj0gZW5kKSB7XG4gICAgcmV0dXJuIDFcbiAgfVxuXG4gIHN0YXJ0ID4+Pj0gMFxuICBlbmQgPj4+PSAwXG4gIHRoaXNTdGFydCA+Pj49IDBcbiAgdGhpc0VuZCA+Pj49IDBcblxuICBpZiAodGhpcyA9PT0gdGFyZ2V0KSByZXR1cm4gMFxuXG4gIGxldCB4ID0gdGhpc0VuZCAtIHRoaXNTdGFydFxuICBsZXQgeSA9IGVuZCAtIHN0YXJ0XG4gIGNvbnN0IGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgY29uc3QgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgY29uc3QgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcbiAgICAgIHggPSB0aGlzQ29weVtpXVxuICAgICAgeSA9IHRhcmdldENvcHlbaV1cbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG5cbiAgaWYgKHggPCB5KSByZXR1cm4gLTFcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxuICByZXR1cm4gMFxufVxuXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXG4vLyBPUiB0aGUgbGFzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPD0gYGJ5dGVPZmZzZXRgLlxuLy9cbi8vIEFyZ3VtZW50czpcbi8vIC0gYnVmZmVyIC0gYSBCdWZmZXIgdG8gc2VhcmNoXG4vLyAtIHZhbCAtIGEgc3RyaW5nLCBCdWZmZXIsIG9yIG51bWJlclxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXG4vLyAtIGVuY29kaW5nIC0gYW4gb3B0aW9uYWwgZW5jb2RpbmcsIHJlbGV2YW50IGlzIHZhbCBpcyBhIHN0cmluZ1xuLy8gLSBkaXIgLSB0cnVlIGZvciBpbmRleE9mLCBmYWxzZSBmb3IgbGFzdEluZGV4T2ZcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICAvLyBFbXB0eSBidWZmZXIgbWVhbnMgbm8gbWF0Y2hcbiAgaWYgKGJ1ZmZlci5sZW5ndGggPT09IDApIHJldHVybiAtMVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0XG4gIGlmICh0eXBlb2YgYnl0ZU9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcbiAgICBieXRlT2Zmc2V0ID0gMFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPiAweDdmZmZmZmZmKSB7XG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgLTB4ODAwMDAwMDApIHtcbiAgICBieXRlT2Zmc2V0ID0gLTB4ODAwMDAwMDBcbiAgfVxuICBieXRlT2Zmc2V0ID0gK2J5dGVPZmZzZXQgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgW3ZhbF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH1cblxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxufVxuXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIGxldCBpbmRleFNpemUgPSAxXG4gIGxldCBhcnJMZW5ndGggPSBhcnIubGVuZ3RoXG4gIGxldCB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXG5cbiAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgIGlmIChlbmNvZGluZyA9PT0gJ3VjczInIHx8IGVuY29kaW5nID09PSAndWNzLTInIHx8XG4gICAgICAgIGVuY29kaW5nID09PSAndXRmMTZsZScgfHwgZW5jb2RpbmcgPT09ICd1dGYtMTZsZScpIHtcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xuICAgICAgICByZXR1cm4gLTFcbiAgICAgIH1cbiAgICAgIGluZGV4U2l6ZSA9IDJcbiAgICAgIGFyckxlbmd0aCAvPSAyXG4gICAgICB2YWxMZW5ndGggLz0gMlxuICAgICAgYnl0ZU9mZnNldCAvPSAyXG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVhZCAoYnVmLCBpKSB7XG4gICAgaWYgKGluZGV4U2l6ZSA9PT0gMSkge1xuICAgICAgcmV0dXJuIGJ1ZltpXVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gYnVmLnJlYWRVSW50MTZCRShpICogaW5kZXhTaXplKVxuICAgIH1cbiAgfVxuXG4gIGxldCBpXG4gIGlmIChkaXIpIHtcbiAgICBsZXQgZm91bmRJbmRleCA9IC0xXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAocmVhZChhcnIsIGkpID09PSByZWFkKHZhbCwgZm91bmRJbmRleCA9PT0gLTEgPyAwIDogaSAtIGZvdW5kSW5kZXgpKSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ID09PSAtMSkgZm91bmRJbmRleCA9IGlcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggIT09IC0xKSBpIC09IGkgLSBmb3VuZEluZGV4XG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYnl0ZU9mZnNldCArIHZhbExlbmd0aCA+IGFyckxlbmd0aCkgYnl0ZU9mZnNldCA9IGFyckxlbmd0aCAtIHZhbExlbmd0aFxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBsZXQgZm91bmQgPSB0cnVlXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IHZhbExlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmIChyZWFkKGFyciwgaSArIGopICE9PSByZWFkKHZhbCwgaikpIHtcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGZvdW5kKSByZXR1cm4gaVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluY2x1ZGVzID0gZnVuY3Rpb24gaW5jbHVkZXMgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgdHJ1ZSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5sYXN0SW5kZXhPZiA9IGZ1bmN0aW9uIGxhc3RJbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBmYWxzZSlcbn1cblxuZnVuY3Rpb24gaGV4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXG4gIGNvbnN0IHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcblxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xuICAgIGxlbmd0aCA9IHN0ckxlbiAvIDJcbiAgfVxuICBsZXQgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBiYXNlNjRXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmMTZsZVRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIHdyaXRlIChzdHJpbmcsIG9mZnNldCwgbGVuZ3RoLCBlbmNvZGluZykge1xuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nKVxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBlbmNvZGluZylcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygb2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gb2Zmc2V0XG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXG4gIH0gZWxzZSBpZiAoaXNGaW5pdGUob2Zmc2V0KSkge1xuICAgIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XG4gICAgICBsZW5ndGggPSBsZW5ndGggPj4+IDBcbiAgICAgIGlmIChlbmNvZGluZyA9PT0gdW5kZWZpbmVkKSBlbmNvZGluZyA9ICd1dGY4J1xuICAgIH0gZWxzZSB7XG4gICAgICBlbmNvZGluZyA9IGxlbmd0aFxuICAgICAgbGVuZ3RoID0gdW5kZWZpbmVkXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcbiAgICApXG4gIH1cblxuICBjb25zdCByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgY29uc3QgcmVzID0gW11cblxuICBsZXQgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgY29uc3QgZmlyc3RCeXRlID0gYnVmW2ldXG4gICAgbGV0IGNvZGVQb2ludCA9IG51bGxcbiAgICBsZXQgYnl0ZXNQZXJTZXF1ZW5jZSA9IChmaXJzdEJ5dGUgPiAweEVGKVxuICAgICAgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKVxuICAgICAgICAgID8gM1xuICAgICAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpXG4gICAgICAgICAgICAgID8gMlxuICAgICAgICAgICAgICA6IDFcblxuICAgIGlmIChpICsgYnl0ZXNQZXJTZXF1ZW5jZSA8PSBlbmQpIHtcbiAgICAgIGxldCBzZWNvbmRCeXRlLCB0aGlyZEJ5dGUsIGZvdXJ0aEJ5dGUsIHRlbXBDb2RlUG9pbnRcblxuICAgICAgc3dpdGNoIChieXRlc1BlclNlcXVlbmNlKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gZmlyc3RCeXRlXG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4MUYpIDw8IDB4NiB8IChzZWNvbmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3Rikge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweEMgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4NiB8ICh0aGlyZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIGNhc2UgNDpcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cbiAgICAgICAgICBmb3VydGhCeXRlID0gYnVmW2kgKyAzXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHgxMiB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHhDIHwgKHRoaXJkQnl0ZSAmIDB4M0YpIDw8IDB4NiB8IChmb3VydGhCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHhGRkZGICYmIHRlbXBDb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIHdlIGRpZCBub3QgZ2VuZXJhdGUgYSB2YWxpZCBjb2RlUG9pbnQgc28gaW5zZXJ0IGFcbiAgICAgIC8vIHJlcGxhY2VtZW50IGNoYXIgKFUrRkZGRCkgYW5kIGFkdmFuY2Ugb25seSAxIGJ5dGVcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxuICAgICAgYnl0ZXNQZXJTZXF1ZW5jZSA9IDFcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA+IDB4RkZGRikge1xuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcbiAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwXG4gICAgICByZXMucHVzaChjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxuICAgIH1cblxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcbiAgICBpICs9IGJ5dGVzUGVyU2VxdWVuY2VcbiAgfVxuXG4gIHJldHVybiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkocmVzKVxufVxuXG4vLyBCYXNlZCBvbiBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMjc0NzI3Mi82ODA3NDIsIHRoZSBicm93c2VyIHdpdGhcbi8vIHRoZSBsb3dlc3QgbGltaXQgaXMgQ2hyb21lLCB3aXRoIDB4MTAwMDAgYXJncy5cbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcbmNvbnN0IE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICBjb25zdCBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGxldCByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGhcblxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIGlmICghZW5kIHx8IGVuZCA8IDAgfHwgZW5kID4gbGVuKSBlbmQgPSBsZW5cblxuICBsZXQgb3V0ID0gJydcbiAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQgKz0gaGV4U2xpY2VMb29rdXBUYWJsZVtidWZbaV1dXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBjb25zdCBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICBsZXQgcmVzID0gJydcbiAgLy8gSWYgYnl0ZXMubGVuZ3RoIGlzIG9kZCwgdGhlIGxhc3QgOCBiaXRzIG11c3QgYmUgaWdub3JlZCAoc2FtZSBhcyBub2RlLmpzKVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGJ5dGVzLmxlbmd0aCAtIDE7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gdGhpcy5sZW5ndGhcbiAgc3RhcnQgPSB+fnN0YXJ0XG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuIDogfn5lbmRcblxuICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgc3RhcnQgKz0gbGVuXG4gICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSAwXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcbiAgICBzdGFydCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IDApIHtcbiAgICBlbmQgKz0gbGVuXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcbiAgfSBlbHNlIGlmIChlbmQgPiBsZW4pIHtcbiAgICBlbmQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICBjb25zdCBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihuZXdCdWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG4gIH1cblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdXG4gIGxldCBtdWwgPSAxXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF0gKiBtdWxcbiAgfVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDggPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDggPSBmdW5jdGlvbiByZWFkVUludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2TEUgPSBmdW5jdGlvbiByZWFkVUludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgOCkgfCB0aGlzW29mZnNldCArIDFdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQzMkxFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkxFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAoKHRoaXNbb2Zmc2V0XSkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpKSArXG4gICAgICAodGhpc1tvZmZzZXQgKyAzXSAqIDB4MTAwMDAwMClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkUgPSBmdW5jdGlvbiByZWFkVUludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcbiAgICAoKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCA4KSB8XG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ1VJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgbG8gPSBmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0XG5cbiAgY29uc3QgaGkgPSB0aGlzWysrb2Zmc2V0XSArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgbGFzdCAqIDIgKiogMjRcblxuICByZXR1cm4gQmlnSW50KGxvKSArIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBoaSA9IGZpcnN0ICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF1cblxuICBjb25zdCBsbyA9IHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdFxuXG4gIHJldHVybiAoQmlnSW50KGhpKSA8PCBCaWdJbnQoMzIpKSArIEJpZ0ludChsbylcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldF1cbiAgbGV0IG11bCA9IDFcbiAgbGV0IGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgaSA9IGJ5dGVMZW5ndGhcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZCRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICBjb25zdCB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRMRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgNF0gK1xuICAgIHRoaXNbb2Zmc2V0ICsgNV0gKiAyICoqIDggK1xuICAgIHRoaXNbb2Zmc2V0ICsgNl0gKiAyICoqIDE2ICtcbiAgICAobGFzdCA8PCAyNCkgLy8gT3ZlcmZsb3dcblxuICByZXR1cm4gKEJpZ0ludCh2YWwpIDw8IEJpZ0ludCgzMikpICtcbiAgICBCaWdJbnQoZmlyc3QgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAyNClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ0ludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gcmVhZEJpZ0ludDY0QkUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCB2YWwgPSAoZmlyc3QgPDwgMjQpICsgLy8gT3ZlcmZsb3dcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludCh0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjQgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIGxhc3QpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnRMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFID0gZnVuY3Rpb24gd3JpdGVVSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludEJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgbGV0IG11bCA9IDFcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkxFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MTZCRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHhmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQzMkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIHdydEJpZ1VJbnQ2NExFIChidWYsIHZhbHVlLCBvZmZzZXQsIG1pbiwgbWF4KSB7XG4gIGNoZWNrSW50QkkodmFsdWUsIG1pbiwgbWF4LCBidWYsIG9mZnNldCwgNylcblxuICBsZXQgbG8gPSBOdW1iZXIodmFsdWUgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIHJldHVybiBvZmZzZXRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0QkUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDddID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA2XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNV0gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDRdID0gbG9cbiAgbGV0IGhpID0gTnVtYmVyKHZhbHVlID4+IEJpZ0ludCgzMikgJiBCaWdJbnQoMHhmZmZmZmZmZikpXG4gIGJ1ZltvZmZzZXQgKyAzXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMl0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCArIDFdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXRdID0gaGlcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ1VJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnVUludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBCaWdJbnQoMCksIEJpZ0ludCgnMHhmZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0QkUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSAwXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY29uc3QgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICBsZXQgc3ViID0gMFxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSArIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHg3ZiwgLTB4ODApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2QkUgPSBmdW5jdGlvbiB3cml0ZUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmZmZmZmZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUJpZ0ludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdJbnQ2NExFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0TEUodGhpcywgdmFsdWUsIG9mZnNldCwgLUJpZ0ludCgnMHg4MDAwMDAwMDAwMDAwMDAwJyksIEJpZ0ludCgnMHg3ZmZmZmZmZmZmZmZmZmZmJykpXG59KVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0QkUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRCRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHRhcmdldCkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHNob3VsZCBiZSBhIEJ1ZmZlcicpXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAoZW5kIDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZUVuZCBvdXQgb2YgYm91bmRzJylcblxuICAvLyBBcmUgd2Ugb29iP1xuICBpZiAoZW5kID4gdGhpcy5sZW5ndGgpIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgPCBlbmQgLSBzdGFydCkge1xuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XG4gIH1cblxuICBjb25zdCBsZW4gPSBlbmQgLSBzdGFydFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAvLyBVc2UgYnVpbHQtaW4gd2hlbiBhdmFpbGFibGUsIG1pc3NpbmcgZnJvbSBJRTExXG4gICAgdGhpcy5jb3B5V2l0aGluKHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKVxuICB9IGVsc2Uge1xuICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgdGFyZ2V0LFxuICAgICAgdGhpcy5zdWJhcnJheShzdGFydCwgZW5kKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IGNvZGUgPSB2YWwuY2hhckNvZGVBdCgwKVxuICAgICAgaWYgKChlbmNvZGluZyA9PT0gJ3V0ZjgnICYmIGNvZGUgPCAxMjgpIHx8XG4gICAgICAgICAgZW5jb2RpbmcgPT09ICdsYXRpbjEnKSB7XG4gICAgICAgIC8vIEZhc3QgcGF0aDogSWYgYHZhbGAgZml0cyBpbnRvIGEgc2luZ2xlIGJ5dGUsIHVzZSB0aGF0IG51bWVyaWMgdmFsdWUuXG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICB2YWwgPSBOdW1iZXIodmFsKVxuICB9XG5cbiAgLy8gSW52YWxpZCByYW5nZXMgYXJlIG5vdCBzZXQgdG8gYSBkZWZhdWx0LCBzbyBjYW4gcmFuZ2UgY2hlY2sgZWFybHkuXG4gIGlmIChzdGFydCA8IDAgfHwgdGhpcy5sZW5ndGggPCBzdGFydCB8fCB0aGlzLmxlbmd0aCA8IGVuZCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKGVuZCA8PSBzdGFydCkge1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICBzdGFydCA9IHN0YXJ0ID4+PiAwXG4gIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gdGhpcy5sZW5ndGggOiBlbmQgPj4+IDBcblxuICBpZiAoIXZhbCkgdmFsID0gMFxuXG4gIGxldCBpXG4gIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIGZvciAoaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICAgIHRoaXNbaV0gPSB2YWxcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgICBjb25zdCBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBpZiAobGVuID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgdmFsdWUgXCInICsgdmFsICtcbiAgICAgICAgJ1wiIGlzIGludmFsaWQgZm9yIGFyZ3VtZW50IFwidmFsdWVcIicpXG4gICAgfVxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIENVU1RPTSBFUlJPUlNcbi8vID09PT09PT09PT09PT1cblxuLy8gU2ltcGxpZmllZCB2ZXJzaW9ucyBmcm9tIE5vZGUsIGNoYW5nZWQgZm9yIEJ1ZmZlci1vbmx5IHVzYWdlXG5jb25zdCBlcnJvcnMgPSB7fVxuZnVuY3Rpb24gRSAoc3ltLCBnZXRNZXNzYWdlLCBCYXNlKSB7XG4gIGVycm9yc1tzeW1dID0gY2xhc3MgTm9kZUVycm9yIGV4dGVuZHMgQmFzZSB7XG4gICAgY29uc3RydWN0b3IgKCkge1xuICAgICAgc3VwZXIoKVxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ21lc3NhZ2UnLCB7XG4gICAgICAgIHZhbHVlOiBnZXRNZXNzYWdlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyksXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgIH0pXG5cbiAgICAgIC8vIEFkZCB0aGUgZXJyb3IgY29kZSB0byB0aGUgbmFtZSB0byBpbmNsdWRlIGl0IGluIHRoZSBzdGFjayB0cmFjZS5cbiAgICAgIHRoaXMubmFtZSA9IGAke3RoaXMubmFtZX0gWyR7c3ltfV1gXG4gICAgICAvLyBBY2Nlc3MgdGhlIHN0YWNrIHRvIGdlbmVyYXRlIHRoZSBlcnJvciBtZXNzYWdlIGluY2x1ZGluZyB0aGUgZXJyb3IgY29kZVxuICAgICAgLy8gZnJvbSB0aGUgbmFtZS5cbiAgICAgIHRoaXMuc3RhY2sgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgICAgIC8vIFJlc2V0IHRoZSBuYW1lIHRvIHRoZSBhY3R1YWwgbmFtZS5cbiAgICAgIGRlbGV0ZSB0aGlzLm5hbWVcbiAgICB9XG5cbiAgICBnZXQgY29kZSAoKSB7XG4gICAgICByZXR1cm4gc3ltXG4gICAgfVxuXG4gICAgc2V0IGNvZGUgKHZhbHVlKSB7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgJ2NvZGUnLCB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9KVxuICAgIH1cblxuICAgIHRvU3RyaW5nICgpIHtcbiAgICAgIHJldHVybiBgJHt0aGlzLm5hbWV9IFske3N5bX1dOiAke3RoaXMubWVzc2FnZX1gXG4gICAgfVxuICB9XG59XG5cbkUoJ0VSUl9CVUZGRVJfT1VUX09GX0JPVU5EUycsXG4gIGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgaWYgKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSBpcyBvdXRzaWRlIG9mIGJ1ZmZlciBib3VuZHNgXG4gICAgfVxuXG4gICAgcmV0dXJuICdBdHRlbXB0IHRvIGFjY2VzcyBtZW1vcnkgb3V0c2lkZSBidWZmZXIgYm91bmRzJ1xuICB9LCBSYW5nZUVycm9yKVxuRSgnRVJSX0lOVkFMSURfQVJHX1RZUEUnLFxuICBmdW5jdGlvbiAobmFtZSwgYWN0dWFsKSB7XG4gICAgcmV0dXJuIGBUaGUgXCIke25hbWV9XCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlci4gUmVjZWl2ZWQgdHlwZSAke3R5cGVvZiBhY3R1YWx9YFxuICB9LCBUeXBlRXJyb3IpXG5FKCdFUlJfT1VUX09GX1JBTkdFJyxcbiAgZnVuY3Rpb24gKHN0ciwgcmFuZ2UsIGlucHV0KSB7XG4gICAgbGV0IG1zZyA9IGBUaGUgdmFsdWUgb2YgXCIke3N0cn1cIiBpcyBvdXQgb2YgcmFuZ2UuYFxuICAgIGxldCByZWNlaXZlZCA9IGlucHV0XG4gICAgaWYgKE51bWJlci5pc0ludGVnZXIoaW5wdXQpICYmIE1hdGguYWJzKGlucHV0KSA+IDIgKiogMzIpIHtcbiAgICAgIHJlY2VpdmVkID0gYWRkTnVtZXJpY2FsU2VwYXJhdG9yKFN0cmluZyhpbnB1dCkpXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgaW5wdXQgPT09ICdiaWdpbnQnKSB7XG4gICAgICByZWNlaXZlZCA9IFN0cmluZyhpbnB1dClcbiAgICAgIGlmIChpbnB1dCA+IEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpIHx8IGlucHV0IDwgLShCaWdJbnQoMikgKiogQmlnSW50KDMyKSkpIHtcbiAgICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IocmVjZWl2ZWQpXG4gICAgICB9XG4gICAgICByZWNlaXZlZCArPSAnbidcbiAgICB9XG4gICAgbXNnICs9IGAgSXQgbXVzdCBiZSAke3JhbmdlfS4gUmVjZWl2ZWQgJHtyZWNlaXZlZH1gXG4gICAgcmV0dXJuIG1zZ1xuICB9LCBSYW5nZUVycm9yKVxuXG5mdW5jdGlvbiBhZGROdW1lcmljYWxTZXBhcmF0b3IgKHZhbCkge1xuICBsZXQgcmVzID0gJydcbiAgbGV0IGkgPSB2YWwubGVuZ3RoXG4gIGNvbnN0IHN0YXJ0ID0gdmFsWzBdID09PSAnLScgPyAxIDogMFxuICBmb3IgKDsgaSA+PSBzdGFydCArIDQ7IGkgLT0gMykge1xuICAgIHJlcyA9IGBfJHt2YWwuc2xpY2UoaSAtIDMsIGkpfSR7cmVzfWBcbiAgfVxuICByZXR1cm4gYCR7dmFsLnNsaWNlKDAsIGkpfSR7cmVzfWBcbn1cblxuLy8gQ0hFQ0sgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT1cblxuZnVuY3Rpb24gY2hlY2tCb3VuZHMgKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGlmIChidWZbb2Zmc2V0XSA9PT0gdW5kZWZpbmVkIHx8IGJ1ZltvZmZzZXQgKyBieXRlTGVuZ3RoXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCBidWYubGVuZ3RoIC0gKGJ5dGVMZW5ndGggKyAxKSlcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja0ludEJJICh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKSB7XG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikge1xuICAgIGNvbnN0IG4gPSB0eXBlb2YgbWluID09PSAnYmlnaW50JyA/ICduJyA6ICcnXG4gICAgbGV0IHJhbmdlXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAzKSB7XG4gICAgICBpZiAobWluID09PSAwIHx8IG1pbiA9PT0gQmlnSW50KDApKSB7XG4gICAgICAgIHJhbmdlID0gYD49IDAke259IGFuZCA8IDIke259ICoqICR7KGJ5dGVMZW5ndGggKyAxKSAqIDh9JHtufWBcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJhbmdlID0gYD49IC0oMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufSkgYW5kIDwgMiAqKiBgICtcbiAgICAgICAgICAgICAgICBgJHsoYnl0ZUxlbmd0aCArIDEpICogOCAtIDF9JHtufWBcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmFuZ2UgPSBgPj0gJHttaW59JHtufSBhbmQgPD0gJHttYXh9JHtufWBcbiAgICB9XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKCd2YWx1ZScsIHJhbmdlLCB2YWx1ZSlcbiAgfVxuICBjaGVja0JvdW5kcyhidWYsIG9mZnNldCwgYnl0ZUxlbmd0aClcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVOdW1iZXIgKHZhbHVlLCBuYW1lKSB7XG4gIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfSU5WQUxJRF9BUkdfVFlQRShuYW1lLCAnbnVtYmVyJywgdmFsdWUpXG4gIH1cbn1cblxuZnVuY3Rpb24gYm91bmRzRXJyb3IgKHZhbHVlLCBsZW5ndGgsIHR5cGUpIHtcbiAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgIHZhbGlkYXRlTnVtYmVyKHZhbHVlLCB0eXBlKVxuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLCAnYW4gaW50ZWdlcicsIHZhbHVlKVxuICB9XG5cbiAgaWYgKGxlbmd0aCA8IDApIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9CVUZGRVJfT1VUX09GX0JPVU5EUygpXG4gIH1cblxuICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UodHlwZSB8fCAnb2Zmc2V0JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGA+PSAke3R5cGUgPyAxIDogMH0gYW5kIDw9ICR7bGVuZ3RofWAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSlcbn1cblxuLy8gSEVMUEVSIEZVTkNUSU9OU1xuLy8gPT09PT09PT09PT09PT09PVxuXG5jb25zdCBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHRha2VzIGVxdWFsIHNpZ25zIGFzIGVuZCBvZiB0aGUgQmFzZTY0IGVuY29kaW5nXG4gIHN0ciA9IHN0ci5zcGxpdCgnPScpWzBdXG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgbGV0IGNvZGVQb2ludFxuICBjb25zdCBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIGxldCBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICBjb25zdCBieXRlcyA9IFtdXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvZGVQb2ludCA9IHN0cmluZy5jaGFyQ29kZUF0KGkpXG5cbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XG4gICAgaWYgKGNvZGVQb2ludCA+IDB4RDdGRiAmJiBjb2RlUG9pbnQgPCAweEUwMDApIHtcbiAgICAgIC8vIGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcbiAgICAgICAgLy8gbm8gbGVhZCB5ZXRcbiAgICAgICAgaWYgKGNvZGVQb2ludCA+IDB4REJGRikge1xuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcbiAgICAgICAgICAvLyB1bnBhaXJlZCBsZWFkXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweERDMDApIHtcbiAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gdmFsaWQgc3Vycm9nYXRlIHBhaXJcbiAgICAgIGNvZGVQb2ludCA9IChsZWFkU3Vycm9nYXRlIC0gMHhEODAwIDw8IDEwIHwgY29kZVBvaW50IC0gMHhEQzAwKSArIDB4MTAwMDBcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcbiAgICAgIC8vIHZhbGlkIGJtcCBjaGFyLCBidXQgbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgIH1cblxuICAgIGxlYWRTdXJyb2dhdGUgPSBudWxsXG5cbiAgICAvLyBlbmNvZGUgdXRmOFxuICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goY29kZVBvaW50KVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiB8IDB4QzAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgfCAweEUwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSA0KSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweEMgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpVG9CeXRlcyAoc3RyKSB7XG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgbGV0IGMsIGhpLCBsb1xuICBjb25zdCBieXRlQXJyYXkgPSBbXVxuICBmb3IgKGxldCBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGlmICgoaSArIG9mZnNldCA+PSBkc3QubGVuZ3RoKSB8fCAoaSA+PSBzcmMubGVuZ3RoKSkgYnJlYWtcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cbiAgfVxuICByZXR1cm4gaVxufVxuXG4vLyBBcnJheUJ1ZmZlciBvciBVaW50OEFycmF5IG9iamVjdHMgZnJvbSBvdGhlciBjb250ZXh0cyAoaS5lLiBpZnJhbWVzKSBkbyBub3QgcGFzc1xuLy8gdGhlIGBpbnN0YW5jZW9mYCBjaGVjayBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyBvZiB0aGF0IHR5cGUuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzSW5zdGFuY2UgKG9iaiwgdHlwZSkge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgdHlwZSB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSAhPSBudWxsICYmXG4gICAgICBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gdHlwZS5uYW1lKVxufVxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICAvLyBGb3IgSUUxMSBzdXBwb3J0XG4gIHJldHVybiBvYmogIT09IG9iaiAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXNlbGYtY29tcGFyZVxufVxuXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlIGZvciBgdG9TdHJpbmcoJ2hleCcpYFxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMjE5XG5jb25zdCBoZXhTbGljZUxvb2t1cFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcbiAgY29uc3QgYWxwaGFiZXQgPSAnMDEyMzQ1Njc4OWFiY2RlZidcbiAgY29uc3QgdGFibGUgPSBuZXcgQXJyYXkoMjU2KVxuICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyArK2kpIHtcbiAgICBjb25zdCBpMTYgPSBpICogMTZcbiAgICBmb3IgKGxldCBqID0gMDsgaiA8IDE2OyArK2opIHtcbiAgICAgIHRhYmxlW2kxNiArIGpdID0gYWxwaGFiZXRbaV0gKyBhbHBoYWJldFtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gdGFibGVcbn0pKClcblxuLy8gUmV0dXJuIG5vdCBmdW5jdGlvbiB3aXRoIEVycm9yIGlmIEJpZ0ludCBub3Qgc3VwcG9ydGVkXG5mdW5jdGlvbiBkZWZpbmVCaWdJbnRNZXRob2QgKGZuKSB7XG4gIHJldHVybiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgOiBmblxufVxuXG5mdW5jdGlvbiBCdWZmZXJCaWdJbnROb3REZWZpbmVkICgpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdCaWdJbnQgbm90IHN1cHBvcnRlZCcpXG59XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuY29uc3QgbWFzayA9IChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpID0+IHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59O1xuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmNvbnN0IHVubWFzayA9IChidWZmZXIsIG1hc2spID0+IHtcbiAgLy8gUmVxdWlyZWQgdW50aWwgaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy85MDA2IGlzIHJlc29sdmVkLlxuICBjb25zdCBsZW5ndGggPSBidWZmZXIubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHsgbWFzaywgdW5tYXNrIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKTtcbn1cbiIsIlxyXG4vKipcclxuICogRXhwb3NlIGBFbWl0dGVyYC5cclxuICovXHJcblxyXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICBtb2R1bGUuZXhwb3J0cyA9IEVtaXR0ZXI7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBJbml0aWFsaXplIGEgbmV3IGBFbWl0dGVyYC5cclxuICpcclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5mdW5jdGlvbiBFbWl0dGVyKG9iaikge1xyXG4gIGlmIChvYmopIHJldHVybiBtaXhpbihvYmopO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIE1peGluIHRoZSBlbWl0dGVyIHByb3BlcnRpZXMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmpcclxuICogQHJldHVybiB7T2JqZWN0fVxyXG4gKiBAYXBpIHByaXZhdGVcclxuICovXHJcblxyXG5mdW5jdGlvbiBtaXhpbihvYmopIHtcclxuICBmb3IgKHZhciBrZXkgaW4gRW1pdHRlci5wcm90b3R5cGUpIHtcclxuICAgIG9ialtrZXldID0gRW1pdHRlci5wcm90b3R5cGVba2V5XTtcclxuICB9XHJcbiAgcmV0dXJuIG9iajtcclxufVxyXG5cclxuLyoqXHJcbiAqIExpc3RlbiBvbiB0aGUgZ2l2ZW4gYGV2ZW50YCB3aXRoIGBmbmAuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLm9uID1cclxuRW1pdHRlci5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG4gICh0aGlzLl9jYWxsYmFja3NbJyQnICsgZXZlbnRdID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXSlcclxuICAgIC5wdXNoKGZuKTtcclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBBZGRzIGFuIGBldmVudGAgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGludm9rZWQgYSBzaW5nbGVcclxuICogdGltZSB0aGVuIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZC5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXHJcbiAqIEByZXR1cm4ge0VtaXR0ZXJ9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKGV2ZW50LCBmbil7XHJcbiAgZnVuY3Rpb24gb24oKSB7XHJcbiAgICB0aGlzLm9mZihldmVudCwgb24pO1xyXG4gICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICB9XHJcblxyXG4gIG9uLmZuID0gZm47XHJcbiAgdGhpcy5vbihldmVudCwgb24pO1xyXG4gIHJldHVybiB0aGlzO1xyXG59O1xyXG5cclxuLyoqXHJcbiAqIFJlbW92ZSB0aGUgZ2l2ZW4gY2FsbGJhY2sgZm9yIGBldmVudGAgb3IgYWxsXHJcbiAqIHJlZ2lzdGVyZWQgY2FsbGJhY2tzLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cclxuICogQHJldHVybiB7RW1pdHRlcn1cclxuICogQGFwaSBwdWJsaWNcclxuICovXHJcblxyXG5FbWl0dGVyLnByb3RvdHlwZS5vZmYgPVxyXG5FbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XHJcbkVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbihldmVudCwgZm4pe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuXHJcbiAgLy8gYWxsXHJcbiAgaWYgKDAgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgdGhpcy5fY2FsbGJhY2tzID0ge307XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHNwZWNpZmljIGV2ZW50XHJcbiAgdmFyIGNhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgaWYgKCFjYWxsYmFja3MpIHJldHVybiB0aGlzO1xyXG5cclxuICAvLyByZW1vdmUgYWxsIGhhbmRsZXJzXHJcbiAgaWYgKDEgPT0gYXJndW1lbnRzLmxlbmd0aCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgICByZXR1cm4gdGhpcztcclxuICB9XHJcblxyXG4gIC8vIHJlbW92ZSBzcGVjaWZpYyBoYW5kbGVyXHJcbiAgdmFyIGNiO1xyXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICBjYiA9IGNhbGxiYWNrc1tpXTtcclxuICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XHJcbiAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbiAgICAgIGJyZWFrO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLy8gUmVtb3ZlIGV2ZW50IHNwZWNpZmljIGFycmF5cyBmb3IgZXZlbnQgdHlwZXMgdGhhdCBub1xyXG4gIC8vIG9uZSBpcyBzdWJzY3JpYmVkIGZvciB0byBhdm9pZCBtZW1vcnkgbGVhay5cclxuICBpZiAoY2FsbGJhY2tzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1snJCcgKyBldmVudF07XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbWl0IGBldmVudGAgd2l0aCB0aGUgZ2l2ZW4gYXJncy5cclxuICpcclxuICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50XHJcbiAqIEBwYXJhbSB7TWl4ZWR9IC4uLlxyXG4gKiBAcmV0dXJuIHtFbWl0dGVyfVxyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbihldmVudCl7XHJcbiAgdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xyXG5cclxuICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSlcclxuICAgICwgY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XTtcclxuXHJcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xyXG4gIH1cclxuXHJcbiAgaWYgKGNhbGxiYWNrcykge1xyXG4gICAgY2FsbGJhY2tzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xyXG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNhbGxiYWNrcy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xyXG4gICAgICBjYWxsYmFja3NbaV0uYXBwbHkodGhpcywgYXJncyk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdGhpcztcclxufTtcclxuXHJcbi8qKlxyXG4gKiBSZXR1cm4gYXJyYXkgb2YgY2FsbGJhY2tzIGZvciBgZXZlbnRgLlxyXG4gKlxyXG4gKiBAcGFyYW0ge1N0cmluZ30gZXZlbnRcclxuICogQHJldHVybiB7QXJyYXl9XHJcbiAqIEBhcGkgcHVibGljXHJcbiAqL1xyXG5cclxuRW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24oZXZlbnQpe1xyXG4gIHRoaXMuX2NhbGxiYWNrcyA9IHRoaXMuX2NhbGxiYWNrcyB8fCB7fTtcclxuICByZXR1cm4gdGhpcy5fY2FsbGJhY2tzWyckJyArIGV2ZW50XSB8fCBbXTtcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDaGVjayBpZiB0aGlzIGVtaXR0ZXIgaGFzIGBldmVudGAgaGFuZGxlcnMuXHJcbiAqXHJcbiAqIEBwYXJhbSB7U3RyaW5nfSBldmVudFxyXG4gKiBAcmV0dXJuIHtCb29sZWFufVxyXG4gKiBAYXBpIHB1YmxpY1xyXG4gKi9cclxuXHJcbkVtaXR0ZXIucHJvdG90eXBlLmhhc0xpc3RlbmVycyA9IGZ1bmN0aW9uKGV2ZW50KXtcclxuICByZXR1cm4gISEgdGhpcy5saXN0ZW5lcnMoZXZlbnQpLmxlbmd0aDtcclxufTtcclxuIiwiLyohXG4gKiBjb29raWVcbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgUm9tYW4gU2h0eWxtYW5cbiAqIENvcHlyaWdodChjKSAyMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5wYXJzZSA9IHBhcnNlO1xuZXhwb3J0cy5zZXJpYWxpemUgPSBzZXJpYWxpemU7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGRlY29kZSA9IGRlY29kZVVSSUNvbXBvbmVudDtcbnZhciBlbmNvZGUgPSBlbmNvZGVVUklDb21wb25lbnQ7XG5cbi8qKlxuICogUmVnRXhwIHRvIG1hdGNoIGZpZWxkLWNvbnRlbnQgaW4gUkZDIDcyMzAgc2VjIDMuMlxuICpcbiAqIGZpZWxkLWNvbnRlbnQgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiBmaWVsZC12Y2hhciAgID0gVkNIQVIgLyBvYnMtdGV4dFxuICogb2JzLXRleHQgICAgICA9ICV4ODAtRkZcbiAqL1xuXG52YXIgZmllbGRDb250ZW50UmVnRXhwID0gL15bXFx1MDAwOVxcdTAwMjAtXFx1MDA3ZVxcdTAwODAtXFx1MDBmZl0rJC87XG5cbi8qKlxuICogUGFyc2UgYSBjb29raWUgaGVhZGVyLlxuICpcbiAqIFBhcnNlIHRoZSBnaXZlbiBjb29raWUgaGVhZGVyIHN0cmluZyBpbnRvIGFuIG9iamVjdFxuICogVGhlIG9iamVjdCBoYXMgdGhlIHZhcmlvdXMgY29va2llcyBhcyBrZXlzKG5hbWVzKSA9PiB2YWx1ZXNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge29iamVjdH0gW29wdGlvbnNdXG4gKiBAcmV0dXJuIHtvYmplY3R9XG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcGFyc2Uoc3RyLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IHN0ciBtdXN0IGJlIGEgc3RyaW5nJyk7XG4gIH1cblxuICB2YXIgb2JqID0ge31cbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gIHZhciBwYWlycyA9IHN0ci5zcGxpdCgnOycpXG4gIHZhciBkZWMgPSBvcHQuZGVjb2RlIHx8IGRlY29kZTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHBhaXIgPSBwYWlyc1tpXTtcbiAgICB2YXIgaW5kZXggPSBwYWlyLmluZGV4T2YoJz0nKVxuXG4gICAgLy8gc2tpcCB0aGluZ3MgdGhhdCBkb24ndCBsb29rIGxpa2Uga2V5PXZhbHVlXG4gICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgdmFyIGtleSA9IHBhaXIuc3Vic3RyaW5nKDAsIGluZGV4KS50cmltKClcblxuICAgIC8vIG9ubHkgYXNzaWduIG9uY2VcbiAgICBpZiAodW5kZWZpbmVkID09IG9ialtrZXldKSB7XG4gICAgICB2YXIgdmFsID0gcGFpci5zdWJzdHJpbmcoaW5kZXggKyAxLCBwYWlyLmxlbmd0aCkudHJpbSgpXG5cbiAgICAgIC8vIHF1b3RlZCB2YWx1ZXNcbiAgICAgIGlmICh2YWxbMF0gPT09ICdcIicpIHtcbiAgICAgICAgdmFsID0gdmFsLnNsaWNlKDEsIC0xKVxuICAgICAgfVxuXG4gICAgICBvYmpba2V5XSA9IHRyeURlY29kZSh2YWwsIGRlYyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxuLyoqXG4gKiBTZXJpYWxpemUgZGF0YSBpbnRvIGEgY29va2llIGhlYWRlci5cbiAqXG4gKiBTZXJpYWxpemUgdGhlIGEgbmFtZSB2YWx1ZSBwYWlyIGludG8gYSBjb29raWUgc3RyaW5nIHN1aXRhYmxlIGZvclxuICogaHR0cCBoZWFkZXJzLiBBbiBvcHRpb25hbCBvcHRpb25zIG9iamVjdCBzcGVjaWZpZWQgY29va2llIHBhcmFtZXRlcnMuXG4gKlxuICogc2VyaWFsaXplKCdmb28nLCAnYmFyJywgeyBodHRwT25seTogdHJ1ZSB9KVxuICogICA9PiBcImZvbz1iYXI7IGh0dHBPbmx5XCJcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICogQHBhcmFtIHtzdHJpbmd9IHZhbFxuICogQHBhcmFtIHtvYmplY3R9IFtvcHRpb25zXVxuICogQHJldHVybiB7c3RyaW5nfVxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHNlcmlhbGl6ZShuYW1lLCB2YWwsIG9wdGlvbnMpIHtcbiAgdmFyIG9wdCA9IG9wdGlvbnMgfHwge307XG4gIHZhciBlbmMgPSBvcHQuZW5jb2RlIHx8IGVuY29kZTtcblxuICBpZiAodHlwZW9mIGVuYyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBlbmNvZGUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChuYW1lKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2FyZ3VtZW50IG5hbWUgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHZhbHVlID0gZW5jKHZhbCk7XG5cbiAgaWYgKHZhbHVlICYmICFmaWVsZENvbnRlbnRSZWdFeHAudGVzdCh2YWx1ZSkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdhcmd1bWVudCB2YWwgaXMgaW52YWxpZCcpO1xuICB9XG5cbiAgdmFyIHN0ciA9IG5hbWUgKyAnPScgKyB2YWx1ZTtcblxuICBpZiAobnVsbCAhPSBvcHQubWF4QWdlKSB7XG4gICAgdmFyIG1heEFnZSA9IG9wdC5tYXhBZ2UgLSAwO1xuXG4gICAgaWYgKGlzTmFOKG1heEFnZSkgfHwgIWlzRmluaXRlKG1heEFnZSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBtYXhBZ2UgaXMgaW52YWxpZCcpXG4gICAgfVxuXG4gICAgc3RyICs9ICc7IE1heC1BZ2U9JyArIE1hdGguZmxvb3IobWF4QWdlKTtcbiAgfVxuXG4gIGlmIChvcHQuZG9tYWluKSB7XG4gICAgaWYgKCFmaWVsZENvbnRlbnRSZWdFeHAudGVzdChvcHQuZG9tYWluKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGRvbWFpbiBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IERvbWFpbj0nICsgb3B0LmRvbWFpbjtcbiAgfVxuXG4gIGlmIChvcHQucGF0aCkge1xuICAgIGlmICghZmllbGRDb250ZW50UmVnRXhwLnRlc3Qob3B0LnBhdGgpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gcGF0aCBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgc3RyICs9ICc7IFBhdGg9JyArIG9wdC5wYXRoO1xuICB9XG5cbiAgaWYgKG9wdC5leHBpcmVzKSB7XG4gICAgaWYgKHR5cGVvZiBvcHQuZXhwaXJlcy50b1VUQ1N0cmluZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIGV4cGlyZXMgaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIHN0ciArPSAnOyBFeHBpcmVzPScgKyBvcHQuZXhwaXJlcy50b1VUQ1N0cmluZygpO1xuICB9XG5cbiAgaWYgKG9wdC5odHRwT25seSkge1xuICAgIHN0ciArPSAnOyBIdHRwT25seSc7XG4gIH1cblxuICBpZiAob3B0LnNlY3VyZSkge1xuICAgIHN0ciArPSAnOyBTZWN1cmUnO1xuICB9XG5cbiAgaWYgKG9wdC5zYW1lU2l0ZSkge1xuICAgIHZhciBzYW1lU2l0ZSA9IHR5cGVvZiBvcHQuc2FtZVNpdGUgPT09ICdzdHJpbmcnXG4gICAgICA/IG9wdC5zYW1lU2l0ZS50b0xvd2VyQ2FzZSgpIDogb3B0LnNhbWVTaXRlO1xuXG4gICAgc3dpdGNoIChzYW1lU2l0ZSkge1xuICAgICAgY2FzZSB0cnVlOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsYXgnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9TGF4JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdzdHJpY3QnOlxuICAgICAgICBzdHIgKz0gJzsgU2FtZVNpdGU9U3RyaWN0JztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdub25lJzpcbiAgICAgICAgc3RyICs9ICc7IFNhbWVTaXRlPU5vbmUnO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBzYW1lU2l0ZSBpcyBpbnZhbGlkJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHN0cjtcbn1cblxuLyoqXG4gKiBUcnkgZGVjb2RpbmcgYSBzdHJpbmcgdXNpbmcgYSBkZWNvZGluZyBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBkZWNvZGVcbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gdHJ5RGVjb2RlKHN0ciwgZGVjb2RlKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGRlY29kZShzdHIpO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxufVxuIiwiKGZ1bmN0aW9uICgpIHtcblxuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIGFzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcbiAgdmFyIHZhcnkgPSByZXF1aXJlKCd2YXJ5Jyk7XG5cbiAgdmFyIGRlZmF1bHRzID0ge1xuICAgIG9yaWdpbjogJyonLFxuICAgIG1ldGhvZHM6ICdHRVQsSEVBRCxQVVQsUEFUQ0gsUE9TVCxERUxFVEUnLFxuICAgIHByZWZsaWdodENvbnRpbnVlOiBmYWxzZSxcbiAgICBvcHRpb25zU3VjY2Vzc1N0YXR1czogMjA0XG4gIH07XG5cbiAgZnVuY3Rpb24gaXNTdHJpbmcocykge1xuICAgIHJldHVybiB0eXBlb2YgcyA9PT0gJ3N0cmluZycgfHwgcyBpbnN0YW5jZW9mIFN0cmluZztcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzT3JpZ2luQWxsb3dlZChvcmlnaW4sIGFsbG93ZWRPcmlnaW4pIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhbGxvd2VkT3JpZ2luKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxvd2VkT3JpZ2luLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChpc09yaWdpbkFsbG93ZWQob3JpZ2luLCBhbGxvd2VkT3JpZ2luW2ldKSkge1xuICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhhbGxvd2VkT3JpZ2luKSkge1xuICAgICAgcmV0dXJuIG9yaWdpbiA9PT0gYWxsb3dlZE9yaWdpbjtcbiAgICB9IGVsc2UgaWYgKGFsbG93ZWRPcmlnaW4gaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJldHVybiBhbGxvd2VkT3JpZ2luLnRlc3Qob3JpZ2luKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuICEhYWxsb3dlZE9yaWdpbjtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb25maWd1cmVPcmlnaW4ob3B0aW9ucywgcmVxKSB7XG4gICAgdmFyIHJlcXVlc3RPcmlnaW4gPSByZXEuaGVhZGVycy5vcmlnaW4sXG4gICAgICBoZWFkZXJzID0gW10sXG4gICAgICBpc0FsbG93ZWQ7XG5cbiAgICBpZiAoIW9wdGlvbnMub3JpZ2luIHx8IG9wdGlvbnMub3JpZ2luID09PSAnKicpIHtcbiAgICAgIC8vIGFsbG93IGFueSBvcmlnaW5cbiAgICAgIGhlYWRlcnMucHVzaChbe1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1PcmlnaW4nLFxuICAgICAgICB2YWx1ZTogJyonXG4gICAgICB9XSk7XG4gICAgfSBlbHNlIGlmIChpc1N0cmluZyhvcHRpb25zLm9yaWdpbikpIHtcbiAgICAgIC8vIGZpeGVkIG9yaWdpblxuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LU9yaWdpbicsXG4gICAgICAgIHZhbHVlOiBvcHRpb25zLm9yaWdpblxuICAgICAgfV0pO1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ1ZhcnknLFxuICAgICAgICB2YWx1ZTogJ09yaWdpbidcbiAgICAgIH1dKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBbGxvd2VkID0gaXNPcmlnaW5BbGxvd2VkKHJlcXVlc3RPcmlnaW4sIG9wdGlvbnMub3JpZ2luKTtcbiAgICAgIC8vIHJlZmxlY3Qgb3JpZ2luXG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctT3JpZ2luJyxcbiAgICAgICAgdmFsdWU6IGlzQWxsb3dlZCA/IHJlcXVlc3RPcmlnaW4gOiBmYWxzZVxuICAgICAgfV0pO1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ1ZhcnknLFxuICAgICAgICB2YWx1ZTogJ09yaWdpbidcbiAgICAgIH1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1ldGhvZHMob3B0aW9ucykge1xuICAgIHZhciBtZXRob2RzID0gb3B0aW9ucy5tZXRob2RzO1xuICAgIGlmIChtZXRob2RzLmpvaW4pIHtcbiAgICAgIG1ldGhvZHMgPSBvcHRpb25zLm1ldGhvZHMuam9pbignLCcpOyAvLyAubWV0aG9kcyBpcyBhbiBhcnJheSwgc28gdHVybiBpdCBpbnRvIGEgc3RyaW5nXG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1BbGxvdy1NZXRob2RzJyxcbiAgICAgIHZhbHVlOiBtZXRob2RzXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUNyZWRlbnRpYWxzKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5jcmVkZW50aWFscyA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAga2V5OiAnQWNjZXNzLUNvbnRyb2wtQWxsb3ctQ3JlZGVudGlhbHMnLFxuICAgICAgICB2YWx1ZTogJ3RydWUnXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUFsbG93ZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkge1xuICAgIHZhciBhbGxvd2VkSGVhZGVycyA9IG9wdGlvbnMuYWxsb3dlZEhlYWRlcnMgfHwgb3B0aW9ucy5oZWFkZXJzO1xuICAgIHZhciBoZWFkZXJzID0gW107XG5cbiAgICBpZiAoIWFsbG93ZWRIZWFkZXJzKSB7XG4gICAgICBhbGxvd2VkSGVhZGVycyA9IHJlcS5oZWFkZXJzWydhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LWhlYWRlcnMnXTsgLy8gLmhlYWRlcnMgd2Fzbid0IHNwZWNpZmllZCwgc28gcmVmbGVjdCB0aGUgcmVxdWVzdCBoZWFkZXJzXG4gICAgICBoZWFkZXJzLnB1c2goW3tcbiAgICAgICAga2V5OiAnVmFyeScsXG4gICAgICAgIHZhbHVlOiAnQWNjZXNzLUNvbnRyb2wtUmVxdWVzdC1IZWFkZXJzJ1xuICAgICAgfV0pO1xuICAgIH0gZWxzZSBpZiAoYWxsb3dlZEhlYWRlcnMuam9pbikge1xuICAgICAgYWxsb3dlZEhlYWRlcnMgPSBhbGxvd2VkSGVhZGVycy5qb2luKCcsJyk7IC8vIC5oZWFkZXJzIGlzIGFuIGFycmF5LCBzbyB0dXJuIGl0IGludG8gYSBzdHJpbmdcbiAgICB9XG4gICAgaWYgKGFsbG93ZWRIZWFkZXJzICYmIGFsbG93ZWRIZWFkZXJzLmxlbmd0aCkge1xuICAgICAgaGVhZGVycy5wdXNoKFt7XG4gICAgICAgIGtleTogJ0FjY2Vzcy1Db250cm9sLUFsbG93LUhlYWRlcnMnLFxuICAgICAgICB2YWx1ZTogYWxsb3dlZEhlYWRlcnNcbiAgICAgIH1dKTtcbiAgICB9XG5cbiAgICByZXR1cm4gaGVhZGVycztcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZUV4cG9zZWRIZWFkZXJzKG9wdGlvbnMpIHtcbiAgICB2YXIgaGVhZGVycyA9IG9wdGlvbnMuZXhwb3NlZEhlYWRlcnM7XG4gICAgaWYgKCFoZWFkZXJzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKGhlYWRlcnMuam9pbikge1xuICAgICAgaGVhZGVycyA9IGhlYWRlcnMuam9pbignLCcpOyAvLyAuaGVhZGVycyBpcyBhbiBhcnJheSwgc28gdHVybiBpdCBpbnRvIGEgc3RyaW5nXG4gICAgfVxuICAgIGlmIChoZWFkZXJzICYmIGhlYWRlcnMubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1FeHBvc2UtSGVhZGVycycsXG4gICAgICAgIHZhbHVlOiBoZWFkZXJzXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNvbmZpZ3VyZU1heEFnZShvcHRpb25zKSB7XG4gICAgdmFyIG1heEFnZSA9ICh0eXBlb2Ygb3B0aW9ucy5tYXhBZ2UgPT09ICdudW1iZXInIHx8IG9wdGlvbnMubWF4QWdlKSAmJiBvcHRpb25zLm1heEFnZS50b1N0cmluZygpXG4gICAgaWYgKG1heEFnZSAmJiBtYXhBZ2UubGVuZ3RoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBrZXk6ICdBY2Nlc3MtQ29udHJvbC1NYXgtQWdlJyxcbiAgICAgICAgdmFsdWU6IG1heEFnZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBhcHBseUhlYWRlcnMoaGVhZGVycywgcmVzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIG4gPSBoZWFkZXJzLmxlbmd0aDsgaSA8IG47IGkrKykge1xuICAgICAgdmFyIGhlYWRlciA9IGhlYWRlcnNbaV07XG4gICAgICBpZiAoaGVhZGVyKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGhlYWRlcikpIHtcbiAgICAgICAgICBhcHBseUhlYWRlcnMoaGVhZGVyLCByZXMpO1xuICAgICAgICB9IGVsc2UgaWYgKGhlYWRlci5rZXkgPT09ICdWYXJ5JyAmJiBoZWFkZXIudmFsdWUpIHtcbiAgICAgICAgICB2YXJ5KHJlcywgaGVhZGVyLnZhbHVlKTtcbiAgICAgICAgfSBlbHNlIGlmIChoZWFkZXIudmFsdWUpIHtcbiAgICAgICAgICByZXMuc2V0SGVhZGVyKGhlYWRlci5rZXksIGhlYWRlci52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBjb3JzKG9wdGlvbnMsIHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgdmFyIGhlYWRlcnMgPSBbXSxcbiAgICAgIG1ldGhvZCA9IHJlcS5tZXRob2QgJiYgcmVxLm1ldGhvZC50b1VwcGVyQ2FzZSAmJiByZXEubWV0aG9kLnRvVXBwZXJDYXNlKCk7XG5cbiAgICBpZiAobWV0aG9kID09PSAnT1BUSU9OUycpIHtcbiAgICAgIC8vIHByZWZsaWdodFxuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU9yaWdpbihvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVDcmVkZW50aWFscyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVNZXRob2RzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZUFsbG93ZWRIZWFkZXJzKG9wdGlvbnMsIHJlcSkpO1xuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU1heEFnZShvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVFeHBvc2VkSGVhZGVycyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGFwcGx5SGVhZGVycyhoZWFkZXJzLCByZXMpO1xuXG4gICAgICBpZiAob3B0aW9ucy5wcmVmbGlnaHRDb250aW51ZSkge1xuICAgICAgICBuZXh0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBTYWZhcmkgKGFuZCBwb3RlbnRpYWxseSBvdGhlciBicm93c2VycykgbmVlZCBjb250ZW50LWxlbmd0aCAwLFxuICAgICAgICAvLyAgIGZvciAyMDQgb3IgdGhleSBqdXN0IGhhbmcgd2FpdGluZyBmb3IgYSBib2R5XG4gICAgICAgIHJlcy5zdGF0dXNDb2RlID0gb3B0aW9ucy5vcHRpb25zU3VjY2Vzc1N0YXR1cztcbiAgICAgICAgcmVzLnNldEhlYWRlcignQ29udGVudC1MZW5ndGgnLCAnMCcpO1xuICAgICAgICByZXMuZW5kKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGFjdHVhbCByZXNwb25zZVxuICAgICAgaGVhZGVycy5wdXNoKGNvbmZpZ3VyZU9yaWdpbihvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVDcmVkZW50aWFscyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGhlYWRlcnMucHVzaChjb25maWd1cmVFeHBvc2VkSGVhZGVycyhvcHRpb25zLCByZXEpKTtcbiAgICAgIGFwcGx5SGVhZGVycyhoZWFkZXJzLCByZXMpO1xuICAgICAgbmV4dCgpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG1pZGRsZXdhcmVXcmFwcGVyKG8pIHtcbiAgICAvLyBpZiBvcHRpb25zIGFyZSBzdGF0aWMgKGVpdGhlciB2aWEgZGVmYXVsdHMgb3IgY3VzdG9tIG9wdGlvbnMgcGFzc2VkIGluKSwgd3JhcCBpbiBhIGZ1bmN0aW9uXG4gICAgdmFyIG9wdGlvbnNDYWxsYmFjayA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiBvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBvcHRpb25zQ2FsbGJhY2sgPSBvO1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRpb25zQ2FsbGJhY2sgPSBmdW5jdGlvbiAocmVxLCBjYikge1xuICAgICAgICBjYihudWxsLCBvKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGNvcnNNaWRkbGV3YXJlKHJlcSwgcmVzLCBuZXh0KSB7XG4gICAgICBvcHRpb25zQ2FsbGJhY2socmVxLCBmdW5jdGlvbiAoZXJyLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBuZXh0KGVycik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGNvcnNPcHRpb25zID0gYXNzaWduKHt9LCBkZWZhdWx0cywgb3B0aW9ucyk7XG4gICAgICAgICAgdmFyIG9yaWdpbkNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgICBpZiAoY29yc09wdGlvbnMub3JpZ2luICYmIHR5cGVvZiBjb3JzT3B0aW9ucy5vcmlnaW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIG9yaWdpbkNhbGxiYWNrID0gY29yc09wdGlvbnMub3JpZ2luO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29yc09wdGlvbnMub3JpZ2luKSB7XG4gICAgICAgICAgICBvcmlnaW5DYWxsYmFjayA9IGZ1bmN0aW9uIChvcmlnaW4sIGNiKSB7XG4gICAgICAgICAgICAgIGNiKG51bGwsIGNvcnNPcHRpb25zLm9yaWdpbik7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChvcmlnaW5DYWxsYmFjaykge1xuICAgICAgICAgICAgb3JpZ2luQ2FsbGJhY2socmVxLmhlYWRlcnMub3JpZ2luLCBmdW5jdGlvbiAoZXJyMiwgb3JpZ2luKSB7XG4gICAgICAgICAgICAgIGlmIChlcnIyIHx8ICFvcmlnaW4pIHtcbiAgICAgICAgICAgICAgICBuZXh0KGVycjIpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvcnNPcHRpb25zLm9yaWdpbiA9IG9yaWdpbjtcbiAgICAgICAgICAgICAgICBjb3JzKGNvcnNPcHRpb25zLCByZXEsIHJlcywgbmV4dCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLy8gY2FuIHBhc3MgZWl0aGVyIGFuIG9wdGlvbnMgaGFzaCwgYW4gb3B0aW9ucyBkZWxlZ2F0ZSwgb3Igbm90aGluZ1xuICBtb2R1bGUuZXhwb3J0cyA9IG1pZGRsZXdhcmVXcmFwcGVyO1xuXG59KCkpO1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBSID0gdHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnID8gUmVmbGVjdCA6IG51bGxcbnZhciBSZWZsZWN0QXBwbHkgPSBSICYmIHR5cGVvZiBSLmFwcGx5ID09PSAnZnVuY3Rpb24nXG4gID8gUi5hcHBseVxuICA6IGZ1bmN0aW9uIFJlZmxlY3RBcHBseSh0YXJnZXQsIHJlY2VpdmVyLCBhcmdzKSB7XG4gICAgcmV0dXJuIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpO1xuICB9XG5cbnZhciBSZWZsZWN0T3duS2V5c1xuaWYgKFIgJiYgdHlwZW9mIFIub3duS2V5cyA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWZsZWN0T3duS2V5cyA9IFIub3duS2V5c1xufSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldClcbiAgICAgIC5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyh0YXJnZXQpKTtcbiAgfTtcbn0gZWxzZSB7XG4gIFJlZmxlY3RPd25LZXlzID0gZnVuY3Rpb24gUmVmbGVjdE93bktleXModGFyZ2V0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRhcmdldCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFByb2Nlc3NFbWl0V2FybmluZyh3YXJuaW5nKSB7XG4gIGlmIChjb25zb2xlICYmIGNvbnNvbGUud2FybikgY29uc29sZS53YXJuKHdhcm5pbmcpO1xufVxuXG52YXIgTnVtYmVySXNOYU4gPSBOdW1iZXIuaXNOYU4gfHwgZnVuY3Rpb24gTnVtYmVySXNOYU4odmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZTtcbn1cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICBFdmVudEVtaXR0ZXIuaW5pdC5jYWxsKHRoaXMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG5tb2R1bGUuZXhwb3J0cy5vbmNlID0gb25jZTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHNDb3VudCA9IDA7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbmZ1bmN0aW9uIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEZ1bmN0aW9uLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgbGlzdGVuZXIpO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIGlmICh0eXBlb2YgYXJnICE9PSAnbnVtYmVyJyB8fCBhcmcgPCAwIHx8IE51bWJlcklzTmFOKGFyZykpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJkZWZhdWx0TWF4TGlzdGVuZXJzXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIGFyZyArICcuJyk7XG4gICAgfVxuICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gIH1cbn0pO1xuXG5FdmVudEVtaXR0ZXIuaW5pdCA9IGZ1bmN0aW9uKCkge1xuXG4gIGlmICh0aGlzLl9ldmVudHMgPT09IHVuZGVmaW5lZCB8fFxuICAgICAgdGhpcy5fZXZlbnRzID09PSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuX2V2ZW50cykge1xuICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICB9XG5cbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn07XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIHNldE1heExpc3RlbmVycyhuKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgbiA8IDAgfHwgTnVtYmVySXNOYU4obikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIG9mIFwiblwiIGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIuIFJlY2VpdmVkICcgKyBuICsgJy4nKTtcbiAgfVxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIF9nZXRNYXhMaXN0ZW5lcnModGhhdCkge1xuICBpZiAodGhhdC5fbWF4TGlzdGVuZXJzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICByZXR1cm4gdGhhdC5fbWF4TGlzdGVuZXJzO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmdldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uIGdldE1heExpc3RlbmVycygpIHtcbiAgcmV0dXJuIF9nZXRNYXhMaXN0ZW5lcnModGhpcyk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiBlbWl0KHR5cGUpIHtcbiAgdmFyIGFyZ3MgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIGFyZ3MucHVzaChhcmd1bWVudHNbaV0pO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICB2YXIgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PT0gdW5kZWZpbmVkKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID4gMClcbiAgICAgIGVyID0gYXJnc1swXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgLy8gTm90ZTogVGhlIGNvbW1lbnRzIG9uIHRoZSBgdGhyb3dgIGxpbmVzIGFyZSBpbnRlbnRpb25hbCwgdGhleSBzaG93XG4gICAgICAvLyB1cCBpbiBOb2RlJ3Mgb3V0cHV0IGlmIHRoaXMgcmVzdWx0cyBpbiBhbiB1bmhhbmRsZWQgZXhjZXB0aW9uLlxuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfVxuICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmhhbmRsZWQgZXJyb3IuJyArIChlciA/ICcgKCcgKyBlci5tZXNzYWdlICsgJyknIDogJycpKTtcbiAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgIHRocm93IGVycjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgfVxuXG4gIHZhciBoYW5kbGVyID0gZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChoYW5kbGVyID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIFJlZmxlY3RBcHBseShoYW5kbGVyLCB0aGlzLCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgUmVmbGVjdEFwcGx5KGxpc3RlbmVyc1tpXSwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmIChldmVudHMgPT09IHVuZGVmaW5lZCkge1xuICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0YXJnZXQuX2V2ZW50c0NvdW50ID0gMDtcbiAgfSBlbHNlIHtcbiAgICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAgIC8vIGFkZGluZyBpdCB0byB0aGUgbGlzdGVuZXJzLCBmaXJzdCBlbWl0IFwibmV3TGlzdGVuZXJcIi5cbiAgICBpZiAoZXZlbnRzLm5ld0xpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRhcmdldC5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoZXhpc3RpbmcgPT09IHVuZGVmaW5lZCkge1xuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIGV4aXN0aW5nID0gZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gICAgKyt0YXJnZXQuX2V2ZW50c0NvdW50O1xuICB9IGVsc2Uge1xuICAgIGlmICh0eXBlb2YgZXhpc3RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPVxuICAgICAgICBwcmVwZW5kID8gW2xpc3RlbmVyLCBleGlzdGluZ10gOiBbZXhpc3RpbmcsIGxpc3RlbmVyXTtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB9IGVsc2UgaWYgKHByZXBlbmQpIHtcbiAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBleGlzdGluZy5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICAgIG0gPSBfZ2V0TWF4TGlzdGVuZXJzKHRhcmdldCk7XG4gICAgaWYgKG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0gJiYgIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgIC8vIE5vIGVycm9yIGNvZGUgZm9yIHRoaXMgc2luY2UgaXQgaXMgYSBXYXJuaW5nXG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcbiAgICAgIHZhciB3ID0gbmV3IEVycm9yKCdQb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5IGxlYWsgZGV0ZWN0ZWQuICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnICcgKyBTdHJpbmcodHlwZSkgKyAnIGxpc3RlbmVycyAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2FkZGVkLiBVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0Jyk7XG4gICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgIHcuZW1pdHRlciA9IHRhcmdldDtcbiAgICAgIHcudHlwZSA9IHR5cGU7XG4gICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgUHJvY2Vzc0VtaXRXYXJuaW5nKHcpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbiBhZGRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lcjtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIF9hZGRMaXN0ZW5lcih0aGlzLCB0eXBlLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfTtcblxuZnVuY3Rpb24gb25jZVdyYXBwZXIoKSB7XG4gIGlmICghdGhpcy5maXJlZCkge1xuICAgIHRoaXMudGFyZ2V0LnJlbW92ZUxpc3RlbmVyKHRoaXMudHlwZSwgdGhpcy53cmFwRm4pO1xuICAgIHRoaXMuZmlyZWQgPSB0cnVlO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuY2FsbCh0aGlzLnRhcmdldCk7XG4gICAgcmV0dXJuIHRoaXMubGlzdGVuZXIuYXBwbHkodGhpcy50YXJnZXQsIGFyZ3VtZW50cyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gX29uY2VXcmFwKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIHN0YXRlID0geyBmaXJlZDogZmFsc2UsIHdyYXBGbjogdW5kZWZpbmVkLCB0YXJnZXQ6IHRhcmdldCwgdHlwZTogdHlwZSwgbGlzdGVuZXI6IGxpc3RlbmVyIH07XG4gIHZhciB3cmFwcGVkID0gb25jZVdyYXBwZXIuYmluZChzdGF0ZSk7XG4gIHdyYXBwZWQubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgc3RhdGUud3JhcEZuID0gd3JhcHBlZDtcbiAgcmV0dXJuIHdyYXBwZWQ7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UodHlwZSwgbGlzdGVuZXIpIHtcbiAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG4gIHRoaXMub24odHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5wcmVwZW5kT25jZUxpc3RlbmVyID1cbiAgICBmdW5jdGlvbiBwcmVwZW5kT25jZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgICAgIHRoaXMucHJlcGVuZExpc3RlbmVyKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuLy8gRW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmIGFuZCBvbmx5IGlmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICB2YXIgbGlzdCwgZXZlbnRzLCBwb3NpdGlvbiwgaSwgb3JpZ2luYWxMaXN0ZW5lcjtcblxuICAgICAgY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcik7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmIChldmVudHMgPT09IHVuZGVmaW5lZClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGxpc3QgPSBldmVudHNbdHlwZV07XG4gICAgICBpZiAobGlzdCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8IGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBzcGxpY2VPbmUobGlzdCwgcG9zaXRpb24pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKVxuICAgICAgICAgIGV2ZW50c1t0eXBlXSA9IGxpc3RbMF07XG5cbiAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlQWxsTGlzdGVuZXJzKHR5cGUpIHtcbiAgICAgIHZhciBsaXN0ZW5lcnMsIGV2ZW50cywgaTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIH0gZWxzZSBpZiAoZXZlbnRzW3R5cGVdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICBsaXN0ZW5lcnMgPSBldmVudHNbdHlwZV07XG5cbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcbiAgICAgIH0gZWxzZSBpZiAobGlzdGVuZXJzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcbiAgaWYgKGV2bGlzdGVuZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gW107XG5cbiAgaWYgKHR5cGVvZiBldmxpc3RlbmVyID09PSAnZnVuY3Rpb24nKVxuICAgIHJldHVybiB1bndyYXAgPyBbZXZsaXN0ZW5lci5saXN0ZW5lciB8fCBldmxpc3RlbmVyXSA6IFtldmxpc3RlbmVyXTtcblxuICByZXR1cm4gdW53cmFwID9cbiAgICB1bndyYXBMaXN0ZW5lcnMoZXZsaXN0ZW5lcikgOiBhcnJheUNsb25lKGV2bGlzdGVuZXIsIGV2bGlzdGVuZXIubGVuZ3RoKTtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCB0cnVlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmF3TGlzdGVuZXJzID0gZnVuY3Rpb24gcmF3TGlzdGVuZXJzKHR5cGUpIHtcbiAgcmV0dXJuIF9saXN0ZW5lcnModGhpcywgdHlwZSwgZmFsc2UpO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5saXN0ZW5lckNvdW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGlzdGVuZXJDb3VudC5jYWxsKGVtaXR0ZXIsIHR5cGUpO1xuICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVyQ291bnQgPSBsaXN0ZW5lckNvdW50O1xuZnVuY3Rpb24gbGlzdGVuZXJDb3VudCh0eXBlKSB7XG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG5cbiAgaWYgKGV2ZW50cyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIDA7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZXZlbnROYW1lcyA9IGZ1bmN0aW9uIGV2ZW50TmFtZXMoKSB7XG4gIHJldHVybiB0aGlzLl9ldmVudHNDb3VudCA+IDAgPyBSZWZsZWN0T3duS2V5cyh0aGlzLl9ldmVudHMpIDogW107XG59O1xuXG5mdW5jdGlvbiBhcnJheUNsb25lKGFyciwgbikge1xuICB2YXIgY29weSA9IG5ldyBBcnJheShuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyArK2kpXG4gICAgY29weVtpXSA9IGFycltpXTtcbiAgcmV0dXJuIGNvcHk7XG59XG5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKDsgaW5kZXggKyAxIDwgbGlzdC5sZW5ndGg7IGluZGV4KyspXG4gICAgbGlzdFtpbmRleF0gPSBsaXN0W2luZGV4ICsgMV07XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIHVud3JhcExpc3RlbmVycyhhcnIpIHtcbiAgdmFyIHJldCA9IG5ldyBBcnJheShhcnIubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCByZXQubGVuZ3RoOyArK2kpIHtcbiAgICByZXRbaV0gPSBhcnJbaV0ubGlzdGVuZXIgfHwgYXJyW2ldO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIG9uY2UoZW1pdHRlciwgbmFtZSkge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgIGZ1bmN0aW9uIGVycm9yTGlzdGVuZXIoZXJyKSB7XG4gICAgICBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyKG5hbWUsIHJlc29sdmVyKTtcbiAgICAgIHJlamVjdChlcnIpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJlc29sdmVyKCkge1xuICAgICAgaWYgKHR5cGVvZiBlbWl0dGVyLnJlbW92ZUxpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgZXJyb3JMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICByZXNvbHZlKFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgfTtcblxuICAgIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCByZXNvbHZlciwgeyBvbmNlOiB0cnVlIH0pO1xuICAgIGlmIChuYW1lICE9PSAnZXJyb3InKSB7XG4gICAgICBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBlcnJvckxpc3RlbmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRXJyb3JIYW5kbGVySWZFdmVudEVtaXR0ZXIoZW1pdHRlciwgaGFuZGxlciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsICdlcnJvcicsIGhhbmRsZXIsIGZsYWdzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgbmFtZSwgbGlzdGVuZXIsIGZsYWdzKSB7XG4gIGlmICh0eXBlb2YgZW1pdHRlci5vbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICBlbWl0dGVyLm9uY2UobmFtZSwgbGlzdGVuZXIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbWl0dGVyLm9uKG5hbWUsIGxpc3RlbmVyKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIEV2ZW50VGFyZ2V0IGRvZXMgbm90IGhhdmUgYGVycm9yYCBldmVudCBzZW1hbnRpY3MgbGlrZSBOb2RlXG4gICAgLy8gRXZlbnRFbWl0dGVycywgd2UgZG8gbm90IGxpc3RlbiBmb3IgYGVycm9yYCBldmVudHMgaGVyZS5cbiAgICBlbWl0dGVyLmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgZnVuY3Rpb24gd3JhcExpc3RlbmVyKGFyZykge1xuICAgICAgLy8gSUUgZG9lcyBub3QgaGF2ZSBidWlsdGluIGB7IG9uY2U6IHRydWUgfWAgc3VwcG9ydCBzbyB3ZVxuICAgICAgLy8gaGF2ZSB0byBkbyBpdCBtYW51YWxseS5cbiAgICAgIGlmIChmbGFncy5vbmNlKSB7XG4gICAgICAgIGVtaXR0ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihuYW1lLCB3cmFwTGlzdGVuZXIpO1xuICAgICAgfVxuICAgICAgbGlzdGVuZXIoYXJnKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJlbWl0dGVyXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIEV2ZW50RW1pdHRlci4gUmVjZWl2ZWQgdHlwZSAnICsgdHlwZW9mIGVtaXR0ZXIpO1xuICB9XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgPyBzZWxmLkZvcm1EYXRhIDogd2luZG93LkZvcm1EYXRhO1xuIiwiLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbmV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBuQml0cyA9IC03XG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcbiAgdmFyIGQgPSBpc0xFID8gLTEgOiAxXG4gIHZhciBzID0gYnVmZmVyW29mZnNldCArIGldXG5cbiAgaSArPSBkXG5cbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgcyA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gZUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gKGUgKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gKG0gKiAyNTYpICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IChuQnl0ZXMgKiA4KSAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgcnQgPSAobUxlbiA9PT0gMjMgPyBNYXRoLnBvdygyLCAtMjQpIC0gTWF0aC5wb3coMiwgLTc3KSA6IDApXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcbiAgdmFyIGQgPSBpc0xFID8gMSA6IC0xXG4gIHZhciBzID0gdmFsdWUgPCAwIHx8ICh2YWx1ZSA9PT0gMCAmJiAxIC8gdmFsdWUgPCAwKSA/IDEgOiAwXG5cbiAgdmFsdWUgPSBNYXRoLmFicyh2YWx1ZSlcblxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xuICAgIG0gPSBpc05hTih2YWx1ZSkgPyAxIDogMFxuICAgIGUgPSBlTWF4XG4gIH0gZWxzZSB7XG4gICAgZSA9IE1hdGguZmxvb3IoTWF0aC5sb2codmFsdWUpIC8gTWF0aC5MTjIpXG4gICAgaWYgKHZhbHVlICogKGMgPSBNYXRoLnBvdygyLCAtZSkpIDwgMSkge1xuICAgICAgZS0tXG4gICAgICBjICo9IDJcbiAgICB9XG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICB2YWx1ZSArPSBydCAvIGNcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXG4gICAgfVxuICAgIGlmICh2YWx1ZSAqIGMgPj0gMikge1xuICAgICAgZSsrXG4gICAgICBjIC89IDJcbiAgICB9XG5cbiAgICBpZiAoZSArIGVCaWFzID49IGVNYXgpIHtcbiAgICAgIG0gPSAwXG4gICAgICBlID0gZU1heFxuICAgIH0gZWxzZSBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIG0gPSAoKHZhbHVlICogYykgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsIi8qIVxuICogbWltZS1kYlxuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNS0yMDIyIERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9kYi5qc29uJylcbiIsIi8qIVxuICogbWltZS10eXBlc1xuICogQ29weXJpZ2h0KGMpIDIwMTQgSm9uYXRoYW4gT25nXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIGRiID0gcmVxdWlyZSgnbWltZS1kYicpXG52YXIgZXh0bmFtZSA9IHJlcXVpcmUoJ3BhdGgnKS5leHRuYW1lXG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIEVYVFJBQ1RfVFlQRV9SRUdFWFAgPSAvXlxccyooW147XFxzXSopKD86O3xcXHN8JCkvXG52YXIgVEVYVF9UWVBFX1JFR0VYUCA9IC9edGV4dFxcLy9pXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxuZXhwb3J0cy5jaGFyc2V0ID0gY2hhcnNldFxuZXhwb3J0cy5jaGFyc2V0cyA9IHsgbG9va3VwOiBjaGFyc2V0IH1cbmV4cG9ydHMuY29udGVudFR5cGUgPSBjb250ZW50VHlwZVxuZXhwb3J0cy5leHRlbnNpb24gPSBleHRlbnNpb25cbmV4cG9ydHMuZXh0ZW5zaW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbClcbmV4cG9ydHMubG9va3VwID0gbG9va3VwXG5leHBvcnRzLnR5cGVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxuXG4vLyBQb3B1bGF0ZSB0aGUgZXh0ZW5zaW9ucy90eXBlcyBtYXBzXG5wb3B1bGF0ZU1hcHMoZXhwb3J0cy5leHRlbnNpb25zLCBleHBvcnRzLnR5cGVzKVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBjaGFyc2V0IGZvciBhIE1JTUUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZVxuICogQHJldHVybiB7Ym9vbGVhbnxzdHJpbmd9XG4gKi9cblxuZnVuY3Rpb24gY2hhcnNldCAodHlwZSkge1xuICBpZiAoIXR5cGUgfHwgdHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cblxuICAvLyBUT0RPOiB1c2UgbWVkaWEtdHlwZXJcbiAgdmFyIG1hdGNoID0gRVhUUkFDVF9UWVBFX1JFR0VYUC5leGVjKHR5cGUpXG4gIHZhciBtaW1lID0gbWF0Y2ggJiYgZGJbbWF0Y2hbMV0udG9Mb3dlckNhc2UoKV1cblxuICBpZiAobWltZSAmJiBtaW1lLmNoYXJzZXQpIHtcbiAgICByZXR1cm4gbWltZS5jaGFyc2V0XG4gIH1cblxuICAvLyBkZWZhdWx0IHRleHQvKiB0byB1dGYtOFxuICBpZiAobWF0Y2ggJiYgVEVYVF9UWVBFX1JFR0VYUC50ZXN0KG1hdGNoWzFdKSkge1xuICAgIHJldHVybiAnVVRGLTgnXG4gIH1cblxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBmdWxsIENvbnRlbnQtVHlwZSBoZWFkZXIgZ2l2ZW4gYSBNSU1FIHR5cGUgb3IgZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge2Jvb2xlYW58c3RyaW5nfVxuICovXG5cbmZ1bmN0aW9uIGNvbnRlbnRUeXBlIChzdHIpIHtcbiAgLy8gVE9ETzogc2hvdWxkIHRoaXMgZXZlbiBiZSBpbiB0aGlzIG1vZHVsZT9cbiAgaWYgKCFzdHIgfHwgdHlwZW9mIHN0ciAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuXG4gIHZhciBtaW1lID0gc3RyLmluZGV4T2YoJy8nKSA9PT0gLTFcbiAgICA/IGV4cG9ydHMubG9va3VwKHN0cilcbiAgICA6IHN0clxuXG4gIGlmICghbWltZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVE9ETzogdXNlIGNvbnRlbnQtdHlwZSBvciBvdGhlciBtb2R1bGVcbiAgaWYgKG1pbWUuaW5kZXhPZignY2hhcnNldCcpID09PSAtMSkge1xuICAgIHZhciBjaGFyc2V0ID0gZXhwb3J0cy5jaGFyc2V0KG1pbWUpXG4gICAgaWYgKGNoYXJzZXQpIG1pbWUgKz0gJzsgY2hhcnNldD0nICsgY2hhcnNldC50b0xvd2VyQ2FzZSgpXG4gIH1cblxuICByZXR1cm4gbWltZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCBleHRlbnNpb24gZm9yIGEgTUlNRSB0eXBlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBleHRlbnNpb24gKHR5cGUpIHtcbiAgaWYgKCF0eXBlIHx8IHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gVE9ETzogdXNlIG1lZGlhLXR5cGVyXG4gIHZhciBtYXRjaCA9IEVYVFJBQ1RfVFlQRV9SRUdFWFAuZXhlYyh0eXBlKVxuXG4gIC8vIGdldCBleHRlbnNpb25zXG4gIHZhciBleHRzID0gbWF0Y2ggJiYgZXhwb3J0cy5leHRlbnNpb25zW21hdGNoWzFdLnRvTG93ZXJDYXNlKCldXG5cbiAgaWYgKCFleHRzIHx8ICFleHRzLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGV4dHNbMF1cbn1cblxuLyoqXG4gKiBMb29rdXAgdGhlIE1JTUUgdHlwZSBmb3IgYSBmaWxlIHBhdGgvZXh0ZW5zaW9uLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBwYXRoXG4gKiBAcmV0dXJuIHtib29sZWFufHN0cmluZ31cbiAqL1xuXG5mdW5jdGlvbiBsb29rdXAgKHBhdGgpIHtcbiAgaWYgKCFwYXRoIHx8IHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgLy8gZ2V0IHRoZSBleHRlbnNpb24gKFwiZXh0XCIgb3IgXCIuZXh0XCIgb3IgZnVsbCBwYXRoKVxuICB2YXIgZXh0ZW5zaW9uID0gZXh0bmFtZSgneC4nICsgcGF0aClcbiAgICAudG9Mb3dlckNhc2UoKVxuICAgIC5zdWJzdHIoMSlcblxuICBpZiAoIWV4dGVuc2lvbikge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG5cbiAgcmV0dXJuIGV4cG9ydHMudHlwZXNbZXh0ZW5zaW9uXSB8fCBmYWxzZVxufVxuXG4vKipcbiAqIFBvcHVsYXRlIHRoZSBleHRlbnNpb25zIGFuZCB0eXBlcyBtYXBzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwb3B1bGF0ZU1hcHMgKGV4dGVuc2lvbnMsIHR5cGVzKSB7XG4gIC8vIHNvdXJjZSBwcmVmZXJlbmNlIChsZWFzdCAtPiBtb3N0KVxuICB2YXIgcHJlZmVyZW5jZSA9IFsnbmdpbngnLCAnYXBhY2hlJywgdW5kZWZpbmVkLCAnaWFuYSddXG5cbiAgT2JqZWN0LmtleXMoZGIpLmZvckVhY2goZnVuY3Rpb24gZm9yRWFjaE1pbWVUeXBlICh0eXBlKSB7XG4gICAgdmFyIG1pbWUgPSBkYlt0eXBlXVxuICAgIHZhciBleHRzID0gbWltZS5leHRlbnNpb25zXG5cbiAgICBpZiAoIWV4dHMgfHwgIWV4dHMubGVuZ3RoKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICAvLyBtaW1lIC0+IGV4dGVuc2lvbnNcbiAgICBleHRlbnNpb25zW3R5cGVdID0gZXh0c1xuXG4gICAgLy8gZXh0ZW5zaW9uIC0+IG1pbWVcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV4dHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBleHRlbnNpb24gPSBleHRzW2ldXG5cbiAgICAgIGlmICh0eXBlc1tleHRlbnNpb25dKSB7XG4gICAgICAgIHZhciBmcm9tID0gcHJlZmVyZW5jZS5pbmRleE9mKGRiW3R5cGVzW2V4dGVuc2lvbl1dLnNvdXJjZSlcbiAgICAgICAgdmFyIHRvID0gcHJlZmVyZW5jZS5pbmRleE9mKG1pbWUuc291cmNlKVxuXG4gICAgICAgIGlmICh0eXBlc1tleHRlbnNpb25dICE9PSAnYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtJyAmJlxuICAgICAgICAgIChmcm9tID4gdG8gfHwgKGZyb20gPT09IHRvICYmIHR5cGVzW2V4dGVuc2lvbl0uc3Vic3RyKDAsIDEyKSA9PT0gJ2FwcGxpY2F0aW9uLycpKSkge1xuICAgICAgICAgIC8vIHNraXAgdGhlIHJlbWFwcGluZ1xuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHRoZSBleHRlbnNpb24gLT4gbWltZVxuICAgICAgdHlwZXNbZXh0ZW5zaW9uXSA9IHR5cGVcbiAgICB9XG4gIH0pXG59XG4iLCJhc3NlcnQubm90RXF1YWwgPSBub3RFcXVhbFxuYXNzZXJ0Lm5vdE9rID0gbm90T2tcbmFzc2VydC5lcXVhbCA9IGVxdWFsXG5hc3NlcnQub2sgPSBhc3NlcnRcblxubW9kdWxlLmV4cG9ydHMgPSBhc3NlcnRcblxuZnVuY3Rpb24gZXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgPT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90RXF1YWwgKGEsIGIsIG0pIHtcbiAgYXNzZXJ0KGEgIT0gYiwgbSkgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbn1cblxuZnVuY3Rpb24gbm90T2sgKHQsIG0pIHtcbiAgYXNzZXJ0KCF0LCBtKVxufVxuXG5mdW5jdGlvbiBhc3NlcnQgKHQsIG0pIHtcbiAgaWYgKCF0KSB0aHJvdyBuZXcgRXJyb3IobSB8fCAnQXNzZXJ0aW9uRXJyb3InKVxufVxuIiwiLyohXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDEyLTIwMTQgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHJlZmVycmVkQ2hhcnNldHMgPSByZXF1aXJlKCcuL2xpYi9jaGFyc2V0JylcbnZhciBwcmVmZXJyZWRFbmNvZGluZ3MgPSByZXF1aXJlKCcuL2xpYi9lbmNvZGluZycpXG52YXIgcHJlZmVycmVkTGFuZ3VhZ2VzID0gcmVxdWlyZSgnLi9saWIvbGFuZ3VhZ2UnKVxudmFyIHByZWZlcnJlZE1lZGlhVHlwZXMgPSByZXF1aXJlKCcuL2xpYi9tZWRpYVR5cGUnKVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gTmVnb3RpYXRvcjtcbm1vZHVsZS5leHBvcnRzLk5lZ290aWF0b3IgPSBOZWdvdGlhdG9yO1xuXG4vKipcbiAqIENyZWF0ZSBhIE5lZ290aWF0b3IgaW5zdGFuY2UgZnJvbSBhIHJlcXVlc3QuXG4gKiBAcGFyYW0ge29iamVjdH0gcmVxdWVzdFxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIE5lZ290aWF0b3IocmVxdWVzdCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTmVnb3RpYXRvcikpIHtcbiAgICByZXR1cm4gbmV3IE5lZ290aWF0b3IocmVxdWVzdCk7XG4gIH1cblxuICB0aGlzLnJlcXVlc3QgPSByZXF1ZXN0O1xufVxuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5jaGFyc2V0ID0gZnVuY3Rpb24gY2hhcnNldChhdmFpbGFibGUpIHtcbiAgdmFyIHNldCA9IHRoaXMuY2hhcnNldHMoYXZhaWxhYmxlKTtcbiAgcmV0dXJuIHNldCAmJiBzZXRbMF07XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5jaGFyc2V0cyA9IGZ1bmN0aW9uIGNoYXJzZXRzKGF2YWlsYWJsZSkge1xuICByZXR1cm4gcHJlZmVycmVkQ2hhcnNldHModGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ2FjY2VwdC1jaGFyc2V0J10sIGF2YWlsYWJsZSk7XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5lbmNvZGluZyA9IGZ1bmN0aW9uIGVuY29kaW5nKGF2YWlsYWJsZSkge1xuICB2YXIgc2V0ID0gdGhpcy5lbmNvZGluZ3MoYXZhaWxhYmxlKTtcbiAgcmV0dXJuIHNldCAmJiBzZXRbMF07XG59O1xuXG5OZWdvdGlhdG9yLnByb3RvdHlwZS5lbmNvZGluZ3MgPSBmdW5jdGlvbiBlbmNvZGluZ3MoYXZhaWxhYmxlKSB7XG4gIHJldHVybiBwcmVmZXJyZWRFbmNvZGluZ3ModGhpcy5yZXF1ZXN0LmhlYWRlcnNbJ2FjY2VwdC1lbmNvZGluZyddLCBhdmFpbGFibGUpO1xufTtcblxuTmVnb3RpYXRvci5wcm90b3R5cGUubGFuZ3VhZ2UgPSBmdW5jdGlvbiBsYW5ndWFnZShhdmFpbGFibGUpIHtcbiAgdmFyIHNldCA9IHRoaXMubGFuZ3VhZ2VzKGF2YWlsYWJsZSk7XG4gIHJldHVybiBzZXQgJiYgc2V0WzBdO1xufTtcblxuTmVnb3RpYXRvci5wcm90b3R5cGUubGFuZ3VhZ2VzID0gZnVuY3Rpb24gbGFuZ3VhZ2VzKGF2YWlsYWJsZSkge1xuICByZXR1cm4gcHJlZmVycmVkTGFuZ3VhZ2VzKHRoaXMucmVxdWVzdC5oZWFkZXJzWydhY2NlcHQtbGFuZ3VhZ2UnXSwgYXZhaWxhYmxlKTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZSA9IGZ1bmN0aW9uIG1lZGlhVHlwZShhdmFpbGFibGUpIHtcbiAgdmFyIHNldCA9IHRoaXMubWVkaWFUeXBlcyhhdmFpbGFibGUpO1xuICByZXR1cm4gc2V0ICYmIHNldFswXTtcbn07XG5cbk5lZ290aWF0b3IucHJvdG90eXBlLm1lZGlhVHlwZXMgPSBmdW5jdGlvbiBtZWRpYVR5cGVzKGF2YWlsYWJsZSkge1xuICByZXR1cm4gcHJlZmVycmVkTWVkaWFUeXBlcyh0aGlzLnJlcXVlc3QuaGVhZGVycy5hY2NlcHQsIGF2YWlsYWJsZSk7XG59O1xuXG4vLyBCYWNrd2FyZHMgY29tcGF0aWJpbGl0eVxuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkQ2hhcnNldCA9IE5lZ290aWF0b3IucHJvdG90eXBlLmNoYXJzZXQ7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRDaGFyc2V0cyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmNoYXJzZXRzO1xuTmVnb3RpYXRvci5wcm90b3R5cGUucHJlZmVycmVkRW5jb2RpbmcgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5lbmNvZGluZztcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZEVuY29kaW5ncyA9IE5lZ290aWF0b3IucHJvdG90eXBlLmVuY29kaW5ncztcbk5lZ290aWF0b3IucHJvdG90eXBlLnByZWZlcnJlZExhbmd1YWdlID0gTmVnb3RpYXRvci5wcm90b3R5cGUubGFuZ3VhZ2U7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRMYW5ndWFnZXMgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5sYW5ndWFnZXM7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRNZWRpYVR5cGUgPSBOZWdvdGlhdG9yLnByb3RvdHlwZS5tZWRpYVR5cGU7XG5OZWdvdGlhdG9yLnByb3RvdHlwZS5wcmVmZXJyZWRNZWRpYVR5cGVzID0gTmVnb3RpYXRvci5wcm90b3R5cGUubWVkaWFUeXBlcztcbiIsIi8qKlxuICogbmVnb3RpYXRvclxuICogQ29weXJpZ2h0KGMpIDIwMTIgSXNhYWMgWi4gU2NobHVldGVyXG4gKiBDb3B5cmlnaHQoYykgMjAxNCBGZWRlcmljbyBSb21lcm9cbiAqIENvcHlyaWdodChjKSAyMDE0LTIwMTUgRG91Z2xhcyBDaHJpc3RvcGhlciBXaWxzb25cbiAqIE1JVCBMaWNlbnNlZFxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqIEBwdWJsaWNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByZWZlcnJlZENoYXJzZXRzO1xubW9kdWxlLmV4cG9ydHMucHJlZmVycmVkQ2hhcnNldHMgPSBwcmVmZXJyZWRDaGFyc2V0cztcblxuLyoqXG4gKiBNb2R1bGUgdmFyaWFibGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG52YXIgc2ltcGxlQ2hhcnNldFJlZ0V4cCA9IC9eXFxzKihbXlxccztdKylcXHMqKD86OyguKikpPyQvO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBBY2NlcHQtQ2hhcnNldCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0Q2hhcnNldChhY2NlcHQpIHtcbiAgdmFyIGFjY2VwdHMgPSBhY2NlcHQuc3BsaXQoJywnKTtcblxuICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBhY2NlcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGNoYXJzZXQgPSBwYXJzZUNoYXJzZXQoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKGNoYXJzZXQpIHtcbiAgICAgIGFjY2VwdHNbaisrXSA9IGNoYXJzZXQ7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gajtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGNoYXJzZXQgZnJvbSB0aGUgQWNjZXB0LUNoYXJzZXQgaGVhZGVyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUNoYXJzZXQoc3RyLCBpKSB7XG4gIHZhciBtYXRjaCA9IHNpbXBsZUNoYXJzZXRSZWdFeHAuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgY2hhcnNldCA9IG1hdGNoWzFdO1xuICB2YXIgcSA9IDE7XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHZhciBwYXJhbXMgPSBtYXRjaFsyXS5zcGxpdCgnOycpXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBwYXJhbXMubGVuZ3RoOyBqKyspIHtcbiAgICAgIHZhciBwID0gcGFyYW1zW2pdLnRyaW0oKS5zcGxpdCgnPScpO1xuICAgICAgaWYgKHBbMF0gPT09ICdxJykge1xuICAgICAgICBxID0gcGFyc2VGbG9hdChwWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBjaGFyc2V0OiBjaGFyc2V0LFxuICAgIHE6IHEsXG4gICAgaTogaVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJpb3JpdHkgb2YgYSBjaGFyc2V0LlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRDaGFyc2V0UHJpb3JpdHkoY2hhcnNldCwgYWNjZXB0ZWQsIGluZGV4KSB7XG4gIHZhciBwcmlvcml0eSA9IHtvOiAtMSwgcTogMCwgczogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGVjID0gc3BlY2lmeShjaGFyc2V0LCBhY2NlcHRlZFtpXSwgaW5kZXgpO1xuXG4gICAgaWYgKHNwZWMgJiYgKHByaW9yaXR5LnMgLSBzcGVjLnMgfHwgcHJpb3JpdHkucSAtIHNwZWMucSB8fCBwcmlvcml0eS5vIC0gc3BlYy5vKSA8IDApIHtcbiAgICAgIHByaW9yaXR5ID0gc3BlYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgY2hhcnNldC5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeShjaGFyc2V0LCBzcGVjLCBpbmRleCkge1xuICB2YXIgcyA9IDA7XG4gIGlmKHNwZWMuY2hhcnNldC50b0xvd2VyQ2FzZSgpID09PSBjaGFyc2V0LnRvTG93ZXJDYXNlKCkpe1xuICAgIHMgfD0gMTtcbiAgfSBlbHNlIGlmIChzcGVjLmNoYXJzZXQgIT09ICcqJyApIHtcbiAgICByZXR1cm4gbnVsbFxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpOiBpbmRleCxcbiAgICBvOiBzcGVjLmksXG4gICAgcTogc3BlYy5xLFxuICAgIHM6IHNcbiAgfVxufVxuXG4vKipcbiAqIEdldCB0aGUgcHJlZmVycmVkIGNoYXJzZXRzIGZyb20gYW4gQWNjZXB0LUNoYXJzZXQgaGVhZGVyLlxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHByZWZlcnJlZENoYXJzZXRzKGFjY2VwdCwgcHJvdmlkZWQpIHtcbiAgLy8gUkZDIDI2MTYgc2VjIDE0LjI6IG5vIGhlYWRlciA9ICpcbiAgdmFyIGFjY2VwdHMgPSBwYXJzZUFjY2VwdENoYXJzZXQoYWNjZXB0ID09PSB1bmRlZmluZWQgPyAnKicgOiBhY2NlcHQgfHwgJycpO1xuXG4gIGlmICghcHJvdmlkZWQpIHtcbiAgICAvLyBzb3J0ZWQgbGlzdCBvZiBhbGwgY2hhcnNldHNcbiAgICByZXR1cm4gYWNjZXB0c1xuICAgICAgLmZpbHRlcihpc1F1YWxpdHkpXG4gICAgICAuc29ydChjb21wYXJlU3BlY3MpXG4gICAgICAubWFwKGdldEZ1bGxDaGFyc2V0KTtcbiAgfVxuXG4gIHZhciBwcmlvcml0aWVzID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIGdldFByaW9yaXR5KHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGdldENoYXJzZXRQcmlvcml0eSh0eXBlLCBhY2NlcHRzLCBpbmRleCk7XG4gIH0pO1xuXG4gIC8vIHNvcnRlZCBsaXN0IG9mIGFjY2VwdGVkIGNoYXJzZXRzXG4gIHJldHVybiBwcmlvcml0aWVzLmZpbHRlcihpc1F1YWxpdHkpLnNvcnQoY29tcGFyZVNwZWNzKS5tYXAoZnVuY3Rpb24gZ2V0Q2hhcnNldChwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIGNoYXJzZXQgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRGdWxsQ2hhcnNldChzcGVjKSB7XG4gIHJldHVybiBzcGVjLmNoYXJzZXQ7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG4iLCIvKipcbiAqIG5lZ290aWF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyIElzYWFjIFouIFNjaGx1ZXRlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRmVkZXJpY28gUm9tZXJvXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVmZXJyZWRFbmNvZGluZ3M7XG5tb2R1bGUuZXhwb3J0cy5wcmVmZXJyZWRFbmNvZGluZ3MgPSBwcmVmZXJyZWRFbmNvZGluZ3M7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNpbXBsZUVuY29kaW5nUmVnRXhwID0gL15cXHMqKFteXFxzO10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdC1FbmNvZGluZyBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0RW5jb2RpbmcoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG4gIHZhciBoYXNJZGVudGl0eSA9IGZhbHNlO1xuICB2YXIgbWluUXVhbGl0eSA9IDE7XG5cbiAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBlbmNvZGluZyA9IHBhcnNlRW5jb2RpbmcoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICBhY2NlcHRzW2orK10gPSBlbmNvZGluZztcbiAgICAgIGhhc0lkZW50aXR5ID0gaGFzSWRlbnRpdHkgfHwgc3BlY2lmeSgnaWRlbnRpdHknLCBlbmNvZGluZyk7XG4gICAgICBtaW5RdWFsaXR5ID0gTWF0aC5taW4obWluUXVhbGl0eSwgZW5jb2RpbmcucSB8fCAxKTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhhc0lkZW50aXR5KSB7XG4gICAgLypcbiAgICAgKiBJZiBpZGVudGl0eSBkb2Vzbid0IGV4cGxpY2l0bHkgYXBwZWFyIGluIHRoZSBhY2NlcHQtZW5jb2RpbmcgaGVhZGVyLFxuICAgICAqIGl0J3MgYWRkZWQgdG8gdGhlIGxpc3Qgb2YgYWNjZXB0YWJsZSBlbmNvZGluZyB3aXRoIHRoZSBsb3dlc3QgcVxuICAgICAqL1xuICAgIGFjY2VwdHNbaisrXSA9IHtcbiAgICAgIGVuY29kaW5nOiAnaWRlbnRpdHknLFxuICAgICAgcTogbWluUXVhbGl0eSxcbiAgICAgIGk6IGlcbiAgICB9O1xuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gajtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBQYXJzZSBhbiBlbmNvZGluZyBmcm9tIHRoZSBBY2NlcHQtRW5jb2RpbmcgaGVhZGVyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUVuY29kaW5nKHN0ciwgaSkge1xuICB2YXIgbWF0Y2ggPSBzaW1wbGVFbmNvZGluZ1JlZ0V4cC5leGVjKHN0cik7XG4gIGlmICghbWF0Y2gpIHJldHVybiBudWxsO1xuXG4gIHZhciBlbmNvZGluZyA9IG1hdGNoWzFdO1xuICB2YXIgcSA9IDE7XG4gIGlmIChtYXRjaFsyXSkge1xuICAgIHZhciBwYXJhbXMgPSBtYXRjaFsyXS5zcGxpdCgnOycpO1xuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtc1tqXS50cmltKCkuc3BsaXQoJz0nKTtcbiAgICAgIGlmIChwWzBdID09PSAncScpIHtcbiAgICAgICAgcSA9IHBhcnNlRmxvYXQocFsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgIHE6IHEsXG4gICAgaTogaVxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJpb3JpdHkgb2YgYW4gZW5jb2RpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGdldEVuY29kaW5nUHJpb3JpdHkoZW5jb2RpbmcsIGFjY2VwdGVkLCBpbmRleCkge1xuICB2YXIgcHJpb3JpdHkgPSB7bzogLTEsIHE6IDAsIHM6IDB9O1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWNjZXB0ZWQubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc3BlYyA9IHNwZWNpZnkoZW5jb2RpbmcsIGFjY2VwdGVkW2ldLCBpbmRleCk7XG5cbiAgICBpZiAoc3BlYyAmJiAocHJpb3JpdHkucyAtIHNwZWMucyB8fCBwcmlvcml0eS5xIC0gc3BlYy5xIHx8IHByaW9yaXR5Lm8gLSBzcGVjLm8pIDwgMCkge1xuICAgICAgcHJpb3JpdHkgPSBzcGVjO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwcmlvcml0eTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHNwZWNpZmljaXR5IG9mIHRoZSBlbmNvZGluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeShlbmNvZGluZywgc3BlYywgaW5kZXgpIHtcbiAgdmFyIHMgPSAwO1xuICBpZihzcGVjLmVuY29kaW5nLnRvTG93ZXJDYXNlKCkgPT09IGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpe1xuICAgIHMgfD0gMTtcbiAgfSBlbHNlIGlmIChzcGVjLmVuY29kaW5nICE9PSAnKicgKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaTogaW5kZXgsXG4gICAgbzogc3BlYy5pLFxuICAgIHE6IHNwZWMucSxcbiAgICBzOiBzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmZXJyZWQgZW5jb2RpbmdzIGZyb20gYW4gQWNjZXB0LUVuY29kaW5nIGhlYWRlci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwcmVmZXJyZWRFbmNvZGluZ3MoYWNjZXB0LCBwcm92aWRlZCkge1xuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0RW5jb2RpbmcoYWNjZXB0IHx8ICcnKTtcblxuICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgLy8gc29ydGVkIGxpc3Qgb2YgYWxsIGVuY29kaW5nc1xuICAgIHJldHVybiBhY2NlcHRzXG4gICAgICAuZmlsdGVyKGlzUXVhbGl0eSlcbiAgICAgIC5zb3J0KGNvbXBhcmVTcGVjcylcbiAgICAgIC5tYXAoZ2V0RnVsbEVuY29kaW5nKTtcbiAgfVxuXG4gIHZhciBwcmlvcml0aWVzID0gcHJvdmlkZWQubWFwKGZ1bmN0aW9uIGdldFByaW9yaXR5KHR5cGUsIGluZGV4KSB7XG4gICAgcmV0dXJuIGdldEVuY29kaW5nUHJpb3JpdHkodHlwZSwgYWNjZXB0cywgaW5kZXgpO1xuICB9KTtcblxuICAvLyBzb3J0ZWQgbGlzdCBvZiBhY2NlcHRlZCBlbmNvZGluZ3NcbiAgcmV0dXJuIHByaW9yaXRpZXMuZmlsdGVyKGlzUXVhbGl0eSkuc29ydChjb21wYXJlU3BlY3MpLm1hcChmdW5jdGlvbiBnZXRFbmNvZGluZyhwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIGVuY29kaW5nIHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0RnVsbEVuY29kaW5nKHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMuZW5jb2Rpbmc7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG4iLCIvKipcbiAqIG5lZ290aWF0b3JcbiAqIENvcHlyaWdodChjKSAyMDEyIElzYWFjIFouIFNjaGx1ZXRlclxuICogQ29weXJpZ2h0KGMpIDIwMTQgRmVkZXJpY28gUm9tZXJvXG4gKiBDb3B5cmlnaHQoYykgMjAxNC0yMDE1IERvdWdsYXMgQ2hyaXN0b3BoZXIgV2lsc29uXG4gKiBNSVQgTGljZW5zZWRcbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKiBAcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBwcmVmZXJyZWRMYW5ndWFnZXM7XG5tb2R1bGUuZXhwb3J0cy5wcmVmZXJyZWRMYW5ndWFnZXMgPSBwcmVmZXJyZWRMYW5ndWFnZXM7XG5cbi8qKlxuICogTW9kdWxlIHZhcmlhYmxlcy5cbiAqIEBwcml2YXRlXG4gKi9cblxudmFyIHNpbXBsZUxhbmd1YWdlUmVnRXhwID0gL15cXHMqKFteXFxzXFwtO10rKSg/Oi0oW15cXHM7XSspKT9cXHMqKD86OyguKikpPyQvO1xuXG4vKipcbiAqIFBhcnNlIHRoZSBBY2NlcHQtTGFuZ3VhZ2UgaGVhZGVyLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZUFjY2VwdExhbmd1YWdlKGFjY2VwdCkge1xuICB2YXIgYWNjZXB0cyA9IGFjY2VwdC5zcGxpdCgnLCcpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFjY2VwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbGFuZ3VhZ2UgPSBwYXJzZUxhbmd1YWdlKGFjY2VwdHNbaV0udHJpbSgpLCBpKTtcblxuICAgIGlmIChsYW5ndWFnZSkge1xuICAgICAgYWNjZXB0c1tqKytdID0gbGFuZ3VhZ2U7XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gajtcblxuICByZXR1cm4gYWNjZXB0cztcbn1cblxuLyoqXG4gKiBQYXJzZSBhIGxhbmd1YWdlIGZyb20gdGhlIEFjY2VwdC1MYW5ndWFnZSBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTGFuZ3VhZ2Uoc3RyLCBpKSB7XG4gIHZhciBtYXRjaCA9IHNpbXBsZUxhbmd1YWdlUmVnRXhwLmV4ZWMoc3RyKTtcbiAgaWYgKCFtYXRjaCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHByZWZpeCA9IG1hdGNoWzFdXG4gIHZhciBzdWZmaXggPSBtYXRjaFsyXVxuICB2YXIgZnVsbCA9IHByZWZpeFxuXG4gIGlmIChzdWZmaXgpIGZ1bGwgKz0gXCItXCIgKyBzdWZmaXg7XG5cbiAgdmFyIHEgPSAxO1xuICBpZiAobWF0Y2hbM10pIHtcbiAgICB2YXIgcGFyYW1zID0gbWF0Y2hbM10uc3BsaXQoJzsnKVxuICAgIGZvciAodmFyIGogPSAwOyBqIDwgcGFyYW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcCA9IHBhcmFtc1tqXS5zcGxpdCgnPScpO1xuICAgICAgaWYgKHBbMF0gPT09ICdxJykgcSA9IHBhcnNlRmxvYXQocFsxXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBwcmVmaXg6IHByZWZpeCxcbiAgICBzdWZmaXg6IHN1ZmZpeCxcbiAgICBxOiBxLFxuICAgIGk6IGksXG4gICAgZnVsbDogZnVsbFxuICB9O1xufVxuXG4vKipcbiAqIEdldCB0aGUgcHJpb3JpdHkgb2YgYSBsYW5ndWFnZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0TGFuZ3VhZ2VQcmlvcml0eShsYW5ndWFnZSwgYWNjZXB0ZWQsIGluZGV4KSB7XG4gIHZhciBwcmlvcml0eSA9IHtvOiAtMSwgcTogMCwgczogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGVjID0gc3BlY2lmeShsYW5ndWFnZSwgYWNjZXB0ZWRbaV0sIGluZGV4KTtcblxuICAgIGlmIChzcGVjICYmIChwcmlvcml0eS5zIC0gc3BlYy5zIHx8IHByaW9yaXR5LnEgLSBzcGVjLnEgfHwgcHJpb3JpdHkubyAtIHNwZWMubykgPCAwKSB7XG4gICAgICBwcmlvcml0eSA9IHNwZWM7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHByaW9yaXR5O1xufVxuXG4vKipcbiAqIEdldCB0aGUgc3BlY2lmaWNpdHkgb2YgdGhlIGxhbmd1YWdlLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGVjaWZ5KGxhbmd1YWdlLCBzcGVjLCBpbmRleCkge1xuICB2YXIgcCA9IHBhcnNlTGFuZ3VhZ2UobGFuZ3VhZ2UpXG4gIGlmICghcCkgcmV0dXJuIG51bGw7XG4gIHZhciBzID0gMDtcbiAgaWYoc3BlYy5mdWxsLnRvTG93ZXJDYXNlKCkgPT09IHAuZnVsbC50b0xvd2VyQ2FzZSgpKXtcbiAgICBzIHw9IDQ7XG4gIH0gZWxzZSBpZiAoc3BlYy5wcmVmaXgudG9Mb3dlckNhc2UoKSA9PT0gcC5mdWxsLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBzIHw9IDI7XG4gIH0gZWxzZSBpZiAoc3BlYy5mdWxsLnRvTG93ZXJDYXNlKCkgPT09IHAucHJlZml4LnRvTG93ZXJDYXNlKCkpIHtcbiAgICBzIHw9IDE7XG4gIH0gZWxzZSBpZiAoc3BlYy5mdWxsICE9PSAnKicgKSB7XG4gICAgcmV0dXJuIG51bGxcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgaTogaW5kZXgsXG4gICAgbzogc3BlYy5pLFxuICAgIHE6IHNwZWMucSxcbiAgICBzOiBzXG4gIH1cbn07XG5cbi8qKlxuICogR2V0IHRoZSBwcmVmZXJyZWQgbGFuZ3VhZ2VzIGZyb20gYW4gQWNjZXB0LUxhbmd1YWdlIGhlYWRlci5cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBwcmVmZXJyZWRMYW5ndWFnZXMoYWNjZXB0LCBwcm92aWRlZCkge1xuICAvLyBSRkMgMjYxNiBzZWMgMTQuNDogbm8gaGVhZGVyID0gKlxuICB2YXIgYWNjZXB0cyA9IHBhcnNlQWNjZXB0TGFuZ3VhZ2UoYWNjZXB0ID09PSB1bmRlZmluZWQgPyAnKicgOiBhY2NlcHQgfHwgJycpO1xuXG4gIGlmICghcHJvdmlkZWQpIHtcbiAgICAvLyBzb3J0ZWQgbGlzdCBvZiBhbGwgbGFuZ3VhZ2VzXG4gICAgcmV0dXJuIGFjY2VwdHNcbiAgICAgIC5maWx0ZXIoaXNRdWFsaXR5KVxuICAgICAgLnNvcnQoY29tcGFyZVNwZWNzKVxuICAgICAgLm1hcChnZXRGdWxsTGFuZ3VhZ2UpO1xuICB9XG5cbiAgdmFyIHByaW9yaXRpZXMgPSBwcm92aWRlZC5tYXAoZnVuY3Rpb24gZ2V0UHJpb3JpdHkodHlwZSwgaW5kZXgpIHtcbiAgICByZXR1cm4gZ2V0TGFuZ3VhZ2VQcmlvcml0eSh0eXBlLCBhY2NlcHRzLCBpbmRleCk7XG4gIH0pO1xuXG4gIC8vIHNvcnRlZCBsaXN0IG9mIGFjY2VwdGVkIGxhbmd1YWdlc1xuICByZXR1cm4gcHJpb3JpdGllcy5maWx0ZXIoaXNRdWFsaXR5KS5zb3J0KGNvbXBhcmVTcGVjcykubWFwKGZ1bmN0aW9uIGdldExhbmd1YWdlKHByaW9yaXR5KSB7XG4gICAgcmV0dXJuIHByb3ZpZGVkW3ByaW9yaXRpZXMuaW5kZXhPZihwcmlvcml0eSldO1xuICB9KTtcbn1cblxuLyoqXG4gKiBDb21wYXJlIHR3byBzcGVjcy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29tcGFyZVNwZWNzKGEsIGIpIHtcbiAgcmV0dXJuIChiLnEgLSBhLnEpIHx8IChiLnMgLSBhLnMpIHx8IChhLm8gLSBiLm8pIHx8IChhLmkgLSBiLmkpIHx8IDA7XG59XG5cbi8qKlxuICogR2V0IGZ1bGwgbGFuZ3VhZ2Ugc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRGdWxsTGFuZ3VhZ2Uoc3BlYykge1xuICByZXR1cm4gc3BlYy5mdWxsO1xufVxuXG4vKipcbiAqIENoZWNrIGlmIGEgc3BlYyBoYXMgYW55IHF1YWxpdHkuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGlzUXVhbGl0eShzcGVjKSB7XG4gIHJldHVybiBzcGVjLnEgPiAwO1xufVxuIiwiLyoqXG4gKiBuZWdvdGlhdG9yXG4gKiBDb3B5cmlnaHQoYykgMjAxMiBJc2FhYyBaLiBTY2hsdWV0ZXJcbiAqIENvcHlyaWdodChjKSAyMDE0IEZlZGVyaWNvIFJvbWVyb1xuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNSBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICogQHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gcHJlZmVycmVkTWVkaWFUeXBlcztcbm1vZHVsZS5leHBvcnRzLnByZWZlcnJlZE1lZGlhVHlwZXMgPSBwcmVmZXJyZWRNZWRpYVR5cGVzO1xuXG4vKipcbiAqIE1vZHVsZSB2YXJpYWJsZXMuXG4gKiBAcHJpdmF0ZVxuICovXG5cbnZhciBzaW1wbGVNZWRpYVR5cGVSZWdFeHAgPSAvXlxccyooW15cXHNcXC87XSspXFwvKFteO1xcc10rKVxccyooPzo7KC4qKSk/JC87XG5cbi8qKlxuICogUGFyc2UgdGhlIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlQWNjZXB0KGFjY2VwdCkge1xuICB2YXIgYWNjZXB0cyA9IHNwbGl0TWVkaWFUeXBlcyhhY2NlcHQpO1xuXG4gIGZvciAodmFyIGkgPSAwLCBqID0gMDsgaSA8IGFjY2VwdHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWVkaWFUeXBlID0gcGFyc2VNZWRpYVR5cGUoYWNjZXB0c1tpXS50cmltKCksIGkpO1xuXG4gICAgaWYgKG1lZGlhVHlwZSkge1xuICAgICAgYWNjZXB0c1tqKytdID0gbWVkaWFUeXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyaW0gYWNjZXB0c1xuICBhY2NlcHRzLmxlbmd0aCA9IGo7XG5cbiAgcmV0dXJuIGFjY2VwdHM7XG59XG5cbi8qKlxuICogUGFyc2UgYSBtZWRpYSB0eXBlIGZyb20gdGhlIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlTWVkaWFUeXBlKHN0ciwgaSkge1xuICB2YXIgbWF0Y2ggPSBzaW1wbGVNZWRpYVR5cGVSZWdFeHAuZXhlYyhzdHIpO1xuICBpZiAoIW1hdGNoKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIHEgPSAxO1xuICB2YXIgc3VidHlwZSA9IG1hdGNoWzJdO1xuICB2YXIgdHlwZSA9IG1hdGNoWzFdO1xuXG4gIGlmIChtYXRjaFszXSkge1xuICAgIHZhciBrdnBzID0gc3BsaXRQYXJhbWV0ZXJzKG1hdGNoWzNdKS5tYXAoc3BsaXRLZXlWYWx1ZVBhaXIpO1xuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBrdnBzLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgcGFpciA9IGt2cHNbal07XG4gICAgICB2YXIga2V5ID0gcGFpclswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgdmFyIHZhbCA9IHBhaXJbMV07XG5cbiAgICAgIC8vIGdldCB0aGUgdmFsdWUsIHVud3JhcHBpbmcgcXVvdGVzXG4gICAgICB2YXIgdmFsdWUgPSB2YWwgJiYgdmFsWzBdID09PSAnXCInICYmIHZhbFt2YWwubGVuZ3RoIC0gMV0gPT09ICdcIidcbiAgICAgICAgPyB2YWwuc3Vic3RyKDEsIHZhbC5sZW5ndGggLSAyKVxuICAgICAgICA6IHZhbDtcblxuICAgICAgaWYgKGtleSA9PT0gJ3EnKSB7XG4gICAgICAgIHEgPSBwYXJzZUZsb2F0KHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIHN0b3JlIHBhcmFtZXRlclxuICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc3VidHlwZTogc3VidHlwZSxcbiAgICBwYXJhbXM6IHBhcmFtcyxcbiAgICBxOiBxLFxuICAgIGk6IGlcbiAgfTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByaW9yaXR5IG9mIGEgbWVkaWEgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZ2V0TWVkaWFUeXBlUHJpb3JpdHkodHlwZSwgYWNjZXB0ZWQsIGluZGV4KSB7XG4gIHZhciBwcmlvcml0eSA9IHtvOiAtMSwgcTogMCwgczogMH07XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBhY2NlcHRlZC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzcGVjID0gc3BlY2lmeSh0eXBlLCBhY2NlcHRlZFtpXSwgaW5kZXgpO1xuXG4gICAgaWYgKHNwZWMgJiYgKHByaW9yaXR5LnMgLSBzcGVjLnMgfHwgcHJpb3JpdHkucSAtIHNwZWMucSB8fCBwcmlvcml0eS5vIC0gc3BlYy5vKSA8IDApIHtcbiAgICAgIHByaW9yaXR5ID0gc3BlYztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcHJpb3JpdHk7XG59XG5cbi8qKlxuICogR2V0IHRoZSBzcGVjaWZpY2l0eSBvZiB0aGUgbWVkaWEgdHlwZS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BlY2lmeSh0eXBlLCBzcGVjLCBpbmRleCkge1xuICB2YXIgcCA9IHBhcnNlTWVkaWFUeXBlKHR5cGUpO1xuICB2YXIgcyA9IDA7XG5cbiAgaWYgKCFwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZihzcGVjLnR5cGUudG9Mb3dlckNhc2UoKSA9PSBwLnR5cGUudG9Mb3dlckNhc2UoKSkge1xuICAgIHMgfD0gNFxuICB9IGVsc2UgaWYoc3BlYy50eXBlICE9ICcqJykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYoc3BlYy5zdWJ0eXBlLnRvTG93ZXJDYXNlKCkgPT0gcC5zdWJ0eXBlLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBzIHw9IDJcbiAgfSBlbHNlIGlmKHNwZWMuc3VidHlwZSAhPSAnKicpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoc3BlYy5wYXJhbXMpO1xuICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgaWYgKGtleXMuZXZlcnkoZnVuY3Rpb24gKGspIHtcbiAgICAgIHJldHVybiBzcGVjLnBhcmFtc1trXSA9PSAnKicgfHwgKHNwZWMucGFyYW1zW2tdIHx8ICcnKS50b0xvd2VyQ2FzZSgpID09IChwLnBhcmFtc1trXSB8fCAnJykudG9Mb3dlckNhc2UoKTtcbiAgICB9KSkge1xuICAgICAgcyB8PSAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBudWxsXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBpOiBpbmRleCxcbiAgICBvOiBzcGVjLmksXG4gICAgcTogc3BlYy5xLFxuICAgIHM6IHMsXG4gIH1cbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZlcnJlZCBtZWRpYSB0eXBlcyBmcm9tIGFuIEFjY2VwdCBoZWFkZXIuXG4gKiBAcHVibGljXG4gKi9cblxuZnVuY3Rpb24gcHJlZmVycmVkTWVkaWFUeXBlcyhhY2NlcHQsIHByb3ZpZGVkKSB7XG4gIC8vIFJGQyAyNjE2IHNlYyAxNC4yOiBubyBoZWFkZXIgPSAqLypcbiAgdmFyIGFjY2VwdHMgPSBwYXJzZUFjY2VwdChhY2NlcHQgPT09IHVuZGVmaW5lZCA/ICcqLyonIDogYWNjZXB0IHx8ICcnKTtcblxuICBpZiAoIXByb3ZpZGVkKSB7XG4gICAgLy8gc29ydGVkIGxpc3Qgb2YgYWxsIHR5cGVzXG4gICAgcmV0dXJuIGFjY2VwdHNcbiAgICAgIC5maWx0ZXIoaXNRdWFsaXR5KVxuICAgICAgLnNvcnQoY29tcGFyZVNwZWNzKVxuICAgICAgLm1hcChnZXRGdWxsVHlwZSk7XG4gIH1cblxuICB2YXIgcHJpb3JpdGllcyA9IHByb3ZpZGVkLm1hcChmdW5jdGlvbiBnZXRQcmlvcml0eSh0eXBlLCBpbmRleCkge1xuICAgIHJldHVybiBnZXRNZWRpYVR5cGVQcmlvcml0eSh0eXBlLCBhY2NlcHRzLCBpbmRleCk7XG4gIH0pO1xuXG4gIC8vIHNvcnRlZCBsaXN0IG9mIGFjY2VwdGVkIHR5cGVzXG4gIHJldHVybiBwcmlvcml0aWVzLmZpbHRlcihpc1F1YWxpdHkpLnNvcnQoY29tcGFyZVNwZWNzKS5tYXAoZnVuY3Rpb24gZ2V0VHlwZShwcmlvcml0eSkge1xuICAgIHJldHVybiBwcm92aWRlZFtwcmlvcml0aWVzLmluZGV4T2YocHJpb3JpdHkpXTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ29tcGFyZSB0d28gc3BlY3MuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbXBhcmVTcGVjcyhhLCBiKSB7XG4gIHJldHVybiAoYi5xIC0gYS5xKSB8fCAoYi5zIC0gYS5zKSB8fCAoYS5vIC0gYi5vKSB8fCAoYS5pIC0gYi5pKSB8fCAwO1xufVxuXG4vKipcbiAqIEdldCBmdWxsIHR5cGUgc3RyaW5nLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBnZXRGdWxsVHlwZShzcGVjKSB7XG4gIHJldHVybiBzcGVjLnR5cGUgKyAnLycgKyBzcGVjLnN1YnR5cGU7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzcGVjIGhhcyBhbnkgcXVhbGl0eS5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gaXNRdWFsaXR5KHNwZWMpIHtcbiAgcmV0dXJuIHNwZWMucSA+IDA7XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBxdW90ZXMgaW4gYSBzdHJpbmcuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHF1b3RlQ291bnQoc3RyaW5nKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIHZhciBpbmRleCA9IDA7XG5cbiAgd2hpbGUgKChpbmRleCA9IHN0cmluZy5pbmRleE9mKCdcIicsIGluZGV4KSkgIT09IC0xKSB7XG4gICAgY291bnQrKztcbiAgICBpbmRleCsrO1xuICB9XG5cbiAgcmV0dXJuIGNvdW50O1xufVxuXG4vKipcbiAqIFNwbGl0IGEga2V5IHZhbHVlIHBhaXIuXG4gKiBAcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHNwbGl0S2V5VmFsdWVQYWlyKHN0cikge1xuICB2YXIgaW5kZXggPSBzdHIuaW5kZXhPZignPScpO1xuICB2YXIga2V5O1xuICB2YXIgdmFsO1xuXG4gIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICBrZXkgPSBzdHI7XG4gIH0gZWxzZSB7XG4gICAga2V5ID0gc3RyLnN1YnN0cigwLCBpbmRleCk7XG4gICAgdmFsID0gc3RyLnN1YnN0cihpbmRleCArIDEpO1xuICB9XG5cbiAgcmV0dXJuIFtrZXksIHZhbF07XG59XG5cbi8qKlxuICogU3BsaXQgYW4gQWNjZXB0IGhlYWRlciBpbnRvIG1lZGlhIHR5cGVzLlxuICogQHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBzcGxpdE1lZGlhVHlwZXMoYWNjZXB0KSB7XG4gIHZhciBhY2NlcHRzID0gYWNjZXB0LnNwbGl0KCcsJyk7XG5cbiAgZm9yICh2YXIgaSA9IDEsIGogPSAwOyBpIDwgYWNjZXB0cy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChxdW90ZUNvdW50KGFjY2VwdHNbal0pICUgMiA9PSAwKSB7XG4gICAgICBhY2NlcHRzWysral0gPSBhY2NlcHRzW2ldO1xuICAgIH0gZWxzZSB7XG4gICAgICBhY2NlcHRzW2pdICs9ICcsJyArIGFjY2VwdHNbaV07XG4gICAgfVxuICB9XG5cbiAgLy8gdHJpbSBhY2NlcHRzXG4gIGFjY2VwdHMubGVuZ3RoID0gaiArIDE7XG5cbiAgcmV0dXJuIGFjY2VwdHM7XG59XG5cbi8qKlxuICogU3BsaXQgYSBzdHJpbmcgb2YgcGFyYW1ldGVycy5cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gc3BsaXRQYXJhbWV0ZXJzKHN0cikge1xuICB2YXIgcGFyYW1ldGVycyA9IHN0ci5zcGxpdCgnOycpO1xuXG4gIGZvciAodmFyIGkgPSAxLCBqID0gMDsgaSA8IHBhcmFtZXRlcnMubGVuZ3RoOyBpKyspIHtcbiAgICBpZiAocXVvdGVDb3VudChwYXJhbWV0ZXJzW2pdKSAlIDIgPT0gMCkge1xuICAgICAgcGFyYW1ldGVyc1srK2pdID0gcGFyYW1ldGVyc1tpXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFyYW1ldGVyc1tqXSArPSAnOycgKyBwYXJhbWV0ZXJzW2ldO1xuICAgIH1cbiAgfVxuXG4gIC8vIHRyaW0gcGFyYW1ldGVyc1xuICBwYXJhbWV0ZXJzLmxlbmd0aCA9IGogKyAxO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcGFyYW1ldGVycy5sZW5ndGg7IGkrKykge1xuICAgIHBhcmFtZXRlcnNbaV0gPSBwYXJhbWV0ZXJzW2ldLnRyaW0oKTtcbiAgfVxuXG4gIHJldHVybiBwYXJhbWV0ZXJzO1xufVxuIiwidmFyIGZzID0gcmVxdWlyZSgnZnMnKVxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJylcbnZhciBvcyA9IHJlcXVpcmUoJ29zJylcblxuLy8gV29ya2Fyb3VuZCB0byBmaXggd2VicGFjaydzIGJ1aWxkIHdhcm5pbmdzOiAndGhlIHJlcXVlc3Qgb2YgYSBkZXBlbmRlbmN5IGlzIGFuIGV4cHJlc3Npb24nXG52YXIgcnVudGltZVJlcXVpcmUgPSB0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXyA9PT0gJ2Z1bmN0aW9uJyA/IF9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fIDogcmVxdWlyZSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG5cbnZhciB2YXJzID0gKHByb2Nlc3MuY29uZmlnICYmIHByb2Nlc3MuY29uZmlnLnZhcmlhYmxlcykgfHwge31cbnZhciBwcmVidWlsZHNPbmx5ID0gISFwcm9jZXNzLmVudi5QUkVCVUlMRFNfT05MWVxudmFyIGFiaSA9IHByb2Nlc3MudmVyc2lvbnMubW9kdWxlcyAvLyBUT0RPOiBzdXBwb3J0IG9sZCBub2RlIHdoZXJlIHRoaXMgaXMgdW5kZWZcbnZhciBydW50aW1lID0gaXNFbGVjdHJvbigpID8gJ2VsZWN0cm9uJyA6ICdub2RlJ1xudmFyIGFyY2ggPSBvcy5hcmNoKClcbnZhciBwbGF0Zm9ybSA9IG9zLnBsYXRmb3JtKClcbnZhciBsaWJjID0gcHJvY2Vzcy5lbnYuTElCQyB8fCAoaXNBbHBpbmUocGxhdGZvcm0pID8gJ211c2wnIDogJ2dsaWJjJylcbnZhciBhcm12ID0gcHJvY2Vzcy5lbnYuQVJNX1ZFUlNJT04gfHwgKGFyY2ggPT09ICdhcm02NCcgPyAnOCcgOiB2YXJzLmFybV92ZXJzaW9uKSB8fCAnJ1xudmFyIHV2ID0gKHByb2Nlc3MudmVyc2lvbnMudXYgfHwgJycpLnNwbGl0KCcuJylbMF1cblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkXG5cbmZ1bmN0aW9uIGxvYWQgKGRpcikge1xuICByZXR1cm4gcnVudGltZVJlcXVpcmUobG9hZC5wYXRoKGRpcikpXG59XG5cbmxvYWQucGF0aCA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgZGlyID0gcGF0aC5yZXNvbHZlKGRpciB8fCAnLicpXG5cbiAgdHJ5IHtcbiAgICB2YXIgbmFtZSA9IHJ1bnRpbWVSZXF1aXJlKHBhdGguam9pbihkaXIsICdwYWNrYWdlLmpzb24nKSkubmFtZS50b1VwcGVyQ2FzZSgpLnJlcGxhY2UoLy0vZywgJ18nKVxuICAgIGlmIChwcm9jZXNzLmVudltuYW1lICsgJ19QUkVCVUlMRCddKSBkaXIgPSBwcm9jZXNzLmVudltuYW1lICsgJ19QUkVCVUlMRCddXG4gIH0gY2F0Y2ggKGVycikge31cblxuICBpZiAoIXByZWJ1aWxkc09ubHkpIHtcbiAgICB2YXIgcmVsZWFzZSA9IGdldEZpcnN0KHBhdGguam9pbihkaXIsICdidWlsZC9SZWxlYXNlJyksIG1hdGNoQnVpbGQpXG4gICAgaWYgKHJlbGVhc2UpIHJldHVybiByZWxlYXNlXG5cbiAgICB2YXIgZGVidWcgPSBnZXRGaXJzdChwYXRoLmpvaW4oZGlyLCAnYnVpbGQvRGVidWcnKSwgbWF0Y2hCdWlsZClcbiAgICBpZiAoZGVidWcpIHJldHVybiBkZWJ1Z1xuICB9XG5cbiAgdmFyIHByZWJ1aWxkID0gcmVzb2x2ZShkaXIpXG4gIGlmIChwcmVidWlsZCkgcmV0dXJuIHByZWJ1aWxkXG5cbiAgdmFyIG5lYXJieSA9IHJlc29sdmUocGF0aC5kaXJuYW1lKHByb2Nlc3MuZXhlY1BhdGgpKVxuICBpZiAobmVhcmJ5KSByZXR1cm4gbmVhcmJ5XG5cbiAgdmFyIHRhcmdldCA9IFtcbiAgICAncGxhdGZvcm09JyArIHBsYXRmb3JtLFxuICAgICdhcmNoPScgKyBhcmNoLFxuICAgICdydW50aW1lPScgKyBydW50aW1lLFxuICAgICdhYmk9JyArIGFiaSxcbiAgICAndXY9JyArIHV2LFxuICAgIGFybXYgPyAnYXJtdj0nICsgYXJtdiA6ICcnLFxuICAgICdsaWJjPScgKyBsaWJjLFxuICAgICdub2RlPScgKyBwcm9jZXNzLnZlcnNpb25zLm5vZGUsXG4gICAgcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiA/ICdlbGVjdHJvbj0nICsgcHJvY2Vzcy52ZXJzaW9ucy5lbGVjdHJvbiA6ICcnLFxuICAgIHR5cGVvZiBfX3dlYnBhY2tfcmVxdWlyZV9fID09PSAnZnVuY3Rpb24nID8gJ3dlYnBhY2s9dHJ1ZScgOiAnJyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lXG4gIF0uZmlsdGVyKEJvb2xlYW4pLmpvaW4oJyAnKVxuXG4gIHRocm93IG5ldyBFcnJvcignTm8gbmF0aXZlIGJ1aWxkIHdhcyBmb3VuZCBmb3IgJyArIHRhcmdldCArICdcXG4gICAgbG9hZGVkIGZyb206ICcgKyBkaXIgKyAnXFxuJylcblxuICBmdW5jdGlvbiByZXNvbHZlIChkaXIpIHtcbiAgICAvLyBGaW5kIG1hdGNoaW5nIFwicHJlYnVpbGRzLzxwbGF0Zm9ybT4tPGFyY2g+XCIgZGlyZWN0b3J5XG4gICAgdmFyIHR1cGxlcyA9IHJlYWRkaXJTeW5jKHBhdGguam9pbihkaXIsICdwcmVidWlsZHMnKSkubWFwKHBhcnNlVHVwbGUpXG4gICAgdmFyIHR1cGxlID0gdHVwbGVzLmZpbHRlcihtYXRjaFR1cGxlKHBsYXRmb3JtLCBhcmNoKSkuc29ydChjb21wYXJlVHVwbGVzKVswXVxuICAgIGlmICghdHVwbGUpIHJldHVyblxuXG4gICAgLy8gRmluZCBtb3N0IHNwZWNpZmljIGZsYXZvciBmaXJzdFxuICAgIHZhciBwcmVidWlsZHMgPSBwYXRoLmpvaW4oZGlyLCAncHJlYnVpbGRzJywgdHVwbGUubmFtZSlcbiAgICB2YXIgcGFyc2VkID0gcmVhZGRpclN5bmMocHJlYnVpbGRzKS5tYXAocGFyc2VUYWdzKVxuICAgIHZhciBjYW5kaWRhdGVzID0gcGFyc2VkLmZpbHRlcihtYXRjaFRhZ3MocnVudGltZSwgYWJpKSlcbiAgICB2YXIgd2lubmVyID0gY2FuZGlkYXRlcy5zb3J0KGNvbXBhcmVUYWdzKHJ1bnRpbWUpKVswXVxuICAgIGlmICh3aW5uZXIpIHJldHVybiBwYXRoLmpvaW4ocHJlYnVpbGRzLCB3aW5uZXIuZmlsZSlcbiAgfVxufVxuXG5mdW5jdGlvbiByZWFkZGlyU3luYyAoZGlyKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZzLnJlYWRkaXJTeW5jKGRpcilcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0Rmlyc3QgKGRpciwgZmlsdGVyKSB7XG4gIHZhciBmaWxlcyA9IHJlYWRkaXJTeW5jKGRpcikuZmlsdGVyKGZpbHRlcilcbiAgcmV0dXJuIGZpbGVzWzBdICYmIHBhdGguam9pbihkaXIsIGZpbGVzWzBdKVxufVxuXG5mdW5jdGlvbiBtYXRjaEJ1aWxkIChuYW1lKSB7XG4gIHJldHVybiAvXFwubm9kZSQvLnRlc3QobmFtZSlcbn1cblxuZnVuY3Rpb24gcGFyc2VUdXBsZSAobmFtZSkge1xuICAvLyBFeGFtcGxlOiBkYXJ3aW4teDY0K2FybTY0XG4gIHZhciBhcnIgPSBuYW1lLnNwbGl0KCctJylcbiAgaWYgKGFyci5sZW5ndGggIT09IDIpIHJldHVyblxuXG4gIHZhciBwbGF0Zm9ybSA9IGFyclswXVxuICB2YXIgYXJjaGl0ZWN0dXJlcyA9IGFyclsxXS5zcGxpdCgnKycpXG5cbiAgaWYgKCFwbGF0Zm9ybSkgcmV0dXJuXG4gIGlmICghYXJjaGl0ZWN0dXJlcy5sZW5ndGgpIHJldHVyblxuICBpZiAoIWFyY2hpdGVjdHVyZXMuZXZlcnkoQm9vbGVhbikpIHJldHVyblxuXG4gIHJldHVybiB7IG5hbWUsIHBsYXRmb3JtLCBhcmNoaXRlY3R1cmVzIH1cbn1cblxuZnVuY3Rpb24gbWF0Y2hUdXBsZSAocGxhdGZvcm0sIGFyY2gpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uICh0dXBsZSkge1xuICAgIGlmICh0dXBsZSA9PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICBpZiAodHVwbGUucGxhdGZvcm0gIT09IHBsYXRmb3JtKSByZXR1cm4gZmFsc2VcbiAgICByZXR1cm4gdHVwbGUuYXJjaGl0ZWN0dXJlcy5pbmNsdWRlcyhhcmNoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVUdXBsZXMgKGEsIGIpIHtcbiAgLy8gUHJlZmVyIHNpbmdsZS1hcmNoIHByZWJ1aWxkcyBvdmVyIG11bHRpLWFyY2hcbiAgcmV0dXJuIGEuYXJjaGl0ZWN0dXJlcy5sZW5ndGggLSBiLmFyY2hpdGVjdHVyZXMubGVuZ3RoXG59XG5cbmZ1bmN0aW9uIHBhcnNlVGFncyAoZmlsZSkge1xuICB2YXIgYXJyID0gZmlsZS5zcGxpdCgnLicpXG4gIHZhciBleHRlbnNpb24gPSBhcnIucG9wKClcbiAgdmFyIHRhZ3MgPSB7IGZpbGU6IGZpbGUsIHNwZWNpZmljaXR5OiAwIH1cblxuICBpZiAoZXh0ZW5zaW9uICE9PSAnbm9kZScpIHJldHVyblxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIHRhZyA9IGFycltpXVxuXG4gICAgaWYgKHRhZyA9PT0gJ25vZGUnIHx8IHRhZyA9PT0gJ2VsZWN0cm9uJyB8fCB0YWcgPT09ICdub2RlLXdlYmtpdCcpIHtcbiAgICAgIHRhZ3MucnVudGltZSA9IHRhZ1xuICAgIH0gZWxzZSBpZiAodGFnID09PSAnbmFwaScpIHtcbiAgICAgIHRhZ3MubmFwaSA9IHRydWVcbiAgICB9IGVsc2UgaWYgKHRhZy5zbGljZSgwLCAzKSA9PT0gJ2FiaScpIHtcbiAgICAgIHRhZ3MuYWJpID0gdGFnLnNsaWNlKDMpXG4gICAgfSBlbHNlIGlmICh0YWcuc2xpY2UoMCwgMikgPT09ICd1dicpIHtcbiAgICAgIHRhZ3MudXYgPSB0YWcuc2xpY2UoMilcbiAgICB9IGVsc2UgaWYgKHRhZy5zbGljZSgwLCA0KSA9PT0gJ2FybXYnKSB7XG4gICAgICB0YWdzLmFybXYgPSB0YWcuc2xpY2UoNClcbiAgICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2dsaWJjJyB8fCB0YWcgPT09ICdtdXNsJykge1xuICAgICAgdGFncy5saWJjID0gdGFnXG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnRpbnVlXG4gICAgfVxuXG4gICAgdGFncy5zcGVjaWZpY2l0eSsrXG4gIH1cblxuICByZXR1cm4gdGFnc1xufVxuXG5mdW5jdGlvbiBtYXRjaFRhZ3MgKHJ1bnRpbWUsIGFiaSkge1xuICByZXR1cm4gZnVuY3Rpb24gKHRhZ3MpIHtcbiAgICBpZiAodGFncyA9PSBudWxsKSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGFncy5ydW50aW1lICE9PSBydW50aW1lICYmICFydW50aW1lQWdub3N0aWModGFncykpIHJldHVybiBmYWxzZVxuICAgIGlmICh0YWdzLmFiaSAhPT0gYWJpICYmICF0YWdzLm5hcGkpIHJldHVybiBmYWxzZVxuICAgIGlmICh0YWdzLnV2ICYmIHRhZ3MudXYgIT09IHV2KSByZXR1cm4gZmFsc2VcbiAgICBpZiAodGFncy5hcm12ICYmIHRhZ3MuYXJtdiAhPT0gYXJtdikgcmV0dXJuIGZhbHNlXG4gICAgaWYgKHRhZ3MubGliYyAmJiB0YWdzLmxpYmMgIT09IGxpYmMpIHJldHVybiBmYWxzZVxuXG4gICAgcmV0dXJuIHRydWVcbiAgfVxufVxuXG5mdW5jdGlvbiBydW50aW1lQWdub3N0aWMgKHRhZ3MpIHtcbiAgcmV0dXJuIHRhZ3MucnVudGltZSA9PT0gJ25vZGUnICYmIHRhZ3MubmFwaVxufVxuXG5mdW5jdGlvbiBjb21wYXJlVGFncyAocnVudGltZSkge1xuICAvLyBQcmVjZWRlbmNlOiBub24tYWdub3N0aWMgcnVudGltZSwgYWJpIG92ZXIgbmFwaSwgdGhlbiBieSBzcGVjaWZpY2l0eS5cbiAgcmV0dXJuIGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgaWYgKGEucnVudGltZSAhPT0gYi5ydW50aW1lKSB7XG4gICAgICByZXR1cm4gYS5ydW50aW1lID09PSBydW50aW1lID8gLTEgOiAxXG4gICAgfSBlbHNlIGlmIChhLmFiaSAhPT0gYi5hYmkpIHtcbiAgICAgIHJldHVybiBhLmFiaSA/IC0xIDogMVxuICAgIH0gZWxzZSBpZiAoYS5zcGVjaWZpY2l0eSAhPT0gYi5zcGVjaWZpY2l0eSkge1xuICAgICAgcmV0dXJuIGEuc3BlY2lmaWNpdHkgPiBiLnNwZWNpZmljaXR5ID8gLTEgOiAxXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiAwXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzRWxlY3Ryb24gKCkge1xuICBpZiAocHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLmVsZWN0cm9uKSByZXR1cm4gdHJ1ZVxuICBpZiAocHJvY2Vzcy5lbnYuRUxFQ1RST05fUlVOX0FTX05PREUpIHJldHVybiB0cnVlXG4gIHJldHVybiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInXG59XG5cbmZ1bmN0aW9uIGlzQWxwaW5lIChwbGF0Zm9ybSkge1xuICByZXR1cm4gcGxhdGZvcm0gPT09ICdsaW51eCcgJiYgZnMuZXhpc3RzU3luYygnL2V0Yy9hbHBpbmUtcmVsZWFzZScpXG59XG5cbi8vIEV4cG9zZWQgZm9yIHVuaXQgdGVzdHNcbi8vIFRPRE86IG1vdmUgdG8gbGliXG5sb2FkLnBhcnNlVGFncyA9IHBhcnNlVGFnc1xubG9hZC5tYXRjaFRhZ3MgPSBtYXRjaFRhZ3NcbmxvYWQuY29tcGFyZVRhZ3MgPSBjb21wYXJlVGFnc1xubG9hZC5wYXJzZVR1cGxlID0gcGFyc2VUdXBsZVxubG9hZC5tYXRjaFR1cGxlID0gbWF0Y2hUdXBsZVxubG9hZC5jb21wYXJlVHVwbGVzID0gY29tcGFyZVR1cGxlc1xuIiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5BZGFwdGVyID0gdm9pZCAwO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY2xhc3MgQWRhcHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogSW4tbWVtb3J5IGFkYXB0ZXIgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge05hbWVzcGFjZX0gbnNwXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnNwKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMubnNwID0gbnNwO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnNpZHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5zcC5zZXJ2ZXIuZW5jb2RlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG8gYmUgb3ZlcnJpZGRlblxuICAgICAqL1xuICAgIGluaXQoKSB7IH1cbiAgICAvKipcbiAgICAgKiBUbyBiZSBvdmVycmlkZGVuXG4gICAgICovXG4gICAgY2xvc2UoKSB7IH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgc29ja2V0IHRvIGEgbGlzdCBvZiByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTb2NrZXRJZH0gIGlkICAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7U2V0PFJvb20+fSByb29tcyAgIGEgc2V0IG9mIHJvb21zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGFkZEFsbChpZCwgcm9vbXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLnNldChpZCwgbmV3IFNldCgpKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2Ygcm9vbXMpIHtcbiAgICAgICAgICAgIHRoaXMuc2lkcy5nZXQoaWQpLmFkZChyb29tKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5yb29tcy5oYXMocm9vbSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvb21zLnNldChyb29tLCBuZXcgU2V0KCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNyZWF0ZS1yb29tXCIsIHJvb20pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF0aGlzLnJvb21zLmdldChyb29tKS5oYXMoaWQpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yb29tcy5nZXQocm9vbSkuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJqb2luLXJvb21cIiwgcm9vbSwgaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYSBzb2NrZXQgZnJvbSBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgICAgdGhlIHNvY2tldCBpZFxuICAgICAqIEBwYXJhbSB7Um9vbX0gICAgIHJvb20gICB0aGUgcm9vbSBuYW1lXG4gICAgICovXG4gICAgZGVsKGlkLCByb29tKSB7XG4gICAgICAgIGlmICh0aGlzLnNpZHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgdGhpcy5zaWRzLmdldChpZCkuZGVsZXRlKHJvb20pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RlbChyb29tLCBpZCk7XG4gICAgfVxuICAgIF9kZWwocm9vbSwgaWQpIHtcbiAgICAgICAgY29uc3QgX3Jvb20gPSB0aGlzLnJvb21zLmdldChyb29tKTtcbiAgICAgICAgaWYgKF9yb29tICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IGRlbGV0ZWQgPSBfcm9vbS5kZWxldGUoaWQpO1xuICAgICAgICAgICAgaWYgKGRlbGV0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJsZWF2ZS1yb29tXCIsIHJvb20sIGlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChfcm9vbS5zaXplID09PSAwICYmIHRoaXMucm9vbXMuZGVsZXRlKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVsZXRlLXJvb21cIiwgcm9vbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIHNvY2tldCBmcm9tIGFsbCByb29tcyBpdCdzIGpvaW5lZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U29ja2V0SWR9IGlkICAgdGhlIHNvY2tldCBpZFxuICAgICAqL1xuICAgIGRlbEFsbChpZCkge1xuICAgICAgICBpZiAoIXRoaXMuc2lkcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChjb25zdCByb29tIG9mIHRoaXMuc2lkcy5nZXQoaWQpKSB7XG4gICAgICAgICAgICB0aGlzLl9kZWwocm9vbSwgaWQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2lkcy5kZWxldGUoaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCcm9hZGNhc3RzIGEgcGFja2V0LlxuICAgICAqXG4gICAgICogT3B0aW9uczpcbiAgICAgKiAgLSBgZmxhZ3NgIHtPYmplY3R9IGZsYWdzIGZvciB0aGlzIHBhY2tldFxuICAgICAqICAtIGBleGNlcHRgIHtBcnJheX0gc2lkcyB0aGF0IHNob3VsZCBiZSBleGNsdWRlZFxuICAgICAqICAtIGByb29tc2Age0FycmF5fSBsaXN0IG9mIHJvb21zIHRvIGJyb2FkY2FzdCB0b1xuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCAgIHRoZSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgICAgIHRoZSBvcHRpb25zXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGJyb2FkY2FzdChwYWNrZXQsIG9wdHMpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBvcHRzLmZsYWdzIHx8IHt9O1xuICAgICAgICBjb25zdCBwYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzc1xuICAgICAgICB9O1xuICAgICAgICBwYWNrZXQubnNwID0gdGhpcy5uc3AubmFtZTtcbiAgICAgICAgY29uc3QgZW5jb2RlZFBhY2tldHMgPSB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgcGFja2V0T3B0cyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBzb2NrZXRzIGJ5IHNpZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U2V0PFJvb20+fSByb29tcyAgIHRoZSBleHBsaWNpdCBzZXQgb2Ygcm9vbXMgdG8gY2hlY2suXG4gICAgICovXG4gICAgc29ja2V0cyhyb29tcykge1xuICAgICAgICBjb25zdCBzaWRzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLmFwcGx5KHsgcm9vbXMgfSwgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNpZHMuYWRkKHNvY2tldC5pZCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHNpZHMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IG9mIHJvb21zIGEgZ2l2ZW4gc29ja2V0IGhhcyBqb2luZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1NvY2tldElkfSBpZCAgIHRoZSBzb2NrZXQgaWRcbiAgICAgKi9cbiAgICBzb2NrZXRSb29tcyhpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zaWRzLmdldChpZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMob3B0cykge1xuICAgICAgICBjb25zdCBzb2NrZXRzID0gW107XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNvY2tldHMucHVzaChzb2NrZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShzb2NrZXRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0cyAtIHRoZSBmaWx0ZXJzIHRvIGFwcGx5XG4gICAgICogQHBhcmFtIHJvb21zIC0gdGhlIHJvb21zIHRvIGpvaW5cbiAgICAgKi9cbiAgICBhZGRTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5qb2luKHJvb21zKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGxlYXZlIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSBvcHRzIC0gdGhlIGZpbHRlcnMgdG8gYXBwbHlcbiAgICAgKiBAcGFyYW0gcm9vbXMgLSB0aGUgcm9vbXMgdG8gbGVhdmVcbiAgICAgKi9cbiAgICBkZWxTb2NrZXRzKG9wdHMsIHJvb21zKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHJvb21zLmZvckVhY2gocm9vbSA9PiBzb2NrZXQubGVhdmUocm9vbSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIG9wdHMgLSB0aGUgZmlsdGVycyB0byBhcHBseVxuICAgICAqIEBwYXJhbSBjbG9zZSAtIHdoZXRoZXIgdG8gY2xvc2UgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKG9wdHMsIGNsb3NlKSB7XG4gICAgICAgIHRoaXMuYXBwbHkob3B0cywgc29ja2V0ID0+IHtcbiAgICAgICAgICAgIHNvY2tldC5kaXNjb25uZWN0KGNsb3NlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFwcGx5KG9wdHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGNvbnN0IHJvb21zID0gb3B0cy5yb29tcztcbiAgICAgICAgY29uc3QgZXhjZXB0ID0gdGhpcy5jb21wdXRlRXhjZXB0U2lkcyhvcHRzLmV4Y2VwdCk7XG4gICAgICAgIGlmIChyb29tcy5zaXplKSB7XG4gICAgICAgICAgICBjb25zdCBpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHJvb20gb2Ygcm9vbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMucm9vbXMuaGFzKHJvb20pKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIHRoaXMucm9vbXMuZ2V0KHJvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZHMuaGFzKGlkKSB8fCBleGNlcHQuaGFzKGlkKSlcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZHMuYWRkKGlkKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgW2lkXSBvZiB0aGlzLnNpZHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXhjZXB0LmhhcyhpZCkpXG4gICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubnNwLnNvY2tldHMuZ2V0KGlkKTtcbiAgICAgICAgICAgICAgICBpZiAoc29ja2V0KVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzb2NrZXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbXB1dGVFeGNlcHRTaWRzKGV4Y2VwdFJvb21zKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdFNpZHMgPSBuZXcgU2V0KCk7XG4gICAgICAgIGlmIChleGNlcHRSb29tcyAmJiBleGNlcHRSb29tcy5zaXplID4gMCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCByb29tIG9mIGV4Y2VwdFJvb21zKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucm9vbXMuaGFzKHJvb20pKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucm9vbXMuZ2V0KHJvb20pLmZvckVhY2goc2lkID0+IGV4Y2VwdFNpZHMuYWRkKHNpZCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZXhjZXB0U2lkcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIHBhY2tldCB0byB0aGUgb3RoZXIgU29ja2V0LklPIHNlcnZlcnMgaW4gdGhlIGNsdXN0ZXJcbiAgICAgKiBAcGFyYW0gcGFja2V0IC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqL1xuICAgIHNlcnZlclNpZGVFbWl0KHBhY2tldCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0aGlzIGFkYXB0ZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgc2VydmVyU2lkZUVtaXQoKSBmdW5jdGlvbmFsaXR5XCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuQWRhcHRlciA9IEFkYXB0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSBleHBvcnRzLmRlY29uc3RydWN0UGFja2V0ID0gdm9pZCAwO1xuY29uc3QgaXNfYmluYXJ5XzEgPSByZXF1aXJlKFwiLi9pcy1iaW5hcnlcIik7XG4vKipcbiAqIFJlcGxhY2VzIGV2ZXJ5IEJ1ZmZlciB8IEFycmF5QnVmZmVyIHwgQmxvYiB8IEZpbGUgaW4gcGFja2V0IHdpdGggYSBudW1iZXJlZCBwbGFjZWhvbGRlci5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gc29ja2V0LmlvIGV2ZW50IHBhY2tldFxuICogQHJldHVybiB7T2JqZWN0fSB3aXRoIGRlY29uc3RydWN0ZWQgcGFja2V0IGFuZCBsaXN0IG9mIGJ1ZmZlcnNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb25zdHJ1Y3RQYWNrZXQocGFja2V0KSB7XG4gICAgY29uc3QgYnVmZmVycyA9IFtdO1xuICAgIGNvbnN0IHBhY2tldERhdGEgPSBwYWNrZXQuZGF0YTtcbiAgICBjb25zdCBwYWNrID0gcGFja2V0O1xuICAgIHBhY2suZGF0YSA9IF9kZWNvbnN0cnVjdFBhY2tldChwYWNrZXREYXRhLCBidWZmZXJzKTtcbiAgICBwYWNrLmF0dGFjaG1lbnRzID0gYnVmZmVycy5sZW5ndGg7IC8vIG51bWJlciBvZiBiaW5hcnkgJ2F0dGFjaG1lbnRzJ1xuICAgIHJldHVybiB7IHBhY2tldDogcGFjaywgYnVmZmVyczogYnVmZmVycyB9O1xufVxuZXhwb3J0cy5kZWNvbnN0cnVjdFBhY2tldCA9IGRlY29uc3RydWN0UGFja2V0O1xuZnVuY3Rpb24gX2RlY29uc3RydWN0UGFja2V0KGRhdGEsIGJ1ZmZlcnMpIHtcbiAgICBpZiAoIWRhdGEpXG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIGlmIChpc19iaW5hcnlfMS5pc0JpbmFyeShkYXRhKSkge1xuICAgICAgICBjb25zdCBwbGFjZWhvbGRlciA9IHsgX3BsYWNlaG9sZGVyOiB0cnVlLCBudW06IGJ1ZmZlcnMubGVuZ3RoIH07XG4gICAgICAgIGJ1ZmZlcnMucHVzaChkYXRhKTtcbiAgICAgICAgcmV0dXJuIHBsYWNlaG9sZGVyO1xuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSBuZXcgQXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld0RhdGFbaV0gPSBfZGVjb25zdHJ1Y3RQYWNrZXQoZGF0YVtpXSwgYnVmZmVycyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld0RhdGE7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmICEoZGF0YSBpbnN0YW5jZW9mIERhdGUpKSB7XG4gICAgICAgIGNvbnN0IG5ld0RhdGEgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgaWYgKGRhdGEuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgIG5ld0RhdGFba2V5XSA9IF9kZWNvbnN0cnVjdFBhY2tldChkYXRhW2tleV0sIGJ1ZmZlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXdEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbn1cbi8qKlxuICogUmVjb25zdHJ1Y3RzIGEgYmluYXJ5IHBhY2tldCBmcm9tIGl0cyBwbGFjZWhvbGRlciBwYWNrZXQgYW5kIGJ1ZmZlcnNcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gZXZlbnQgcGFja2V0IHdpdGggcGxhY2Vob2xkZXJzXG4gKiBAcGFyYW0ge0FycmF5fSBidWZmZXJzIC0gYmluYXJ5IGJ1ZmZlcnMgdG8gcHV0IGluIHBsYWNlaG9sZGVyIHBvc2l0aW9uc1xuICogQHJldHVybiB7T2JqZWN0fSByZWNvbnN0cnVjdGVkIHBhY2tldFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiByZWNvbnN0cnVjdFBhY2tldChwYWNrZXQsIGJ1ZmZlcnMpIHtcbiAgICBwYWNrZXQuZGF0YSA9IF9yZWNvbnN0cnVjdFBhY2tldChwYWNrZXQuZGF0YSwgYnVmZmVycyk7XG4gICAgcGFja2V0LmF0dGFjaG1lbnRzID0gdW5kZWZpbmVkOyAvLyBubyBsb25nZXIgdXNlZnVsXG4gICAgcmV0dXJuIHBhY2tldDtcbn1cbmV4cG9ydHMucmVjb25zdHJ1Y3RQYWNrZXQgPSByZWNvbnN0cnVjdFBhY2tldDtcbmZ1bmN0aW9uIF9yZWNvbnN0cnVjdFBhY2tldChkYXRhLCBidWZmZXJzKSB7XG4gICAgaWYgKCFkYXRhKVxuICAgICAgICByZXR1cm4gZGF0YTtcbiAgICBpZiAoZGF0YSAmJiBkYXRhLl9wbGFjZWhvbGRlcikge1xuICAgICAgICByZXR1cm4gYnVmZmVyc1tkYXRhLm51bV07IC8vIGFwcHJvcHJpYXRlIGJ1ZmZlciAoc2hvdWxkIGJlIG5hdHVyYWwgb3JkZXIgYW55d2F5KVxuICAgIH1cbiAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGF0YVtpXSA9IF9yZWNvbnN0cnVjdFBhY2tldChkYXRhW2ldLCBidWZmZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgZGF0YVtrZXldID0gX3JlY29uc3RydWN0UGFja2V0KGRhdGFba2V5XSwgYnVmZmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGVjb2RlciA9IGV4cG9ydHMuRW5jb2RlciA9IGV4cG9ydHMuUGFja2V0VHlwZSA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5jb25zdCBFbWl0dGVyID0gcmVxdWlyZShcImNvbXBvbmVudC1lbWl0dGVyXCIpO1xuY29uc3QgYmluYXJ5XzEgPSByZXF1aXJlKFwiLi9iaW5hcnlcIik7XG5jb25zdCBpc19iaW5hcnlfMSA9IHJlcXVpcmUoXCIuL2lzLWJpbmFyeVwiKTtcbmNvbnN0IGRlYnVnID0gcmVxdWlyZShcImRlYnVnXCIpKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbi8qKlxuICogUHJvdG9jb2wgdmVyc2lvbi5cbiAqXG4gKiBAcHVibGljXG4gKi9cbmV4cG9ydHMucHJvdG9jb2wgPSA1O1xudmFyIFBhY2tldFR5cGU7XG4oZnVuY3Rpb24gKFBhY2tldFR5cGUpIHtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUXCJdID0gMF0gPSBcIkNPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJESVNDT05ORUNUXCJdID0gMV0gPSBcIkRJU0NPTk5FQ1RcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJFVkVOVFwiXSA9IDJdID0gXCJFVkVOVFwiO1xuICAgIFBhY2tldFR5cGVbUGFja2V0VHlwZVtcIkFDS1wiXSA9IDNdID0gXCJBQ0tcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJDT05ORUNUX0VSUk9SXCJdID0gNF0gPSBcIkNPTk5FQ1RfRVJST1JcIjtcbiAgICBQYWNrZXRUeXBlW1BhY2tldFR5cGVbXCJCSU5BUllfRVZFTlRcIl0gPSA1XSA9IFwiQklOQVJZX0VWRU5UXCI7XG4gICAgUGFja2V0VHlwZVtQYWNrZXRUeXBlW1wiQklOQVJZX0FDS1wiXSA9IDZdID0gXCJCSU5BUllfQUNLXCI7XG59KShQYWNrZXRUeXBlID0gZXhwb3J0cy5QYWNrZXRUeXBlIHx8IChleHBvcnRzLlBhY2tldFR5cGUgPSB7fSkpO1xuLyoqXG4gKiBBIHNvY2tldC5pbyBFbmNvZGVyIGluc3RhbmNlXG4gKi9cbmNsYXNzIEVuY29kZXIge1xuICAgIC8qKlxuICAgICAqIEVuY29kZSBhIHBhY2tldCBhcyBhIHNpbmdsZSBzdHJpbmcgaWYgbm9uLWJpbmFyeSwgb3IgYXMgYVxuICAgICAqIGJ1ZmZlciBzZXF1ZW5jZSwgZGVwZW5kaW5nIG9uIHBhY2tldCB0eXBlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iaiAtIHBhY2tldCBvYmplY3RcbiAgICAgKi9cbiAgICBlbmNvZGUob2JqKSB7XG4gICAgICAgIGRlYnVnKFwiZW5jb2RpbmcgcGFja2V0ICVqXCIsIG9iaik7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5FVkVOVCB8fCBvYmoudHlwZSA9PT0gUGFja2V0VHlwZS5BQ0spIHtcbiAgICAgICAgICAgIGlmIChpc19iaW5hcnlfMS5oYXNCaW5hcnkob2JqKSkge1xuICAgICAgICAgICAgICAgIG9iai50eXBlID1cbiAgICAgICAgICAgICAgICAgICAgb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgID8gUGFja2V0VHlwZS5CSU5BUllfRVZFTlRcbiAgICAgICAgICAgICAgICAgICAgICAgIDogUGFja2V0VHlwZS5CSU5BUllfQUNLO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmVuY29kZUFzQmluYXJ5KG9iaik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFt0aGlzLmVuY29kZUFzU3RyaW5nKG9iaildO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbmNvZGUgcGFja2V0IGFzIHN0cmluZy5cbiAgICAgKi9cbiAgICBlbmNvZGVBc1N0cmluZyhvYmopIHtcbiAgICAgICAgLy8gZmlyc3QgaXMgdHlwZVxuICAgICAgICBsZXQgc3RyID0gXCJcIiArIG9iai50eXBlO1xuICAgICAgICAvLyBhdHRhY2htZW50cyBpZiB3ZSBoYXZlIHRoZW1cbiAgICAgICAgaWYgKG9iai50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fFxuICAgICAgICAgICAgb2JqLnR5cGUgPT09IFBhY2tldFR5cGUuQklOQVJZX0FDSykge1xuICAgICAgICAgICAgc3RyICs9IG9iai5hdHRhY2htZW50cyArIFwiLVwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGlmIHdlIGhhdmUgYSBuYW1lc3BhY2Ugb3RoZXIgdGhhbiBgL2BcbiAgICAgICAgLy8gd2UgYXBwZW5kIGl0IGZvbGxvd2VkIGJ5IGEgY29tbWEgYCxgXG4gICAgICAgIGlmIChvYmoubnNwICYmIFwiL1wiICE9PSBvYmoubnNwKSB7XG4gICAgICAgICAgICBzdHIgKz0gb2JqLm5zcCArIFwiLFwiO1xuICAgICAgICB9XG4gICAgICAgIC8vIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IHRoZSBpZFxuICAgICAgICBpZiAobnVsbCAhPSBvYmouaWQpIHtcbiAgICAgICAgICAgIHN0ciArPSBvYmouaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8ganNvbiBkYXRhXG4gICAgICAgIGlmIChudWxsICE9IG9iai5kYXRhKSB7XG4gICAgICAgICAgICBzdHIgKz0gSlNPTi5zdHJpbmdpZnkob2JqLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiZW5jb2RlZCAlaiBhcyAlc1wiLCBvYmosIHN0cik7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVuY29kZSBwYWNrZXQgYXMgJ2J1ZmZlciBzZXF1ZW5jZScgYnkgcmVtb3ZpbmcgYmxvYnMsIGFuZFxuICAgICAqIGRlY29uc3RydWN0aW5nIHBhY2tldCBpbnRvIG9iamVjdCB3aXRoIHBsYWNlaG9sZGVycyBhbmRcbiAgICAgKiBhIGxpc3Qgb2YgYnVmZmVycy5cbiAgICAgKi9cbiAgICBlbmNvZGVBc0JpbmFyeShvYmopIHtcbiAgICAgICAgY29uc3QgZGVjb25zdHJ1Y3Rpb24gPSBiaW5hcnlfMS5kZWNvbnN0cnVjdFBhY2tldChvYmopO1xuICAgICAgICBjb25zdCBwYWNrID0gdGhpcy5lbmNvZGVBc1N0cmluZyhkZWNvbnN0cnVjdGlvbi5wYWNrZXQpO1xuICAgICAgICBjb25zdCBidWZmZXJzID0gZGVjb25zdHJ1Y3Rpb24uYnVmZmVycztcbiAgICAgICAgYnVmZmVycy51bnNoaWZ0KHBhY2spOyAvLyBhZGQgcGFja2V0IGluZm8gdG8gYmVnaW5uaW5nIG9mIGRhdGEgbGlzdFxuICAgICAgICByZXR1cm4gYnVmZmVyczsgLy8gd3JpdGUgYWxsIHRoZSBidWZmZXJzXG4gICAgfVxufVxuZXhwb3J0cy5FbmNvZGVyID0gRW5jb2Rlcjtcbi8qKlxuICogQSBzb2NrZXQuaW8gRGVjb2RlciBpbnN0YW5jZVxuICpcbiAqIEByZXR1cm4ge09iamVjdH0gZGVjb2RlclxuICovXG5jbGFzcyBEZWNvZGVyIGV4dGVuZHMgRW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERlY29kZXMgYW4gZW5jb2RlZCBwYWNrZXQgc3RyaW5nIGludG8gcGFja2V0IEpTT04uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gb2JqIC0gZW5jb2RlZCBwYWNrZXRcbiAgICAgKi9cbiAgICBhZGQob2JqKSB7XG4gICAgICAgIGxldCBwYWNrZXQ7XG4gICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBwYWNrZXQgPSB0aGlzLmRlY29kZVN0cmluZyhvYmopO1xuICAgICAgICAgICAgaWYgKHBhY2tldC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fFxuICAgICAgICAgICAgICAgIHBhY2tldC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgICAgICAvLyBiaW5hcnkgcGFja2V0J3MganNvblxuICAgICAgICAgICAgICAgIHRoaXMucmVjb25zdHJ1Y3RvciA9IG5ldyBCaW5hcnlSZWNvbnN0cnVjdG9yKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgLy8gbm8gYXR0YWNobWVudHMsIGxhYmVsZWQgYmluYXJ5IGJ1dCBubyBiaW5hcnkgZGF0YSB0byBmb2xsb3dcbiAgICAgICAgICAgICAgICBpZiAocGFja2V0LmF0dGFjaG1lbnRzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1cGVyLmVtaXQoXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gbm9uLWJpbmFyeSBmdWxsIHBhY2tldFxuICAgICAgICAgICAgICAgIHN1cGVyLmVtaXQoXCJkZWNvZGVkXCIsIHBhY2tldCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNfYmluYXJ5XzEuaXNCaW5hcnkob2JqKSB8fCBvYmouYmFzZTY0KSB7XG4gICAgICAgICAgICAvLyByYXcgYmluYXJ5IGRhdGFcbiAgICAgICAgICAgIGlmICghdGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ290IGJpbmFyeSBkYXRhIHdoZW4gbm90IHJlY29uc3RydWN0aW5nIGEgcGFja2V0XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGFja2V0ID0gdGhpcy5yZWNvbnN0cnVjdG9yLnRha2VCaW5hcnlEYXRhKG9iaik7XG4gICAgICAgICAgICAgICAgaWYgKHBhY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAvLyByZWNlaXZlZCBmaW5hbCBidWZmZXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbnN0cnVjdG9yID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgc3VwZXIuZW1pdChcImRlY29kZWRcIiwgcGFja2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIHR5cGU6IFwiICsgb2JqKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZWNvZGUgYSBwYWNrZXQgU3RyaW5nIChKU09OIGRhdGEpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gICAgICogQHJldHVybiB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKi9cbiAgICBkZWNvZGVTdHJpbmcoc3RyKSB7XG4gICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgLy8gbG9vayB1cCB0eXBlXG4gICAgICAgIGNvbnN0IHAgPSB7XG4gICAgICAgICAgICB0eXBlOiBOdW1iZXIoc3RyLmNoYXJBdCgwKSksXG4gICAgICAgIH07XG4gICAgICAgIGlmIChQYWNrZXRUeXBlW3AudHlwZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBwYWNrZXQgdHlwZSBcIiArIHAudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBhdHRhY2htZW50cyBpZiB0eXBlIGJpbmFyeVxuICAgICAgICBpZiAocC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVCB8fFxuICAgICAgICAgICAgcC50eXBlID09PSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0spIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gaSArIDE7XG4gICAgICAgICAgICB3aGlsZSAoc3RyLmNoYXJBdCgrK2kpICE9PSBcIi1cIiAmJiBpICE9IHN0ci5sZW5ndGgpIHsgfVxuICAgICAgICAgICAgY29uc3QgYnVmID0gc3RyLnN1YnN0cmluZyhzdGFydCwgaSk7XG4gICAgICAgICAgICBpZiAoYnVmICE9IE51bWJlcihidWYpIHx8IHN0ci5jaGFyQXQoaSkgIT09IFwiLVwiKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSWxsZWdhbCBhdHRhY2htZW50c1wiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHAuYXR0YWNobWVudHMgPSBOdW1iZXIoYnVmKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBsb29rIHVwIG5hbWVzcGFjZSAoaWYgYW55KVxuICAgICAgICBpZiAoXCIvXCIgPT09IHN0ci5jaGFyQXQoaSArIDEpKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKCsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChcIixcIiA9PT0gYylcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5uc3AgPSBzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHAubnNwID0gXCIvXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbG9vayB1cCBpZFxuICAgICAgICBjb25zdCBuZXh0ID0gc3RyLmNoYXJBdChpICsgMSk7XG4gICAgICAgIGlmIChcIlwiICE9PSBuZXh0ICYmIE51bWJlcihuZXh0KSA9PSBuZXh0KSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGkgKyAxO1xuICAgICAgICAgICAgd2hpbGUgKCsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckF0KGkpO1xuICAgICAgICAgICAgICAgIGlmIChudWxsID09IGMgfHwgTnVtYmVyKGMpICE9IGMpIHtcbiAgICAgICAgICAgICAgICAgICAgLS1pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGkgPT09IHN0ci5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcC5pZCA9IE51bWJlcihzdHIuc3Vic3RyaW5nKHN0YXJ0LCBpICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGxvb2sgdXAganNvbiBkYXRhXG4gICAgICAgIGlmIChzdHIuY2hhckF0KCsraSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSB0cnlQYXJzZShzdHIuc3Vic3RyKGkpKTtcbiAgICAgICAgICAgIGlmIChEZWNvZGVyLmlzUGF5bG9hZFZhbGlkKHAudHlwZSwgcGF5bG9hZCkpIHtcbiAgICAgICAgICAgICAgICBwLmRhdGEgPSBwYXlsb2FkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXlsb2FkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwiZGVjb2RlZCAlcyBhcyAlalwiLCBzdHIsIHApO1xuICAgICAgICByZXR1cm4gcDtcbiAgICB9XG4gICAgc3RhdGljIGlzUGF5bG9hZFZhbGlkKHR5cGUsIHBheWxvYWQpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZW9mIHBheWxvYWQgPT09IFwib2JqZWN0XCI7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuRElTQ09OTkVDVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gcGF5bG9hZCA9PT0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkNPTk5FQ1RfRVJST1I6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHR5cGVvZiBwYXlsb2FkID09PSBcInN0cmluZ1wiIHx8IHR5cGVvZiBwYXlsb2FkID09PSBcIm9iamVjdFwiO1xuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkVWRU5UOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheShwYXlsb2FkKSAmJiBwYXlsb2FkLmxlbmd0aCA+IDA7XG4gICAgICAgICAgICBjYXNlIFBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgY2FzZSBQYWNrZXRUeXBlLkJJTkFSWV9BQ0s6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkocGF5bG9hZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVhbGxvY2F0ZXMgYSBwYXJzZXIncyByZXNvdXJjZXNcbiAgICAgKi9cbiAgICBkZXN0cm95KCkge1xuICAgICAgICBpZiAodGhpcy5yZWNvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLnJlY29uc3RydWN0b3IuZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5EZWNvZGVyID0gRGVjb2RlcjtcbmZ1bmN0aW9uIHRyeVBhcnNlKHN0cikge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBKU09OLnBhcnNlKHN0cik7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIEEgbWFuYWdlciBvZiBhIGJpbmFyeSBldmVudCdzICdidWZmZXIgc2VxdWVuY2UnLiBTaG91bGRcbiAqIGJlIGNvbnN0cnVjdGVkIHdoZW5ldmVyIGEgcGFja2V0IG9mIHR5cGUgQklOQVJZX0VWRU5UIGlzXG4gKiBkZWNvZGVkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAqIEByZXR1cm4ge0JpbmFyeVJlY29uc3RydWN0b3J9IGluaXRpYWxpemVkIHJlY29uc3RydWN0b3JcbiAqL1xuY2xhc3MgQmluYXJ5UmVjb25zdHJ1Y3RvciB7XG4gICAgY29uc3RydWN0b3IocGFja2V0KSB7XG4gICAgICAgIHRoaXMucGFja2V0ID0gcGFja2V0O1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBwYWNrZXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBiZSBjYWxsZWQgd2hlbiBiaW5hcnkgZGF0YSByZWNlaXZlZCBmcm9tIGNvbm5lY3Rpb25cbiAgICAgKiBhZnRlciBhIEJJTkFSWV9FVkVOVCBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0J1ZmZlciB8IEFycmF5QnVmZmVyfSBiaW5EYXRhIC0gdGhlIHJhdyBiaW5hcnkgZGF0YSByZWNlaXZlZFxuICAgICAqIEByZXR1cm4ge251bGwgfCBPYmplY3R9IHJldHVybnMgbnVsbCBpZiBtb3JlIGJpbmFyeSBkYXRhIGlzIGV4cGVjdGVkIG9yXG4gICAgICogICBhIHJlY29uc3RydWN0ZWQgcGFja2V0IG9iamVjdCBpZiBhbGwgYnVmZmVycyBoYXZlIGJlZW4gcmVjZWl2ZWQuXG4gICAgICovXG4gICAgdGFrZUJpbmFyeURhdGEoYmluRGF0YSkge1xuICAgICAgICB0aGlzLmJ1ZmZlcnMucHVzaChiaW5EYXRhKTtcbiAgICAgICAgaWYgKHRoaXMuYnVmZmVycy5sZW5ndGggPT09IHRoaXMucmVjb25QYWNrLmF0dGFjaG1lbnRzKSB7XG4gICAgICAgICAgICAvLyBkb25lIHdpdGggYnVmZmVyIGxpc3RcbiAgICAgICAgICAgIGNvbnN0IHBhY2tldCA9IGJpbmFyeV8xLnJlY29uc3RydWN0UGFja2V0KHRoaXMucmVjb25QYWNrLCB0aGlzLmJ1ZmZlcnMpO1xuICAgICAgICAgICAgdGhpcy5maW5pc2hlZFJlY29uc3RydWN0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm4gcGFja2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgYmluYXJ5IHBhY2tldCByZWNvbnN0cnVjdGlvbiB2YXJpYWJsZXMuXG4gICAgICovXG4gICAgZmluaXNoZWRSZWNvbnN0cnVjdGlvbigpIHtcbiAgICAgICAgdGhpcy5yZWNvblBhY2sgPSBudWxsO1xuICAgICAgICB0aGlzLmJ1ZmZlcnMgPSBbXTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuaGFzQmluYXJ5ID0gZXhwb3J0cy5pc0JpbmFyeSA9IHZvaWQgMDtcbmNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgaXNWaWV3ID0gKG9iaikgPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iai5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcjtcbn07XG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChCbG9iKSA9PT0gXCJbb2JqZWN0IEJsb2JDb25zdHJ1Y3Rvcl1cIik7XG5jb25zdCB3aXRoTmF0aXZlRmlsZSA9IHR5cGVvZiBGaWxlID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEZpbGUgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgdG9TdHJpbmcuY2FsbChGaWxlKSA9PT0gXCJbb2JqZWN0IEZpbGVDb25zdHJ1Y3Rvcl1cIik7XG4vKipcbiAqIFJldHVybnMgdHJ1ZSBpZiBvYmogaXMgYSBCdWZmZXIsIGFuIEFycmF5QnVmZmVyLCBhIEJsb2Igb3IgYSBGaWxlLlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGlzQmluYXJ5KG9iaikge1xuICAgIHJldHVybiAoKHdpdGhOYXRpdmVBcnJheUJ1ZmZlciAmJiAob2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgaXNWaWV3KG9iaikpKSB8fFxuICAgICAgICAod2l0aE5hdGl2ZUJsb2IgJiYgb2JqIGluc3RhbmNlb2YgQmxvYikgfHxcbiAgICAgICAgKHdpdGhOYXRpdmVGaWxlICYmIG9iaiBpbnN0YW5jZW9mIEZpbGUpKTtcbn1cbmV4cG9ydHMuaXNCaW5hcnkgPSBpc0JpbmFyeTtcbmZ1bmN0aW9uIGhhc0JpbmFyeShvYmosIHRvSlNPTikge1xuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBsID0gb2JqLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgaWYgKGhhc0JpbmFyeShvYmpbaV0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXNCaW5hcnkob2JqKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9iai50b0pTT04gJiZcbiAgICAgICAgdHlwZW9mIG9iai50b0pTT04gPT09IFwiZnVuY3Rpb25cIiAmJlxuICAgICAgICBhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiBoYXNCaW5hcnkob2JqLnRvSlNPTigpLCB0cnVlKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpICYmIGhhc0JpbmFyeShvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydHMuaGFzQmluYXJ5ID0gaGFzQmluYXJ5O1xuIiwiLyogZXNsaW50LWVudiBicm93c2VyICovXG5cbi8qKlxuICogVGhpcyBpcyB0aGUgd2ViIGJyb3dzZXIgaW1wbGVtZW50YXRpb24gb2YgYGRlYnVnKClgLlxuICovXG5cbmV4cG9ydHMuZm9ybWF0QXJncyA9IGZvcm1hdEFyZ3M7XG5leHBvcnRzLnNhdmUgPSBzYXZlO1xuZXhwb3J0cy5sb2FkID0gbG9hZDtcbmV4cG9ydHMudXNlQ29sb3JzID0gdXNlQ29sb3JzO1xuZXhwb3J0cy5zdG9yYWdlID0gbG9jYWxzdG9yYWdlKCk7XG5leHBvcnRzLmRlc3Ryb3kgPSAoKCkgPT4ge1xuXHRsZXQgd2FybmVkID0gZmFsc2U7XG5cblx0cmV0dXJuICgpID0+IHtcblx0XHRpZiAoIXdhcm5lZCkge1xuXHRcdFx0d2FybmVkID0gdHJ1ZTtcblx0XHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHRcdH1cblx0fTtcbn0pKCk7XG5cbi8qKlxuICogQ29sb3JzLlxuICovXG5cbmV4cG9ydHMuY29sb3JzID0gW1xuXHQnIzAwMDBDQycsXG5cdCcjMDAwMEZGJyxcblx0JyMwMDMzQ0MnLFxuXHQnIzAwMzNGRicsXG5cdCcjMDA2NkNDJyxcblx0JyMwMDY2RkYnLFxuXHQnIzAwOTlDQycsXG5cdCcjMDA5OUZGJyxcblx0JyMwMENDMDAnLFxuXHQnIzAwQ0MzMycsXG5cdCcjMDBDQzY2Jyxcblx0JyMwMENDOTknLFxuXHQnIzAwQ0NDQycsXG5cdCcjMDBDQ0ZGJyxcblx0JyMzMzAwQ0MnLFxuXHQnIzMzMDBGRicsXG5cdCcjMzMzM0NDJyxcblx0JyMzMzMzRkYnLFxuXHQnIzMzNjZDQycsXG5cdCcjMzM2NkZGJyxcblx0JyMzMzk5Q0MnLFxuXHQnIzMzOTlGRicsXG5cdCcjMzNDQzAwJyxcblx0JyMzM0NDMzMnLFxuXHQnIzMzQ0M2NicsXG5cdCcjMzNDQzk5Jyxcblx0JyMzM0NDQ0MnLFxuXHQnIzMzQ0NGRicsXG5cdCcjNjYwMENDJyxcblx0JyM2NjAwRkYnLFxuXHQnIzY2MzNDQycsXG5cdCcjNjYzM0ZGJyxcblx0JyM2NkNDMDAnLFxuXHQnIzY2Q0MzMycsXG5cdCcjOTkwMENDJyxcblx0JyM5OTAwRkYnLFxuXHQnIzk5MzNDQycsXG5cdCcjOTkzM0ZGJyxcblx0JyM5OUNDMDAnLFxuXHQnIzk5Q0MzMycsXG5cdCcjQ0MwMDAwJyxcblx0JyNDQzAwMzMnLFxuXHQnI0NDMDA2NicsXG5cdCcjQ0MwMDk5Jyxcblx0JyNDQzAwQ0MnLFxuXHQnI0NDMDBGRicsXG5cdCcjQ0MzMzAwJyxcblx0JyNDQzMzMzMnLFxuXHQnI0NDMzM2NicsXG5cdCcjQ0MzMzk5Jyxcblx0JyNDQzMzQ0MnLFxuXHQnI0NDMzNGRicsXG5cdCcjQ0M2NjAwJyxcblx0JyNDQzY2MzMnLFxuXHQnI0NDOTkwMCcsXG5cdCcjQ0M5OTMzJyxcblx0JyNDQ0NDMDAnLFxuXHQnI0NDQ0MzMycsXG5cdCcjRkYwMDAwJyxcblx0JyNGRjAwMzMnLFxuXHQnI0ZGMDA2NicsXG5cdCcjRkYwMDk5Jyxcblx0JyNGRjAwQ0MnLFxuXHQnI0ZGMDBGRicsXG5cdCcjRkYzMzAwJyxcblx0JyNGRjMzMzMnLFxuXHQnI0ZGMzM2NicsXG5cdCcjRkYzMzk5Jyxcblx0JyNGRjMzQ0MnLFxuXHQnI0ZGMzNGRicsXG5cdCcjRkY2NjAwJyxcblx0JyNGRjY2MzMnLFxuXHQnI0ZGOTkwMCcsXG5cdCcjRkY5OTMzJyxcblx0JyNGRkNDMDAnLFxuXHQnI0ZGQ0MzMydcbl07XG5cbi8qKlxuICogQ3VycmVudGx5IG9ubHkgV2ViS2l0LWJhc2VkIFdlYiBJbnNwZWN0b3JzLCBGaXJlZm94ID49IHYzMSxcbiAqIGFuZCB0aGUgRmlyZWJ1ZyBleHRlbnNpb24gKGFueSBGaXJlZm94IHZlcnNpb24pIGFyZSBrbm93blxuICogdG8gc3VwcG9ydCBcIiVjXCIgQ1NTIGN1c3RvbWl6YXRpb25zLlxuICpcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXG4gKi9cblxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbXBsZXhpdHlcbmZ1bmN0aW9uIHVzZUNvbG9ycygpIHtcblx0Ly8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxuXHQvLyBpbml0aWFsaXplZC4gU2luY2Ugd2Uga25vdyB3ZSdyZSBpbiBDaHJvbWUsIHdlJ2xsIGp1c3QgZGV0ZWN0IHRoaXMgY2FzZVxuXHQvLyBleHBsaWNpdGx5XG5cdGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiAod2luZG93LnByb2Nlc3MudHlwZSA9PT0gJ3JlbmRlcmVyJyB8fCB3aW5kb3cucHJvY2Vzcy5fX253anMpKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHQvLyBJbnRlcm5ldCBFeHBsb3JlciBhbmQgRWRnZSBkbyBub3Qgc3VwcG9ydCBjb2xvcnMuXG5cdGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvKGVkZ2V8dHJpZGVudClcXC8oXFxkKykvKSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdC8vIElzIHdlYmtpdD8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMTY0NTk2MDYvMzc2NzczXG5cdC8vIGRvY3VtZW50IGlzIHVuZGVmaW5lZCBpbiByZWFjdC1uYXRpdmU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC1uYXRpdmUvcHVsbC8xNjMyXG5cdHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxuXHRcdC8vIElzIGZpcmVidWc/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzM5ODEyMC8zNzY3NzNcblx0XHQodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LmNvbnNvbGUgJiYgKHdpbmRvdy5jb25zb2xlLmZpcmVidWcgfHwgKHdpbmRvdy5jb25zb2xlLmV4Y2VwdGlvbiAmJiB3aW5kb3cuY29uc29sZS50YWJsZSkpKSB8fFxuXHRcdC8vIElzIGZpcmVmb3ggPj0gdjMxP1xuXHRcdC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvVG9vbHMvV2ViX0NvbnNvbGUjU3R5bGluZ19tZXNzYWdlc1xuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvZmlyZWZveFxcLyhcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxuXHRcdC8vIERvdWJsZSBjaGVjayB3ZWJraXQgaW4gdXNlckFnZW50IGp1c3QgaW4gY2FzZSB3ZSBhcmUgaW4gYSB3b3JrZXJcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2FwcGxld2Via2l0XFwvKFxcZCspLykpO1xufVxuXG4vKipcbiAqIENvbG9yaXplIGxvZyBhcmd1bWVudHMgaWYgZW5hYmxlZC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGZvcm1hdEFyZ3MoYXJncykge1xuXHRhcmdzWzBdID0gKHRoaXMudXNlQ29sb3JzID8gJyVjJyA6ICcnKSArXG5cdFx0dGhpcy5uYW1lc3BhY2UgK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKSArXG5cdFx0YXJnc1swXSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyVjICcgOiAnICcpICtcblx0XHQnKycgKyBtb2R1bGUuZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xuXG5cdGlmICghdGhpcy51c2VDb2xvcnMpIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRjb25zdCBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcblx0YXJncy5zcGxpY2UoMSwgMCwgYywgJ2NvbG9yOiBpbmhlcml0Jyk7XG5cblx0Ly8gVGhlIGZpbmFsIFwiJWNcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcblx0Ly8gYXJndW1lbnRzIHBhc3NlZCBlaXRoZXIgYmVmb3JlIG9yIGFmdGVyIHRoZSAlYywgc28gd2UgbmVlZCB0b1xuXHQvLyBmaWd1cmUgb3V0IHRoZSBjb3JyZWN0IGluZGV4IHRvIGluc2VydCB0aGUgQ1NTIGludG9cblx0bGV0IGluZGV4ID0gMDtcblx0bGV0IGxhc3RDID0gMDtcblx0YXJnc1swXS5yZXBsYWNlKC8lW2EtekEtWiVdL2csIG1hdGNoID0+IHtcblx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0aW5kZXgrKztcblx0XHRpZiAobWF0Y2ggPT09ICclYycpIHtcblx0XHRcdC8vIFdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xuXHRcdFx0Ly8gKHRoZSB1c2VyIG1heSBoYXZlIHByb3ZpZGVkIHRoZWlyIG93bilcblx0XHRcdGxhc3RDID0gaW5kZXg7XG5cdFx0fVxuXHR9KTtcblxuXHRhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XG59XG5cbi8qKlxuICogSW52b2tlcyBgY29uc29sZS5kZWJ1ZygpYCB3aGVuIGF2YWlsYWJsZS5cbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhIFwiZnVuY3Rpb25cIi5cbiAqIElmIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYXZhaWxhYmxlLCBmYWxscyBiYWNrXG4gKiB0byBgY29uc29sZS5sb2dgLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cbmV4cG9ydHMubG9nID0gY29uc29sZS5kZWJ1ZyB8fCBjb25zb2xlLmxvZyB8fCAoKCkgPT4ge30pO1xuXG4vKipcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2F2ZShuYW1lc3BhY2VzKSB7XG5cdHRyeSB7XG5cdFx0aWYgKG5hbWVzcGFjZXMpIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5zZXRJdGVtKCdkZWJ1ZycsIG5hbWVzcGFjZXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbi8qKlxuICogTG9hZCBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGxvYWQoKSB7XG5cdGxldCByO1xuXHR0cnkge1xuXHRcdHIgPSBleHBvcnRzLnN0b3JhZ2UuZ2V0SXRlbSgnZGVidWcnKTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cblxuXHQvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXG5cdGlmICghciAmJiB0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgJ2VudicgaW4gcHJvY2Vzcykge1xuXHRcdHIgPSBwcm9jZXNzLmVudi5ERUJVRztcblx0fVxuXG5cdHJldHVybiByO1xufVxuXG4vKipcbiAqIExvY2Fsc3RvcmFnZSBhdHRlbXB0cyB0byByZXR1cm4gdGhlIGxvY2Fsc3RvcmFnZS5cbiAqXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcbiAqIHdoZW4gYSB1c2VyIGRpc2FibGVzIGNvb2tpZXMvbG9jYWxzdG9yYWdlXG4gKiBhbmQgeW91IGF0dGVtcHQgdG8gYWNjZXNzIGl0LlxuICpcbiAqIEByZXR1cm4ge0xvY2FsU3RvcmFnZX1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGxvY2Fsc3RvcmFnZSgpIHtcblx0dHJ5IHtcblx0XHQvLyBUVk1MS2l0IChBcHBsZSBUViBKUyBSdW50aW1lKSBkb2VzIG5vdCBoYXZlIGEgd2luZG93IG9iamVjdCwganVzdCBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0XG5cdFx0Ly8gVGhlIEJyb3dzZXIgYWxzbyBoYXMgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dC5cblx0XHRyZXR1cm4gbG9jYWxTdG9yYWdlO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY29tbW9uJykoZXhwb3J0cyk7XG5cbmNvbnN0IHtmb3JtYXR0ZXJzfSA9IG1vZHVsZS5leHBvcnRzO1xuXG4vKipcbiAqIE1hcCAlaiB0byBgSlNPTi5zdHJpbmdpZnkoKWAsIHNpbmNlIG5vIFdlYiBJbnNwZWN0b3JzIGRvIHRoYXQgYnkgZGVmYXVsdC5cbiAqL1xuXG5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbiAodikge1xuXHR0cnkge1xuXHRcdHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHRyZXR1cm4gJ1tVbmV4cGVjdGVkSlNPTlBhcnNlRXJyb3JdOiAnICsgZXJyb3IubWVzc2FnZTtcblx0fVxufTtcbiIsIlxuLyoqXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXG4gKiBpbXBsZW1lbnRhdGlvbnMgb2YgYGRlYnVnKClgLlxuICovXG5cbmZ1bmN0aW9uIHNldHVwKGVudikge1xuXHRjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5kZWZhdWx0ID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmNvZXJjZSA9IGNvZXJjZTtcblx0Y3JlYXRlRGVidWcuZGlzYWJsZSA9IGRpc2FibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZSA9IGVuYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlZCA9IGVuYWJsZWQ7XG5cdGNyZWF0ZURlYnVnLmh1bWFuaXplID0gcmVxdWlyZSgnbXMnKTtcblx0Y3JlYXRlRGVidWcuZGVzdHJveSA9IGRlc3Ryb3k7XG5cblx0T2JqZWN0LmtleXMoZW52KS5mb3JFYWNoKGtleSA9PiB7XG5cdFx0Y3JlYXRlRGVidWdba2V5XSA9IGVudltrZXldO1xuXHR9KTtcblxuXHQvKipcblx0KiBUaGUgY3VycmVudGx5IGFjdGl2ZSBkZWJ1ZyBtb2RlIG5hbWVzLCBhbmQgbmFtZXMgdG8gc2tpcC5cblx0Ki9cblxuXHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdC8qKlxuXHQqIE1hcCBvZiBzcGVjaWFsIFwiJW5cIiBoYW5kbGluZyBmdW5jdGlvbnMsIGZvciB0aGUgZGVidWcgXCJmb3JtYXRcIiBhcmd1bWVudC5cblx0KlxuXHQqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFwiblwiIGFuZCBcIk5cIi5cblx0Ki9cblx0Y3JlYXRlRGVidWcuZm9ybWF0dGVycyA9IHt9O1xuXG5cdC8qKlxuXHQqIFNlbGVjdHMgYSBjb2xvciBmb3IgYSBkZWJ1ZyBuYW1lc3BhY2Vcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlIFRoZSBuYW1lc3BhY2Ugc3RyaW5nIGZvciB0aGUgZGVidWcgaW5zdGFuY2UgdG8gYmUgY29sb3JlZFxuXHQqIEByZXR1cm4ge051bWJlcnxTdHJpbmd9IEFuIEFOU0kgY29sb3IgY29kZSBmb3IgdGhlIGdpdmVuIG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBzZWxlY3RDb2xvcihuYW1lc3BhY2UpIHtcblx0XHRsZXQgaGFzaCA9IDA7XG5cblx0XHRmb3IgKGxldCBpID0gMDsgaSA8IG5hbWVzcGFjZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0aGFzaCA9ICgoaGFzaCA8PCA1KSAtIGhhc2gpICsgbmFtZXNwYWNlLmNoYXJDb2RlQXQoaSk7XG5cdFx0XHRoYXNoIHw9IDA7IC8vIENvbnZlcnQgdG8gMzJiaXQgaW50ZWdlclxuXHRcdH1cblxuXHRcdHJldHVybiBjcmVhdGVEZWJ1Zy5jb2xvcnNbTWF0aC5hYnMoaGFzaCkgJSBjcmVhdGVEZWJ1Zy5jb2xvcnMubGVuZ3RoXTtcblx0fVxuXHRjcmVhdGVEZWJ1Zy5zZWxlY3RDb2xvciA9IHNlbGVjdENvbG9yO1xuXG5cdC8qKlxuXHQqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEByZXR1cm4ge0Z1bmN0aW9ufVxuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGNyZWF0ZURlYnVnKG5hbWVzcGFjZSkge1xuXHRcdGxldCBwcmV2VGltZTtcblx0XHRsZXQgZW5hYmxlT3ZlcnJpZGUgPSBudWxsO1xuXHRcdGxldCBuYW1lc3BhY2VzQ2FjaGU7XG5cdFx0bGV0IGVuYWJsZWRDYWNoZTtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiB7XG5cdFx0XHRcdGlmIChlbmFibGVPdmVycmlkZSAhPT0gbnVsbCkge1xuXHRcdFx0XHRcdHJldHVybiBlbmFibGVPdmVycmlkZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAobmFtZXNwYWNlc0NhY2hlICE9PSBjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzKSB7XG5cdFx0XHRcdFx0bmFtZXNwYWNlc0NhY2hlID0gY3JlYXRlRGVidWcubmFtZXNwYWNlcztcblx0XHRcdFx0XHRlbmFibGVkQ2FjaGUgPSBjcmVhdGVEZWJ1Zy5lbmFibGVkKG5hbWVzcGFjZSk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZW5hYmxlZENhY2hlO1xuXHRcdFx0fSxcblx0XHRcdHNldDogdiA9PiB7XG5cdFx0XHRcdGVuYWJsZU92ZXJyaWRlID0gdjtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdC8vIEVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXG5cdFx0aWYgKHR5cGVvZiBjcmVhdGVEZWJ1Zy5pbml0ID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRjcmVhdGVEZWJ1Zy5pbml0KGRlYnVnKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVidWc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHRlbmQobmFtZXNwYWNlLCBkZWxpbWl0ZXIpIHtcblx0XHRjb25zdCBuZXdEZWJ1ZyA9IGNyZWF0ZURlYnVnKHRoaXMubmFtZXNwYWNlICsgKHR5cGVvZiBkZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gJzonIDogZGVsaW1pdGVyKSArIG5hbWVzcGFjZSk7XG5cdFx0bmV3RGVidWcubG9nID0gdGhpcy5sb2c7XG5cdFx0cmV0dXJuIG5ld0RlYnVnO1xuXHR9XG5cblx0LyoqXG5cdCogRW5hYmxlcyBhIGRlYnVnIG1vZGUgYnkgbmFtZXNwYWNlcy4gVGhpcyBjYW4gaW5jbHVkZSBtb2Rlc1xuXHQqIHNlcGFyYXRlZCBieSBhIGNvbG9uIGFuZCB3aWxkY2FyZHMuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XG5cdFx0Y3JlYXRlRGVidWcuc2F2ZShuYW1lc3BhY2VzKTtcblx0XHRjcmVhdGVEZWJ1Zy5uYW1lc3BhY2VzID0gbmFtZXNwYWNlcztcblxuXHRcdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdFx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHRcdGxldCBpO1xuXHRcdGNvbnN0IHNwbGl0ID0gKHR5cGVvZiBuYW1lc3BhY2VzID09PSAnc3RyaW5nJyA/IG5hbWVzcGFjZXMgOiAnJykuc3BsaXQoL1tcXHMsXSsvKTtcblx0XHRjb25zdCBsZW4gPSBzcGxpdC5sZW5ndGg7XG5cblx0XHRmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmICghc3BsaXRbaV0pIHtcblx0XHRcdFx0Ly8gaWdub3JlIGVtcHR5IHN0cmluZ3Ncblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXCovZywgJy4qPycpO1xuXG5cdFx0XHRpZiAobmFtZXNwYWNlc1swXSA9PT0gJy0nKSB7XG5cdFx0XHRcdGNyZWF0ZURlYnVnLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnNsaWNlKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKipcbiAqIEhlbHBlcnMuXG4gKi9cblxudmFyIHMgPSAxMDAwO1xudmFyIG0gPSBzICogNjA7XG52YXIgaCA9IG0gKiA2MDtcbnZhciBkID0gaCAqIDI0O1xudmFyIHcgPSBkICogNztcbnZhciB5ID0gZCAqIDM2NS4yNTtcblxuLyoqXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxuICpcbiAqIE9wdGlvbnM6XG4gKlxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8TnVtYmVyfSB2YWxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiB2YWwgaXMgbm90IGEgbm9uLWVtcHR5IHN0cmluZyBvciBhIG51bWJlclxuICogQHJldHVybiB7U3RyaW5nfE51bWJlcn1cbiAqIEBhcGkgcHVibGljXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gIHZhciB0eXBlID0gdHlwZW9mIHZhbDtcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XG4gICAgcmV0dXJuIHBhcnNlKHZhbCk7XG4gIH0gZWxzZSBpZiAodHlwZSA9PT0gJ251bWJlcicgJiYgaXNGaW5pdGUodmFsKSkge1xuICAgIHJldHVybiBvcHRpb25zLmxvbmcgPyBmbXRMb25nKHZhbCkgOiBmbXRTaG9ydCh2YWwpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcbiAgICAndmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSB2YWxpZCBudW1iZXIuIHZhbD0nICtcbiAgICAgIEpTT04uc3RyaW5naWZ5KHZhbClcbiAgKTtcbn07XG5cbi8qKlxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcbiAqIEByZXR1cm4ge051bWJlcn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIHBhcnNlKHN0cikge1xuICBzdHIgPSBTdHJpbmcoc3RyKTtcbiAgaWYgKHN0ci5sZW5ndGggPiAxMDApIHtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG1hdGNoID0gL14oLT8oPzpcXGQrKT9cXC4/XFxkKykgKihtaWxsaXNlY29uZHM/fG1zZWNzP3xtc3xzZWNvbmRzP3xzZWNzP3xzfG1pbnV0ZXM/fG1pbnM/fG18aG91cnM/fGhycz98aHxkYXlzP3xkfHdlZWtzP3x3fHllYXJzP3x5cnM/fHkpPyQvaS5leGVjKFxuICAgIHN0clxuICApO1xuICBpZiAoIW1hdGNoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBuID0gcGFyc2VGbG9hdChtYXRjaFsxXSk7XG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3llYXJzJzpcbiAgICBjYXNlICd5ZWFyJzpcbiAgICBjYXNlICd5cnMnOlxuICAgIGNhc2UgJ3lyJzpcbiAgICBjYXNlICd5JzpcbiAgICAgIHJldHVybiBuICogeTtcbiAgICBjYXNlICd3ZWVrcyc6XG4gICAgY2FzZSAnd2Vlayc6XG4gICAgY2FzZSAndyc6XG4gICAgICByZXR1cm4gbiAqIHc7XG4gICAgY2FzZSAnZGF5cyc6XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdkJzpcbiAgICAgIHJldHVybiBuICogZDtcbiAgICBjYXNlICdob3Vycyc6XG4gICAgY2FzZSAnaG91cic6XG4gICAgY2FzZSAnaHJzJzpcbiAgICBjYXNlICdocic6XG4gICAgY2FzZSAnaCc6XG4gICAgICByZXR1cm4gbiAqIGg7XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnbWludXRlJzpcbiAgICBjYXNlICdtaW5zJzpcbiAgICBjYXNlICdtaW4nOlxuICAgIGNhc2UgJ20nOlxuICAgICAgcmV0dXJuIG4gKiBtO1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ3NlY29uZCc6XG4gICAgY2FzZSAnc2Vjcyc6XG4gICAgY2FzZSAnc2VjJzpcbiAgICBjYXNlICdzJzpcbiAgICAgIHJldHVybiBuICogcztcbiAgICBjYXNlICdtaWxsaXNlY29uZHMnOlxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcbiAgICBjYXNlICdtc2Vjcyc6XG4gICAgY2FzZSAnbXNlYyc6XG4gICAgY2FzZSAnbXMnOlxuICAgICAgcmV0dXJuIG47XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbn1cblxuLyoqXG4gKiBTaG9ydCBmb3JtYXQgZm9yIGBtc2AuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXG4gKiBAcmV0dXJuIHtTdHJpbmd9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IG0pIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xuICB9XG4gIGlmIChtc0FicyA+PSBzKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcbiAgfVxuICByZXR1cm4gbXMgKyAnbXMnO1xufVxuXG4vKipcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10TG9uZyhtcykge1xuICB2YXIgbXNBYnMgPSBNYXRoLmFicyhtcyk7XG4gIGlmIChtc0FicyA+PSBkKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIGQsICdkYXknKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gaCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBoLCAnaG91cicpO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIHBsdXJhbChtcywgbXNBYnMsIG0sICdtaW51dGUnKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBzLCAnc2Vjb25kJyk7XG4gIH1cbiAgcmV0dXJuIG1zICsgJyBtcyc7XG59XG5cbi8qKlxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXG4gKi9cblxuZnVuY3Rpb24gcGx1cmFsKG1zLCBtc0FicywgbiwgbmFtZSkge1xuICB2YXIgaXNQbHVyYWwgPSBtc0FicyA+PSBuICogMS41O1xuICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG4pICsgJyAnICsgbmFtZSArIChpc1BsdXJhbCA/ICdzJyA6ICcnKTtcbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xuXG4vKipcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5leHBvcnRzLmZvcm1hdEFyZ3MgPSBmb3JtYXRBcmdzO1xuZXhwb3J0cy5zYXZlID0gc2F2ZTtcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XG5leHBvcnRzLnVzZUNvbG9ycyA9IHVzZUNvbG9ycztcbmV4cG9ydHMuc3RvcmFnZSA9IGxvY2Fsc3RvcmFnZSgpO1xuZXhwb3J0cy5kZXN0cm95ID0gKCgpID0+IHtcblx0bGV0IHdhcm5lZCA9IGZhbHNlO1xuXG5cdHJldHVybiAoKSA9PiB7XG5cdFx0aWYgKCF3YXJuZWQpIHtcblx0XHRcdHdhcm5lZCA9IHRydWU7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0luc3RhbmNlIG1ldGhvZCBgZGVidWcuZGVzdHJveSgpYCBpcyBkZXByZWNhdGVkIGFuZCBubyBsb25nZXIgZG9lcyBhbnl0aGluZy4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24gb2YgYGRlYnVnYC4nKTtcblx0XHR9XG5cdH07XG59KSgpO1xuXG4vKipcbiAqIENvbG9ycy5cbiAqL1xuXG5leHBvcnRzLmNvbG9ycyA9IFtcblx0JyMwMDAwQ0MnLFxuXHQnIzAwMDBGRicsXG5cdCcjMDAzM0NDJyxcblx0JyMwMDMzRkYnLFxuXHQnIzAwNjZDQycsXG5cdCcjMDA2NkZGJyxcblx0JyMwMDk5Q0MnLFxuXHQnIzAwOTlGRicsXG5cdCcjMDBDQzAwJyxcblx0JyMwMENDMzMnLFxuXHQnIzAwQ0M2NicsXG5cdCcjMDBDQzk5Jyxcblx0JyMwMENDQ0MnLFxuXHQnIzAwQ0NGRicsXG5cdCcjMzMwMENDJyxcblx0JyMzMzAwRkYnLFxuXHQnIzMzMzNDQycsXG5cdCcjMzMzM0ZGJyxcblx0JyMzMzY2Q0MnLFxuXHQnIzMzNjZGRicsXG5cdCcjMzM5OUNDJyxcblx0JyMzMzk5RkYnLFxuXHQnIzMzQ0MwMCcsXG5cdCcjMzNDQzMzJyxcblx0JyMzM0NDNjYnLFxuXHQnIzMzQ0M5OScsXG5cdCcjMzNDQ0NDJyxcblx0JyMzM0NDRkYnLFxuXHQnIzY2MDBDQycsXG5cdCcjNjYwMEZGJyxcblx0JyM2NjMzQ0MnLFxuXHQnIzY2MzNGRicsXG5cdCcjNjZDQzAwJyxcblx0JyM2NkNDMzMnLFxuXHQnIzk5MDBDQycsXG5cdCcjOTkwMEZGJyxcblx0JyM5OTMzQ0MnLFxuXHQnIzk5MzNGRicsXG5cdCcjOTlDQzAwJyxcblx0JyM5OUNDMzMnLFxuXHQnI0NDMDAwMCcsXG5cdCcjQ0MwMDMzJyxcblx0JyNDQzAwNjYnLFxuXHQnI0NDMDA5OScsXG5cdCcjQ0MwMENDJyxcblx0JyNDQzAwRkYnLFxuXHQnI0NDMzMwMCcsXG5cdCcjQ0MzMzMzJyxcblx0JyNDQzMzNjYnLFxuXHQnI0NDMzM5OScsXG5cdCcjQ0MzM0NDJyxcblx0JyNDQzMzRkYnLFxuXHQnI0NDNjYwMCcsXG5cdCcjQ0M2NjMzJyxcblx0JyNDQzk5MDAnLFxuXHQnI0NDOTkzMycsXG5cdCcjQ0NDQzAwJyxcblx0JyNDQ0NDMzMnLFxuXHQnI0ZGMDAwMCcsXG5cdCcjRkYwMDMzJyxcblx0JyNGRjAwNjYnLFxuXHQnI0ZGMDA5OScsXG5cdCcjRkYwMENDJyxcblx0JyNGRjAwRkYnLFxuXHQnI0ZGMzMwMCcsXG5cdCcjRkYzMzMzJyxcblx0JyNGRjMzNjYnLFxuXHQnI0ZGMzM5OScsXG5cdCcjRkYzM0NDJyxcblx0JyNGRjMzRkYnLFxuXHQnI0ZGNjYwMCcsXG5cdCcjRkY2NjMzJyxcblx0JyNGRjk5MDAnLFxuXHQnI0ZGOTkzMycsXG5cdCcjRkZDQzAwJyxcblx0JyNGRkNDMzMnXG5dO1xuXG4vKipcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXG4gKiBhbmQgdGhlIEZpcmVidWcgZXh0ZW5zaW9uIChhbnkgRmlyZWZveCB2ZXJzaW9uKSBhcmUga25vd25cbiAqIHRvIHN1cHBvcnQgXCIlY1wiIENTUyBjdXN0b21pemF0aW9ucy5cbiAqXG4gKiBUT0RPOiBhZGQgYSBgbG9jYWxTdG9yYWdlYCB2YXJpYWJsZSB0byBleHBsaWNpdGx5IGVuYWJsZS9kaXNhYmxlIGNvbG9yc1xuICovXG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb21wbGV4aXR5XG5mdW5jdGlvbiB1c2VDb2xvcnMoKSB7XG5cdC8vIE5COiBJbiBhbiBFbGVjdHJvbiBwcmVsb2FkIHNjcmlwdCwgZG9jdW1lbnQgd2lsbCBiZSBkZWZpbmVkIGJ1dCBub3QgZnVsbHlcblx0Ly8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2Vcblx0Ly8gZXhwbGljaXRseVxuXHRpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnByb2Nlc3MgJiYgKHdpbmRvdy5wcm9jZXNzLnR5cGUgPT09ICdyZW5kZXJlcicgfHwgd2luZG93LnByb2Nlc3MuX19ud2pzKSkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG5cblx0Ly8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxuXHRpZiAodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goLyhlZGdlfHRyaWRlbnQpXFwvKFxcZCspLykpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvLyBJcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xuXHQvLyBkb2N1bWVudCBpcyB1bmRlZmluZWQgaW4gcmVhY3QtbmF0aXZlOiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QtbmF0aXZlL3B1bGwvMTYzMlxuXHRyZXR1cm4gKHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZSAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUuV2Via2l0QXBwZWFyYW5jZSkgfHxcblx0XHQvLyBJcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXG5cdFx0KHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5jb25zb2xlICYmICh3aW5kb3cuY29uc29sZS5maXJlYnVnIHx8ICh3aW5kb3cuY29uc29sZS5leGNlcHRpb24gJiYgd2luZG93LmNvbnNvbGUudGFibGUpKSkgfHxcblx0XHQvLyBJcyBmaXJlZm94ID49IHYzMT9cblx0XHQvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcblx0XHQodHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudCAmJiBuYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCkubWF0Y2goL2ZpcmVmb3hcXC8oXFxkKykvKSAmJiBwYXJzZUludChSZWdFeHAuJDEsIDEwKSA+PSAzMSkgfHxcblx0XHQvLyBEb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9hcHBsZXdlYmtpdFxcLyhcXGQrKS8pKTtcbn1cblxuLyoqXG4gKiBDb2xvcml6ZSBsb2cgYXJndW1lbnRzIGlmIGVuYWJsZWQuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcblx0YXJnc1swXSA9ICh0aGlzLnVzZUNvbG9ycyA/ICclYycgOiAnJykgK1xuXHRcdHRoaXMubmFtZXNwYWNlICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnICVjJyA6ICcgJykgK1xuXHRcdGFyZ3NbMF0gK1xuXHRcdCh0aGlzLnVzZUNvbG9ycyA/ICclYyAnIDogJyAnKSArXG5cdFx0JysnICsgbW9kdWxlLmV4cG9ydHMuaHVtYW5pemUodGhpcy5kaWZmKTtcblxuXHRpZiAoIXRoaXMudXNlQ29sb3JzKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Y29uc3QgYyA9ICdjb2xvcjogJyArIHRoaXMuY29sb3I7XG5cdGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpO1xuXG5cdC8vIFRoZSBmaW5hbCBcIiVjXCIgaXMgc29tZXdoYXQgdHJpY2t5LCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG90aGVyXG5cdC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cblx0Ly8gZmlndXJlIG91dCB0aGUgY29ycmVjdCBpbmRleCB0byBpbnNlcnQgdGhlIENTUyBpbnRvXG5cdGxldCBpbmRleCA9IDA7XG5cdGxldCBsYXN0QyA9IDA7XG5cdGFyZ3NbMF0ucmVwbGFjZSgvJVthLXpBLVolXS9nLCBtYXRjaCA9PiB7XG5cdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdGluZGV4Kys7XG5cdFx0aWYgKG1hdGNoID09PSAnJWMnKSB7XG5cdFx0XHQvLyBXZSBvbmx5IGFyZSBpbnRlcmVzdGVkIGluIHRoZSAqbGFzdCogJWNcblx0XHRcdC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXG5cdFx0XHRsYXN0QyA9IGluZGV4O1xuXHRcdH1cblx0fSk7XG5cblx0YXJncy5zcGxpY2UobGFzdEMsIDAsIGMpO1xufVxuXG4vKipcbiAqIEludm9rZXMgYGNvbnNvbGUuZGVidWcoKWAgd2hlbiBhdmFpbGFibGUuXG4gKiBOby1vcCB3aGVuIGBjb25zb2xlLmRlYnVnYCBpcyBub3QgYSBcImZ1bmN0aW9uXCIuXG4gKiBJZiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGF2YWlsYWJsZSwgZmFsbHMgYmFja1xuICogdG8gYGNvbnNvbGUubG9nYC5cbiAqXG4gKiBAYXBpIHB1YmxpY1xuICovXG5leHBvcnRzLmxvZyA9IGNvbnNvbGUuZGVidWcgfHwgY29uc29sZS5sb2cgfHwgKCgpID0+IHt9KTtcblxuLyoqXG4gKiBTYXZlIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZXNwYWNlc1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNhdmUobmFtZXNwYWNlcykge1xuXHR0cnkge1xuXHRcdGlmIChuYW1lc3BhY2VzKSB7XG5cdFx0XHRleHBvcnRzLnN0b3JhZ2Uuc2V0SXRlbSgnZGVidWcnLCBuYW1lc3BhY2VzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnJlbW92ZUl0ZW0oJ2RlYnVnJyk7XG5cdFx0fVxuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxufVxuXG4vKipcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxuICpcbiAqIEByZXR1cm4ge1N0cmluZ30gcmV0dXJucyB0aGUgcHJldmlvdXNseSBwZXJzaXN0ZWQgZGVidWcgbW9kZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBsb2FkKCkge1xuXHRsZXQgcjtcblx0dHJ5IHtcblx0XHRyID0gZXhwb3J0cy5zdG9yYWdlLmdldEl0ZW0oJ2RlYnVnJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG5cblx0Ly8gSWYgZGVidWcgaXNuJ3Qgc2V0IGluIExTLCBhbmQgd2UncmUgaW4gRWxlY3Ryb24sIHRyeSB0byBsb2FkICRERUJVR1xuXHRpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcblx0XHRyID0gcHJvY2Vzcy5lbnYuREVCVUc7XG5cdH1cblxuXHRyZXR1cm4gcjtcbn1cblxuLyoqXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXG4gKlxuICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBzYWZhcmkgdGhyb3dzXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxuICogYW5kIHlvdSBhdHRlbXB0IHRvIGFjY2VzcyBpdC5cbiAqXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBsb2NhbHN0b3JhZ2UoKSB7XG5cdHRyeSB7XG5cdFx0Ly8gVFZNTEtpdCAoQXBwbGUgVFYgSlMgUnVudGltZSkgZG9lcyBub3QgaGF2ZSBhIHdpbmRvdyBvYmplY3QsIGp1c3QgbG9jYWxTdG9yYWdlIGluIHRoZSBnbG9iYWwgY29udGV4dFxuXHRcdC8vIFRoZSBCcm93c2VyIGFsc28gaGFzIGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHQuXG5cdFx0cmV0dXJuIGxvY2FsU3RvcmFnZTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2NvbW1vbicpKGV4cG9ydHMpO1xuXG5jb25zdCB7Zm9ybWF0dGVyc30gPSBtb2R1bGUuZXhwb3J0cztcblxuLyoqXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXG4gKi9cblxuZm9ybWF0dGVycy5qID0gZnVuY3Rpb24gKHYpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0cmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVycm9yLm1lc3NhZ2U7XG5cdH1cbn07XG4iLCJcbi8qKlxuICogVGhpcyBpcyB0aGUgY29tbW9uIGxvZ2ljIGZvciBib3RoIHRoZSBOb2RlLmpzIGFuZCB3ZWIgYnJvd3NlclxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cbiAqL1xuXG5mdW5jdGlvbiBzZXR1cChlbnYpIHtcblx0Y3JlYXRlRGVidWcuZGVidWcgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuZGVmYXVsdCA9IGNyZWF0ZURlYnVnO1xuXHRjcmVhdGVEZWJ1Zy5jb2VyY2UgPSBjb2VyY2U7XG5cdGNyZWF0ZURlYnVnLmRpc2FibGUgPSBkaXNhYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGUgPSBlbmFibGU7XG5cdGNyZWF0ZURlYnVnLmVuYWJsZWQgPSBlbmFibGVkO1xuXHRjcmVhdGVEZWJ1Zy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XG5cdGNyZWF0ZURlYnVnLmRlc3Ryb3kgPSBkZXN0cm95O1xuXG5cdE9iamVjdC5rZXlzKGVudikuZm9yRWFjaChrZXkgPT4ge1xuXHRcdGNyZWF0ZURlYnVnW2tleV0gPSBlbnZba2V5XTtcblx0fSk7XG5cblx0LyoqXG5cdCogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXG5cdCovXG5cblx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0Y3JlYXRlRGVidWcuc2tpcHMgPSBbXTtcblxuXHQvKipcblx0KiBNYXAgb2Ygc3BlY2lhbCBcIiVuXCIgaGFuZGxpbmcgZnVuY3Rpb25zLCBmb3IgdGhlIGRlYnVnIFwiZm9ybWF0XCIgYXJndW1lbnQuXG5cdCpcblx0KiBWYWxpZCBrZXkgbmFtZXMgYXJlIGEgc2luZ2xlLCBsb3dlciBvciB1cHBlci1jYXNlIGxldHRlciwgaS5lLiBcIm5cIiBhbmQgXCJOXCIuXG5cdCovXG5cdGNyZWF0ZURlYnVnLmZvcm1hdHRlcnMgPSB7fTtcblxuXHQvKipcblx0KiBTZWxlY3RzIGEgY29sb3IgZm9yIGEgZGVidWcgbmFtZXNwYWNlXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZSBUaGUgbmFtZXNwYWNlIHN0cmluZyBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblx0XHRsZXQgbmFtZXNwYWNlc0NhY2hlO1xuXHRcdGxldCBlbmFibGVkQ2FjaGU7XG5cblx0XHRmdW5jdGlvbiBkZWJ1ZyguLi5hcmdzKSB7XG5cdFx0XHQvLyBEaXNhYmxlZD9cblx0XHRcdGlmICghZGVidWcuZW5hYmxlZCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNlbGYgPSBkZWJ1ZztcblxuXHRcdFx0Ly8gU2V0IGBkaWZmYCB0aW1lc3RhbXBcblx0XHRcdGNvbnN0IGN1cnIgPSBOdW1iZXIobmV3IERhdGUoKSk7XG5cdFx0XHRjb25zdCBtcyA9IGN1cnIgLSAocHJldlRpbWUgfHwgY3Vycik7XG5cdFx0XHRzZWxmLmRpZmYgPSBtcztcblx0XHRcdHNlbGYucHJldiA9IHByZXZUaW1lO1xuXHRcdFx0c2VsZi5jdXJyID0gY3Vycjtcblx0XHRcdHByZXZUaW1lID0gY3VycjtcblxuXHRcdFx0YXJnc1swXSA9IGNyZWF0ZURlYnVnLmNvZXJjZShhcmdzWzBdKTtcblxuXHRcdFx0aWYgKHR5cGVvZiBhcmdzWzBdICE9PSAnc3RyaW5nJykge1xuXHRcdFx0XHQvLyBBbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xuXHRcdFx0XHRhcmdzLnVuc2hpZnQoJyVPJyk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFwcGx5IGFueSBgZm9ybWF0dGVyc2AgdHJhbnNmb3JtYXRpb25zXG5cdFx0XHRsZXQgaW5kZXggPSAwO1xuXHRcdFx0YXJnc1swXSA9IGFyZ3NbMF0ucmVwbGFjZSgvJShbYS16QS1aJV0pL2csIChtYXRjaCwgZm9ybWF0KSA9PiB7XG5cdFx0XHRcdC8vIElmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcblx0XHRcdFx0aWYgKG1hdGNoID09PSAnJSUnKSB7XG5cdFx0XHRcdFx0cmV0dXJuICclJztcblx0XHRcdFx0fVxuXHRcdFx0XHRpbmRleCsrO1xuXHRcdFx0XHRjb25zdCBmb3JtYXR0ZXIgPSBjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzW2Zvcm1hdF07XG5cdFx0XHRcdGlmICh0eXBlb2YgZm9ybWF0dGVyID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdFx0Y29uc3QgdmFsID0gYXJnc1tpbmRleF07XG5cdFx0XHRcdFx0bWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xuXG5cdFx0XHRcdFx0Ly8gTm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxuXHRcdFx0XHRcdGFyZ3Muc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBtYXRjaDtcblx0XHRcdH0pO1xuXG5cdFx0XHQvLyBBcHBseSBlbnYtc3BlY2lmaWMgZm9ybWF0dGluZyAoY29sb3JzLCBldGMuKVxuXHRcdFx0Y3JlYXRlRGVidWcuZm9ybWF0QXJncy5jYWxsKHNlbGYsIGFyZ3MpO1xuXG5cdFx0XHRjb25zdCBsb2dGbiA9IHNlbGYubG9nIHx8IGNyZWF0ZURlYnVnLmxvZztcblx0XHRcdGxvZ0ZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXHRcdH1cblxuXHRcdGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcblx0XHRkZWJ1Zy51c2VDb2xvcnMgPSBjcmVhdGVEZWJ1Zy51c2VDb2xvcnMoKTtcblx0XHRkZWJ1Zy5jb2xvciA9IGNyZWF0ZURlYnVnLnNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XG5cdFx0ZGVidWcuZXh0ZW5kID0gZXh0ZW5kO1xuXHRcdGRlYnVnLmRlc3Ryb3kgPSBjcmVhdGVEZWJ1Zy5kZXN0cm95OyAvLyBYWFggVGVtcG9yYXJ5LiBXaWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgcmVsZWFzZS5cblxuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShkZWJ1ZywgJ2VuYWJsZWQnLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Y29uZmlndXJhYmxlOiBmYWxzZSxcblx0XHRcdGdldDogKCkgPT4ge1xuXHRcdFx0XHRpZiAoZW5hYmxlT3ZlcnJpZGUgIT09IG51bGwpIHtcblx0XHRcdFx0XHRyZXR1cm4gZW5hYmxlT3ZlcnJpZGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5hbWVzcGFjZXNDYWNoZSAhPT0gY3JlYXRlRGVidWcubmFtZXNwYWNlcykge1xuXHRcdFx0XHRcdG5hbWVzcGFjZXNDYWNoZSA9IGNyZWF0ZURlYnVnLm5hbWVzcGFjZXM7XG5cdFx0XHRcdFx0ZW5hYmxlZENhY2hlID0gY3JlYXRlRGVidWcuZW5hYmxlZChuYW1lc3BhY2UpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVuYWJsZWRDYWNoZTtcblx0XHRcdH0sXG5cdFx0XHRzZXQ6IHYgPT4ge1xuXHRcdFx0XHRlbmFibGVPdmVycmlkZSA9IHY7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHQvLyBFbnYtc3BlY2lmaWMgaW5pdGlhbGl6YXRpb24gbG9naWMgZm9yIGRlYnVnIGluc3RhbmNlc1xuXHRcdGlmICh0eXBlb2YgY3JlYXRlRGVidWcuaW5pdCA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdFx0Y3JlYXRlRGVidWcuaW5pdChkZWJ1Zyk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRlYnVnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXh0ZW5kKG5hbWVzcGFjZSwgZGVsaW1pdGVyKSB7XG5cdFx0Y29uc3QgbmV3RGVidWcgPSBjcmVhdGVEZWJ1Zyh0aGlzLm5hbWVzcGFjZSArICh0eXBlb2YgZGVsaW1pdGVyID09PSAndW5kZWZpbmVkJyA/ICc6JyA6IGRlbGltaXRlcikgKyBuYW1lc3BhY2UpO1xuXHRcdG5ld0RlYnVnLmxvZyA9IHRoaXMubG9nO1xuXHRcdHJldHVybiBuZXdEZWJ1Zztcblx0fVxuXG5cdC8qKlxuXHQqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcblx0KiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxuXHQqXG5cdCogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGUobmFtZXNwYWNlcykge1xuXHRcdGNyZWF0ZURlYnVnLnNhdmUobmFtZXNwYWNlcyk7XG5cdFx0Y3JlYXRlRGVidWcubmFtZXNwYWNlcyA9IG5hbWVzcGFjZXM7XG5cblx0XHRjcmVhdGVEZWJ1Zy5uYW1lcyA9IFtdO1xuXHRcdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0XHRsZXQgaTtcblx0XHRjb25zdCBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxzLF0rLyk7XG5cdFx0Y29uc3QgbGVuID0gc3BsaXQubGVuZ3RoO1xuXG5cdFx0Zm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoIXNwbGl0W2ldKSB7XG5cdFx0XHRcdC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHRuYW1lc3BhY2VzID0gc3BsaXRbaV0ucmVwbGFjZSgvXFwqL2csICcuKj8nKTtcblxuXHRcdFx0aWYgKG5hbWVzcGFjZXNbMF0gPT09ICctJykge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5za2lwcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcy5zbGljZSgxKSArICckJykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvKipcblx0KiBEaXNhYmxlIGRlYnVnIG91dHB1dC5cblx0KlxuXHQqIEByZXR1cm4ge1N0cmluZ30gbmFtZXNwYWNlc1xuXHQqIEBhcGkgcHVibGljXG5cdCovXG5cdGZ1bmN0aW9uIGRpc2FibGUoKSB7XG5cdFx0Y29uc3QgbmFtZXNwYWNlcyA9IFtcblx0XHRcdC4uLmNyZWF0ZURlYnVnLm5hbWVzLm1hcCh0b05hbWVzcGFjZSksXG5cdFx0XHQuLi5jcmVhdGVEZWJ1Zy5za2lwcy5tYXAodG9OYW1lc3BhY2UpLm1hcChuYW1lc3BhY2UgPT4gJy0nICsgbmFtZXNwYWNlKVxuXHRcdF0uam9pbignLCcpO1xuXHRcdGNyZWF0ZURlYnVnLmVuYWJsZSgnJyk7XG5cdFx0cmV0dXJuIG5hbWVzcGFjZXM7XG5cdH1cblxuXHQvKipcblx0KiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXG5cdCpcblx0KiBAcGFyYW0ge1N0cmluZ30gbmFtZVxuXHQqIEByZXR1cm4ge0Jvb2xlYW59XG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlZChuYW1lKSB7XG5cdFx0aWYgKG5hbWVbbmFtZS5sZW5ndGggLSAxXSA9PT0gJyonKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cblx0XHRsZXQgaTtcblx0XHRsZXQgbGVuO1xuXG5cdFx0Zm9yIChpID0gMCwgbGVuID0gY3JlYXRlRGVidWcuc2tpcHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcblx0XHRcdGlmIChjcmVhdGVEZWJ1Zy5za2lwc1tpXS50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5uYW1lcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLm5hbWVzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0LyoqXG5cdCogQ29udmVydCByZWdleHAgdG8gbmFtZXNwYWNlXG5cdCpcblx0KiBAcGFyYW0ge1JlZ0V4cH0gcmVneGVwXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gdG9OYW1lc3BhY2UocmVnZXhwKSB7XG5cdFx0cmV0dXJuIHJlZ2V4cC50b1N0cmluZygpXG5cdFx0XHQuc3Vic3RyaW5nKDIsIHJlZ2V4cC50b1N0cmluZygpLmxlbmd0aCAtIDIpXG5cdFx0XHQucmVwbGFjZSgvXFwuXFwqXFw/JC8sICcqJyk7XG5cdH1cblxuXHQvKipcblx0KiBDb2VyY2UgYHZhbGAuXG5cdCpcblx0KiBAcGFyYW0ge01peGVkfSB2YWxcblx0KiBAcmV0dXJuIHtNaXhlZH1cblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gY29lcmNlKHZhbCkge1xuXHRcdGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikge1xuXHRcdFx0cmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcblx0XHR9XG5cdFx0cmV0dXJuIHZhbDtcblx0fVxuXG5cdC8qKlxuXHQqIFhYWCBETyBOT1QgVVNFLiBUaGlzIGlzIGEgdGVtcG9yYXJ5IHN0dWIgZnVuY3Rpb24uXG5cdCogWFhYIEl0IFdJTEwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXHQqL1xuXHRmdW5jdGlvbiBkZXN0cm95KCkge1xuXHRcdGNvbnNvbGUud2FybignSW5zdGFuY2UgbWV0aG9kIGBkZWJ1Zy5kZXN0cm95KClgIGlzIGRlcHJlY2F0ZWQgYW5kIG5vIGxvbmdlciBkb2VzIGFueXRoaW5nLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbiBvZiBgZGVidWdgLicpO1xuXHR9XG5cblx0Y3JlYXRlRGVidWcuZW5hYmxlKGNyZWF0ZURlYnVnLmxvYWQoKSk7XG5cblx0cmV0dXJuIGNyZWF0ZURlYnVnO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHNldHVwO1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gaXNWYWxpZFVURjgoYnVmKSB7XG4gIGNvbnN0IGxlbiA9IGJ1Zi5sZW5ndGg7XG4gIGxldCBpID0gMDtcblxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIGlmICgoYnVmW2ldICYgMHg4MCkgPT09IDB4MDApIHsgIC8vIDB4eHh4eHh4XG4gICAgICBpKys7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhlMCkgPT09IDB4YzApIHsgIC8vIDExMHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAxID09PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2ldICYgMHhmZSkgPT09IDB4YzAgIC8vIG92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHsgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgYnVmW2ldID09PSAweGUwICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4ODAgfHwgIC8vIG92ZXJsb25nXG4gICAgICAgIGJ1ZltpXSA9PT0gMHhlZCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweGEwICAvLyBzdXJyb2dhdGUgKFUrRDgwMCAtIFUrREZGRilcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gMztcbiAgICB9IGVsc2UgaWYgKChidWZbaV0gJiAweGY4KSA9PT0gMHhmMCkgeyAgLy8gMTExMTB4eHggMTB4eHh4eHggMTB4eHh4eHggMTB4eHh4eHhcbiAgICAgIGlmIChcbiAgICAgICAgaSArIDMgPj0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpICsgMl0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAzXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwIHx8ICAvLyBvdmVybG9uZ1xuICAgICAgICBidWZbaV0gPT09IDB4ZjQgJiYgYnVmW2kgKyAxXSA+IDB4OGYgfHwgYnVmW2ldID4gMHhmNCAgLy8gPiBVKzEwRkZGRlxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaXNWYWxpZFVURjg7XG4iLCIndXNlIHN0cmljdCc7XG5cbnRyeSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnbm9kZS1neXAtYnVpbGQnKShfX2Rpcm5hbWUpO1xufSBjYXRjaCAoZSkge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vZmFsbGJhY2snKTtcbn1cbiIsIi8qIVxuICogdmFyeVxuICogQ29weXJpZ2h0KGMpIDIwMTQtMjAxNyBEb3VnbGFzIENocmlzdG9waGVyIFdpbHNvblxuICogTUlUIExpY2Vuc2VkXG4gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbi8qKlxuICogTW9kdWxlIGV4cG9ydHMuXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSB2YXJ5XG5tb2R1bGUuZXhwb3J0cy5hcHBlbmQgPSBhcHBlbmRcblxuLyoqXG4gKiBSZWdFeHAgdG8gbWF0Y2ggZmllbGQtbmFtZSBpbiBSRkMgNzIzMCBzZWMgMy4yXG4gKlxuICogZmllbGQtbmFtZSAgICA9IHRva2VuXG4gKiB0b2tlbiAgICAgICAgID0gMSp0Y2hhclxuICogdGNoYXIgICAgICAgICA9IFwiIVwiIC8gXCIjXCIgLyBcIiRcIiAvIFwiJVwiIC8gXCImXCIgLyBcIidcIiAvIFwiKlwiXG4gKiAgICAgICAgICAgICAgIC8gXCIrXCIgLyBcIi1cIiAvIFwiLlwiIC8gXCJeXCIgLyBcIl9cIiAvIFwiYFwiIC8gXCJ8XCIgLyBcIn5cIlxuICogICAgICAgICAgICAgICAvIERJR0lUIC8gQUxQSEFcbiAqICAgICAgICAgICAgICAgOyBhbnkgVkNIQVIsIGV4Y2VwdCBkZWxpbWl0ZXJzXG4gKi9cblxudmFyIEZJRUxEX05BTUVfUkVHRVhQID0gL15bISMkJSYnKitcXC0uXl9gfH4wLTlBLVphLXpdKyQvXG5cbi8qKlxuICogQXBwZW5kIGEgZmllbGQgdG8gYSB2YXJ5IGhlYWRlci5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZmllbGRcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBhcHBlbmQgKGhlYWRlciwgZmllbGQpIHtcbiAgaWYgKHR5cGVvZiBoZWFkZXIgIT09ICdzdHJpbmcnKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaGVhZGVyIGFyZ3VtZW50IGlzIHJlcXVpcmVkJylcbiAgfVxuXG4gIGlmICghZmllbGQpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdmaWVsZCBhcmd1bWVudCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBnZXQgZmllbGRzIGFycmF5XG4gIHZhciBmaWVsZHMgPSAhQXJyYXkuaXNBcnJheShmaWVsZClcbiAgICA/IHBhcnNlKFN0cmluZyhmaWVsZCkpXG4gICAgOiBmaWVsZFxuXG4gIC8vIGFzc2VydCBvbiBpbnZhbGlkIGZpZWxkIG5hbWVzXG4gIGZvciAodmFyIGogPSAwOyBqIDwgZmllbGRzLmxlbmd0aDsgaisrKSB7XG4gICAgaWYgKCFGSUVMRF9OQU1FX1JFR0VYUC50ZXN0KGZpZWxkc1tqXSkpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZpZWxkIGFyZ3VtZW50IGNvbnRhaW5zIGFuIGludmFsaWQgaGVhZGVyIG5hbWUnKVxuICAgIH1cbiAgfVxuXG4gIC8vIGV4aXN0aW5nLCB1bnNwZWNpZmllZCB2YXJ5XG4gIGlmIChoZWFkZXIgPT09ICcqJykge1xuICAgIHJldHVybiBoZWFkZXJcbiAgfVxuXG4gIC8vIGVudW1lcmF0ZSBjdXJyZW50IHZhbHVlc1xuICB2YXIgdmFsID0gaGVhZGVyXG4gIHZhciB2YWxzID0gcGFyc2UoaGVhZGVyLnRvTG93ZXJDYXNlKCkpXG5cbiAgLy8gdW5zcGVjaWZpZWQgdmFyeVxuICBpZiAoZmllbGRzLmluZGV4T2YoJyonKSAhPT0gLTEgfHwgdmFscy5pbmRleE9mKCcqJykgIT09IC0xKSB7XG4gICAgcmV0dXJuICcqJ1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBmaWVsZHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZmxkID0gZmllbGRzW2ldLnRvTG93ZXJDYXNlKClcblxuICAgIC8vIGFwcGVuZCB2YWx1ZSAoY2FzZS1wcmVzZXJ2aW5nKVxuICAgIGlmICh2YWxzLmluZGV4T2YoZmxkKSA9PT0gLTEpIHtcbiAgICAgIHZhbHMucHVzaChmbGQpXG4gICAgICB2YWwgPSB2YWxcbiAgICAgICAgPyB2YWwgKyAnLCAnICsgZmllbGRzW2ldXG4gICAgICAgIDogZmllbGRzW2ldXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIFBhcnNlIGEgdmFyeSBoZWFkZXIgaW50byBhbiBhcnJheS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVyXG4gKiBAcmV0dXJuIHtBcnJheX1cbiAqIEBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gcGFyc2UgKGhlYWRlcikge1xuICB2YXIgZW5kID0gMFxuICB2YXIgbGlzdCA9IFtdXG4gIHZhciBzdGFydCA9IDBcblxuICAvLyBnYXRoZXIgdG9rZW5zXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBoZWFkZXIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICBzd2l0Y2ggKGhlYWRlci5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIDB4MjA6IC8qICAgKi9cbiAgICAgICAgaWYgKHN0YXJ0ID09PSBlbmQpIHtcbiAgICAgICAgICBzdGFydCA9IGVuZCA9IGkgKyAxXG4gICAgICAgIH1cbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgMHgyYzogLyogLCAqL1xuICAgICAgICBsaXN0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcbiAgICAgICAgc3RhcnQgPSBlbmQgPSBpICsgMVxuICAgICAgICBicmVha1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgZW5kID0gaSArIDFcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBmaW5hbCB0b2tlblxuICBsaXN0LnB1c2goaGVhZGVyLnN1YnN0cmluZyhzdGFydCwgZW5kKSlcblxuICByZXR1cm4gbGlzdFxufVxuXG4vKipcbiAqIE1hcmsgdGhhdCBhIHJlcXVlc3QgaXMgdmFyaWVkIG9uIGEgaGVhZGVyIGZpZWxkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNcbiAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSBmaWVsZFxuICogQHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIHZhcnkgKHJlcywgZmllbGQpIHtcbiAgaWYgKCFyZXMgfHwgIXJlcy5nZXRIZWFkZXIgfHwgIXJlcy5zZXRIZWFkZXIpIHtcbiAgICAvLyBxdWFjayBxdWFja1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3JlcyBhcmd1bWVudCBpcyByZXF1aXJlZCcpXG4gIH1cblxuICAvLyBnZXQgZXhpc3RpbmcgaGVhZGVyXG4gIHZhciB2YWwgPSByZXMuZ2V0SGVhZGVyKCdWYXJ5JykgfHwgJydcbiAgdmFyIGhlYWRlciA9IEFycmF5LmlzQXJyYXkodmFsKVxuICAgID8gdmFsLmpvaW4oJywgJylcbiAgICA6IFN0cmluZyh2YWwpXG5cbiAgLy8gc2V0IG5ldyBoZWFkZXJcbiAgaWYgKCh2YWwgPSBhcHBlbmQoaGVhZGVyLCBmaWVsZCkpKSB7XG4gICAgcmVzLnNldEhlYWRlcignVmFyeScsIHZhbClcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL2xpYi93ZWJzb2NrZXQnKTtcblxuV2ViU29ja2V0LmNyZWF0ZVdlYlNvY2tldFN0cmVhbSA9IHJlcXVpcmUoJy4vbGliL3N0cmVhbScpO1xuV2ViU29ja2V0LlNlcnZlciA9IHJlcXVpcmUoJy4vbGliL3dlYnNvY2tldC1zZXJ2ZXInKTtcbldlYlNvY2tldC5SZWNlaXZlciA9IHJlcXVpcmUoJy4vbGliL3JlY2VpdmVyJyk7XG5XZWJTb2NrZXQuU2VuZGVyID0gcmVxdWlyZSgnLi9saWIvc2VuZGVyJyk7XG5cbldlYlNvY2tldC5XZWJTb2NrZXQgPSBXZWJTb2NrZXQ7XG5XZWJTb2NrZXQuV2ViU29ja2V0U2VydmVyID0gV2ViU29ja2V0LlNlcnZlcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG4vKipcbiAqIE1lcmdlcyBhbiBhcnJheSBvZiBidWZmZXJzIGludG8gYSBuZXcgYnVmZmVyLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyW119IGxpc3QgVGhlIGFycmF5IG9mIGJ1ZmZlcnMgdG8gY29uY2F0XG4gKiBAcGFyYW0ge051bWJlcn0gdG90YWxMZW5ndGggVGhlIHRvdGFsIGxlbmd0aCBvZiBidWZmZXJzIGluIHRoZSBsaXN0XG4gKiBAcmV0dXJuIHtCdWZmZXJ9IFRoZSByZXN1bHRpbmcgYnVmZmVyXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGNvbmNhdChsaXN0LCB0b3RhbExlbmd0aCkge1xuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHJldHVybiBFTVBUWV9CVUZGRVI7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMSkgcmV0dXJuIGxpc3RbMF07XG5cbiAgY29uc3QgdGFyZ2V0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgYnVmID0gbGlzdFtpXTtcbiAgICB0YXJnZXQuc2V0KGJ1Ziwgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gYnVmLmxlbmd0aDtcbiAgfVxuXG4gIGlmIChvZmZzZXQgPCB0b3RhbExlbmd0aCkgcmV0dXJuIHRhcmdldC5zbGljZSgwLCBvZmZzZXQpO1xuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8qKlxuICogTWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IHNvdXJjZSBUaGUgYnVmZmVyIHRvIG1hc2tcbiAqIEBwYXJhbSB7QnVmZmVyfSBtYXNrIFRoZSBtYXNrIHRvIHVzZVxuICogQHBhcmFtIHtCdWZmZXJ9IG91dHB1dCBUaGUgYnVmZmVyIHdoZXJlIHRvIHN0b3JlIHRoZSByZXN1bHRcbiAqIEBwYXJhbSB7TnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCBhdCB3aGljaCB0byBzdGFydCB3cml0aW5nXG4gKiBAcGFyYW0ge051bWJlcn0gbGVuZ3RoIFRoZSBudW1iZXIgb2YgYnl0ZXMgdG8gbWFzay5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRbb2Zmc2V0ICsgaV0gPSBzb3VyY2VbaV0gXiBtYXNrW2kgJiAzXTtcbiAgfVxufVxuXG4vKipcbiAqIFVubWFza3MgYSBidWZmZXIgdXNpbmcgdGhlIGdpdmVuIG1hc2suXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZmZlciBUaGUgYnVmZmVyIHRvIHVubWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIF91bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnVmZmVyLmxlbmd0aDsgaSsrKSB7XG4gICAgYnVmZmVyW2ldIF49IG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBidWZmZXIgdG8gYW4gYEFycmF5QnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmIFRoZSBidWZmZXIgdG8gY29udmVydFxuICogQHJldHVybiB7QXJyYXlCdWZmZXJ9IENvbnZlcnRlZCBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gdG9BcnJheUJ1ZmZlcihidWYpIHtcbiAgaWYgKGJ1Zi5ieXRlTGVuZ3RoID09PSBidWYuYnVmZmVyLmJ5dGVMZW5ndGgpIHtcbiAgICByZXR1cm4gYnVmLmJ1ZmZlcjtcbiAgfVxuXG4gIHJldHVybiBidWYuYnVmZmVyLnNsaWNlKGJ1Zi5ieXRlT2Zmc2V0LCBidWYuYnl0ZU9mZnNldCArIGJ1Zi5ieXRlTGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IEJ1ZmZlci5mcm9tKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbnRyeSB7XG4gIGNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCdidWZmZXJ1dGlsJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgY29uY2F0LFxuICAgIG1hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgICBpZiAobGVuZ3RoIDwgNDgpIF9tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwubWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpO1xuICAgIH0sXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2soYnVmZmVyLCBtYXNrKSB7XG4gICAgICBpZiAoYnVmZmVyLmxlbmd0aCA8IDMyKSBfdW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgICBlbHNlIGJ1ZmZlclV0aWwudW5tYXNrKGJ1ZmZlciwgbWFzayk7XG4gICAgfVxuICB9O1xufSBjYXRjaCAoZSkgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi8ge1xuICBtb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBjb25jYXQsXG4gICAgbWFzazogX21hc2ssXG4gICAgdG9BcnJheUJ1ZmZlcixcbiAgICB0b0J1ZmZlcixcbiAgICB1bm1hc2s6IF91bm1hc2tcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIEJJTkFSWV9UWVBFUzogWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBhZGRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBBbiBvcHRpb25zIG9iamVjdCBzcGVjaWZpZXMgY2hhcmFjdGVyaXN0aWNzIGFib3V0XG4gICAqICAgICB0aGUgZXZlbnQgbGlzdGVuZXJcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5vbmNlPWZhbHNlXSBBIGBCb29sZWFuYCBpbmRpY2F0aW5nIHRoYXQgdGhlXG4gICAqICAgICBsaXN0ZW5lciBzaG91bGQgYmUgaW52b2tlZCBhdCBtb3N0IG9uY2UgYWZ0ZXIgYmVpbmcgYWRkZWQuIElmIGB0cnVlYCxcbiAgICogICAgIHRoZSBsaXN0ZW5lciB3b3VsZCBiZSBhdXRvbWF0aWNhbGx5IHJlbW92ZWQgd2hlbiBpbnZva2VkLlxuICAgKiBAcHVibGljXG4gICAqL1xuICBhZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyLCBvcHRpb25zID0ge30pIHtcbiAgICBsZXQgd3JhcHBlcjtcblxuICAgIGlmICh0eXBlID09PSAnbWVzc2FnZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbk1lc3NhZ2UoZGF0YSwgaXNCaW5hcnkpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgTWVzc2FnZUV2ZW50KCdtZXNzYWdlJywge1xuICAgICAgICAgIGRhdGE6IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdjbG9zZScpIHtcbiAgICAgIHdyYXBwZXIgPSBmdW5jdGlvbiBvbkNsb3NlKGNvZGUsIG1lc3NhZ2UpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgQ2xvc2VFdmVudCgnY2xvc2UnLCB7XG4gICAgICAgICAgY29kZSxcbiAgICAgICAgICByZWFzb246IG1lc3NhZ2UudG9TdHJpbmcoKSxcbiAgICAgICAgICB3YXNDbGVhbjogdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkICYmIHRoaXMuX2Nsb3NlRnJhbWVTZW50XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgbGlzdGVuZXIuY2FsbCh0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdvcGVuJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXZlbnQoJ29wZW4nKTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdyYXBwZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdID0gISFvcHRpb25zW2tGb3JPbkV2ZW50QXR0cmlidXRlXTtcbiAgICB3cmFwcGVyW2tMaXN0ZW5lcl0gPSBsaXN0ZW5lcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IGtEb25lID0gU3ltYm9sKCdrRG9uZScpO1xuY29uc3Qga1J1biA9IFN5bWJvbCgna1J1bicpO1xuXG4vKipcbiAqIEEgdmVyeSBzaW1wbGUgam9iIHF1ZXVlIHdpdGggYWRqdXN0YWJsZSBjb25jdXJyZW5jeS4gQWRhcHRlZCBmcm9tXG4gKiBodHRwczovL2dpdGh1Yi5jb20vU1RSTUwvYXN5bmMtbGltaXRlclxuICovXG5jbGFzcyBMaW1pdGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBuZXcgYExpbWl0ZXJgLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvbmN1cnJlbmN5PUluZmluaXR5XSBUaGUgbWF4aW11bSBudW1iZXIgb2Ygam9icyBhbGxvd2VkXG4gICAqICAgICB0byBydW4gY29uY3VycmVudGx5XG4gICAqL1xuICBjb25zdHJ1Y3Rvcihjb25jdXJyZW5jeSkge1xuICAgIHRoaXNba0RvbmVdID0gKCkgPT4ge1xuICAgICAgdGhpcy5wZW5kaW5nLS07XG4gICAgICB0aGlzW2tSdW5dKCk7XG4gICAgfTtcbiAgICB0aGlzLmNvbmN1cnJlbmN5ID0gY29uY3VycmVuY3kgfHwgSW5maW5pdHk7XG4gICAgdGhpcy5qb2JzID0gW107XG4gICAgdGhpcy5wZW5kaW5nID0gMDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgam9iIHRvIHRoZSBxdWV1ZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gam9iIFRoZSBqb2IgdG8gcnVuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZChqb2IpIHtcbiAgICB0aGlzLmpvYnMucHVzaChqb2IpO1xuICAgIHRoaXNba1J1bl0oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZW1vdmVzIGEgam9iIGZyb20gdGhlIHF1ZXVlIGFuZCBydW5zIGl0IGlmIHBvc3NpYmxlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgW2tSdW5dKCkge1xuICAgIGlmICh0aGlzLnBlbmRpbmcgPT09IHRoaXMuY29uY3VycmVuY3kpIHJldHVybjtcblxuICAgIGlmICh0aGlzLmpvYnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBqb2IgPSB0aGlzLmpvYnMuc2hpZnQoKTtcblxuICAgICAgdGhpcy5wZW5kaW5nKys7XG4gICAgICBqb2IodGhpc1trRG9uZV0pO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IExpbWl0ZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHpsaWIgPSByZXF1aXJlKCd6bGliJyk7XG5cbmNvbnN0IGJ1ZmZlclV0aWwgPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5jb25zdCBMaW1pdGVyID0gcmVxdWlyZSgnLi9saW1pdGVyJyk7XG5jb25zdCB7IGtTdGF0dXNDb2RlIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBUUkFJTEVSID0gQnVmZmVyLmZyb20oWzB4MDAsIDB4MDAsIDB4ZmYsIDB4ZmZdKTtcbmNvbnN0IGtQZXJNZXNzYWdlRGVmbGF0ZSA9IFN5bWJvbCgncGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBrVG90YWxMZW5ndGggPSBTeW1ib2woJ3RvdGFsLWxlbmd0aCcpO1xuY29uc3Qga0NhbGxiYWNrID0gU3ltYm9sKCdjYWxsYmFjaycpO1xuY29uc3Qga0J1ZmZlcnMgPSBTeW1ib2woJ2J1ZmZlcnMnKTtcbmNvbnN0IGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcblxuLy9cbi8vIFdlIGxpbWl0IHpsaWIgY29uY3VycmVuY3ksIHdoaWNoIHByZXZlbnRzIHNldmVyZSBtZW1vcnkgZnJhZ21lbnRhdGlvblxuLy8gYXMgZG9jdW1lbnRlZCBpbiBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUvaXNzdWVzLzg4NzEjaXNzdWVjb21tZW50LTI1MDkxNTkxM1xuLy8gYW5kIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJzb2NrZXRzL3dzL2lzc3Vlcy8xMjAyXG4vL1xuLy8gSW50ZW50aW9uYWxseSBnbG9iYWw7IGl0J3MgdGhlIGdsb2JhbCB0aHJlYWQgcG9vbCB0aGF0J3MgYW4gaXNzdWUuXG4vL1xubGV0IHpsaWJMaW1pdGVyO1xuXG4vKipcbiAqIHBlcm1lc3NhZ2UtZGVmbGF0ZSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgUGVyTWVzc2FnZURlZmxhdGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFBlck1lc3NhZ2VEZWZsYXRlIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHNdIEFkdmVydGlzZSBzdXBwb3J0XG4gICAqICAgICBmb3IsIG9yIHJlcXVlc3QsIGEgY3VzdG9tIGNsaWVudCB3aW5kb3cgc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyPWZhbHNlXSBBZHZlcnRpc2UvXG4gICAqICAgICBhY2tub3dsZWRnZSBkaXNhYmxpbmcgb2YgY2xpZW50IGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvbmN1cnJlbmN5TGltaXQ9MTBdIFRoZSBudW1iZXIgb2YgY29uY3VycmVudFxuICAgKiAgICAgY2FsbHMgdG8gemxpYlxuICAgKiBAcGFyYW0geyhCb29sZWFufE51bWJlcil9IFtvcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHNdIFJlcXVlc3QvY29uZmlybSB0aGVcbiAgICogICAgIHVzZSBvZiBhIGN1c3RvbSBzZXJ2ZXIgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gUmVxdWVzdC9hY2NlcHRcbiAgICogICAgIGRpc2FibGluZyBvZiBzZXJ2ZXIgY29udGV4dCB0YWtlb3ZlclxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMudGhyZXNob2xkPTEwMjRdIFNpemUgKGluIGJ5dGVzKSBiZWxvdyB3aGljaFxuICAgKiAgICAgbWVzc2FnZXMgc2hvdWxkIG5vdCBiZSBjb21wcmVzc2VkIGlmIGNvbnRleHQgdGFrZW92ZXIgaXMgZGlzYWJsZWRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGRlZmxhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9uc10gT3B0aW9ucyB0byBwYXNzIHRvIHpsaWIgb25cbiAgICogICAgIGluZmxhdGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTZXJ2ZXI9ZmFsc2VdIENyZWF0ZSB0aGUgaW5zdGFuY2UgaW4gZWl0aGVyIHNlcnZlciBvclxuICAgKiAgICAgY2xpZW50IG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFttYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBsZW5ndGhcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGlzU2VydmVyLCBtYXhQYXlsb2FkKSB7XG4gICAgdGhpcy5fbWF4UGF5bG9hZCA9IG1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX29wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIHRoaXMuX3RocmVzaG9sZCA9XG4gICAgICB0aGlzLl9vcHRpb25zLnRocmVzaG9sZCAhPT0gdW5kZWZpbmVkID8gdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgOiAxMDI0O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFpc1NlcnZlcjtcbiAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcbiAgICB0aGlzLl9pbmZsYXRlID0gbnVsbDtcblxuICAgIHRoaXMucGFyYW1zID0gbnVsbDtcblxuICAgIGlmICghemxpYkxpbWl0ZXIpIHtcbiAgICAgIGNvbnN0IGNvbmN1cnJlbmN5ID1cbiAgICAgICAgdGhpcy5fb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0ICE9PSB1bmRlZmluZWRcbiAgICAgICAgICA/IHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdFxuICAgICAgICAgIDogMTA7XG4gICAgICB6bGliTGltaXRlciA9IG5ldyBMaW1pdGVyKGNvbmN1cnJlbmN5KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIHN0YXRpYyBnZXQgZXh0ZW5zaW9uTmFtZSgpIHtcbiAgICByZXR1cm4gJ3Blcm1lc3NhZ2UtZGVmbGF0ZSc7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlIGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHJldHVybiB7T2JqZWN0fSBFeHRlbnNpb24gcGFyYW1ldGVyc1xuICAgKiBAcHVibGljXG4gICAqL1xuICBvZmZlcigpIHtcbiAgICBjb25zdCBwYXJhbXMgPSB7fTtcblxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck5vQ29udGV4dFRha2VvdmVyKSB7XG4gICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2VydmVyTWF4V2luZG93Qml0cykge1xuICAgICAgcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSB0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09IG51bGwpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIvcmVzcG9uc2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IGNvbmZpZ3VyYXRpb25zIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzL3JlcG9uc2VcbiAgICogQHJldHVybiB7T2JqZWN0fSBBY2NlcHRlZCBjb25maWd1cmF0aW9uXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFjY2VwdChjb25maWd1cmF0aW9ucykge1xuICAgIGNvbmZpZ3VyYXRpb25zID0gdGhpcy5ub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpO1xuXG4gICAgdGhpcy5wYXJhbXMgPSB0aGlzLl9pc1NlcnZlclxuICAgICAgPyB0aGlzLmFjY2VwdEFzU2VydmVyKGNvbmZpZ3VyYXRpb25zKVxuICAgICAgOiB0aGlzLmFjY2VwdEFzQ2xpZW50KGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHJldHVybiB0aGlzLnBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWxlYXNlcyBhbGwgcmVzb3VyY2VzIHVzZWQgYnkgdGhlIGV4dGVuc2lvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xlYW51cCgpIHtcbiAgICBpZiAodGhpcy5faW5mbGF0ZSkge1xuICAgICAgdGhpcy5faW5mbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2RlZmxhdGUpIHtcbiAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLmNsb3NlKCk7XG4gICAgICB0aGlzLl9kZWZsYXRlID0gbnVsbDtcblxuICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKFxuICAgICAgICAgIG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQnXG4gICAgICAgICAgKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiAgQWNjZXB0IGFuIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlci5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gb2ZmZXJzIFRoZSBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXJzXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNTZXJ2ZXIob2ZmZXJzKSB7XG4gICAgY29uc3Qgb3B0cyA9IHRoaXMuX29wdGlvbnM7XG4gICAgY29uc3QgYWNjZXB0ZWQgPSBvZmZlcnMuZmluZCgocGFyYW1zKSA9PiB7XG4gICAgICBpZiAoXG4gICAgICAgIChvcHRzLnNlcnZlck5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgICAgIHBhcmFtcy5zZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcikgfHxcbiAgICAgICAgKHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzICYmXG4gICAgICAgICAgKG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gZmFsc2UgfHxcbiAgICAgICAgICAgICh0eXBlb2Ygb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJyAmJlxuICAgICAgICAgICAgICBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPiBwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cykpKSB8fFxuICAgICAgICAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAhcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9KTtcblxuICAgIGlmICghYWNjZXB0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm9uZSBvZiB0aGUgZXh0ZW5zaW9uIG9mZmVycyBjYW4gYmUgYWNjZXB0ZWQnKTtcbiAgICB9XG5cbiAgICBpZiAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAob3B0cy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIgPSB0cnVlO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9tYXhfd2luZG93X2JpdHMgPSBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHM7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9IG9wdHMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgYWNjZXB0ZWQuY2xpZW50X21heF93aW5kb3dfYml0cyA9PT0gdHJ1ZSB8fFxuICAgICAgb3B0cy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZVxuICAgICkge1xuICAgICAgZGVsZXRlIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHM7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFjY2VwdGVkO1xuICB9XG5cbiAgLyoqXG4gICAqIEFjY2VwdCB0aGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSByZXNwb25zZSBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIHJlc3BvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYWNjZXB0QXNDbGllbnQocmVzcG9uc2UpIHtcbiAgICBjb25zdCBwYXJhbXMgPSByZXNwb25zZVswXTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIgPT09IGZhbHNlICYmXG4gICAgICBwYXJhbXMuY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5leHBlY3RlZCBwYXJhbWV0ZXIgXCJjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlclwiJyk7XG4gICAgfVxuXG4gICAgaWYgKCFwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cykge1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAodHlwZW9mIHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMpXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVbmV4cGVjdGVkIG9yIGludmFsaWQgcGFyYW1ldGVyIFwiY2xpZW50X21heF93aW5kb3dfYml0c1wiJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcGFyYW1zO1xuICB9XG5cbiAgLyoqXG4gICAqIE5vcm1hbGl6ZSBwYXJhbWV0ZXJzLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge0FycmF5fSBUaGUgb2ZmZXJzL3Jlc3BvbnNlIHdpdGggbm9ybWFsaXplZCBwYXJhbWV0ZXJzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBub3JtYWxpemVQYXJhbXMoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucy5mb3JFYWNoKChwYXJhbXMpID0+IHtcbiAgICAgIE9iamVjdC5rZXlzKHBhcmFtcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIGxldCB2YWx1ZSA9IHBhcmFtc1trZXldO1xuXG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBQYXJhbWV0ZXIgXCIke2tleX1cIiBtdXN0IGhhdmUgb25seSBhIHNpbmdsZSB2YWx1ZWApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFsdWUgPSB2YWx1ZVswXTtcblxuICAgICAgICBpZiAoa2V5ID09PSAnY2xpZW50X21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihudW0pIHx8IG51bSA8IDggfHwgbnVtID4gMTUpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgICAgfSBlbHNlIGlmICghdGhpcy5faXNTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdzZXJ2ZXJfbWF4X3dpbmRvd19iaXRzJykge1xuICAgICAgICAgIGNvbnN0IG51bSA9ICt2YWx1ZTtcbiAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsdWUgPSBudW07XG4gICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAga2V5ID09PSAnY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXInIHx8XG4gICAgICAgICAga2V5ID09PSAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICkge1xuICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBwYXJhbWV0ZXIgXCIke2tleX1cImApO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1zW2tleV0gPSB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIGNvbmZpZ3VyYXRpb25zO1xuICB9XG5cbiAgLyoqXG4gICAqIERlY29tcHJlc3MgZGF0YS4gQ29uY3VycmVuY3kgbGltaXRlZC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGRlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fZGVjb21wcmVzcyhkYXRhLCBmaW4sIChlcnIsIHJlc3VsdCkgPT4ge1xuICAgICAgICBkb25lKCk7XG4gICAgICAgIGNhbGxiYWNrKGVyciwgcmVzdWx0KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIERhdGEgdG8gY29tcHJlc3NcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIHpsaWJMaW1pdGVyLmFkZCgoZG9uZSkgPT4ge1xuICAgICAgdGhpcy5fY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2RlY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnY2xpZW50JyA6ICdzZXJ2ZXInO1xuXG4gICAgaWYgKCF0aGlzLl9pbmZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2luZmxhdGUgPSB6bGliLmNyZWF0ZUluZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJJbmZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tQZXJNZXNzYWdlRGVmbGF0ZV0gPSB0aGlzO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgIHRoaXMuX2luZmxhdGVba0J1ZmZlcnNdID0gW107XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdlcnJvcicsIGluZmxhdGVPbkVycm9yKTtcbiAgICAgIHRoaXMuX2luZmxhdGUub24oJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcbiAgICB9XG5cbiAgICB0aGlzLl9pbmZsYXRlW2tDYWxsYmFja10gPSBjYWxsYmFjaztcblxuICAgIHRoaXMuX2luZmxhdGUud3JpdGUoZGF0YSk7XG4gICAgaWYgKGZpbikgdGhpcy5faW5mbGF0ZS53cml0ZShUUkFJTEVSKTtcblxuICAgIHRoaXMuX2luZmxhdGUuZmx1c2goKCkgPT4ge1xuICAgICAgY29uc3QgZXJyID0gdGhpcy5faW5mbGF0ZVtrRXJyb3JdO1xuXG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZGF0YSA9IGJ1ZmZlclV0aWwuY29uY2F0KFxuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSxcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdXG4gICAgICApO1xuXG4gICAgICBpZiAodGhpcy5faW5mbGF0ZS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICAgIGlmIChmaW4gJiYgdGhpcy5wYXJhbXNbYCR7ZW5kcG9pbnR9X25vX2NvbnRleHRfdGFrZW92ZXJgXSkge1xuICAgICAgICAgIHRoaXMuX2luZmxhdGUucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfY29tcHJlc3MoZGF0YSwgZmluLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5faXNTZXJ2ZXIgPyAnc2VydmVyJyA6ICdjbGllbnQnO1xuXG4gICAgaWYgKCF0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBrZXkgPSBgJHtlbmRwb2ludH1fbWF4X3dpbmRvd19iaXRzYDtcbiAgICAgIGNvbnN0IHdpbmRvd0JpdHMgPVxuICAgICAgICB0eXBlb2YgdGhpcy5wYXJhbXNba2V5XSAhPT0gJ251bWJlcidcbiAgICAgICAgICA/IHpsaWIuWl9ERUZBVUxUX1dJTkRPV0JJVFNcbiAgICAgICAgICA6IHRoaXMucGFyYW1zW2tleV07XG5cbiAgICAgIHRoaXMuX2RlZmxhdGUgPSB6bGliLmNyZWF0ZURlZmxhdGVSYXcoe1xuICAgICAgICAuLi50aGlzLl9vcHRpb25zLnpsaWJEZWZsYXRlT3B0aW9ucyxcbiAgICAgICAgd2luZG93Qml0c1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlLm9uKCdkYXRhJywgZGVmbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fZGVmbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9kZWZsYXRlLndyaXRlKGRhdGEpO1xuICAgIHRoaXMuX2RlZmxhdGUuZmx1c2goemxpYi5aX1NZTkNfRkxVU0gsICgpID0+IHtcbiAgICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBUaGUgZGVmbGF0ZSBzdHJlYW0gd2FzIGNsb3NlZCB3aGlsZSBkYXRhIHdhcyBiZWluZyBwcm9jZXNzZWQuXG4gICAgICAgIC8vXG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKGZpbikgZGF0YSA9IGRhdGEuc2xpY2UoMCwgZGF0YS5sZW5ndGggLSA0KTtcblxuICAgICAgLy9cbiAgICAgIC8vIEVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayB3aWxsIG5vdCBiZSBjYWxsZWQgYWdhaW4gaW5cbiAgICAgIC8vIGBQZXJNZXNzYWdlRGVmbGF0ZSNjbGVhbnVwKClgLlxuICAgICAgLy9cbiAgICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IG51bGw7XG5cbiAgICAgIHRoaXMuX2RlZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9kZWZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuXG4gICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgdGhpcy5fZGVmbGF0ZS5yZXNldCgpO1xuICAgICAgfVxuXG4gICAgICBjYWxsYmFjayhudWxsLCBkYXRhKTtcbiAgICB9KTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlck1lc3NhZ2VEZWZsYXRlO1xuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuRGVmbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGRlZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gIHRoaXNba1RvdGFsTGVuZ3RoXSArPSBjaHVuay5sZW5ndGg7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdkYXRhJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIEEgY2h1bmsgb2YgZGF0YVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRGF0YShjaHVuaykge1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xuXG4gIGlmIChcbiAgICB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWQgPCAxIHx8XG4gICAgdGhpc1trVG90YWxMZW5ndGhdIDw9IHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5fbWF4UGF5bG9hZFxuICApIHtcbiAgICB0aGlzW2tCdWZmZXJzXS5wdXNoKGNodW5rKTtcbiAgICByZXR1cm47XG4gIH1cblxuICB0aGlzW2tFcnJvcl0gPSBuZXcgUmFuZ2VFcnJvcignTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcpO1xuICB0aGlzW2tFcnJvcl0uY29kZSA9ICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnO1xuICB0aGlzW2tFcnJvcl1ba1N0YXR1c0NvZGVdID0gMTAwOTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIGluZmxhdGVPbkRhdGEpO1xuICB0aGlzLnJlc2V0KCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgemxpYi5JbmZsYXRlUmF3YCBzdHJlYW0gYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5mbGF0ZU9uRXJyb3IoZXJyKSB7XG4gIC8vXG4gIC8vIFRoZXJlIGlzIG5vIG5lZWQgdG8gY2FsbCBgWmxpYiNjbG9zZSgpYCBhcyB0aGUgaGFuZGxlIGlzIGF1dG9tYXRpY2FsbHlcbiAgLy8gY2xvc2VkIHdoZW4gYW4gZXJyb3IgaXMgZW1pdHRlZC5cbiAgLy9cbiAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9pbmZsYXRlID0gbnVsbDtcbiAgZXJyW2tTdGF0dXNDb2RlXSA9IDEwMDc7XG4gIHRoaXNba0NhbGxiYWNrXShlcnIpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IFdyaXRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXRcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBjb25jYXQsIHRvQXJyYXlCdWZmZXIsIHVubWFzayB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSwgaXNWYWxpZFVURjggfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG5jb25zdCBHRVRfSU5GTyA9IDA7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfMTYgPSAxO1xuY29uc3QgR0VUX1BBWUxPQURfTEVOR1RIXzY0ID0gMjtcbmNvbnN0IEdFVF9NQVNLID0gMztcbmNvbnN0IEdFVF9EQVRBID0gNDtcbmNvbnN0IElORkxBVElORyA9IDU7XG5cbi8qKlxuICogSHlCaSBSZWNlaXZlciBpbXBsZW1lbnRhdGlvbi5cbiAqXG4gKiBAZXh0ZW5kcyBXcml0YWJsZVxuICovXG5jbGFzcyBSZWNlaXZlciBleHRlbmRzIFdyaXRhYmxlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBSZWNlaXZlciBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMuYmluYXJ5VHlwZT1ub2RlYnVmZmVyXSBUaGUgdHlwZSBmb3IgYmluYXJ5IGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLmV4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkXG4gICAqICAgICBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuaXNTZXJ2ZXI9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRvIG9wZXJhdGUgaW5cbiAgICogICAgIGNsaWVudCBvciBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLl9iaW5hcnlUeXBlID0gb3B0aW9ucy5iaW5hcnlUeXBlIHx8IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gb3B0aW9ucy5leHRlbnNpb25zIHx8IHt9O1xuICAgIHRoaXMuX2lzU2VydmVyID0gISFvcHRpb25zLmlzU2VydmVyO1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBvcHRpb25zLm1heFBheWxvYWQgfCAwO1xuICAgIHRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiA9ICEhb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb247XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX2J1ZmZlcnMgPSBbXTtcblxuICAgIHRoaXMuX2NvbXByZXNzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tYXNrID0gdW5kZWZpbmVkO1xuICAgIHRoaXMuX2ZyYWdtZW50ZWQgPSAwO1xuICAgIHRoaXMuX21hc2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2ZpbiA9IGZhbHNlO1xuICAgIHRoaXMuX29wY29kZSA9IDA7XG5cbiAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggPSAwO1xuICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogSW1wbGVtZW50cyBgV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSgpYC5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGNodW5rIFRoZSBjaHVuayBvZiBkYXRhIHRvIHdyaXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGluZyBUaGUgY2hhcmFjdGVyIGVuY29kaW5nIG9mIGBjaHVua2BcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwOCAmJiB0aGlzLl9zdGF0ZSA9PSBHRVRfSU5GTykgcmV0dXJuIGNiKCk7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLl9idWZmZXJzLnB1c2goY2h1bmspO1xuICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb25zdW1lcyBgbmAgYnl0ZXMgZnJvbSB0aGUgYnVmZmVyZWQgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG4gVGhlIG51bWJlciBvZiBieXRlcyB0byBjb25zdW1lXG4gICAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIGNvbnN1bWVkIGJ5dGVzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb25zdW1lKG4pIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzIC09IG47XG5cbiAgICBpZiAobiA9PT0gdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHJldHVybiB0aGlzLl9idWZmZXJzLnNoaWZ0KCk7XG5cbiAgICBpZiAobiA8IHRoaXMuX2J1ZmZlcnNbMF0ubGVuZ3RoKSB7XG4gICAgICBjb25zdCBidWYgPSB0aGlzLl9idWZmZXJzWzBdO1xuICAgICAgdGhpcy5fYnVmZmVyc1swXSA9IGJ1Zi5zbGljZShuKTtcbiAgICAgIHJldHVybiBidWYuc2xpY2UoMCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBidWYuc2xpY2Uobik7XG4gICAgICB9XG5cbiAgICAgIG4gLT0gYnVmLmxlbmd0aDtcbiAgICB9IHdoaWxlIChuID4gMCk7XG5cbiAgICByZXR1cm4gZHN0O1xuICB9XG5cbiAgLyoqXG4gICAqIFN0YXJ0cyB0aGUgcGFyc2luZyBsb29wLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgc3RhcnRMb29wKGNiKSB7XG4gICAgbGV0IGVycjtcbiAgICB0aGlzLl9sb29wID0gdHJ1ZTtcblxuICAgIGRvIHtcbiAgICAgIHN3aXRjaCAodGhpcy5fc3RhdGUpIHtcbiAgICAgICAgY2FzZSBHRVRfSU5GTzpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldEluZm8oKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoMTYoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgZXJyID0gdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfTUFTSzpcbiAgICAgICAgICB0aGlzLmdldE1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfREFUQTpcbiAgICAgICAgICBlcnIgPSB0aGlzLmdldERhdGEoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIC8vIGBJTkZMQVRJTkdgXG4gICAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IHdoaWxlICh0aGlzLl9sb29wKTtcblxuICAgIGNiKGVycik7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcmV0dXJuIHsoUmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRJbmZvKCkge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb21wcmVzc2VkID0gKGJ1ZlswXSAmIDB4NDApID09PSAweDQwO1xuXG4gICAgaWYgKGNvbXByZXNzZWQgJiYgIXRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fZmluID0gKGJ1ZlswXSAmIDB4ODApID09PSAweDgwO1xuICAgIHRoaXMuX29wY29kZSA9IGJ1ZlswXSAmIDB4MGY7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IGJ1ZlsxXSAmIDB4N2Y7XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDAwKSB7XG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdSU1YxIG11c3QgYmUgY2xlYXInLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX1VORVhQRUNURURfUlNWXzEnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGhpcy5fZnJhZ21lbnRlZCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2NvbXByZXNzZWQgPSBjb21wcmVzc2VkO1xuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNyAmJiB0aGlzLl9vcGNvZGUgPCAweDBiKSB7XG4gICAgICBpZiAoIXRoaXMuX2Zpbikge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdGSU4gbXVzdCBiZSBzZXQnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0VYUEVDVEVEX0ZJTidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA+IDB4N2QpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fZmluICYmICF0aGlzLl9mcmFnbWVudGVkKSB0aGlzLl9mcmFnbWVudGVkID0gdGhpcy5fb3Bjb2RlO1xuICAgIHRoaXMuX21hc2tlZCA9IChidWZbMV0gJiAweDgwKSA9PT0gMHg4MDtcblxuICAgIGlmICh0aGlzLl9pc1NlcnZlcikge1xuICAgICAgaWYgKCF0aGlzLl9tYXNrZWQpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoID09PSAxMjYpIHRoaXMuX3N0YXRlID0gR0VUX1BBWUxPQURfTEVOR1RIXzE2O1xuICAgIGVsc2UgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNykgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ7XG4gICAgZWxzZSByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGgxNigpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICByZXR1cm4gdGhpcy5oYXZlTGVuZ3RoKCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNys2NCkuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldFBheWxvYWRMZW5ndGg2NCgpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBidWYgPSB0aGlzLmNvbnN1bWUoOCk7XG4gICAgY29uc3QgbnVtID0gYnVmLnJlYWRVSW50MzJCRSgwKTtcblxuICAgIC8vXG4gICAgLy8gVGhlIG1heGltdW0gc2FmZSBpbnRlZ2VyIGluIEphdmFTY3JpcHQgaXMgMl41MyAtIDEuIEFuIGVycm9yIGlzIHJldHVybmVkXG4gICAgLy8gaWYgcGF5bG9hZCBsZW5ndGggaXMgZ3JlYXRlciB0aGFuIHRoaXMgbnVtYmVyLlxuICAgIC8vXG4gICAgaWYgKG51bSA+IE1hdGgucG93KDIsIDUzIC0gMzIpIC0gMSkge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnVW5zdXBwb3J0ZWQgV2ViU29ja2V0IGZyYW1lOiBwYXlsb2FkIGxlbmd0aCA+IDJeNTMgLSAxJyxcbiAgICAgICAgZmFsc2UsXG4gICAgICAgIDEwMDksXG4gICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfREFUQV9QQVlMT0FEX0xFTkdUSCdcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgcmV0dXJuIHRoaXMuaGF2ZUxlbmd0aCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFBheWxvYWQgbGVuZ3RoIGhhcyBiZWVuIHJlYWQuXG4gICAqXG4gICAqIEByZXR1cm4geyhSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhdmVMZW5ndGgoKSB7XG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggJiYgdGhpcy5fb3Bjb2RlIDwgMHgwOCkge1xuICAgICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoICs9IHRoaXMuX3BheWxvYWRMZW5ndGg7XG4gICAgICBpZiAodGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAxMDA5LFxuICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX21hc2tlZCkgdGhpcy5fc3RhdGUgPSBHRVRfTUFTSztcbiAgICBlbHNlIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgbWFzayBieXRlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldE1hc2soKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA0KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fbWFzayA9IHRoaXMuY29uc3VtZSg0KTtcbiAgICB0aGlzLl9zdGF0ZSA9IEdFVF9EQVRBO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlYWRzIGRhdGEgYnl0ZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEByZXR1cm4geyhFcnJvcnxSYW5nZUVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG4gICAgICBpZiAodGhpcy5fbWFza2VkKSB1bm1hc2soZGF0YSwgdGhpcy5fbWFzayk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcpIHJldHVybiB0aGlzLmNvbnRyb2xNZXNzYWdlKGRhdGEpO1xuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuZGF0YU1lc3NhZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzZXMgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgQ29tcHJlc3NlZCBkYXRhXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGNiKSB7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgcGVyTWVzc2FnZURlZmxhdGUuZGVjb21wcmVzcyhkYXRhLCB0aGlzLl9maW4sIChlcnIsIGJ1ZikgPT4ge1xuICAgICAgaWYgKGVycikgcmV0dXJuIGNiKGVycik7XG5cbiAgICAgIGlmIChidWYubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMuX21lc3NhZ2VMZW5ndGggKz0gYnVmLmxlbmd0aDtcbiAgICAgICAgaWYgKHRoaXMuX21lc3NhZ2VMZW5ndGggPiB0aGlzLl9tYXhQYXlsb2FkICYmIHRoaXMuX21heFBheWxvYWQgPiAwKSB7XG4gICAgICAgICAgcmV0dXJuIGNiKFxuICAgICAgICAgICAgZXJyb3IoXG4gICAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAgICdNYXggcGF5bG9hZCBzaXplIGV4Y2VlZGVkJyxcbiAgICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAgICdXU19FUlJfVU5TVVBQT1JURURfTUVTU0FHRV9MRU5HVEgnXG4gICAgICAgICAgICApXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2ZyYWdtZW50cy5wdXNoKGJ1Zik7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGVyID0gdGhpcy5kYXRhTWVzc2FnZSgpO1xuICAgICAgaWYgKGVyKSByZXR1cm4gY2IoZXIpO1xuXG4gICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHJldHVybiB7KEVycm9yfHVuZGVmaW5lZCl9IEEgcG9zc2libGUgZXJyb3JcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKCkge1xuICAgIGlmICh0aGlzLl9maW4pIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2VMZW5ndGggPSB0aGlzLl9tZXNzYWdlTGVuZ3RoO1xuICAgICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgICB0aGlzLl90b3RhbFBheWxvYWRMZW5ndGggPSAwO1xuICAgICAgdGhpcy5fbWVzc2FnZUxlbmd0aCA9IDA7XG4gICAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICAgIHRoaXMuX2ZyYWdtZW50cyA9IFtdO1xuXG4gICAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAyKSB7XG4gICAgICAgIGxldCBkYXRhO1xuXG4gICAgICAgIGlmICh0aGlzLl9iaW5hcnlUeXBlID09PSAnbm9kZWJ1ZmZlcicpIHtcbiAgICAgICAgICBkYXRhID0gY29uY2F0KGZyYWdtZW50cywgbWVzc2FnZUxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICAgIGRhdGEgPSB0b0FycmF5QnVmZmVyKGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgZGF0YSwgdHJ1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBidWYgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGJ1ZiwgZmFsc2UpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGNvbnRyb2wgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgRGF0YSB0byBoYW5kbGVcbiAgICogQHJldHVybiB7KEVycm9yfFJhbmdlRXJyb3J8dW5kZWZpbmVkKX0gQSBwb3NzaWJsZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29udHJvbE1lc3NhZ2UoZGF0YSkge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcblxuICAgICAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIGlmIChkYXRhLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAxJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBjb2RlID0gZGF0YS5yZWFkVUludDE2QkUoMCk7XG5cbiAgICAgICAgaWYgKCFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgICAgIHJldHVybiBlcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICBgaW52YWxpZCBzdGF0dXMgY29kZSAke2NvZGV9YCxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDAyLFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NMT1NFX0NPREUnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJ1ZiA9IGRhdGEuc2xpY2UoMik7XG5cbiAgICAgICAgaWYgKCF0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gJiYgIWlzVmFsaWRVVEY4KGJ1ZikpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3IoXG4gICAgICAgICAgICBFcnJvcixcbiAgICAgICAgICAgICdpbnZhbGlkIFVURi04IHNlcXVlbmNlJyxcbiAgICAgICAgICAgIHRydWUsXG4gICAgICAgICAgICAxMDA3LFxuICAgICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX1VURjgnXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCBjb2RlLCBidWYpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA5KSB7XG4gICAgICB0aGlzLmVtaXQoJ3BpbmcnLCBkYXRhKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbWl0KCdwb25nJywgZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFJlY2VpdmVyO1xuXG4vKipcbiAqIEJ1aWxkcyBhbiBlcnJvciBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IHByZWZpeCBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gYWRkIGEgZGVmYXVsdCBwcmVmaXggdG9cbiAqICAgICBgbWVzc2FnZWBcbiAqIEBwYXJhbSB7TnVtYmVyfSBzdGF0dXNDb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtTdHJpbmd9IGVycm9yQ29kZSBUaGUgZXhwb3NlZCBlcnJvciBjb2RlXG4gKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICBjb25zdCBlcnIgPSBuZXcgRXJyb3JDdG9yKFxuICAgIHByZWZpeCA/IGBJbnZhbGlkIFdlYlNvY2tldCBmcmFtZTogJHttZXNzYWdlfWAgOiBtZXNzYWdlXG4gICk7XG5cbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBlcnJvcik7XG4gIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICBlcnJba1N0YXR1c0NvZGVdID0gc3RhdHVzQ29kZTtcbiAgcmV0dXJuIGVycjtcbn1cbiIsIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXm5ldHx0bHMkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21GaWxsU3luYyB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHsgRU1QVFlfQlVGRkVSIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3QgeyBpc1ZhbGlkU3RhdHVzQ29kZSB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5jb25zdCB7IG1hc2s6IGFwcGx5TWFzaywgdG9CdWZmZXIgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcblxuY29uc3QgbWFzayA9IEJ1ZmZlci5hbGxvYyg0KTtcblxuLyoqXG4gKiBIeUJpIFNlbmRlciBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuY2xhc3MgU2VuZGVyIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBTZW5kZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7KG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHNvY2tldCBUaGUgY29ubmVjdGlvbiBzb2NrZXRcbiAgICogQHBhcmFtIHtPYmplY3R9IFtleHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZCBleHRlbnNpb25zXG4gICAqL1xuICBjb25zdHJ1Y3Rvcihzb2NrZXQsIGV4dGVuc2lvbnMpIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcbiAgICB0aGlzLl9jb21wcmVzcyA9IGZhbHNlO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyA9IDA7XG4gICAgdGhpcy5fZGVmbGF0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHJldHVybiB7QnVmZmVyW119IFRoZSBmcmFtZWQgZGF0YSBhcyBhIGxpc3Qgb2YgYEJ1ZmZlcmAgaW5zdGFuY2VzXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgY29uc3QgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seTtcbiAgICBsZXQgb2Zmc2V0ID0gb3B0aW9ucy5tYXNrID8gNiA6IDI7XG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhLmxlbmd0aDtcblxuICAgIGlmIChkYXRhLmxlbmd0aCA+PSA2NTUzNikge1xuICAgICAgb2Zmc2V0ICs9IDg7XG4gICAgICBwYXlsb2FkTGVuZ3RoID0gMTI3O1xuICAgIH0gZWxzZSBpZiAoZGF0YS5sZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhLmxlbmd0aCArIG9mZnNldCA6IG9mZnNldCk7XG5cbiAgICB0YXJnZXRbMF0gPSBvcHRpb25zLmZpbiA/IG9wdGlvbnMub3Bjb2RlIHwgMHg4MCA6IG9wdGlvbnMub3Bjb2RlO1xuICAgIGlmIChvcHRpb25zLnJzdjEpIHRhcmdldFswXSB8PSAweDQwO1xuXG4gICAgdGFyZ2V0WzFdID0gcGF5bG9hZExlbmd0aDtcblxuICAgIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjYpIHtcbiAgICAgIHRhcmdldC53cml0ZVVJbnQxNkJFKGRhdGEubGVuZ3RoLCAyKTtcbiAgICB9IGVsc2UgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNykge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDMyQkUoMCwgMik7XG4gICAgICB0YXJnZXQud3JpdGVVSW50MzJCRShkYXRhLmxlbmd0aCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHJhbmRvbUZpbGxTeW5jKG1hc2ssIDAsIDQpO1xuXG4gICAgdGFyZ2V0WzFdIHw9IDB4ODA7XG4gICAgdGFyZ2V0W29mZnNldCAtIDRdID0gbWFza1swXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gM10gPSBtYXNrWzFdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAyXSA9IG1hc2tbMl07XG4gICAgdGFyZ2V0W29mZnNldCAtIDFdID0gbWFza1szXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhLmxlbmd0aCk7XG4gICAgICByZXR1cm4gW3RhcmdldF07XG4gICAgfVxuXG4gICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIGRhdGEsIDAsIGRhdGEubGVuZ3RoKTtcbiAgICByZXR1cm4gW3RhcmdldCwgZGF0YV07XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBjbG9zZSBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2NvZGVdIFRoZSBzdGF0dXMgY29kZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHsoU3RyaW5nfEJ1ZmZlcil9IFtkYXRhXSBUaGUgbWVzc2FnZSBjb21wb25lbnQgb2YgdGhlIGJvZHlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgdGhlIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBjbG9zZShjb2RlLCBkYXRhLCBtYXNrLCBjYikge1xuICAgIGxldCBidWY7XG5cbiAgICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBidWYgPSBFTVBUWV9CVUZGRVI7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgIWlzVmFsaWRTdGF0dXNDb2RlKGNvZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgdmFsaWQgZXJyb3IgY29kZSBudW1iZXInKTtcbiAgICB9IGVsc2UgaWYgKGRhdGEgPT09IHVuZGVmaW5lZCB8fCAhZGF0YS5sZW5ndGgpIHtcbiAgICAgIGJ1ZiA9IEJ1ZmZlci5hbGxvY1Vuc2FmZSgyKTtcbiAgICAgIGJ1Zi53cml0ZVVJbnQxNkJFKGNvZGUsIDApO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChkYXRhKTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEyMykge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIG1lc3NhZ2UgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyMyBieXRlcycpO1xuICAgICAgfVxuXG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMiArIGxlbmd0aCk7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcblxuICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICBidWYud3JpdGUoZGF0YSwgMik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBidWYuc2V0KGRhdGEsIDIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb0Nsb3NlLCBidWYsIG1hc2ssIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9DbG9zZShidWYsIG1hc2ssIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIGNsb3NlIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvQ2xvc2UoZGF0YSwgbWFzaywgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOCxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHk6IGZhbHNlXG4gICAgICB9KSxcbiAgICAgIGNiXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIHBpbmcgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGNvbnN0IGJ1ZiA9IHRvQnVmZmVyKGRhdGEpO1xuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZGVmbGF0aW5nKSB7XG4gICAgICB0aGlzLmVucXVldWUoW3RoaXMuZG9QaW5nLCBidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYl0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRvUGluZyhidWYsIG1hc2ssIHRvQnVmZmVyLnJlYWRPbmx5LCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZyYW1lcyBhbmQgc2VuZHMgYSBwaW5nIG1lc3NhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW3JlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRvUGluZyhkYXRhLCBtYXNrLCByZWFkT25seSwgY2IpIHtcbiAgICB0aGlzLnNlbmRGcmFtZShcbiAgICAgIFNlbmRlci5mcmFtZShkYXRhLCB7XG4gICAgICAgIGZpbjogdHJ1ZSxcbiAgICAgICAgcnN2MTogZmFsc2UsXG4gICAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgICAgbWFzayxcbiAgICAgICAgcmVhZE9ubHlcbiAgICAgIH0pLFxuICAgICAgY2JcbiAgICApO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG5cbiAgICBpZiAoYnVmLmxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRpbmcpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kb1BvbmcsIGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZG9Qb25nKGJ1ZiwgbWFzaywgdG9CdWZmZXIucmVhZE9ubHksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRnJhbWVzIGFuZCBzZW5kcyBhIHBvbmcgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbcmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmUgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZG9Qb25nKGRhdGEsIG1hc2ssIHJlYWRPbmx5LCBjYikge1xuICAgIHRoaXMuc2VuZEZyYW1lKFxuICAgICAgU2VuZGVyLmZyYW1lKGRhdGEsIHtcbiAgICAgICAgZmluOiB0cnVlLFxuICAgICAgICByc3YxOiBmYWxzZSxcbiAgICAgICAgb3Bjb2RlOiAweDBhLFxuICAgICAgICBtYXNrLFxuICAgICAgICByZWFkT25seVxuICAgICAgfSksXG4gICAgICBjYlxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBkYXRhIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5XG4gICAqICAgICBvciB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgY29tcHJlc3MgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0aGUgZnJhZ21lbnQgaXMgdGhlXG4gICAqICAgICBsYXN0IG9uZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNiKSB7XG4gICAgY29uc3QgYnVmID0gdG9CdWZmZXIoZGF0YSk7XG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuICAgIGxldCBvcGNvZGUgPSBvcHRpb25zLmJpbmFyeSA/IDIgOiAxO1xuICAgIGxldCByc3YxID0gb3B0aW9ucy5jb21wcmVzcztcblxuICAgIGlmICh0aGlzLl9maXJzdEZyYWdtZW50KSB7XG4gICAgICB0aGlzLl9maXJzdEZyYWdtZW50ID0gZmFsc2U7XG4gICAgICBpZiAoXG4gICAgICAgIHJzdjEgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUgJiZcbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUucGFyYW1zW1xuICAgICAgICAgIHBlck1lc3NhZ2VEZWZsYXRlLl9pc1NlcnZlclxuICAgICAgICAgICAgPyAnc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXInXG4gICAgICAgICAgICA6ICdjbGllbnRfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgXVxuICAgICAgKSB7XG4gICAgICAgIHJzdjEgPSBidWYubGVuZ3RoID49IHBlck1lc3NhZ2VEZWZsYXRlLl90aHJlc2hvbGQ7XG4gICAgICB9XG4gICAgICB0aGlzLl9jb21wcmVzcyA9IHJzdjE7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJzdjEgPSBmYWxzZTtcbiAgICAgIG9wY29kZSA9IDA7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMuZmluKSB0aGlzLl9maXJzdEZyYWdtZW50ID0gdHJ1ZTtcblxuICAgIGlmIChwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgZmluOiBvcHRpb25zLmZpbixcbiAgICAgICAgcnN2MSxcbiAgICAgICAgb3Bjb2RlLFxuICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgIHJlYWRPbmx5OiB0b0J1ZmZlci5yZWFkT25seVxuICAgICAgfTtcblxuICAgICAgaWYgKHRoaXMuX2RlZmxhdGluZykge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZGlzcGF0Y2gsIGJ1ZiwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmRpc3BhdGNoKGJ1ZiwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoXG4gICAgICAgIFNlbmRlci5mcmFtZShidWYsIHtcbiAgICAgICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgICAgIHJzdjE6IGZhbHNlLFxuICAgICAgICAgIG9wY29kZSxcbiAgICAgICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICAgICAgcmVhZE9ubHk6IHRvQnVmZmVyLnJlYWRPbmx5XG4gICAgICAgIH0pLFxuICAgICAgICBjYlxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGlzcGF0Y2hlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtjb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGNvbXByZXNzXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBkaXNwYXRjaChkYXRhLCBjb21wcmVzcywgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAoIWNvbXByZXNzKSB7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IGRhdGEubGVuZ3RoO1xuICAgIHRoaXMuX2RlZmxhdGluZyA9IHRydWU7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUuY29tcHJlc3MoZGF0YSwgb3B0aW9ucy5maW4sIChfLCBidWYpID0+IHtcbiAgICAgIGlmICh0aGlzLl9zb2NrZXQuZGVzdHJveWVkKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAnVGhlIHNvY2tldCB3YXMgY2xvc2VkIHdoaWxlIGRhdGEgd2FzIGJlaW5nIGNvbXByZXNzZWQnXG4gICAgICAgICk7XG5cbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoZXJyKTtcblxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgY29uc3QgY2FsbGJhY2sgPSB0aGlzLl9xdWV1ZVtpXVs0XTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIGNhbGxiYWNrKGVycik7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gZGF0YS5sZW5ndGg7XG4gICAgICB0aGlzLl9kZWZsYXRpbmcgPSBmYWxzZTtcbiAgICAgIG9wdGlvbnMucmVhZE9ubHkgPSBmYWxzZTtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShidWYsIG9wdGlvbnMpLCBjYik7XG4gICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBxdWV1ZWQgc2VuZCBvcGVyYXRpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVxdWV1ZSgpIHtcbiAgICB3aGlsZSAoIXRoaXMuX2RlZmxhdGluZyAmJiB0aGlzLl9xdWV1ZS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IHRoaXMuX3F1ZXVlLnNoaWZ0KCk7XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gcGFyYW1zWzFdLmxlbmd0aDtcbiAgICAgIFJlZmxlY3QuYXBwbHkocGFyYW1zWzBdLCB0aGlzLCBwYXJhbXMuc2xpY2UoMSkpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBFbnF1ZXVlcyBhIHNlbmQgb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgU2VuZCBvcGVyYXRpb24gcGFyYW1ldGVycy5cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGVucXVldWUocGFyYW1zKSB7XG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBwYXJhbXNbMV0ubGVuZ3RoO1xuICAgIHRoaXMuX3F1ZXVlLnB1c2gocGFyYW1zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcltdfSBsaXN0IFRoZSBmcmFtZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNlbmRGcmFtZShsaXN0LCBjYikge1xuICAgIGlmIChsaXN0Lmxlbmd0aCA9PT0gMikge1xuICAgICAgdGhpcy5fc29ja2V0LmNvcmsoKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdKTtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzFdLCBjYik7XG4gICAgICB0aGlzLl9zb2NrZXQudW5jb3JrKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX3NvY2tldC53cml0ZShsaXN0WzBdLCBjYik7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gU2VuZGVyO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbi8qKlxuICogRW1pdHMgdGhlIGAnY2xvc2UnYCBldmVudCBvbiBhIHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge0R1cGxleH0gc3RyZWFtIFRoZSBzdHJlYW0uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc3RyZWFtKSB7XG4gIHN0cmVhbS5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlbmQnYCBldmVudC5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVuZCgpIHtcbiAgaWYgKCF0aGlzLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkKSB7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVycm9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkdXBsZXhPbkVycm9yKGVycikge1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICB0aGlzLmRlc3Ryb3koKTtcbiAgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnZXJyb3InKSA9PT0gMCkge1xuICAgIC8vIERvIG5vdCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IuXG4gICAgdGhpcy5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBXcmFwcyBhIGBXZWJTb2NrZXRgIGluIGEgZHVwbGV4IHN0cmVhbS5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd3MgVGhlIGBXZWJTb2NrZXRgIHRvIHdyYXBcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gVGhlIG9wdGlvbnMgZm9yIHRoZSBgRHVwbGV4YCBjb25zdHJ1Y3RvclxuICogQHJldHVybiB7RHVwbGV4fSBUaGUgZHVwbGV4IHN0cmVhbVxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBjcmVhdGVXZWJTb2NrZXRTdHJlYW0od3MsIG9wdGlvbnMpIHtcbiAgbGV0IHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IHRydWU7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgICBpZiAocmVzdW1lT25SZWNlaXZlckRyYWluKSB3cy5fc29ja2V0LnJlc3VtZSgpO1xuICB9XG5cbiAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgIHdzLl9yZWNlaXZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoJ2RyYWluJyk7XG4gICAgICB3cy5fcmVjZWl2ZXIub24oJ2RyYWluJywgcmVjZWl2ZXJPbkRyYWluKTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICB3cy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCdkcmFpbicpO1xuICAgIHdzLl9yZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICB9XG5cbiAgY29uc3QgZHVwbGV4ID0gbmV3IER1cGxleCh7XG4gICAgLi4ub3B0aW9ucyxcbiAgICBhdXRvRGVzdHJveTogZmFsc2UsXG4gICAgZW1pdENsb3NlOiBmYWxzZSxcbiAgICBvYmplY3RNb2RlOiBmYWxzZSxcbiAgICB3cml0YWJsZU9iamVjdE1vZGU6IGZhbHNlXG4gIH0pO1xuXG4gIHdzLm9uKCdtZXNzYWdlJywgZnVuY3Rpb24gbWVzc2FnZShtc2csIGlzQmluYXJ5KSB7XG4gICAgY29uc3QgZGF0YSA9XG4gICAgICAhaXNCaW5hcnkgJiYgZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLm9iamVjdE1vZGUgPyBtc2cudG9TdHJpbmcoKSA6IG1zZztcblxuICAgIGlmICghZHVwbGV4LnB1c2goZGF0YSkpIHtcbiAgICAgIHJlc3VtZU9uUmVjZWl2ZXJEcmFpbiA9IGZhbHNlO1xuICAgICAgd3MuX3NvY2tldC5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICBpZiAoZHVwbGV4LmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgLy8gUHJldmVudCBgd3MudGVybWluYXRlKClgIGZyb20gYmVpbmcgY2FsbGVkIGJ5IGBkdXBsZXguX2Rlc3Ryb3koKWAuXG4gICAgLy9cbiAgICAvLyAtIElmIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBiZWZvcmUgdGhlIGAnb3BlbidgIGV2ZW50LCB0aGVuXG4gICAgLy8gICBgd3MudGVybWluYXRlKClgIGlzIGEgbm9vcCBhcyBubyBzb2NrZXQgaXMgYXNzaWduZWQuXG4gICAgLy8gLSBPdGhlcndpc2UsIHRoZSBlcnJvciBpcyByZS1lbWl0dGVkIGJ5IHRoZSBsaXN0ZW5lciBvZiB0aGUgYCdlcnJvcidgXG4gICAgLy8gICBldmVudCBvZiB0aGUgYFJlY2VpdmVyYCBvYmplY3QuIFRoZSBsaXN0ZW5lciBhbHJlYWR5IGNsb3NlcyB0aGVcbiAgICAvLyAgIGNvbm5lY3Rpb24gYnkgY2FsbGluZyBgd3MuY2xvc2UoKWAuIFRoaXMgYWxsb3dzIGEgY2xvc2UgZnJhbWUgdG8gYmVcbiAgICAvLyAgIHNlbnQgdG8gdGhlIG90aGVyIHBlZXIuIElmIGB3cy50ZXJtaW5hdGUoKWAgaXMgY2FsbGVkIHJpZ2h0IGFmdGVyIHRoaXMsXG4gICAgLy8gICB0aGVuIHRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgYmUgc2VudC5cbiAgICB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSBmYWxzZTtcbiAgICBkdXBsZXguZGVzdHJveShlcnIpO1xuICB9KTtcblxuICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICBkdXBsZXgucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgZHVwbGV4Ll9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ0xPU0VEKSB7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuXG4gICAgd3Mub25jZSgnZXJyb3InLCBmdW5jdGlvbiBlcnJvcihlcnIpIHtcbiAgICAgIGNhbGxlZCA9IHRydWU7XG4gICAgICBjYWxsYmFjayhlcnIpO1xuICAgIH0pO1xuXG4gICAgd3Mub25jZSgnY2xvc2UnLCBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgIGlmICghY2FsbGVkKSBjYWxsYmFjayhlcnIpO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIGR1cGxleCk7XG4gICAgfSk7XG5cbiAgICBpZiAodGVybWluYXRlT25EZXN0cm95KSB3cy50ZXJtaW5hdGUoKTtcbiAgfTtcblxuICBkdXBsZXguX2ZpbmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX2ZpbmFsKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIElmIHRoZSB2YWx1ZSBvZiB0aGUgYF9zb2NrZXRgIHByb3BlcnR5IGlzIGBudWxsYCBpdCBtZWFucyB0aGF0IGB3c2AgaXMgYVxuICAgIC8vIGNsaWVudCB3ZWJzb2NrZXQgYW5kIHRoZSBoYW5kc2hha2UgZmFpbGVkLiBJbiBmYWN0LCB3aGVuIHRoaXMgaGFwcGVucywgYVxuICAgIC8vIHNvY2tldCBpcyBuZXZlciBhc3NpZ25lZCB0byB0aGUgd2Vic29ja2V0LiBXYWl0IGZvciB0aGUgYCdlcnJvcidgIGV2ZW50XG4gICAgLy8gdGhhdCB3aWxsIGJlIGVtaXR0ZWQgYnkgdGhlIHdlYnNvY2tldC5cbiAgICBpZiAod3MuX3NvY2tldCA9PT0gbnVsbCkgcmV0dXJuO1xuXG4gICAgaWYgKHdzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQpIHtcbiAgICAgIGNhbGxiYWNrKCk7XG4gICAgICBpZiAoZHVwbGV4Ll9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQpIGR1cGxleC5kZXN0cm95KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHdzLl9zb2NrZXQub25jZSgnZmluaXNoJywgZnVuY3Rpb24gZmluaXNoKCkge1xuICAgICAgICAvLyBgZHVwbGV4YCBpcyBub3QgZGVzdHJveWVkIGhlcmUgYmVjYXVzZSB0aGUgYCdlbmQnYCBldmVudCB3aWxsIGJlXG4gICAgICAgIC8vIGVtaXR0ZWQgb24gYGR1cGxleGAgYWZ0ZXIgdGhpcyBgJ2ZpbmlzaCdgIGV2ZW50LiBUaGUgRU9GIHNpZ25hbGluZ1xuICAgICAgICAvLyBgbnVsbGAgY2h1bmsgaXMsIGluIGZhY3QsIHB1c2hlZCB3aGVuIHRoZSB3ZWJzb2NrZXQgZW1pdHMgYCdjbG9zZSdgLlxuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgfSk7XG4gICAgICB3cy5jbG9zZSgpO1xuICAgIH1cbiAgfTtcblxuICBkdXBsZXguX3JlYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLk9QRU4gJiYgIXJlc3VtZU9uUmVjZWl2ZXJEcmFpbikge1xuICAgICAgcmVzdW1lT25SZWNlaXZlckRyYWluID0gdHJ1ZTtcbiAgICAgIGlmICghd3MuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLm5lZWREcmFpbikgd3MuX3NvY2tldC5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgZHVwbGV4Ll93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHdzLnJlYWR5U3RhdGUgPT09IHdzLkNPTk5FQ1RJTkcpIHtcbiAgICAgIHdzLm9uY2UoJ29wZW4nLCBmdW5jdGlvbiBvcGVuKCkge1xuICAgICAgICBkdXBsZXguX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgd3Muc2VuZChjaHVuaywgY2FsbGJhY2spO1xuICB9O1xuXG4gIGR1cGxleC5vbignZW5kJywgZHVwbGV4T25FbmQpO1xuICBkdXBsZXgub24oJ2Vycm9yJywgZHVwbGV4T25FcnJvcik7XG4gIHJldHVybiBkdXBsZXg7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gY3JlYXRlV2ViU29ja2V0U3RyZWFtO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IHRva2VuQ2hhcnMgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuXG4vKipcbiAqIFBhcnNlcyB0aGUgYFNlYy1XZWJTb2NrZXQtUHJvdG9jb2xgIGhlYWRlciBpbnRvIGEgc2V0IG9mIHN1YnByb3RvY29sIG5hbWVzLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBoZWFkZXIgVGhlIGZpZWxkIHZhbHVlIG9mIHRoZSBoZWFkZXJcbiAqIEByZXR1cm4ge1NldH0gVGhlIHN1YnByb3RvY29sIG5hbWVzXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHBhcnNlKGhlYWRlcikge1xuICBjb25zdCBwcm90b2NvbHMgPSBuZXcgU2V0KCk7XG4gIGxldCBzdGFydCA9IC0xO1xuICBsZXQgZW5kID0gLTE7XG4gIGxldCBpID0gMDtcblxuICBmb3IgKGk7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICBpZiAoc3RhcnQgPT09IC0xKSBzdGFydCA9IGk7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGkgIT09IDAgJiZcbiAgICAgIChjb2RlID09PSAweDIwIC8qICcgJyAqLyB8fCBjb2RlID09PSAweDA5KSAvKiAnXFx0JyAqL1xuICAgICkge1xuICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyYyAvKiAnLCcgKi8pIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbmQgPT09IC0xKSBlbmQgPSBpO1xuXG4gICAgICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcblxuICAgICAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBlbmQgIT09IC0xKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdVbmV4cGVjdGVkIGVuZCBvZiBpbnB1dCcpO1xuICB9XG5cbiAgY29uc3QgcHJvdG9jb2wgPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGkpO1xuXG4gIGlmIChwcm90b2NvbHMuaGFzKHByb3RvY29sKSkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVGhlIFwiJHtwcm90b2NvbH1cIiBzdWJwcm90b2NvbCBpcyBkdXBsaWNhdGVkYCk7XG4gIH1cblxuICBwcm90b2NvbHMuYWRkKHByb3RvY29sKTtcbiAgcmV0dXJuIHByb3RvY29scztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7IHBhcnNlIH07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG50cnkge1xuICBjb25zdCBpc1ZhbGlkVVRGOCA9IHJlcXVpcmUoJ3V0Zi04LXZhbGlkYXRlJyk7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjgoYnVmKSB7XG4gICAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDE1MCA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9LFxuICAgIHRva2VuQ2hhcnNcbiAgfTtcbn0gY2F0Y2ggKGUpIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgaXNWYWxpZFN0YXR1c0NvZGUsXG4gICAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgICB0b2tlbkNoYXJzXG4gIH07XG59XG4iLCIvKiBlc2xpbnQgbm8tdW51c2VkLXZhcnM6IFtcImVycm9yXCIsIHsgXCJ2YXJzSWdub3JlUGF0dGVyblwiOiBcIl5uZXR8dGxzfGh0dHBzJFwiIH1dICovXG5cbid1c2Ugc3RyaWN0JztcblxuY29uc3QgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG5jb25zdCBodHRwID0gcmVxdWlyZSgnaHR0cCcpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgbmV0ID0gcmVxdWlyZSgnbmV0Jyk7XG5jb25zdCB0bHMgPSByZXF1aXJlKCd0bHMnKTtcbmNvbnN0IHsgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5cbmNvbnN0IGV4dGVuc2lvbiA9IHJlcXVpcmUoJy4vZXh0ZW5zaW9uJyk7XG5jb25zdCBQZXJNZXNzYWdlRGVmbGF0ZSA9IHJlcXVpcmUoJy4vcGVybWVzc2FnZS1kZWZsYXRlJyk7XG5jb25zdCBzdWJwcm90b2NvbCA9IHJlcXVpcmUoJy4vc3VicHJvdG9jb2wnKTtcbmNvbnN0IFdlYlNvY2tldCA9IHJlcXVpcmUoJy4vd2Vic29ja2V0Jyk7XG5jb25zdCB7IEdVSUQsIGtXZWJTb2NrZXQgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IGtleVJlZ2V4ID0gL15bKy8wLTlBLVphLXpdezIyfT09JC87XG5cbmNvbnN0IFJVTk5JTkcgPSAwO1xuY29uc3QgQ0xPU0lORyA9IDE7XG5jb25zdCBDTE9TRUQgPSAyO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhIFdlYlNvY2tldCBzZXJ2ZXIuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldFNlcnZlciBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBgV2ViU29ja2V0U2VydmVyYCBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29uZmlndXJhdGlvbiBvcHRpb25zXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5iYWNrbG9nPTUxMV0gVGhlIG1heGltdW0gbGVuZ3RoIG9mIHRoZSBxdWV1ZSBvZlxuICAgKiAgICAgcGVuZGluZyBjb25uZWN0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmNsaWVudFRyYWNraW5nPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0b1xuICAgKiAgICAgdHJhY2sgY2xpZW50c1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPVxuICAgICAgcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQta2V5J10gIT09IHVuZGVmaW5lZFxuICAgICAgICA/IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LWtleSddXG4gICAgICAgIDogZmFsc2U7XG4gICAgY29uc3QgdmVyc2lvbiA9ICtyZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC12ZXJzaW9uJ107XG5cbiAgICBpZiAoXG4gICAgICByZXEubWV0aG9kICE9PSAnR0VUJyB8fFxuICAgICAgcmVxLmhlYWRlcnMudXBncmFkZS50b0xvd2VyQ2FzZSgpICE9PSAnd2Vic29ja2V0JyB8fFxuICAgICAgIWtleSB8fFxuICAgICAgIWtleVJlZ2V4LnRlc3Qoa2V5KSB8fFxuICAgICAgKHZlcnNpb24gIT09IDggJiYgdmVyc2lvbiAhPT0gMTMpIHx8XG4gICAgICAhdGhpcy5zaG91bGRIYW5kbGUocmVxKVxuICAgICkge1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRQcm90b2NvbCA9IHJlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXByb3RvY29sJ107XG4gICAgbGV0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcblxuICAgIGlmIChzZWNXZWJTb2NrZXRQcm90b2NvbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0cnkge1xuICAgICAgICBwcm90b2NvbHMgPSBzdWJwcm90b2NvbC5wYXJzZShzZWNXZWJTb2NrZXRQcm90b2NvbCk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgNDAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0geyhuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzb2NrZXQgVGhlIG5ldHdvcmsgc29ja2V0IGJldHdlZW4gdGhlXG4gICAqICAgICBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgV2ViU29ja2V0KG51bGwpO1xuXG4gICAgaWYgKHByb3RvY29scy5zaXplKSB7XG4gICAgICAvL1xuICAgICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIHByb3RvY29sIHNlbGVjdGlvbiBoYW5kbGVyLlxuICAgICAgLy9cbiAgICAgIGNvbnN0IHByb3RvY29sID0gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29sc1xuICAgICAgICA/IHRoaXMub3B0aW9ucy5oYW5kbGVQcm90b2NvbHMocHJvdG9jb2xzLCByZXEpXG4gICAgICAgIDogcHJvdG9jb2xzLnZhbHVlcygpLm5leHQoKS52YWx1ZTtcblxuICAgICAgaWYgKHByb3RvY29sKSB7XG4gICAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1Qcm90b2NvbDogJHtwcm90b2NvbH1gKTtcbiAgICAgICAgd3MuX3Byb3RvY29sID0gcHJvdG9jb2w7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgIGNvbnN0IHBhcmFtcyA9IGV4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0ucGFyYW1zO1xuICAgICAgY29uc3QgdmFsdWUgPSBleHRlbnNpb24uZm9ybWF0KHtcbiAgICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBbcGFyYW1zXVxuICAgICAgfSk7XG4gICAgICBoZWFkZXJzLnB1c2goYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uczogJHt2YWx1ZX1gKTtcbiAgICAgIHdzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucztcbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IGV4dGVybmFsIG1vZGlmaWNhdGlvbi9pbnNwZWN0aW9uIG9mIGhhbmRzaGFrZSBoZWFkZXJzLlxuICAgIC8vXG4gICAgdGhpcy5lbWl0KCdoZWFkZXJzJywgaGVhZGVycywgcmVxKTtcblxuICAgIHNvY2tldC53cml0ZShoZWFkZXJzLmNvbmNhdCgnXFxyXFxuJykuam9pbignXFxyXFxuJykpO1xuICAgIHNvY2tldC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHdzLnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IHRoaXMub3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiB0aGlzLm9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG5cbiAgICBpZiAodGhpcy5jbGllbnRzKSB7XG4gICAgICB0aGlzLmNsaWVudHMuYWRkKHdzKTtcbiAgICAgIHdzLm9uKCdjbG9zZScsICgpID0+IHtcbiAgICAgICAgdGhpcy5jbGllbnRzLmRlbGV0ZSh3cyk7XG5cbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZEVtaXRDbG9zZSAmJiAhdGhpcy5jbGllbnRzLnNpemUpIHtcbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNiKHdzLCByZXEpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0U2VydmVyO1xuXG4vKipcbiAqIEFkZCBldmVudCBsaXN0ZW5lcnMgb24gYW4gYEV2ZW50RW1pdHRlcmAgdXNpbmcgYSBtYXAgb2YgPGV2ZW50LCBsaXN0ZW5lcj5cbiAqIHBhaXJzLlxuICpcbiAqIEBwYXJhbSB7RXZlbnRFbWl0dGVyfSBzZXJ2ZXIgVGhlIGV2ZW50IGVtaXR0ZXJcbiAqIEBwYXJhbSB7T2JqZWN0LjxTdHJpbmcsIEZ1bmN0aW9uPn0gbWFwIFRoZSBsaXN0ZW5lcnMgdG8gYWRkXG4gKiBAcmV0dXJuIHtGdW5jdGlvbn0gQSBmdW5jdGlvbiB0aGF0IHdpbGwgcmVtb3ZlIHRoZSBhZGRlZCBsaXN0ZW5lcnMgd2hlblxuICogICAgIGNhbGxlZFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWRkTGlzdGVuZXJzKHNlcnZlciwgbWFwKSB7XG4gIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkgc2VydmVyLm9uKGV2ZW50LCBtYXBbZXZlbnRdKTtcblxuICByZXR1cm4gZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXJzKCkge1xuICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXMobWFwKSkge1xuICAgICAgc2VydmVyLnJlbW92ZUxpc3RlbmVyKGV2ZW50LCBtYXBbZXZlbnRdKTtcbiAgICB9XG4gIH07XG59XG5cbi8qKlxuICogRW1pdCBhIGAnY2xvc2UnYCBldmVudCBvbiBhbiBgRXZlbnRFbWl0dGVyYC5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0Q2xvc2Uoc2VydmVyKSB7XG4gIHNlcnZlci5fc3RhdGUgPSBDTE9TRUQ7XG4gIHNlcnZlci5lbWl0KCdjbG9zZScpO1xufVxuXG4vKipcbiAqIEhhbmRsZSBwcmVtYXR1cmUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbbWVzc2FnZV0gVGhlIEhUVFAgcmVzcG9uc2UgYm9keVxuICogQHBhcmFtIHtPYmplY3R9IFtoZWFkZXJzXSBBZGRpdGlvbmFsIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCBjb2RlLCBtZXNzYWdlLCBoZWFkZXJzKSB7XG4gIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgICBoZWFkZXJzID0ge1xuICAgICAgQ29ubmVjdGlvbjogJ2Nsb3NlJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAgICdDb250ZW50LUxlbmd0aCc6IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH07XG5cbiAgICBzb2NrZXQud3JpdGUoXG4gICAgICBgSFRUUC8xLjEgJHtjb2RlfSAke2h0dHAuU1RBVFVTX0NPREVTW2NvZGVdfVxcclxcbmAgK1xuICAgICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAgIC5tYXAoKGgpID0+IGAke2h9OiAke2hlYWRlcnNbaF19YClcbiAgICAgICAgICAuam9pbignXFxyXFxuJykgK1xuICAgICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICAgIG1lc3NhZ2VcbiAgICApO1xuICB9XG5cbiAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuICBzb2NrZXQuZGVzdHJveSgpO1xufVxuIiwiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeUmVhZGFibGUkXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHBzID0gcmVxdWlyZSgnaHR0cHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCBuZXQgPSByZXF1aXJlKCduZXQnKTtcbmNvbnN0IHRscyA9IHJlcXVpcmUoJ3RscycpO1xuY29uc3QgeyByYW5kb21CeXRlcywgY3JlYXRlSGFzaCB9ID0gcmVxdWlyZSgnY3J5cHRvJyk7XG5jb25zdCB7IFJlYWRhYmxlIH0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbmNvbnN0IHsgVVJMIH0gPSByZXF1aXJlKCd1cmwnKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgUmVjZWl2ZXIgPSByZXF1aXJlKCcuL3JlY2VpdmVyJyk7XG5jb25zdCBTZW5kZXIgPSByZXF1aXJlKCcuL3NlbmRlcicpO1xuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCByZWFkeVN0YXRlcyA9IFsnQ09OTkVDVElORycsICdPUEVOJywgJ0NMT1NJTkcnLCAnQ0xPU0VEJ107XG5jb25zdCBzdWJwcm90b2NvbFJlZ2V4ID0gL15bISMkJSYnKitcXC0uMC05QS1aXl9gfGEten5dKyQvO1xuY29uc3QgcHJvdG9jb2xWZXJzaW9ucyA9IFs4LCAxM107XG5jb25zdCBjbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgV2ViU29ja2V0LlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBXZWJTb2NrZXRgLlxuICAgKlxuICAgKiBAcGFyYW0geyhTdHJpbmd8VVJMKX0gYWRkcmVzcyBUaGUgVVJMIHRvIHdoaWNoIHRvIGNvbm5lY3RcbiAgICogQHBhcmFtIHsoU3RyaW5nfFN0cmluZ1tdKX0gW3Byb3RvY29sc10gVGhlIHN1YnByb3RvY29sc1xuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIENvbm5lY3Rpb24gb3B0aW9uc1xuICAgKi9cbiAgY29uc3RydWN0b3IoYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fY2xvc2VDb2RlID0gMTAwNjtcbiAgICB0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlTWVzc2FnZSA9IEVNUFRZX0JVRkZFUjtcbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gbnVsbDtcbiAgICB0aGlzLl9leHRlbnNpb25zID0ge307XG4gICAgdGhpcy5fcHJvdG9jb2wgPSAnJztcbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNPTk5FQ1RJTkc7XG4gICAgdGhpcy5fcmVjZWl2ZXIgPSBudWxsO1xuICAgIHRoaXMuX3NlbmRlciA9IG51bGw7XG4gICAgdGhpcy5fc29ja2V0ID0gbnVsbDtcblxuICAgIGlmIChhZGRyZXNzICE9PSBudWxsKSB7XG4gICAgICB0aGlzLl9idWZmZXJlZEFtb3VudCA9IDA7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IGZhbHNlO1xuICAgICAgdGhpcy5fcmVkaXJlY3RzID0gMDtcblxuICAgICAgaWYgKHByb3RvY29scyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShwcm90b2NvbHMpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcHJvdG9jb2xzID09PSAnb2JqZWN0JyAmJiBwcm90b2NvbHMgIT09IG51bGwpIHtcbiAgICAgICAgICBvcHRpb25zID0gcHJvdG9jb2xzO1xuICAgICAgICAgIHByb3RvY29scyA9IFtdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHByb3RvY29scyA9IFtwcm90b2NvbHNdO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGluaXRBc0NsaWVudCh0aGlzLCBhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc1NlcnZlciA9IHRydWU7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFRoaXMgZGV2aWF0ZXMgZnJvbSB0aGUgV0hBVFdHIGludGVyZmFjZSBzaW5jZSB3cyBkb2Vzbid0IHN1cHBvcnQgdGhlXG4gICAqIHJlcXVpcmVkIGRlZmF1bHQgXCJibG9iXCIgdHlwZSAoaW5zdGVhZCB3ZSBkZWZpbmUgYSBjdXN0b20gXCJub2RlYnVmZmVyXCJcbiAgICogdHlwZSkuXG4gICAqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgYmluYXJ5VHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fYmluYXJ5VHlwZTtcbiAgfVxuXG4gIHNldCBiaW5hcnlUeXBlKHR5cGUpIHtcbiAgICBpZiAoIUJJTkFSWV9UWVBFUy5pbmNsdWRlcyh0eXBlKSkgcmV0dXJuO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IHR5cGU7XG5cbiAgICAvL1xuICAgIC8vIEFsbG93IHRvIGNoYW5nZSBgYmluYXJ5VHlwZWAgb24gdGhlIGZseS5cbiAgICAvL1xuICAgIGlmICh0aGlzLl9yZWNlaXZlcikgdGhpcy5fcmVjZWl2ZXIuX2JpbmFyeVR5cGUgPSB0eXBlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtOdW1iZXJ9XG4gICAqL1xuICBnZXQgYnVmZmVyZWRBbW91bnQoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHJldHVybiB0aGlzLl9idWZmZXJlZEFtb3VudDtcblxuICAgIHJldHVybiB0aGlzLl9zb2NrZXQuX3dyaXRhYmxlU3RhdGUubGVuZ3RoICsgdGhpcy5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBnZXQgZXh0ZW5zaW9ucygpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZXh0ZW5zaW9ucykuam9pbigpO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHsobmV0LlNvY2tldHx0bHMuU29ja2V0KX0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZVxuICAgKiAgICAgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZSBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHNldFNvY2tldChzb2NrZXQsIGhlYWQsIG9wdGlvbnMpIHtcbiAgICBjb25zdCByZWNlaXZlciA9IG5ldyBSZWNlaXZlcih7XG4gICAgICBiaW5hcnlUeXBlOiB0aGlzLmJpbmFyeVR5cGUsXG4gICAgICBleHRlbnNpb25zOiB0aGlzLl9leHRlbnNpb25zLFxuICAgICAgaXNTZXJ2ZXI6IHRoaXMuX2lzU2VydmVyLFxuICAgICAgbWF4UGF5bG9hZDogb3B0aW9ucy5tYXhQYXlsb2FkLFxuICAgICAgc2tpcFVURjhWYWxpZGF0aW9uOiBvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgdGhpcy5fc2VuZGVyID0gbmV3IFNlbmRlcihzb2NrZXQsIHRoaXMuX2V4dGVuc2lvbnMpO1xuICAgIHRoaXMuX3JlY2VpdmVyID0gcmVjZWl2ZXI7XG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgcmVjZWl2ZXJba1dlYlNvY2tldF0gPSB0aGlzO1xuICAgIHNvY2tldFtrV2ViU29ja2V0XSA9IHRoaXM7XG5cbiAgICByZWNlaXZlci5vbignY29uY2x1ZGUnLCByZWNlaXZlck9uQ29uY2x1ZGUpO1xuICAgIHJlY2VpdmVyLm9uKCdkcmFpbicsIHJlY2VpdmVyT25EcmFpbik7XG4gICAgcmVjZWl2ZXIub24oJ2Vycm9yJywgcmVjZWl2ZXJPbkVycm9yKTtcbiAgICByZWNlaXZlci5vbignbWVzc2FnZScsIHJlY2VpdmVyT25NZXNzYWdlKTtcbiAgICByZWNlaXZlci5vbigncGluZycsIHJlY2VpdmVyT25QaW5nKTtcbiAgICByZWNlaXZlci5vbigncG9uZycsIHJlY2VpdmVyT25Qb25nKTtcblxuICAgIHNvY2tldC5zZXRUaW1lb3V0KDApO1xuICAgIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0lORykge1xuICAgICAgaWYgKFxuICAgICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCAmJlxuICAgICAgICAodGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8IHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZClcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5fc2VuZGVyLmNsb3NlKGNvZGUsIGRhdGEsICF0aGlzLl9pc1NlcnZlciwgKGVycikgPT4ge1xuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgZXJyb3IgaXMgaGFuZGxlZCBieSB0aGUgYCdlcnJvcidgIGxpc3RlbmVyIG9uIHRoZSBzb2NrZXQuIFdlIG9ubHlcbiAgICAgIC8vIHdhbnQgdG8ga25vdyBpZiB0aGUgY2xvc2UgZnJhbWUgaGFzIGJlZW4gc2VudCBoZXJlLlxuICAgICAgLy9cbiAgICAgIGlmIChlcnIpIHJldHVybjtcblxuICAgICAgdGhpcy5fY2xvc2VGcmFtZVNlbnQgPSB0cnVlO1xuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCB8fFxuICAgICAgICB0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWRcbiAgICAgICkge1xuICAgICAgICB0aGlzLl9zb2NrZXQuZW5kKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvL1xuICAgIC8vIFNwZWNpZnkgYSB0aW1lb3V0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gY29tcGxldGUuXG4gICAgLy9cbiAgICB0aGlzLl9jbG9zZVRpbWVyID0gc2V0VGltZW91dChcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95LmJpbmQodGhpcy5fc29ja2V0KSxcbiAgICAgIGNsb3NlVGltZW91dFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBpbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcGluZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucGluZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmQgYSBwb25nLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2tdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrIHdoaWNoIGlzIGV4ZWN1dGVkIHdoZW4gdGhlIHBvbmcgaXMgc2VudFxuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0IGlzIG5vdCBvcGVuOiByZWFkeVN0YXRlIDAgKENPTk5FQ1RJTkcpJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IGRhdGE7XG4gICAgICBkYXRhID0gbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBtYXNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjYiA9IG1hc2s7XG4gICAgICBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ251bWJlcicpIGRhdGEgPSBkYXRhLnRvU3RyaW5nKCk7XG5cbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgc2VuZEFmdGVyQ2xvc2UodGhpcywgZGF0YSwgY2IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChtYXNrID09PSB1bmRlZmluZWQpIG1hc2sgPSAhdGhpcy5faXNTZXJ2ZXI7XG4gICAgdGhpcy5fc2VuZGVyLnBvbmcoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG1hc2ssIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgcmV0dXJuIGFib3J0SGFuZHNoYWtlKHRoaXMsIHRoaXMuX3JlcSwgbXNnKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc29ja2V0KSB7XG4gICAgICB0aGlzLl9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgICB0aGlzLl9zb2NrZXQuZGVzdHJveSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ09OTkVDVElOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdDT05ORUNUSU5HJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ09OTkVDVElORycpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IE9QRU5cbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnT1BFTicsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ09QRU4nKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDTE9TSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0VEXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NMT1NFRCcsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NFRCcpXG59KTtcblxuW1xuICAnYmluYXJ5VHlwZScsXG4gICdidWZmZXJlZEFtb3VudCcsXG4gICdleHRlbnNpb25zJyxcbiAgJ3Byb3RvY29sJyxcbiAgJ3JlYWR5U3RhdGUnLFxuICAndXJsJ1xuXS5mb3JFYWNoKChwcm9wZXJ0eSkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgcHJvcGVydHksIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbn0pO1xuXG4vL1xuLy8gQWRkIHRoZSBgb25vcGVuYCwgYG9uZXJyb3JgLCBgb25jbG9zZWAsIGFuZCBgb25tZXNzYWdlYCBhdHRyaWJ1dGVzLlxuLy8gU2VlIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL2NvbW1zLmh0bWwjdGhlLXdlYnNvY2tldC1pbnRlcmZhY2Vcbi8vXG5bJ29wZW4nLCAnZXJyb3InLCAnY2xvc2UnLCAnbWVzc2FnZSddLmZvckVhY2goKG1ldGhvZCkgPT4ge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgYG9uJHttZXRob2R9YCwge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0KCkge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyhtZXRob2QpKSB7XG4gICAgICAgIGlmIChsaXN0ZW5lcltrRm9yT25FdmVudEF0dHJpYnV0ZV0pIHJldHVybiBsaXN0ZW5lcltrTGlzdGVuZXJdO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9LFxuICAgIHNldChoYW5kbGVyKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIobWV0aG9kLCBsaXN0ZW5lcik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHR5cGVvZiBoYW5kbGVyICE9PSAnZnVuY3Rpb24nKSByZXR1cm47XG5cbiAgICAgIHRoaXMuYWRkRXZlbnRMaXN0ZW5lcihtZXRob2QsIGhhbmRsZXIsIHtcbiAgICAgICAgW2tGb3JPbkV2ZW50QXR0cmlidXRlXTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn0pO1xuXG5XZWJTb2NrZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBhZGRFdmVudExpc3RlbmVyO1xuV2ViU29ja2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gcmVtb3ZlRXZlbnRMaXN0ZW5lcjtcblxubW9kdWxlLmV4cG9ydHMgPSBXZWJTb2NrZXQ7XG5cbi8qKlxuICogSW5pdGlhbGl6ZSBhIFdlYlNvY2tldCBjbGllbnQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgY2xpZW50IHRvIGluaXRpYWxpemVcbiAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICogQHBhcmFtIHtBcnJheX0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZvbGxvd1JlZGlyZWN0cz1mYWxzZV0gV2hldGhlciBvciBub3QgdG8gZm9sbG93XG4gKiAgICAgcmVkaXJlY3RzXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuaGFuZHNoYWtlVGltZW91dF0gVGltZW91dCBpbiBtaWxsaXNlY29uZHMgZm9yIHRoZVxuICogICAgIGhhbmRzaGFrZSByZXF1ZXN0XG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0xMDQ4NTc2MDBdIFRoZSBtYXhpbXVtIGFsbG93ZWQgbWVzc2FnZVxuICogICAgIHNpemVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhSZWRpcmVjdHM9MTBdIFRoZSBtYXhpbXVtIG51bWJlciBvZiByZWRpcmVjdHNcbiAqICAgICBhbGxvd2VkXG4gKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMub3JpZ2luXSBWYWx1ZSBvZiB0aGUgYE9yaWdpbmAgb3JcbiAqICAgICBgU2VjLVdlYlNvY2tldC1PcmlnaW5gIGhlYWRlclxuICogQHBhcmFtIHsoQm9vbGVhbnxPYmplY3QpfSBbb3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZT10cnVlXSBFbmFibGUvZGlzYWJsZVxuICogICAgIHBlcm1lc3NhZ2UtZGVmbGF0ZVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnByb3RvY29sVmVyc2lvbj0xM10gVmFsdWUgb2YgdGhlXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtVmVyc2lvbmAgaGVhZGVyXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAqICAgICBub3QgdG8gc2tpcCBVVEYtOCB2YWxpZGF0aW9uIGZvciB0ZXh0IGFuZCBjbG9zZSBtZXNzYWdlc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaW5pdEFzQ2xpZW50KHdlYnNvY2tldCwgYWRkcmVzcywgcHJvdG9jb2xzLCBvcHRpb25zKSB7XG4gIGNvbnN0IG9wdHMgPSB7XG4gICAgcHJvdG9jb2xWZXJzaW9uOiBwcm90b2NvbFZlcnNpb25zWzFdLFxuICAgIG1heFBheWxvYWQ6IDEwMCAqIDEwMjQgKiAxMDI0LFxuICAgIHNraXBVVEY4VmFsaWRhdGlvbjogZmFsc2UsXG4gICAgcGVyTWVzc2FnZURlZmxhdGU6IHRydWUsXG4gICAgZm9sbG93UmVkaXJlY3RzOiBmYWxzZSxcbiAgICBtYXhSZWRpcmVjdHM6IDEwLFxuICAgIC4uLm9wdGlvbnMsXG4gICAgY3JlYXRlQ29ubmVjdGlvbjogdW5kZWZpbmVkLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogdW5kZWZpbmVkLFxuICAgIGhvc3Q6IHVuZGVmaW5lZCxcbiAgICBwYXRoOiB1bmRlZmluZWQsXG4gICAgcG9ydDogdW5kZWZpbmVkXG4gIH07XG5cbiAgaWYgKCFwcm90b2NvbFZlcnNpb25zLmluY2x1ZGVzKG9wdHMucHJvdG9jb2xWZXJzaW9uKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFxuICAgICAgYFVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb246ICR7b3B0cy5wcm90b2NvbFZlcnNpb259IGAgK1xuICAgICAgICBgKHN1cHBvcnRlZCB2ZXJzaW9uczogJHtwcm90b2NvbFZlcnNpb25zLmpvaW4oJywgJyl9KWBcbiAgICApO1xuICB9XG5cbiAgbGV0IHBhcnNlZFVybDtcblxuICBpZiAoYWRkcmVzcyBpbnN0YW5jZW9mIFVSTCkge1xuICAgIHBhcnNlZFVybCA9IGFkZHJlc3M7XG4gICAgd2Vic29ja2V0Ll91cmwgPSBhZGRyZXNzLmhyZWY7XG4gIH0gZWxzZSB7XG4gICAgdHJ5IHtcbiAgICAgIHBhcnNlZFVybCA9IG5ldyBVUkwoYWRkcmVzcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBJbnZhbGlkIFVSTDogJHthZGRyZXNzfWApO1xuICAgIH1cblxuICAgIHdlYnNvY2tldC5fdXJsID0gYWRkcmVzcztcbiAgfVxuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzVW5peFNvY2tldCA9IHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ3dzK3VuaXg6JztcblxuICBpZiAocGFyc2VkVXJsLnByb3RvY29sICE9PSAnd3M6JyAmJiAhaXNTZWN1cmUgJiYgIWlzVW5peFNvY2tldCkge1xuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgb3IgXCJ3cyt1bml4OlwiJ1xuICAgICk7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0ICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJUaGUgVVJMJ3MgcGF0aG5hbWUgaXMgZW1wdHlcIik7XG4gIH1cblxuICBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1RoZSBVUkwgY29udGFpbnMgYSBmcmFnbWVudCBpZGVudGlmaWVyJyk7XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IGdldCA9IGlzU2VjdXJlID8gaHR0cHMuZ2V0IDogaHR0cC5nZXQ7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID0gaXNTZWN1cmUgPyB0bHNDb25uZWN0IDogbmV0Q29ubmVjdDtcbiAgb3B0cy5kZWZhdWx0UG9ydCA9IG9wdHMuZGVmYXVsdFBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMucG9ydCA9IHBhcnNlZFVybC5wb3J0IHx8IGRlZmF1bHRQb3J0O1xuICBvcHRzLmhvc3QgPSBwYXJzZWRVcmwuaG9zdG5hbWUuc3RhcnRzV2l0aCgnWycpXG4gICAgPyBwYXJzZWRVcmwuaG9zdG5hbWUuc2xpY2UoMSwgLTEpXG4gICAgOiBwYXJzZWRVcmwuaG9zdG5hbWU7XG4gIG9wdHMuaGVhZGVycyA9IHtcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0JyxcbiAgICAuLi5vcHRzLmhlYWRlcnNcbiAgfTtcbiAgb3B0cy5wYXRoID0gcGFyc2VkVXJsLnBhdGhuYW1lICsgcGFyc2VkVXJsLnNlYXJjaDtcbiAgb3B0cy50aW1lb3V0ID0gb3B0cy5oYW5kc2hha2VUaW1lb3V0O1xuXG4gIGlmIChvcHRzLnBlck1lc3NhZ2VEZWZsYXRlKSB7XG4gICAgcGVyTWVzc2FnZURlZmxhdGUgPSBuZXcgUGVyTWVzc2FnZURlZmxhdGUoXG4gICAgICBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlICE9PSB0cnVlID8gb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA6IHt9LFxuICAgICAgZmFsc2UsXG4gICAgICBvcHRzLm1heFBheWxvYWRcbiAgICApO1xuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zJ10gPSBmb3JtYXQoe1xuICAgICAgW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdOiBwZXJNZXNzYWdlRGVmbGF0ZS5vZmZlcigpXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb3RvY29scy5sZW5ndGgpIHtcbiAgICBmb3IgKGNvbnN0IHByb3RvY29sIG9mIHByb3RvY29scykge1xuICAgICAgaWYgKFxuICAgICAgICB0eXBlb2YgcHJvdG9jb2wgIT09ICdzdHJpbmcnIHx8XG4gICAgICAgICFzdWJwcm90b2NvbFJlZ2V4LnRlc3QocHJvdG9jb2wpIHx8XG4gICAgICAgIHByb3RvY29sU2V0Lmhhcyhwcm90b2NvbClcbiAgICAgICkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgJ0FuIGludmFsaWQgb3IgZHVwbGljYXRlZCBzdWJwcm90b2NvbCB3YXMgc3BlY2lmaWVkJ1xuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBwcm90b2NvbFNldC5hZGQocHJvdG9jb2wpO1xuICAgIH1cblxuICAgIG9wdHMuaGVhZGVyc1snU2VjLVdlYlNvY2tldC1Qcm90b2NvbCddID0gcHJvdG9jb2xzLmpvaW4oJywnKTtcbiAgfVxuICBpZiAob3B0cy5vcmlnaW4pIHtcbiAgICBpZiAob3B0cy5wcm90b2NvbFZlcnNpb24gPCAxMykge1xuICAgICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LU9yaWdpbiddID0gb3B0cy5vcmlnaW47XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdHMuaGVhZGVycy5PcmlnaW4gPSBvcHRzLm9yaWdpbjtcbiAgICB9XG4gIH1cbiAgaWYgKHBhcnNlZFVybC51c2VybmFtZSB8fCBwYXJzZWRVcmwucGFzc3dvcmQpIHtcbiAgICBvcHRzLmF1dGggPSBgJHtwYXJzZWRVcmwudXNlcm5hbWV9OiR7cGFyc2VkVXJsLnBhc3N3b3JkfWA7XG4gIH1cblxuICBpZiAoaXNVbml4U29ja2V0KSB7XG4gICAgY29uc3QgcGFydHMgPSBvcHRzLnBhdGguc3BsaXQoJzonKTtcblxuICAgIG9wdHMuc29ja2V0UGF0aCA9IHBhcnRzWzBdO1xuICAgIG9wdHMucGF0aCA9IHBhcnRzWzFdO1xuICB9XG5cbiAgbGV0IHJlcSA9ICh3ZWJzb2NrZXQuX3JlcSA9IGdldChvcHRzKSk7XG5cbiAgaWYgKG9wdHMudGltZW91dCkge1xuICAgIHJlcS5vbigndGltZW91dCcsICgpID0+IHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnT3BlbmluZyBoYW5kc2hha2UgaGFzIHRpbWVkIG91dCcpO1xuICAgIH0pO1xuICB9XG5cbiAgcmVxLm9uKCdlcnJvcicsIChlcnIpID0+IHtcbiAgICBpZiAocmVxID09PSBudWxsIHx8IHJlcS5hYm9ydGVkKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0pO1xuXG4gIHJlcS5vbigncmVzcG9uc2UnLCAocmVzKSA9PiB7XG4gICAgY29uc3QgbG9jYXRpb24gPSByZXMuaGVhZGVycy5sb2NhdGlvbjtcbiAgICBjb25zdCBzdGF0dXNDb2RlID0gcmVzLnN0YXR1c0NvZGU7XG5cbiAgICBpZiAoXG4gICAgICBsb2NhdGlvbiAmJlxuICAgICAgb3B0cy5mb2xsb3dSZWRpcmVjdHMgJiZcbiAgICAgIHN0YXR1c0NvZGUgPj0gMzAwICYmXG4gICAgICBzdGF0dXNDb2RlIDwgNDAwXG4gICAgKSB7XG4gICAgICBpZiAoKyt3ZWJzb2NrZXQuX3JlZGlyZWN0cyA+IG9wdHMubWF4UmVkaXJlY3RzKSB7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgcmVxLCAnTWF4aW11bSByZWRpcmVjdHMgZXhjZWVkZWQnKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICByZXEuYWJvcnQoKTtcblxuICAgICAgY29uc3QgYWRkciA9IG5ldyBVUkwobG9jYXRpb24sIGFkZHJlc3MpO1xuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZSBgdXBncmFkZWBcbiAgICAvLyBldmVudC5cbiAgICAvL1xuICAgIGlmICh3ZWJzb2NrZXQucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHJldHVybjtcblxuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gbnVsbDtcblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIG1heFBheWxvYWQ6IG9wdHMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0cy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcbiAgfSk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGEgYG5ldC5Tb2NrZXRgIGFuZCBpbml0aWF0ZSBhIGNvbm5lY3Rpb24uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgQ29ubmVjdGlvbiBvcHRpb25zXG4gKiBAcmV0dXJuIHtuZXQuU29ja2V0fSBUaGUgbmV3bHkgY3JlYXRlZCBzb2NrZXQgdXNlZCB0byBzdGFydCB0aGUgY29ubmVjdGlvblxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbmV0Q29ubmVjdChvcHRpb25zKSB7XG4gIG9wdGlvbnMucGF0aCA9IG9wdGlvbnMuc29ja2V0UGF0aDtcbiAgcmV0dXJuIG5ldC5jb25uZWN0KG9wdGlvbnMpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGB0bHMuVExTU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7dGxzLlRMU1NvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHRsc0Nvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSB1bmRlZmluZWQ7XG5cbiAgaWYgKCFvcHRpb25zLnNlcnZlcm5hbWUgJiYgb3B0aW9ucy5zZXJ2ZXJuYW1lICE9PSAnJykge1xuICAgIG9wdGlvbnMuc2VydmVybmFtZSA9IG5ldC5pc0lQKG9wdGlvbnMuaG9zdCkgPyAnJyA6IG9wdGlvbnMuaG9zdDtcbiAgfVxuXG4gIHJldHVybiB0bHMuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBBYm9ydCB0aGUgaGFuZHNoYWtlIGFuZCBlbWl0IGFuIGVycm9yLlxuICpcbiAqIEBwYXJhbSB7V2ViU29ja2V0fSB3ZWJzb2NrZXQgVGhlIFdlYlNvY2tldCBpbnN0YW5jZVxuICogQHBhcmFtIHsoaHR0cC5DbGllbnRSZXF1ZXN0fG5ldC5Tb2NrZXR8dGxzLlNvY2tldCl9IHN0cmVhbSBUaGUgcmVxdWVzdCB0b1xuICogICAgIGFib3J0IG9yIHRoZSBzb2NrZXQgdG8gZGVzdHJveVxuICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc3RyZWFtLCBtZXNzYWdlKSB7XG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZSk7XG5cbiAgaWYgKHN0cmVhbS5zZXRIZWFkZXIpIHtcbiAgICBzdHJlYW0uYWJvcnQoKTtcblxuICAgIGlmIChzdHJlYW0uc29ja2V0ICYmICFzdHJlYW0uc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgLy9cbiAgICAgIC8vIE9uIE5vZGUuanMgPj0gMTQuMy4wIGByZXF1ZXN0LmFib3J0KClgIGRvZXMgbm90IGRlc3Ryb3kgdGhlIHNvY2tldCBpZlxuICAgICAgLy8gY2FsbGVkIGFmdGVyIHRoZSByZXF1ZXN0IGNvbXBsZXRlZC4gU2VlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTg2OS5cbiAgICAgIC8vXG4gICAgICBzdHJlYW0uc29ja2V0LmRlc3Ryb3koKTtcbiAgICB9XG5cbiAgICBzdHJlYW0ub25jZSgnYWJvcnQnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gICAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgfSBlbHNlIHtcbiAgICBzdHJlYW0uZGVzdHJveShlcnIpO1xuICAgIHN0cmVhbS5vbmNlKCdlcnJvcicsIHdlYnNvY2tldC5lbWl0LmJpbmQod2Vic29ja2V0LCAnZXJyb3InKSk7XG4gICAgc3RyZWFtLm9uY2UoJ2Nsb3NlJywgd2Vic29ja2V0LmVtaXRDbG9zZS5iaW5kKHdlYnNvY2tldCkpO1xuICB9XG59XG5cbi8qKlxuICogSGFuZGxlIGNhc2VzIHdoZXJlIHRoZSBgcGluZygpYCwgYHBvbmcoKWAsIG9yIGBzZW5kKClgIG1ldGhvZHMgYXJlIGNhbGxlZFxuICogd2hlbiB0aGUgYHJlYWR5U3RhdGVgIGF0dHJpYnV0ZSBpcyBgQ0xPU0lOR2Agb3IgYENMT1NFRGAuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcGFyYW0geyp9IFtkYXRhXSBUaGUgZGF0YSB0byBzZW5kXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZW5kQWZ0ZXJDbG9zZSh3ZWJzb2NrZXQsIGRhdGEsIGNiKSB7XG4gIGlmIChkYXRhKSB7XG4gICAgY29uc3QgbGVuZ3RoID0gdG9CdWZmZXIoZGF0YSkubGVuZ3RoO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgYF9idWZmZXJlZEFtb3VudGAgcHJvcGVydHkgaXMgdXNlZCBvbmx5IHdoZW4gdGhlIHBlZXIgaXMgYSBjbGllbnQgYW5kXG4gICAgLy8gdGhlIG9wZW5pbmcgaGFuZHNoYWtlIGZhaWxzLiBVbmRlciB0aGVzZSBjaXJjdW1zdGFuY2VzLCBpbiBmYWN0LCB0aGVcbiAgICAvLyBgc2V0U29ja2V0KClgIG1ldGhvZCBpcyBub3QgY2FsbGVkLCBzbyB0aGUgYF9zb2NrZXRgIGFuZCBgX3NlbmRlcmBcbiAgICAvLyBwcm9wZXJ0aWVzIGFyZSBzZXQgdG8gYG51bGxgLlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5fc29ja2V0KSB3ZWJzb2NrZXQuX3NlbmRlci5fYnVmZmVyZWRCeXRlcyArPSBsZW5ndGg7XG4gICAgZWxzZSB3ZWJzb2NrZXQuX2J1ZmZlcmVkQW1vdW50ICs9IGxlbmd0aDtcbiAgfVxuXG4gIGlmIChjYikge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgIGBXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgJHt3ZWJzb2NrZXQucmVhZHlTdGF0ZX0gYCArXG4gICAgICAgIGAoJHtyZWFkeVN0YXRlc1t3ZWJzb2NrZXQucmVhZHlTdGF0ZV19KWBcbiAgICApO1xuICAgIGNiKGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdjb25jbHVkZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBzdGF0dXMgY29kZVxuICogQHBhcmFtIHtCdWZmZXJ9IHJlYXNvbiBUaGUgcmVhc29uIGZvciBjbG9zaW5nXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uQ29uY2x1ZGUoY29kZSwgcmVhc29uKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9jbG9zZUZyYW1lUmVjZWl2ZWQgPSB0cnVlO1xuICB3ZWJzb2NrZXQuX2Nsb3NlTWVzc2FnZSA9IHJlYXNvbjtcbiAgd2Vic29ja2V0Ll9jbG9zZUNvZGUgPSBjb2RlO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSA9PT0gdW5kZWZpbmVkKSByZXR1cm47XG5cbiAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gIGlmIChjb2RlID09PSAxMDA1KSB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgZWxzZSB3ZWJzb2NrZXQuY2xvc2UoY29kZSwgcmVhc29uKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdkcmFpbidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25EcmFpbigpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5fc29ja2V0LnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoUmFuZ2VFcnJvcnxFcnJvcil9IGVyciBUaGUgZW1pdHRlZCBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkVycm9yKGVycikge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICh3ZWJzb2NrZXQuX3NvY2tldFtrV2ViU29ja2V0XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgd2Vic29ja2V0Ll9zb2NrZXQucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuXG4gICAgLy9cbiAgICAvLyBPbiBOb2RlLmpzIDwgMTQuMC4wIHRoZSBgJ2Vycm9yJ2AgZXZlbnQgaXMgZW1pdHRlZCBzeW5jaHJvbm91c2x5LiBTZWVcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTk0MC5cbiAgICAvL1xuICAgIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgICB3ZWJzb2NrZXQuY2xvc2UoZXJyW2tTdGF0dXNDb2RlXSk7XG4gIH1cblxuICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2ZpbmlzaCdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25GaW5pc2goKSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdENsb3NlKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnbWVzc2FnZSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfEFycmF5QnVmZmVyfEJ1ZmZlcltdKX0gZGF0YSBUaGUgbWVzc2FnZVxuICogQHBhcmFtIHtCb29sZWFufSBpc0JpbmFyeSBTcGVjaWZpZXMgd2hldGhlciB0aGUgbWVzc2FnZSBpcyBiaW5hcnkgb3Igbm90XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCBpc0JpbmFyeSk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAncGluZydgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIFRoZSBkYXRhIGluY2x1ZGVkIGluIHRoZSBwaW5nIGZyYW1lXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiByZWNlaXZlck9uUGluZyhkYXRhKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXdlYnNvY2tldC5faXNTZXJ2ZXIsIE5PT1ApO1xuICB3ZWJzb2NrZXQuZW1pdCgncGluZycsIGRhdGEpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ3BvbmcnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBUaGUgZGF0YSBpbmNsdWRlZCBpbiB0aGUgcG9uZyBmcmFtZVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPblBvbmcoZGF0YSkge1xuICB0aGlzW2tXZWJTb2NrZXRdLmVtaXQoJ3BvbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBSZXN1bWUgYSByZWFkYWJsZSBzdHJlYW1cbiAqXG4gKiBAcGFyYW0ge1JlYWRhYmxlfSBzdHJlYW0gVGhlIHJlYWRhYmxlIHN0cmVhbVxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSkge1xuICBzdHJlYW0ucmVzdW1lKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdjbG9zZSdgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uQ2xvc2UoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHNvY2tldE9uRW5kKTtcblxuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBsZXQgY2h1bms7XG5cbiAgLy9cbiAgLy8gVGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBoYXZlIGJlZW4gcmVjZWl2ZWQgb3IgdGhlIGAnZW5kJ2AgZXZlbnQgZW1pdHRlZCxcbiAgLy8gZm9yIGV4YW1wbGUsIGlmIHRoZSBzb2NrZXQgd2FzIGRlc3Ryb3llZCBkdWUgdG8gYW4gZXJyb3IuIEVuc3VyZSB0aGF0IHRoZVxuICAvLyBgcmVjZWl2ZXJgIHN0cmVhbSBpcyBjbG9zZWQgYWZ0ZXIgd3JpdGluZyBhbnkgcmVtYWluaW5nIGJ1ZmZlcmVkIGRhdGEgdG9cbiAgLy8gaXQuIElmIHRoZSByZWFkYWJsZSBzaWRlIG9mIHRoZSBzb2NrZXQgaXMgaW4gZmxvd2luZyBtb2RlIHRoZW4gdGhlcmUgaXMgbm9cbiAgLy8gYnVmZmVyZWQgZGF0YSBhcyBldmVyeXRoaW5nIGhhcyBiZWVuIGFscmVhZHkgd3JpdHRlbiBhbmQgYHJlYWRhYmxlLnJlYWQoKWBcbiAgLy8gd2lsbCByZXR1cm4gYG51bGxgLiBJZiBpbnN0ZWFkLCB0aGUgc29ja2V0IGlzIHBhdXNlZCwgYW55IHBvc3NpYmxlIGJ1ZmZlcmVkXG4gIC8vIGRhdGEgd2lsbCBiZSByZWFkIGFzIGEgc2luZ2xlIGNodW5rLlxuICAvL1xuICBpZiAoXG4gICAgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCAmJlxuICAgICF3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJlxuICAgICF3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCAmJlxuICAgIChjaHVuayA9IHdlYnNvY2tldC5fc29ja2V0LnJlYWQoKSkgIT09IG51bGxcbiAgKSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYG5ldC5Tb2NrZXRgIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgbmV0LlNvY2tldGAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FUlJPUl9QQUNLRVQgPSBleHBvcnRzLlBBQ0tFVF9UWVBFU19SRVZFUlNFID0gZXhwb3J0cy5QQUNLRVRfVFlQRVMgPSB2b2lkIDA7XG5jb25zdCBQQUNLRVRfVFlQRVMgPSBPYmplY3QuY3JlYXRlKG51bGwpOyAvLyBubyBNYXAgPSBubyBwb2x5ZmlsbFxuZXhwb3J0cy5QQUNLRVRfVFlQRVMgPSBQQUNLRVRfVFlQRVM7XG5QQUNLRVRfVFlQRVNbXCJvcGVuXCJdID0gXCIwXCI7XG5QQUNLRVRfVFlQRVNbXCJjbG9zZVwiXSA9IFwiMVwiO1xuUEFDS0VUX1RZUEVTW1wicGluZ1wiXSA9IFwiMlwiO1xuUEFDS0VUX1RZUEVTW1wicG9uZ1wiXSA9IFwiM1wiO1xuUEFDS0VUX1RZUEVTW1wibWVzc2FnZVwiXSA9IFwiNFwiO1xuUEFDS0VUX1RZUEVTW1widXBncmFkZVwiXSA9IFwiNVwiO1xuUEFDS0VUX1RZUEVTW1wibm9vcFwiXSA9IFwiNlwiO1xuY29uc3QgUEFDS0VUX1RZUEVTX1JFVkVSU0UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5QQUNLRVRfVFlQRVNfUkVWRVJTRSA9IFBBQ0tFVF9UWVBFU19SRVZFUlNFO1xuT2JqZWN0LmtleXMoUEFDS0VUX1RZUEVTKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgUEFDS0VUX1RZUEVTX1JFVkVSU0VbUEFDS0VUX1RZUEVTW2tleV1dID0ga2V5O1xufSk7XG5jb25zdCBFUlJPUl9QQUNLRVQgPSB7IHR5cGU6IFwiZXJyb3JcIiwgZGF0YTogXCJwYXJzZXIgZXJyb3JcIiB9O1xuZXhwb3J0cy5FUlJPUl9QQUNLRVQgPSBFUlJPUl9QQUNLRVQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbnNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbnMuanNcIik7XG5jb25zdCBiYXNlNjRfYXJyYXlidWZmZXJfMSA9IHJlcXVpcmUoXCJAc29ja2V0LmlvL2Jhc2U2NC1hcnJheWJ1ZmZlclwiKTtcbmNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuY29uc3QgZGVjb2RlUGFja2V0ID0gKGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBpZiAodHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogbWFwQmluYXJ5KGVuY29kZWRQYWNrZXQsIGJpbmFyeVR5cGUpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHR5cGUgPSBlbmNvZGVkUGFja2V0LmNoYXJBdCgwKTtcbiAgICBpZiAodHlwZSA9PT0gXCJiXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwibWVzc2FnZVwiLFxuICAgICAgICAgICAgZGF0YTogZGVjb2RlQmFzZTY0UGFja2V0KGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpLCBiaW5hcnlUeXBlKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBjb25zdCBwYWNrZXRUeXBlID0gY29tbW9uc19qc18xLlBBQ0tFVF9UWVBFU19SRVZFUlNFW3R5cGVdO1xuICAgIGlmICghcGFja2V0VHlwZSkge1xuICAgICAgICByZXR1cm4gY29tbW9uc19qc18xLkVSUk9SX1BBQ0tFVDtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kZWRQYWNrZXQubGVuZ3RoID4gMVxuICAgICAgICA/IHtcbiAgICAgICAgICAgIHR5cGU6IGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNfUkVWRVJTRVt0eXBlXSxcbiAgICAgICAgICAgIGRhdGE6IGVuY29kZWRQYWNrZXQuc3Vic3RyaW5nKDEpXG4gICAgICAgIH1cbiAgICAgICAgOiB7XG4gICAgICAgICAgICB0eXBlOiBjb21tb25zX2pzXzEuUEFDS0VUX1RZUEVTX1JFVkVSU0VbdHlwZV1cbiAgICAgICAgfTtcbn07XG5jb25zdCBkZWNvZGVCYXNlNjRQYWNrZXQgPSAoZGF0YSwgYmluYXJ5VHlwZSkgPT4ge1xuICAgIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9ICgwLCBiYXNlNjRfYXJyYXlidWZmZXJfMS5kZWNvZGUpKGRhdGEpO1xuICAgICAgICByZXR1cm4gbWFwQmluYXJ5KGRlY29kZWQsIGJpbmFyeVR5cGUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHsgYmFzZTY0OiB0cnVlLCBkYXRhIH07IC8vIGZhbGxiYWNrIGZvciBvbGQgYnJvd3NlcnNcbiAgICB9XG59O1xuY29uc3QgbWFwQmluYXJ5ID0gKGRhdGEsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBzd2l0Y2ggKGJpbmFyeVR5cGUpIHtcbiAgICAgICAgY2FzZSBcImJsb2JcIjpcbiAgICAgICAgICAgIHJldHVybiBkYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgPyBuZXcgQmxvYihbZGF0YV0pIDogZGF0YTtcbiAgICAgICAgY2FzZSBcImFycmF5YnVmZmVyXCI6XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gZGF0YTsgLy8gYXNzdW1pbmcgdGhlIGRhdGEgaXMgYWxyZWFkeSBhbiBBcnJheUJ1ZmZlclxuICAgIH1cbn07XG5leHBvcnRzLmRlZmF1bHQgPSBkZWNvZGVQYWNrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1vbnNfanNfMSA9IHJlcXVpcmUoXCIuL2NvbW1vbnMuanNcIik7XG5jb25zdCB3aXRoTmF0aXZlQmxvYiA9IHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgfHxcbiAgICAodHlwZW9mIEJsb2IgIT09IFwidW5kZWZpbmVkXCIgJiZcbiAgICAgICAgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKEJsb2IpID09PSBcIltvYmplY3QgQmxvYkNvbnN0cnVjdG9yXVwiKTtcbmNvbnN0IHdpdGhOYXRpdmVBcnJheUJ1ZmZlciA9IHR5cGVvZiBBcnJheUJ1ZmZlciA9PT0gXCJmdW5jdGlvblwiO1xuLy8gQXJyYXlCdWZmZXIuaXNWaWV3IG1ldGhvZCBpcyBub3QgZGVmaW5lZCBpbiBJRTEwXG5jb25zdCBpc1ZpZXcgPSBvYmogPT4ge1xuICAgIHJldHVybiB0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgPyBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxuICAgICAgICA6IG9iaiAmJiBvYmouYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXI7XG59O1xuY29uc3QgZW5jb2RlUGFja2V0ID0gKHsgdHlwZSwgZGF0YSB9LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spID0+IHtcbiAgICBpZiAod2l0aE5hdGl2ZUJsb2IgJiYgZGF0YSBpbnN0YW5jZW9mIEJsb2IpIHtcbiAgICAgICAgaWYgKHN1cHBvcnRzQmluYXJ5KSB7XG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZW5jb2RlQmxvYkFzQmFzZTY0KGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh3aXRoTmF0aXZlQXJyYXlCdWZmZXIgJiZcbiAgICAgICAgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBpc1ZpZXcoZGF0YSkpKSB7XG4gICAgICAgIGlmIChzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGVuY29kZUJsb2JBc0Jhc2U2NChuZXcgQmxvYihbZGF0YV0pLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcGxhaW4gc3RyaW5nXG4gICAgcmV0dXJuIGNhbGxiYWNrKGNvbW1vbnNfanNfMS5QQUNLRVRfVFlQRVNbdHlwZV0gKyAoZGF0YSB8fCBcIlwiKSk7XG59O1xuY29uc3QgZW5jb2RlQmxvYkFzQmFzZTY0ID0gKGRhdGEsIGNhbGxiYWNrKSA9PiB7XG4gICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgZmlsZVJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBmaWxlUmVhZGVyLnJlc3VsdC5zcGxpdChcIixcIilbMV07XG4gICAgICAgIGNhbGxiYWNrKFwiYlwiICsgY29udGVudCk7XG4gICAgfTtcbiAgICByZXR1cm4gZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGRhdGEpO1xufTtcbmV4cG9ydHMuZGVmYXVsdCA9IGVuY29kZVBhY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZWNvZGVQYXlsb2FkID0gZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBleHBvcnRzLmVuY29kZVBheWxvYWQgPSBleHBvcnRzLmVuY29kZVBhY2tldCA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG5jb25zdCBlbmNvZGVQYWNrZXRfanNfMSA9IHJlcXVpcmUoXCIuL2VuY29kZVBhY2tldC5qc1wiKTtcbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZW5jb2RlUGFja2V0X2pzXzEuZGVmYXVsdDtcbmNvbnN0IGRlY29kZVBhY2tldF9qc18xID0gcmVxdWlyZShcIi4vZGVjb2RlUGFja2V0LmpzXCIpO1xuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBkZWNvZGVQYWNrZXRfanNfMS5kZWZhdWx0O1xuY29uc3QgU0VQQVJBVE9SID0gU3RyaW5nLmZyb21DaGFyQ29kZSgzMCk7IC8vIHNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EZWxpbWl0ZXIjQVNDSUlfZGVsaW1pdGVkX3RleHRcbmNvbnN0IGVuY29kZVBheWxvYWQgPSAocGFja2V0cywgY2FsbGJhY2spID0+IHtcbiAgICAvLyBzb21lIHBhY2tldHMgbWF5IGJlIGFkZGVkIHRvIHRoZSBhcnJheSB3aGlsZSBlbmNvZGluZywgc28gdGhlIGluaXRpYWwgbGVuZ3RoIG11c3QgYmUgc2F2ZWRcbiAgICBjb25zdCBsZW5ndGggPSBwYWNrZXRzLmxlbmd0aDtcbiAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IG5ldyBBcnJheShsZW5ndGgpO1xuICAgIGxldCBjb3VudCA9IDA7XG4gICAgcGFja2V0cy5mb3JFYWNoKChwYWNrZXQsIGkpID0+IHtcbiAgICAgICAgLy8gZm9yY2UgYmFzZTY0IGVuY29kaW5nIGZvciBiaW5hcnkgcGFja2V0c1xuICAgICAgICAoMCwgZW5jb2RlUGFja2V0X2pzXzEuZGVmYXVsdCkocGFja2V0LCBmYWxzZSwgZW5jb2RlZFBhY2tldCA9PiB7XG4gICAgICAgICAgICBlbmNvZGVkUGFja2V0c1tpXSA9IGVuY29kZWRQYWNrZXQ7XG4gICAgICAgICAgICBpZiAoKytjb3VudCA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZW5jb2RlZFBhY2tldHMuam9pbihTRVBBUkFUT1IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuZXhwb3J0cy5lbmNvZGVQYXlsb2FkID0gZW5jb2RlUGF5bG9hZDtcbmNvbnN0IGRlY29kZVBheWxvYWQgPSAoZW5jb2RlZFBheWxvYWQsIGJpbmFyeVR5cGUpID0+IHtcbiAgICBjb25zdCBlbmNvZGVkUGFja2V0cyA9IGVuY29kZWRQYXlsb2FkLnNwbGl0KFNFUEFSQVRPUik7XG4gICAgY29uc3QgcGFja2V0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW5jb2RlZFBhY2tldHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZFBhY2tldCA9ICgwLCBkZWNvZGVQYWNrZXRfanNfMS5kZWZhdWx0KShlbmNvZGVkUGFja2V0c1tpXSwgYmluYXJ5VHlwZSk7XG4gICAgICAgIHBhY2tldHMucHVzaChkZWNvZGVkUGFja2V0KTtcbiAgICAgICAgaWYgKGRlY29kZWRQYWNrZXQudHlwZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFja2V0cztcbn07XG5leHBvcnRzLmRlY29kZVBheWxvYWQgPSBkZWNvZGVQYXlsb2FkO1xuZXhwb3J0cy5wcm90b2NvbCA9IDQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucHJvdG9jb2wgPSBleHBvcnRzLlRyYW5zcG9ydCA9IGV4cG9ydHMuU29ja2V0ID0gZXhwb3J0cy51U2VydmVyID0gZXhwb3J0cy5wYXJzZXIgPSBleHBvcnRzLmF0dGFjaCA9IGV4cG9ydHMubGlzdGVuID0gZXhwb3J0cy50cmFuc3BvcnRzID0gZXhwb3J0cy5TZXJ2ZXIgPSB2b2lkIDA7XG5jb25zdCBodHRwXzEgPSByZXF1aXJlKFwiaHR0cFwiKTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VydmVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzZXJ2ZXJfMS5TZXJ2ZXI7IH0gfSk7XG5jb25zdCBpbmRleF8xID0gcmVxdWlyZShcIi4vdHJhbnNwb3J0cy9pbmRleFwiKTtcbmV4cG9ydHMudHJhbnNwb3J0cyA9IGluZGV4XzEuZGVmYXVsdDtcbmNvbnN0IHBhcnNlciA9IHJlcXVpcmUoXCJlbmdpbmUuaW8tcGFyc2VyXCIpO1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG52YXIgdXNlcnZlcl8xID0gcmVxdWlyZShcIi4vdXNlcnZlclwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVTZXJ2ZXJcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHVzZXJ2ZXJfMS51U2VydmVyOyB9IH0pO1xudmFyIHNvY2tldF8xID0gcmVxdWlyZShcIi4vc29ja2V0XCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU29ja2V0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBzb2NrZXRfMS5Tb2NrZXQ7IH0gfSk7XG52YXIgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJUcmFuc3BvcnRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRyYW5zcG9ydF8xLlRyYW5zcG9ydDsgfSB9KTtcbmV4cG9ydHMucHJvdG9jb2wgPSBwYXJzZXIucHJvdG9jb2w7XG4vKipcbiAqIENyZWF0ZXMgYW4gaHR0cC5TZXJ2ZXIgZXhjbHVzaXZlbHkgdXNlZCBmb3IgV1MgdXBncmFkZXMuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IHBvcnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U2VydmVyfSB3ZWJzb2NrZXQuaW8gc2VydmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBsaXN0ZW4ocG9ydCwgb3B0aW9ucywgZm4pIHtcbiAgICBpZiAoXCJmdW5jdGlvblwiID09PSB0eXBlb2Ygb3B0aW9ucykge1xuICAgICAgICBmbiA9IG9wdGlvbnM7XG4gICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgY29uc3Qgc2VydmVyID0gKDAsIGh0dHBfMS5jcmVhdGVTZXJ2ZXIpKGZ1bmN0aW9uIChyZXEsIHJlcykge1xuICAgICAgICByZXMud3JpdGVIZWFkKDUwMSk7XG4gICAgICAgIHJlcy5lbmQoXCJOb3QgSW1wbGVtZW50ZWRcIik7XG4gICAgfSk7XG4gICAgLy8gY3JlYXRlIGVuZ2luZSBzZXJ2ZXJcbiAgICBjb25zdCBlbmdpbmUgPSBhdHRhY2goc2VydmVyLCBvcHRpb25zKTtcbiAgICBlbmdpbmUuaHR0cFNlcnZlciA9IHNlcnZlcjtcbiAgICBzZXJ2ZXIubGlzdGVuKHBvcnQsIGZuKTtcbiAgICByZXR1cm4gZW5naW5lO1xufVxuZXhwb3J0cy5saXN0ZW4gPSBsaXN0ZW47XG4vKipcbiAqIENhcHR1cmVzIHVwZ3JhZGUgcmVxdWVzdHMgZm9yIGEgaHR0cC5TZXJ2ZXIuXG4gKlxuICogQHBhcmFtIHtodHRwLlNlcnZlcn0gc2VydmVyXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICogQHJldHVybiB7U2VydmVyfSBlbmdpbmUgc2VydmVyXG4gKiBAYXBpIHB1YmxpY1xuICovXG5mdW5jdGlvbiBhdHRhY2goc2VydmVyLCBvcHRpb25zKSB7XG4gICAgY29uc3QgZW5naW5lID0gbmV3IHNlcnZlcl8xLlNlcnZlcihvcHRpb25zKTtcbiAgICBlbmdpbmUuYXR0YWNoKHNlcnZlciwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGVuZ2luZTtcbn1cbmV4cG9ydHMuYXR0YWNoID0gYXR0YWNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBpbXBvcnRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9zb2NrZXRpby9lbmdpbmUuaW8tcGFyc2VyL3RyZWUvMi4yLnhcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZXhwb3J0cy5lbmNvZGVQYXlsb2FkQXNCaW5hcnkgPSBleHBvcnRzLmRlY29kZVBheWxvYWQgPSBleHBvcnRzLmVuY29kZVBheWxvYWQgPSBleHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGV4cG9ydHMuZGVjb2RlUGFja2V0ID0gZXhwb3J0cy5lbmNvZGVCYXNlNjRQYWNrZXQgPSBleHBvcnRzLmVuY29kZVBhY2tldCA9IGV4cG9ydHMucGFja2V0cyA9IGV4cG9ydHMucHJvdG9jb2wgPSB2b2lkIDA7XG4vKipcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXG4gKi9cbnZhciB1dGY4ID0gcmVxdWlyZSgnLi91dGY4Jyk7XG4vKipcbiAqIEN1cnJlbnQgcHJvdG9jb2wgdmVyc2lvbi5cbiAqL1xuZXhwb3J0cy5wcm90b2NvbCA9IDM7XG5jb25zdCBoYXNCaW5hcnkgPSAocGFja2V0cykgPT4ge1xuICAgIGZvciAoY29uc3QgcGFja2V0IG9mIHBhY2tldHMpIHtcbiAgICAgICAgaWYgKHBhY2tldC5kYXRhIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHwgQXJyYXlCdWZmZXIuaXNWaWV3KHBhY2tldC5kYXRhKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcbi8qKlxuICogUGFja2V0IHR5cGVzLlxuICovXG5leHBvcnRzLnBhY2tldHMgPSB7XG4gICAgb3BlbjogMCAvLyBub24td3NcbiAgICAsXG4gICAgY2xvc2U6IDEgLy8gbm9uLXdzXG4gICAgLFxuICAgIHBpbmc6IDIsXG4gICAgcG9uZzogMyxcbiAgICBtZXNzYWdlOiA0LFxuICAgIHVwZ3JhZGU6IDUsXG4gICAgbm9vcDogNlxufTtcbnZhciBwYWNrZXRzbGlzdCA9IE9iamVjdC5rZXlzKGV4cG9ydHMucGFja2V0cyk7XG4vKipcbiAqIFByZW1hZGUgZXJyb3IgcGFja2V0LlxuICovXG52YXIgZXJyID0geyB0eXBlOiAnZXJyb3InLCBkYXRhOiAncGFyc2VyIGVycm9yJyB9O1xuY29uc3QgRU1QVFlfQlVGRkVSID0gQnVmZmVyLmNvbmNhdChbXSk7XG4vKipcbiAqIEVuY29kZXMgYSBwYWNrZXQuXG4gKlxuICogICAgIDxwYWNrZXQgdHlwZSBpZD4gWyA8ZGF0YT4gXVxuICpcbiAqIEV4YW1wbGU6XG4gKlxuICogICAgIDVoZWxsbyB3b3JsZFxuICogICAgIDNcbiAqICAgICA0XG4gKlxuICogQmluYXJ5IGlzIGVuY29kZWQgaW4gYW4gaWRlbnRpY2FsIHByaW5jaXBsZVxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbmNvZGVQYWNrZXQocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgdXRmOGVuY29kZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIHN1cHBvcnRzQmluYXJ5ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gc3VwcG9ydHNCaW5hcnk7XG4gICAgICAgIHN1cHBvcnRzQmluYXJ5ID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB1dGY4ZW5jb2RlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gdXRmOGVuY29kZTtcbiAgICAgICAgdXRmOGVuY29kZSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChCdWZmZXIuaXNCdWZmZXIocGFja2V0LmRhdGEpKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIocGFja2V0LCBzdXBwb3J0c0JpbmFyeSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChwYWNrZXQuZGF0YSAmJiAocGFja2V0LmRhdGEuYnVmZmVyIHx8IHBhY2tldC5kYXRhKSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHJldHVybiBlbmNvZGVCdWZmZXIoeyB0eXBlOiBwYWNrZXQudHlwZSwgZGF0YTogYXJyYXlCdWZmZXJUb0J1ZmZlcihwYWNrZXQuZGF0YSkgfSwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gU2VuZGluZyBkYXRhIGFzIGEgdXRmLTggc3RyaW5nXG4gICAgdmFyIGVuY29kZWQgPSBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIC8vIGRhdGEgZnJhZ21lbnQgaXMgb3B0aW9uYWxcbiAgICBpZiAodW5kZWZpbmVkICE9PSBwYWNrZXQuZGF0YSkge1xuICAgICAgICBlbmNvZGVkICs9IHV0ZjhlbmNvZGUgPyB1dGY4LmVuY29kZShTdHJpbmcocGFja2V0LmRhdGEpLCB7IHN0cmljdDogZmFsc2UgfSkgOiBTdHJpbmcocGFja2V0LmRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gY2FsbGJhY2soJycgKyBlbmNvZGVkKTtcbn1cbmV4cG9ydHMuZW5jb2RlUGFja2V0ID0gZW5jb2RlUGFja2V0O1xuO1xuLyoqXG4gKiBFbmNvZGUgQnVmZmVyIGRhdGFcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQnVmZmVyKHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFzdXBwb3J0c0JpbmFyeSkge1xuICAgICAgICByZXR1cm4gZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spO1xuICAgIH1cbiAgICB2YXIgZGF0YSA9IHBhY2tldC5kYXRhO1xuICAgIHZhciB0eXBlQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKDEpO1xuICAgIHR5cGVCdWZmZXJbMF0gPSBleHBvcnRzLnBhY2tldHNbcGFja2V0LnR5cGVdO1xuICAgIHJldHVybiBjYWxsYmFjayhCdWZmZXIuY29uY2F0KFt0eXBlQnVmZmVyLCBkYXRhXSkpO1xufVxuLyoqXG4gKiBFbmNvZGVzIGEgcGFja2V0IHdpdGggYmluYXJ5IGRhdGEgaW4gYSBiYXNlNjQgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCwgaGFzIGB0eXBlYCBhbmQgYGRhdGFgXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqL1xuZnVuY3Rpb24gZW5jb2RlQmFzZTY0UGFja2V0KHBhY2tldCwgY2FsbGJhY2spIHtcbiAgICB2YXIgZGF0YSA9IEJ1ZmZlci5pc0J1ZmZlcihwYWNrZXQuZGF0YSkgPyBwYWNrZXQuZGF0YSA6IGFycmF5QnVmZmVyVG9CdWZmZXIocGFja2V0LmRhdGEpO1xuICAgIHZhciBtZXNzYWdlID0gJ2InICsgZXhwb3J0cy5wYWNrZXRzW3BhY2tldC50eXBlXTtcbiAgICBtZXNzYWdlICs9IGRhdGEudG9TdHJpbmcoJ2Jhc2U2NCcpO1xuICAgIHJldHVybiBjYWxsYmFjayhtZXNzYWdlKTtcbn1cbmV4cG9ydHMuZW5jb2RlQmFzZTY0UGFja2V0ID0gZW5jb2RlQmFzZTY0UGFja2V0O1xuO1xuLyoqXG4gKiBEZWNvZGVzIGEgcGFja2V0LiBEYXRhIGFsc28gYXZhaWxhYmxlIGFzIGFuIEFycmF5QnVmZmVyIGlmIHJlcXVlc3RlZC5cbiAqXG4gKiBAcmV0dXJuIHtPYmplY3R9IHdpdGggYHR5cGVgIGFuZCBgZGF0YWAgKGlmIGFueSlcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGVQYWNrZXQoZGF0YSwgYmluYXJ5VHlwZSwgdXRmOGRlY29kZSkge1xuICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGVycjtcbiAgICB9XG4gICAgdmFyIHR5cGU7XG4gICAgLy8gU3RyaW5nIGRhdGFcbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHR5cGUgPSBkYXRhLmNoYXJBdCgwKTtcbiAgICAgICAgaWYgKHR5cGUgPT09ICdiJykge1xuICAgICAgICAgICAgcmV0dXJuIGRlY29kZUJhc2U2NFBhY2tldChkYXRhLnN1YnN0cigxKSwgYmluYXJ5VHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHV0ZjhkZWNvZGUpIHtcbiAgICAgICAgICAgIGRhdGEgPSB0cnlEZWNvZGUoZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChOdW1iZXIodHlwZSkgIT0gdHlwZSB8fCAhcGFja2V0c2xpc3RbdHlwZV0pIHtcbiAgICAgICAgICAgIHJldHVybiBlcnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGRhdGEuc3Vic3RyaW5nKDEpIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEJpbmFyeSBkYXRhXG4gICAgaWYgKGJpbmFyeVR5cGUgPT09ICdhcnJheWJ1ZmZlcicpIHtcbiAgICAgICAgLy8gd3JhcCBCdWZmZXIvQXJyYXlCdWZmZXIgZGF0YSBpbnRvIGFuIFVpbnQ4QXJyYXlcbiAgICAgICAgdmFyIGludEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YSk7XG4gICAgICAgIHR5cGUgPSBpbnRBcnJheVswXTtcbiAgICAgICAgcmV0dXJuIHsgdHlwZTogcGFja2V0c2xpc3RbdHlwZV0sIGRhdGE6IGludEFycmF5LmJ1ZmZlci5zbGljZSgxKSB9O1xuICAgIH1cbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIGRhdGEgPSBhcnJheUJ1ZmZlclRvQnVmZmVyKGRhdGEpO1xuICAgIH1cbiAgICB0eXBlID0gZGF0YVswXTtcbiAgICByZXR1cm4geyB0eXBlOiBwYWNrZXRzbGlzdFt0eXBlXSwgZGF0YTogZGF0YS5zbGljZSgxKSB9O1xufVxuZXhwb3J0cy5kZWNvZGVQYWNrZXQgPSBkZWNvZGVQYWNrZXQ7XG47XG5mdW5jdGlvbiB0cnlEZWNvZGUoZGF0YSkge1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSB1dGY4LmRlY29kZShkYXRhLCB7IHN0cmljdDogZmFsc2UgfSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4vKipcbiAqIERlY29kZXMgYSBwYWNrZXQgZW5jb2RlZCBpbiBhIGJhc2U2NCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGJhc2U2NCBlbmNvZGVkIG1lc3NhZ2VcbiAqIEByZXR1cm4ge09iamVjdH0gd2l0aCBgdHlwZWAgYW5kIGBkYXRhYCAoaWYgYW55KVxuICovXG5mdW5jdGlvbiBkZWNvZGVCYXNlNjRQYWNrZXQobXNnLCBiaW5hcnlUeXBlKSB7XG4gICAgdmFyIHR5cGUgPSBwYWNrZXRzbGlzdFttc2cuY2hhckF0KDApXTtcbiAgICB2YXIgZGF0YSA9IEJ1ZmZlci5mcm9tKG1zZy5zdWJzdHIoMSksICdiYXNlNjQnKTtcbiAgICBpZiAoYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICB2YXIgYWJ2ID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFidi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYWJ2W2ldID0gZGF0YVtpXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGRhdGEgPSBhYnYuYnVmZmVyO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiB0eXBlLCBkYXRhOiBkYXRhIH07XG59XG5leHBvcnRzLmRlY29kZUJhc2U2NFBhY2tldCA9IGRlY29kZUJhc2U2NFBhY2tldDtcbjtcbi8qKlxuICogRW5jb2RlcyBtdWx0aXBsZSBtZXNzYWdlcyAocGF5bG9hZCkuXG4gKlxuICogICAgIDxsZW5ndGg+OmRhdGFcbiAqXG4gKiBFeGFtcGxlOlxuICpcbiAqICAgICAxMTpoZWxsbyB3b3JsZDI6aGlcbiAqXG4gKiBJZiBhbnkgY29udGVudHMgYXJlIGJpbmFyeSwgdGhleSB3aWxsIGJlIGVuY29kZWQgYXMgYmFzZTY0IHN0cmluZ3MuIEJhc2U2NFxuICogZW5jb2RlZCBzdHJpbmdzIGFyZSBtYXJrZWQgd2l0aCBhIGIgYmVmb3JlIHRoZSBsZW5ndGggc3BlY2lmaWVyXG4gKlxuICogQHBhcmFtIHtBcnJheX0gcGFja2V0c1xuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGVuY29kZVBheWxvYWQocGFja2V0cywgc3VwcG9ydHNCaW5hcnksIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBzdXBwb3J0c0JpbmFyeSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBjYWxsYmFjayA9IHN1cHBvcnRzQmluYXJ5O1xuICAgICAgICBzdXBwb3J0c0JpbmFyeSA9IG51bGw7XG4gICAgfVxuICAgIGlmIChzdXBwb3J0c0JpbmFyeSAmJiBoYXNCaW5hcnkocGFja2V0cykpIHtcbiAgICAgICAgcmV0dXJuIGVuY29kZVBheWxvYWRBc0JpbmFyeShwYWNrZXRzLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghcGFja2V0cy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKCcwOicpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBlbmNvZGVPbmUocGFja2V0LCBkb25lQ2FsbGJhY2spIHtcbiAgICAgICAgZW5jb2RlUGFja2V0KHBhY2tldCwgc3VwcG9ydHNCaW5hcnksIGZhbHNlLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICAgICAgZG9uZUNhbGxiYWNrKG51bGwsIHNldExlbmd0aEhlYWRlcihtZXNzYWdlKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBtYXAocGFja2V0cywgZW5jb2RlT25lLCBmdW5jdGlvbiAoZXJyLCByZXN1bHRzKSB7XG4gICAgICAgIHJldHVybiBjYWxsYmFjayhyZXN1bHRzLmpvaW4oJycpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZW5jb2RlUGF5bG9hZCA9IGVuY29kZVBheWxvYWQ7XG47XG5mdW5jdGlvbiBzZXRMZW5ndGhIZWFkZXIobWVzc2FnZSkge1xuICAgIHJldHVybiBtZXNzYWdlLmxlbmd0aCArICc6JyArIG1lc3NhZ2U7XG59XG4vKipcbiAqIEFzeW5jIGFycmF5IG1hcCB1c2luZyBhZnRlclxuICovXG5mdW5jdGlvbiBtYXAoYXJ5LCBlYWNoLCBkb25lKSB7XG4gICAgY29uc3QgcmVzdWx0cyA9IG5ldyBBcnJheShhcnkubGVuZ3RoKTtcbiAgICBsZXQgY291bnQgPSAwO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJ5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVhY2goYXJ5W2ldLCAoZXJyb3IsIG1zZykgPT4ge1xuICAgICAgICAgICAgcmVzdWx0c1tpXSA9IG1zZztcbiAgICAgICAgICAgIGlmICgrK2NvdW50ID09PSBhcnkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgZG9uZShudWxsLCByZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxufVxuLypcbiAqIERlY29kZXMgZGF0YSB3aGVuIGEgcGF5bG9hZCBpcyBtYXliZSBleHBlY3RlZC4gUG9zc2libGUgYmluYXJ5IGNvbnRlbnRzIGFyZVxuICogZGVjb2RlZCBmcm9tIHRoZWlyIGJhc2U2NCByZXByZXNlbnRhdGlvblxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhLCBjYWxsYmFjayBtZXRob2RcbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIGRlY29kZVBheWxvYWQoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spIHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBkZWNvZGVQYXlsb2FkQXNCaW5hcnkoZGF0YSwgYmluYXJ5VHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGJpbmFyeVR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBiaW5hcnlUeXBlO1xuICAgICAgICBiaW5hcnlUeXBlID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGRhdGEgPT09ICcnKSB7XG4gICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgfVxuICAgIHZhciBsZW5ndGggPSAnJywgbiwgbXNnLCBwYWNrZXQ7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBkYXRhLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY2hyID0gZGF0YS5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjaHIgIT09ICc6Jykge1xuICAgICAgICAgICAgbGVuZ3RoICs9IGNocjtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gJycgfHwgKGxlbmd0aCAhPSAobiA9IE51bWJlcihsZW5ndGgpKSkpIHtcbiAgICAgICAgICAgIC8vIHBhcnNlciBlcnJvciAtIGlnbm9yaW5nIHBheWxvYWRcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgICAgICB9XG4gICAgICAgIG1zZyA9IGRhdGEuc3Vic3RyKGkgKyAxLCBuKTtcbiAgICAgICAgaWYgKGxlbmd0aCAhPSBtc2cubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnLmxlbmd0aCkge1xuICAgICAgICAgICAgcGFja2V0ID0gZGVjb2RlUGFja2V0KG1zZywgYmluYXJ5VHlwZSwgZmFsc2UpO1xuICAgICAgICAgICAgaWYgKGVyci50eXBlID09PSBwYWNrZXQudHlwZSAmJiBlcnIuZGF0YSA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICAvLyBwYXJzZXIgZXJyb3IgaW4gaW5kaXZpZHVhbCBwYWNrZXQgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVyciwgMCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgbW9yZSA9IGNhbGxiYWNrKHBhY2tldCwgaSArIG4sIGwpO1xuICAgICAgICAgICAgaWYgKGZhbHNlID09PSBtb3JlKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhZHZhbmNlIGN1cnNvclxuICAgICAgICBpICs9IG47XG4gICAgICAgIGxlbmd0aCA9ICcnO1xuICAgIH1cbiAgICBpZiAobGVuZ3RoICE9PSAnJykge1xuICAgICAgICAvLyBwYXJzZXIgZXJyb3IgLSBpZ25vcmluZyBwYXlsb2FkXG4gICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIsIDAsIDEpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZCA9IGRlY29kZVBheWxvYWQ7XG47XG4vKipcbiAqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhIHV0ZjguanMgZW5jb2RlZCBzdHJpbmdcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYnVmZmVyVG9TdHJpbmcoYnVmZmVyKSB7XG4gICAgdmFyIHN0ciA9ICcnO1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBzdHIgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmZXJbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gc3RyO1xufVxuLyoqXG4gKlxuICogQ29udmVydHMgYSB1dGY4LmpzIGVuY29kZWQgc3RyaW5nIHRvIGEgYnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHN0cmluZ1RvQnVmZmVyKHN0cmluZykge1xuICAgIHZhciBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoc3RyaW5nLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIGJ1Zi53cml0ZVVJbnQ4KHN0cmluZy5jaGFyQ29kZUF0KGkpLCBpKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zjtcbn1cbi8qKlxuICpcbiAqIENvbnZlcnRzIGFuIEFycmF5QnVmZmVyIHRvIGEgQnVmZmVyXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFycmF5QnVmZmVyVG9CdWZmZXIoZGF0YSkge1xuICAgIC8vIGRhdGEgaXMgZWl0aGVyIGFuIEFycmF5QnVmZmVyIG9yIEFycmF5QnVmZmVyVmlldy5cbiAgICB2YXIgbGVuZ3RoID0gZGF0YS5ieXRlTGVuZ3RoIHx8IGRhdGEubGVuZ3RoO1xuICAgIHZhciBvZmZzZXQgPSBkYXRhLmJ5dGVPZmZzZXQgfHwgMDtcbiAgICByZXR1cm4gQnVmZmVyLmZyb20oZGF0YS5idWZmZXIgfHwgZGF0YSwgb2Zmc2V0LCBsZW5ndGgpO1xufVxuLyoqXG4gKiBFbmNvZGVzIG11bHRpcGxlIG1lc3NhZ2VzIChwYXlsb2FkKSBhcyBiaW5hcnkuXG4gKlxuICogPDEgPSBiaW5hcnksIDAgPSBzdHJpbmc+PG51bWJlciBmcm9tIDAtOT48bnVtYmVyIGZyb20gMC05PlsuLi5dPG51bWJlclxuICogMjU1PjxkYXRhPlxuICpcbiAqIEV4YW1wbGU6XG4gKiAxIDMgMjU1IDEgMiAzLCBpZiB0aGUgYmluYXJ5IGNvbnRlbnRzIGFyZSBpbnRlcnByZXRlZCBhcyA4IGJpdCBpbnRlZ2Vyc1xuICpcbiAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAqIEByZXR1cm4ge0J1ZmZlcn0gZW5jb2RlZCBwYXlsb2FkXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlUGF5bG9hZEFzQmluYXJ5KHBhY2tldHMsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCFwYWNrZXRzLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soRU1QVFlfQlVGRkVSKTtcbiAgICB9XG4gICAgbWFwKHBhY2tldHMsIGVuY29kZU9uZUJpbmFyeVBhY2tldCwgZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICByZXR1cm4gY2FsbGJhY2soQnVmZmVyLmNvbmNhdChyZXN1bHRzKSk7XG4gICAgfSk7XG59XG5leHBvcnRzLmVuY29kZVBheWxvYWRBc0JpbmFyeSA9IGVuY29kZVBheWxvYWRBc0JpbmFyeTtcbjtcbmZ1bmN0aW9uIGVuY29kZU9uZUJpbmFyeVBhY2tldChwLCBkb25lQ2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBvbkJpbmFyeVBhY2tldEVuY29kZShwYWNrZXQpIHtcbiAgICAgICAgdmFyIGVuY29kaW5nTGVuZ3RoID0gJycgKyBwYWNrZXQubGVuZ3RoO1xuICAgICAgICB2YXIgc2l6ZUJ1ZmZlcjtcbiAgICAgICAgaWYgKHR5cGVvZiBwYWNrZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBzaXplQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoLmxlbmd0aCArIDIpO1xuICAgICAgICAgICAgc2l6ZUJ1ZmZlclswXSA9IDA7IC8vIGlzIGEgc3RyaW5nIChub3QgdHJ1ZSBiaW5hcnkgPSAwKVxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBlbmNvZGluZ0xlbmd0aC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHNpemVCdWZmZXJbaSArIDFdID0gcGFyc2VJbnQoZW5jb2RpbmdMZW5ndGhbaV0sIDEwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHNpemVCdWZmZXJbc2l6ZUJ1ZmZlci5sZW5ndGggLSAxXSA9IDI1NTtcbiAgICAgICAgICAgIHJldHVybiBkb25lQ2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChbc2l6ZUJ1ZmZlciwgc3RyaW5nVG9CdWZmZXIocGFja2V0KV0pKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplQnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGVuY29kaW5nTGVuZ3RoLmxlbmd0aCArIDIpO1xuICAgICAgICBzaXplQnVmZmVyWzBdID0gMTsgLy8gaXMgYmluYXJ5ICh0cnVlIGJpbmFyeSA9IDEpXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jb2RpbmdMZW5ndGgubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNpemVCdWZmZXJbaSArIDFdID0gcGFyc2VJbnQoZW5jb2RpbmdMZW5ndGhbaV0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICBzaXplQnVmZmVyW3NpemVCdWZmZXIubGVuZ3RoIC0gMV0gPSAyNTU7XG4gICAgICAgIGRvbmVDYWxsYmFjayhudWxsLCBCdWZmZXIuY29uY2F0KFtzaXplQnVmZmVyLCBwYWNrZXRdKSk7XG4gICAgfVxuICAgIGVuY29kZVBhY2tldChwLCB0cnVlLCB0cnVlLCBvbkJpbmFyeVBhY2tldEVuY29kZSk7XG59XG4vKlxuICogRGVjb2RlcyBkYXRhIHdoZW4gYSBwYXlsb2FkIGlzIG1heWJlIGV4cGVjdGVkLiBTdHJpbmdzIGFyZSBkZWNvZGVkIGJ5XG4gKiBpbnRlcnByZXRpbmcgZWFjaCBieXRlIGFzIGEga2V5IGNvZGUgZm9yIGVudHJpZXMgbWFya2VkIHRvIHN0YXJ0IHdpdGggMC4gU2VlXG4gKiBkZXNjcmlwdGlvbiBvZiBlbmNvZGVQYXlsb2FkQXNCaW5hcnlcblxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEsIGNhbGxiYWNrIG1ldGhvZFxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZGVjb2RlUGF5bG9hZEFzQmluYXJ5KGRhdGEsIGJpbmFyeVR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKHR5cGVvZiBiaW5hcnlUeXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGNhbGxiYWNrID0gYmluYXJ5VHlwZTtcbiAgICAgICAgYmluYXJ5VHlwZSA9IG51bGw7XG4gICAgfVxuICAgIHZhciBidWZmZXJUYWlsID0gZGF0YTtcbiAgICB2YXIgYnVmZmVycyA9IFtdO1xuICAgIHZhciBpO1xuICAgIHdoaWxlIChidWZmZXJUYWlsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHN0ckxlbiA9ICcnO1xuICAgICAgICB2YXIgaXNTdHJpbmcgPSBidWZmZXJUYWlsWzBdID09PSAwO1xuICAgICAgICBmb3IgKGkgPSAxOzsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnVmZmVyVGFpbFtpXSA9PT0gMjU1KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgLy8gMzEwID0gY2hhciBsZW5ndGggb2YgTnVtYmVyLk1BWF9WQUxVRVxuICAgICAgICAgICAgaWYgKHN0ckxlbi5sZW5ndGggPiAzMTApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyLCAwLCAxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0ckxlbiArPSAnJyArIGJ1ZmZlclRhaWxbaV07XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyVGFpbCA9IGJ1ZmZlclRhaWwuc2xpY2Uoc3RyTGVuLmxlbmd0aCArIDEpO1xuICAgICAgICB2YXIgbXNnTGVuZ3RoID0gcGFyc2VJbnQoc3RyTGVuLCAxMCk7XG4gICAgICAgIHZhciBtc2cgPSBidWZmZXJUYWlsLnNsaWNlKDEsIG1zZ0xlbmd0aCArIDEpO1xuICAgICAgICBpZiAoaXNTdHJpbmcpXG4gICAgICAgICAgICBtc2cgPSBidWZmZXJUb1N0cmluZyhtc2cpO1xuICAgICAgICBidWZmZXJzLnB1c2gobXNnKTtcbiAgICAgICAgYnVmZmVyVGFpbCA9IGJ1ZmZlclRhaWwuc2xpY2UobXNnTGVuZ3RoICsgMSk7XG4gICAgfVxuICAgIHZhciB0b3RhbCA9IGJ1ZmZlcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCB0b3RhbDsgaSsrKSB7XG4gICAgICAgIHZhciBidWZmZXIgPSBidWZmZXJzW2ldO1xuICAgICAgICBjYWxsYmFjayhkZWNvZGVQYWNrZXQoYnVmZmVyLCBiaW5hcnlUeXBlLCB0cnVlKSwgaSwgdG90YWwpO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVjb2RlUGF5bG9hZEFzQmluYXJ5ID0gZGVjb2RlUGF5bG9hZEFzQmluYXJ5O1xuO1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS91dGY4anMgdjIuMS4yIGJ5IEBtYXRoaWFzICovXG52YXIgc3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZTtcbi8vIFRha2VuIGZyb20gaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlXG5mdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuICAgIHZhciBvdXRwdXQgPSBbXTtcbiAgICB2YXIgY291bnRlciA9IDA7XG4gICAgdmFyIGxlbmd0aCA9IHN0cmluZy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBleHRyYTtcbiAgICB3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG4gICAgICAgIGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuICAgICAgICAgICAgZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuICAgICAgICAgICAgaWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcbiAgICAgICAgICAgICAgICAvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcbiAgICAgICAgICAgICAgICBvdXRwdXQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgY291bnRlci0tO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgb3V0cHV0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG4vLyBUYWtlbiBmcm9tIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZVxuZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgdmFyIGluZGV4ID0gLTE7XG4gICAgdmFyIHZhbHVlO1xuICAgIHZhciBvdXRwdXQgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgaWYgKHZhbHVlID4gMHhGRkZGKSB7XG4gICAgICAgICAgICB2YWx1ZSAtPSAweDEwMDAwO1xuICAgICAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG4gICAgICAgICAgICB2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5mdW5jdGlvbiBjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSB7XG4gICAgaWYgKGNvZGVQb2ludCA+PSAweEQ4MDAgJiYgY29kZVBvaW50IDw9IDB4REZGRikge1xuICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignTG9uZSBzdXJyb2dhdGUgVSsnICsgY29kZVBvaW50LnRvU3RyaW5nKDE2KS50b1VwcGVyQ2FzZSgpICtcbiAgICAgICAgICAgICAgICAnIGlzIG5vdCBhIHNjYWxhciB2YWx1ZScpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ5dGUoY29kZVBvaW50LCBzaGlmdCkge1xuICAgIHJldHVybiBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gc2hpZnQpICYgMHgzRikgfCAweDgwKTtcbn1cbmZ1bmN0aW9uIGVuY29kZUNvZGVQb2ludChjb2RlUG9pbnQsIHN0cmljdCkge1xuICAgIGlmICgoY29kZVBvaW50ICYgMHhGRkZGRkY4MCkgPT0gMCkgeyAvLyAxLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgcmV0dXJuIHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgIH1cbiAgICB2YXIgc3ltYm9sID0gJyc7XG4gICAgaWYgKChjb2RlUG9pbnQgJiAweEZGRkZGODAwKSA9PSAwKSB7IC8vIDItYnl0ZSBzZXF1ZW5jZVxuICAgICAgICBzeW1ib2wgPSBzdHJpbmdGcm9tQ2hhckNvZGUoKChjb2RlUG9pbnQgPj4gNikgJiAweDFGKSB8IDB4QzApO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkZGMDAwMCkgPT0gMCkgeyAvLyAzLWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgaWYgKCFjaGVja1NjYWxhclZhbHVlKGNvZGVQb2ludCwgc3RyaWN0KSkge1xuICAgICAgICAgICAgY29kZVBvaW50ID0gMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIHN5bWJvbCA9IHN0cmluZ0Zyb21DaGFyQ29kZSgoKGNvZGVQb2ludCA+PiAxMikgJiAweDBGKSB8IDB4RTApO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBlbHNlIGlmICgoY29kZVBvaW50ICYgMHhGRkUwMDAwMCkgPT0gMCkgeyAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICAgICAgc3ltYm9sID0gc3RyaW5nRnJvbUNoYXJDb2RlKCgoY29kZVBvaW50ID4+IDE4KSAmIDB4MDcpIHwgMHhGMCk7XG4gICAgICAgIHN5bWJvbCArPSBjcmVhdGVCeXRlKGNvZGVQb2ludCwgMTIpO1xuICAgICAgICBzeW1ib2wgKz0gY3JlYXRlQnl0ZShjb2RlUG9pbnQsIDYpO1xuICAgIH1cbiAgICBzeW1ib2wgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKChjb2RlUG9pbnQgJiAweDNGKSB8IDB4ODApO1xuICAgIHJldHVybiBzeW1ib2w7XG59XG5mdW5jdGlvbiB1dGY4ZW5jb2RlKHN0cmluZywgb3B0cykge1xuICAgIG9wdHMgPSBvcHRzIHx8IHt9O1xuICAgIHZhciBzdHJpY3QgPSBmYWxzZSAhPT0gb3B0cy5zdHJpY3Q7XG4gICAgdmFyIGNvZGVQb2ludHMgPSB1Y3MyZGVjb2RlKHN0cmluZyk7XG4gICAgdmFyIGxlbmd0aCA9IGNvZGVQb2ludHMubGVuZ3RoO1xuICAgIHZhciBpbmRleCA9IC0xO1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgdmFyIGJ5dGVTdHJpbmcgPSAnJztcbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBjb2RlUG9pbnQgPSBjb2RlUG9pbnRzW2luZGV4XTtcbiAgICAgICAgYnl0ZVN0cmluZyArPSBlbmNvZGVDb2RlUG9pbnQoY29kZVBvaW50LCBzdHJpY3QpO1xuICAgIH1cbiAgICByZXR1cm4gYnl0ZVN0cmluZztcbn1cbi8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuZnVuY3Rpb24gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKSB7XG4gICAgaWYgKGJ5dGVJbmRleCA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgYnl0ZSBpbmRleCcpO1xuICAgIH1cbiAgICB2YXIgY29udGludWF0aW9uQnl0ZSA9IGJ5dGVBcnJheVtieXRlSW5kZXhdICYgMHhGRjtcbiAgICBieXRlSW5kZXgrKztcbiAgICBpZiAoKGNvbnRpbnVhdGlvbkJ5dGUgJiAweEMwKSA9PSAweDgwKSB7XG4gICAgICAgIHJldHVybiBjb250aW51YXRpb25CeXRlICYgMHgzRjtcbiAgICB9XG4gICAgLy8gSWYgd2UgZW5kIHVwIGhlcmUsIGl04oCZcyBub3QgYSBjb250aW51YXRpb24gYnl0ZVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlJyk7XG59XG5mdW5jdGlvbiBkZWNvZGVTeW1ib2woc3RyaWN0KSB7XG4gICAgdmFyIGJ5dGUxO1xuICAgIHZhciBieXRlMjtcbiAgICB2YXIgYnl0ZTM7XG4gICAgdmFyIGJ5dGU0O1xuICAgIHZhciBjb2RlUG9pbnQ7XG4gICAgaWYgKGJ5dGVJbmRleCA+IGJ5dGVDb3VudCkge1xuICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBieXRlIGluZGV4Jyk7XG4gICAgfVxuICAgIGlmIChieXRlSW5kZXggPT0gYnl0ZUNvdW50KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gUmVhZCBmaXJzdCBieXRlXG4gICAgYnl0ZTEgPSBieXRlQXJyYXlbYnl0ZUluZGV4XSAmIDB4RkY7XG4gICAgYnl0ZUluZGV4Kys7XG4gICAgLy8gMS1ieXRlIHNlcXVlbmNlIChubyBjb250aW51YXRpb24gYnl0ZXMpXG4gICAgaWYgKChieXRlMSAmIDB4ODApID09IDApIHtcbiAgICAgICAgcmV0dXJuIGJ5dGUxO1xuICAgIH1cbiAgICAvLyAyLWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhFMCkgPT0gMHhDMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGNvZGVQb2ludCA9ICgoYnl0ZTEgJiAweDFGKSA8PCA2KSB8IGJ5dGUyO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4ODApIHtcbiAgICAgICAgICAgIHJldHVybiBjb2RlUG9pbnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignSW52YWxpZCBjb250aW51YXRpb24gYnl0ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIDMtYnl0ZSBzZXF1ZW5jZSAobWF5IGluY2x1ZGUgdW5wYWlyZWQgc3Vycm9nYXRlcylcbiAgICBpZiAoKGJ5dGUxICYgMHhGMCkgPT0gMHhFMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgY29kZVBvaW50ID0gKChieXRlMSAmIDB4MEYpIDw8IDEyKSB8IChieXRlMiA8PCA2KSB8IGJ5dGUzO1xuICAgICAgICBpZiAoY29kZVBvaW50ID49IDB4MDgwMCkge1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrU2NhbGFyVmFsdWUoY29kZVBvaW50LCBzdHJpY3QpID8gY29kZVBvaW50IDogMHhGRkZEO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0ludmFsaWQgY29udGludWF0aW9uIGJ5dGUnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyA0LWJ5dGUgc2VxdWVuY2VcbiAgICBpZiAoKGJ5dGUxICYgMHhGOCkgPT0gMHhGMCkge1xuICAgICAgICBieXRlMiA9IHJlYWRDb250aW51YXRpb25CeXRlKCk7XG4gICAgICAgIGJ5dGUzID0gcmVhZENvbnRpbnVhdGlvbkJ5dGUoKTtcbiAgICAgICAgYnl0ZTQgPSByZWFkQ29udGludWF0aW9uQnl0ZSgpO1xuICAgICAgICBjb2RlUG9pbnQgPSAoKGJ5dGUxICYgMHgwNykgPDwgMHgxMikgfCAoYnl0ZTIgPDwgMHgwQykgfFxuICAgICAgICAgICAgKGJ5dGUzIDw8IDB4MDYpIHwgYnl0ZTQ7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPj0gMHgwMTAwMDAgJiYgY29kZVBvaW50IDw9IDB4MTBGRkZGKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZVBvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHRocm93IEVycm9yKCdJbnZhbGlkIFVURi04IGRldGVjdGVkJyk7XG59XG52YXIgYnl0ZUFycmF5O1xudmFyIGJ5dGVDb3VudDtcbnZhciBieXRlSW5kZXg7XG5mdW5jdGlvbiB1dGY4ZGVjb2RlKGJ5dGVTdHJpbmcsIG9wdHMpIHtcbiAgICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgICB2YXIgc3RyaWN0ID0gZmFsc2UgIT09IG9wdHMuc3RyaWN0O1xuICAgIGJ5dGVBcnJheSA9IHVjczJkZWNvZGUoYnl0ZVN0cmluZyk7XG4gICAgYnl0ZUNvdW50ID0gYnl0ZUFycmF5Lmxlbmd0aDtcbiAgICBieXRlSW5kZXggPSAwO1xuICAgIHZhciBjb2RlUG9pbnRzID0gW107XG4gICAgdmFyIHRtcDtcbiAgICB3aGlsZSAoKHRtcCA9IGRlY29kZVN5bWJvbChzdHJpY3QpKSAhPT0gZmFsc2UpIHtcbiAgICAgICAgY29kZVBvaW50cy5wdXNoKHRtcCk7XG4gICAgfVxuICAgIHJldHVybiB1Y3MyZW5jb2RlKGNvZGVQb2ludHMpO1xufVxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgdmVyc2lvbjogJzIuMS4yJyxcbiAgICBlbmNvZGU6IHV0ZjhlbmNvZGUsXG4gICAgZGVjb2RlOiB1dGY4ZGVjb2RlXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlcnZlciA9IGV4cG9ydHMuQmFzZVNlcnZlciA9IHZvaWQgMDtcbmNvbnN0IHFzID0gcmVxdWlyZShcInF1ZXJ5c3RyaW5nXCIpO1xuY29uc3QgdXJsXzEgPSByZXF1aXJlKFwidXJsXCIpO1xuY29uc3QgYmFzZTY0aWQgPSByZXF1aXJlKFwiYmFzZTY0aWRcIik7XG5jb25zdCB0cmFuc3BvcnRzXzEgPSByZXF1aXJlKFwiLi90cmFuc3BvcnRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgY29va2llXzEgPSByZXF1aXJlKFwiY29va2llXCIpO1xuY29uc3Qgd3NfMSA9IHJlcXVpcmUoXCJ3c1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJlbmdpbmVcIik7XG5jbGFzcyBCYXNlU2VydmVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBTZXJ2ZXIgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0cyAtIG9wdGlvbnNcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLmNsaWVudHMgPSB7fTtcbiAgICAgICAgdGhpcy5jbGllbnRzQ291bnQgPSAwO1xuICAgICAgICB0aGlzLm9wdHMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgICAgIHdzRW5naW5lOiB3c18xLlNlcnZlcixcbiAgICAgICAgICAgIHBpbmdUaW1lb3V0OiAyMDAwMCxcbiAgICAgICAgICAgIHBpbmdJbnRlcnZhbDogMjUwMDAsXG4gICAgICAgICAgICB1cGdyYWRlVGltZW91dDogMTAwMDAsXG4gICAgICAgICAgICBtYXhIdHRwQnVmZmVyU2l6ZTogMWU2LFxuICAgICAgICAgICAgdHJhbnNwb3J0czogT2JqZWN0LmtleXModHJhbnNwb3J0c18xLmRlZmF1bHQpLFxuICAgICAgICAgICAgYWxsb3dVcGdyYWRlczogdHJ1ZSxcbiAgICAgICAgICAgIGh0dHBDb21wcmVzc2lvbjoge1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvcnM6IGZhbHNlLFxuICAgICAgICAgICAgYWxsb3dFSU8zOiBmYWxzZVxuICAgICAgICB9LCBvcHRzKTtcbiAgICAgICAgaWYgKG9wdHMuY29va2llKSB7XG4gICAgICAgICAgICB0aGlzLm9wdHMuY29va2llID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgICAgICAgICAgbmFtZTogXCJpb1wiLFxuICAgICAgICAgICAgICAgIHBhdGg6IFwiL1wiLFxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBodHRwT25seTogb3B0cy5jb29raWUucGF0aCAhPT0gZmFsc2UsXG4gICAgICAgICAgICAgICAgc2FtZVNpdGU6IFwibGF4XCJcbiAgICAgICAgICAgIH0sIG9wdHMuY29va2llKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRzLmNvcnMpIHtcbiAgICAgICAgICAgIHRoaXMuY29yc01pZGRsZXdhcmUgPSByZXF1aXJlKFwiY29yc1wiKSh0aGlzLm9wdHMuY29ycyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICAgICAgICAgIHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIHRocmVzaG9sZDogMTAyNFxuICAgICAgICAgICAgfSwgb3B0cy5wZXJNZXNzYWdlRGVmbGF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pbml0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGF2YWlsYWJsZSB0cmFuc3BvcnRzIGZvciB1cGdyYWRlIGdpdmVuIGEgY2VydGFpbiB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIHVwZ3JhZGVzKHRyYW5zcG9ydCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0cy5hbGxvd1VwZ3JhZGVzKVxuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICByZXR1cm4gdHJhbnNwb3J0c18xLmRlZmF1bHRbdHJhbnNwb3J0XS51cGdyYWRlc1RvIHx8IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBWZXJpZmllcyBhIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfVxuICAgICAqIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIHJlcXVlc3QgaXMgdmFsaWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICB2ZXJpZnkocmVxLCB1cGdyYWRlLCBmbikge1xuICAgICAgICAvLyB0cmFuc3BvcnQgY2hlY2tcbiAgICAgICAgY29uc3QgdHJhbnNwb3J0ID0gcmVxLl9xdWVyeS50cmFuc3BvcnQ7XG4gICAgICAgIGlmICghfnRoaXMub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodHJhbnNwb3J0KSkge1xuICAgICAgICAgICAgZGVidWcoJ3Vua25vd24gdHJhbnNwb3J0IFwiJXNcIicsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5VTktOT1dOX1RSQU5TUE9SVCwgeyB0cmFuc3BvcnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gJ09yaWdpbicgaGVhZGVyIGNoZWNrXG4gICAgICAgIGNvbnN0IGlzT3JpZ2luSW52YWxpZCA9IGNoZWNrSW52YWxpZEhlYWRlckNoYXIocmVxLmhlYWRlcnMub3JpZ2luKTtcbiAgICAgICAgaWYgKGlzT3JpZ2luSW52YWxpZCkge1xuICAgICAgICAgICAgY29uc3Qgb3JpZ2luID0gcmVxLmhlYWRlcnMub3JpZ2luO1xuICAgICAgICAgICAgcmVxLmhlYWRlcnMub3JpZ2luID0gbnVsbDtcbiAgICAgICAgICAgIGRlYnVnKFwib3JpZ2luIGhlYWRlciBpbnZhbGlkXCIpO1xuICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1QsIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcIklOVkFMSURfT1JJR0lOXCIsXG4gICAgICAgICAgICAgICAgb3JpZ2luXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBzaWQgY2hlY2tcbiAgICAgICAgY29uc3Qgc2lkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgIGlmIChzaWQpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRzLmhhc093blByb3BlcnR5KHNpZCkpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZygndW5rbm93biBzaWQgXCIlc1wiJywgc2lkKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5VTktOT1dOX1NJRCwge1xuICAgICAgICAgICAgICAgICAgICBzaWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzVHJhbnNwb3J0ID0gdGhpcy5jbGllbnRzW3NpZF0udHJhbnNwb3J0Lm5hbWU7XG4gICAgICAgICAgICBpZiAoIXVwZ3JhZGUgJiYgcHJldmlvdXNUcmFuc3BvcnQgIT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiYmFkIHJlcXVlc3Q6IHVuZXhwZWN0ZWQgdHJhbnNwb3J0IHdpdGhvdXQgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCwge1xuICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIlRSQU5TUE9SVF9NSVNNQVRDSFwiLFxuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQsXG4gICAgICAgICAgICAgICAgICAgIHByZXZpb3VzVHJhbnNwb3J0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBoYW5kc2hha2UgaXMgR0VUIG9ubHlcbiAgICAgICAgICAgIGlmIChcIkdFVFwiICE9PSByZXEubWV0aG9kKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKFNlcnZlci5lcnJvcnMuQkFEX0hBTkRTSEFLRV9NRVRIT0QsIHtcbiAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiByZXEubWV0aG9kXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJhbnNwb3J0ID09PSBcIndlYnNvY2tldFwiICYmICF1cGdyYWRlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJpbnZhbGlkIHRyYW5zcG9ydCB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULCB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IFwiVFJBTlNQT1JUX0hBTkRTSEFLRV9FUlJPUlwiXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMub3B0cy5hbGxvd1JlcXVlc3QpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vcHRzLmFsbG93UmVxdWVzdChyZXEsIChtZXNzYWdlLCBzdWNjZXNzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihTZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm4oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZuKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZyBhbGwgb3BlbiBjbGllbnRzXCIpO1xuICAgICAgICBmb3IgKGxldCBpIGluIHRoaXMuY2xpZW50cykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50cy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tpXS5jbG9zZSh0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFudXAoKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIGdlbmVyYXRlIGEgc29ja2V0IGlkLlxuICAgICAqIE92ZXJ3cml0ZSB0aGlzIG1ldGhvZCB0byBnZW5lcmF0ZSB5b3VyIGN1c3RvbSBzb2NrZXQgaWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSByZXF1ZXN0IG9iamVjdFxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZ2VuZXJhdGVJZChyZXEpIHtcbiAgICAgICAgcmV0dXJuIGJhc2U2NGlkLmdlbmVyYXRlSWQoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZHNoYWtlcyBhIG5ldyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gdHJhbnNwb3J0IG5hbWVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcmVxdWVzdCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjbG9zZUNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgYXN5bmMgaGFuZHNoYWtlKHRyYW5zcG9ydE5hbWUsIHJlcSwgY2xvc2VDb25uZWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IHByb3RvY29sID0gcmVxLl9xdWVyeS5FSU8gPT09IFwiNFwiID8gNCA6IDM7IC8vIDNyZCByZXZpc2lvbiBieSBkZWZhdWx0XG4gICAgICAgIGlmIChwcm90b2NvbCA9PT0gMyAmJiAhdGhpcy5vcHRzLmFsbG93RUlPMykge1xuICAgICAgICAgICAgZGVidWcoXCJ1bnN1cHBvcnRlZCBwcm90b2NvbCB2ZXJzaW9uXCIpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiY29ubmVjdGlvbl9lcnJvclwiLCB7XG4gICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgIGNvZGU6IFNlcnZlci5lcnJvcnMuVU5TVVBQT1JURURfUFJPVE9DT0xfVkVSU0lPTixcbiAgICAgICAgICAgICAgICBtZXNzYWdlOiBTZXJ2ZXIuZXJyb3JNZXNzYWdlc1tTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT05dLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsb3NlQ29ubmVjdGlvbihTZXJ2ZXIuZXJyb3JzLlVOU1VQUE9SVEVEX1BST1RPQ09MX1ZFUlNJT04pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxldCBpZDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlkID0gYXdhaXQgdGhpcy5nZW5lcmF0ZUlkKHJlcSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiZXJyb3Igd2hpbGUgZ2VuZXJhdGluZyBhbiBpZFwiKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJJRF9HRU5FUkFUSU9OX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoJ2hhbmRzaGFraW5nIGNsaWVudCBcIiVzXCInLCBpZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQodHJhbnNwb3J0TmFtZSwgcmVxKTtcbiAgICAgICAgICAgIGlmIChcInBvbGxpbmdcIiA9PT0gdHJhbnNwb3J0TmFtZSkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5tYXhIdHRwQnVmZmVyU2l6ZSA9IHRoaXMub3B0cy5tYXhIdHRwQnVmZmVyU2l6ZTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuaHR0cENvbXByZXNzaW9uID0gdGhpcy5vcHRzLmh0dHBDb21wcmVzc2lvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFwid2Vic29ja2V0XCIgPT09IHRyYW5zcG9ydE5hbWUpIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQucGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLm9wdHMucGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeSAmJiByZXEuX3F1ZXJ5LmI2NCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeSA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnN1cHBvcnRzQmluYXJ5ID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgZGVidWcoJ2Vycm9yIGhhbmRzaGFraW5nIHRvIHRyYW5zcG9ydCBcIiVzXCInLCB0cmFuc3BvcnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgIHJlcSxcbiAgICAgICAgICAgICAgICBjb2RlOiBTZXJ2ZXIuZXJyb3JzLkJBRF9SRVFVRVNULFxuICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW1NlcnZlci5lcnJvcnMuQkFEX1JFUVVFU1RdLFxuICAgICAgICAgICAgICAgIGNvbnRleHQ6IHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogXCJUUkFOU1BPUlRfSEFORFNIQUtFX0VSUk9SXCIsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjbG9zZUNvbm5lY3Rpb24oU2VydmVyLmVycm9ycy5CQURfUkVRVUVTVCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc29ja2V0ID0gbmV3IHNvY2tldF8xLlNvY2tldChpZCwgdGhpcywgdHJhbnNwb3J0LCByZXEsIHByb3RvY29sKTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFwiaGVhZGVyc1wiLCAoaGVhZGVycywgcmVxKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0luaXRpYWxSZXF1ZXN0ID0gIXJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAgICAgaWYgKGlzSW5pdGlhbFJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRzLmNvb2tpZSkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzW1wiU2V0LUNvb2tpZVwiXSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgICAgICgwLCBjb29raWVfMS5zZXJpYWxpemUpKHRoaXMub3B0cy5jb29raWUubmFtZSwgaWQsIHRoaXMub3B0cy5jb29raWUpXG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImluaXRpYWxfaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICB0aGlzLmNsaWVudHNbaWRdID0gc29ja2V0O1xuICAgICAgICB0aGlzLmNsaWVudHNDb3VudCsrO1xuICAgICAgICBzb2NrZXQub25jZShcImNsb3NlXCIsICgpID0+IHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgdGhpcy5jbGllbnRzQ291bnQtLTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgICAgcmV0dXJuIHRyYW5zcG9ydDtcbiAgICB9XG59XG5leHBvcnRzLkJhc2VTZXJ2ZXIgPSBCYXNlU2VydmVyO1xuLyoqXG4gKiBQcm90b2NvbCBlcnJvcnMgbWFwcGluZ3MuXG4gKi9cbkJhc2VTZXJ2ZXIuZXJyb3JzID0ge1xuICAgIFVOS05PV05fVFJBTlNQT1JUOiAwLFxuICAgIFVOS05PV05fU0lEOiAxLFxuICAgIEJBRF9IQU5EU0hBS0VfTUVUSE9EOiAyLFxuICAgIEJBRF9SRVFVRVNUOiAzLFxuICAgIEZPUkJJRERFTjogNCxcbiAgICBVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OOiA1XG59O1xuQmFzZVNlcnZlci5lcnJvck1lc3NhZ2VzID0ge1xuICAgIDA6IFwiVHJhbnNwb3J0IHVua25vd25cIixcbiAgICAxOiBcIlNlc3Npb24gSUQgdW5rbm93blwiLFxuICAgIDI6IFwiQmFkIGhhbmRzaGFrZSBtZXRob2RcIixcbiAgICAzOiBcIkJhZCByZXF1ZXN0XCIsXG4gICAgNDogXCJGb3JiaWRkZW5cIixcbiAgICA1OiBcIlVuc3VwcG9ydGVkIHByb3RvY29sIHZlcnNpb25cIlxufTtcbmNsYXNzIFNlcnZlciBleHRlbmRzIEJhc2VTZXJ2ZXIge1xuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemUgd2Vic29ja2V0IHNlcnZlclxuICAgICAqXG4gICAgICogQGFwaSBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBpbml0KCkge1xuICAgICAgICBpZiAoIX50aGlzLm9wdHMudHJhbnNwb3J0cy5pbmRleE9mKFwid2Vic29ja2V0XCIpKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy53cylcbiAgICAgICAgICAgIHRoaXMud3MuY2xvc2UoKTtcbiAgICAgICAgdGhpcy53cyA9IG5ldyB0aGlzLm9wdHMud3NFbmdpbmUoe1xuICAgICAgICAgICAgbm9TZXJ2ZXI6IHRydWUsXG4gICAgICAgICAgICBjbGllbnRUcmFja2luZzogZmFsc2UsXG4gICAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZTogdGhpcy5vcHRzLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICAgICAgbWF4UGF5bG9hZDogdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodHlwZW9mIHRoaXMud3Mub24gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgdGhpcy53cy5vbihcImhlYWRlcnNcIiwgKGhlYWRlcnNBcnJheSwgcmVxKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gbm90ZTogJ3dzJyB1c2VzIGFuIGFycmF5IG9mIGhlYWRlcnMsIHdoaWxlIEVuZ2luZS5JTyB1c2VzIGFuIG9iamVjdCAocmVzcG9uc2Uud3JpdGVIZWFkKCkgYWNjZXB0cyBib3RoIGZvcm1hdHMpXG4gICAgICAgICAgICAgICAgLy8gd2UgY291bGQgYWxzbyB0cnkgdG8gcGFyc2UgdGhlIGFycmF5IGFuZCB0aGVuIHN5bmMgdGhlIHZhbHVlcywgYnV0IHRoYXQgd2lsbCBiZSBlcnJvci1wcm9uZVxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZGl0aW9uYWxIZWFkZXJzID0ge307XG4gICAgICAgICAgICAgICAgY29uc3QgaXNJbml0aWFsUmVxdWVzdCA9ICFyZXEuX3F1ZXJ5LnNpZDtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbml0aWFsUmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJpbml0aWFsX2hlYWRlcnNcIiwgYWRkaXRpb25hbEhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgYWRkaXRpb25hbEhlYWRlcnMsIHJlcSk7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoYWRkaXRpb25hbEhlYWRlcnMpLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaGVhZGVyc0FycmF5LnB1c2goYCR7a2V5fTogJHthZGRpdGlvbmFsSGVhZGVyc1trZXldfWApO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2xlYW51cCgpIHtcbiAgICAgICAgaWYgKHRoaXMud3MpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY2xvc2luZyB3ZWJTb2NrZXRTZXJ2ZXJcIik7XG4gICAgICAgICAgICB0aGlzLndzLmNsb3NlKCk7XG4gICAgICAgICAgICAvLyBkb24ndCBkZWxldGUgdGhpcy53cyBiZWNhdXNlIGl0IGNhbiBiZSB1c2VkIGFnYWluIGlmIHRoZSBodHRwIHNlcnZlciBzdGFydHMgbGlzdGVuaW5nIGFnYWluXG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJlcGFyZXMgYSByZXF1ZXN0IGJ5IHByb2Nlc3NpbmcgdGhlIHF1ZXJ5IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHByZXBhcmUocmVxKSB7XG4gICAgICAgIC8vIHRyeSB0byBsZXZlcmFnZSBwcmUtZXhpc3RpbmcgYHJlcS5fcXVlcnlgIChlLmc6IGZyb20gY29ubmVjdClcbiAgICAgICAgaWYgKCFyZXEuX3F1ZXJ5KSB7XG4gICAgICAgICAgICByZXEuX3F1ZXJ5ID0gfnJlcS51cmwuaW5kZXhPZihcIj9cIikgPyBxcy5wYXJzZSgoMCwgdXJsXzEucGFyc2UpKHJlcS51cmwpLnF1ZXJ5KSA6IHt9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNyZWF0ZVRyYW5zcG9ydCh0cmFuc3BvcnROYW1lLCByZXEpIHtcbiAgICAgICAgcmV0dXJuIG5ldyB0cmFuc3BvcnRzXzEuZGVmYXVsdFt0cmFuc3BvcnROYW1lXShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIEVuZ2luZS5JTyBIVFRQIHJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtodHRwLlNlcnZlclJlc3BvbnNlfGh0dHAuT3V0Z29pbmdNZXNzYWdlfSByZXNwb25zZVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgaGFuZGxlUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBkZWJ1ZygnaGFuZGxpbmcgXCIlc1wiIGh0dHAgcmVxdWVzdCBcIiVzXCInLCByZXEubWV0aG9kLCByZXEudXJsKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSk7XG4gICAgICAgIHJlcS5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyb3JDb2RlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVxLl9xdWVyeS5zaWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNldHRpbmcgbmV3IHJlcXVlc3QgZm9yIGV4aXN0aW5nIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsaWVudHNbcmVxLl9xdWVyeS5zaWRdLnRyYW5zcG9ydC5vblJlcXVlc3QocmVxKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNsb3NlQ29ubmVjdGlvbiA9IChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4gYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLmNvcnNNaWRkbGV3YXJlKSB7XG4gICAgICAgICAgICB0aGlzLmNvcnNNaWRkbGV3YXJlLmNhbGwobnVsbCwgcmVxLCByZXMsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMudmVyaWZ5KHJlcSwgZmFsc2UsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIEVuZ2luZS5JTyBIVFRQIFVwZ3JhZGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIHVwZ3JhZGVIZWFkKSB7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEpO1xuICAgICAgICB0aGlzLnZlcmlmeShyZXEsIHRydWUsIChlcnJvckNvZGUsIGVycm9yQ29udGV4dCkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycm9yQ29kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhlYWQgPSBCdWZmZXIuZnJvbSh1cGdyYWRlSGVhZCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm9kZS9uby1kZXByZWNhdGVkLWFwaVxuICAgICAgICAgICAgdXBncmFkZUhlYWQgPSBudWxsO1xuICAgICAgICAgICAgLy8gZGVsZWdhdGUgdG8gd3NcbiAgICAgICAgICAgIHRoaXMud3MuaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgd2Vic29ja2V0ID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uV2ViU29ja2V0KHJlcSwgc29ja2V0LCB3ZWJzb2NrZXQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiBhIHdzLmlvIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3dzLlNvY2tldH0gd2Vic29ja2V0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25XZWJTb2NrZXQocmVxLCBzb2NrZXQsIHdlYnNvY2tldCkge1xuICAgICAgICB3ZWJzb2NrZXQub24oXCJlcnJvclwiLCBvblVwZ3JhZGVFcnJvcik7XG4gICAgICAgIGlmICh0cmFuc3BvcnRzXzEuZGVmYXVsdFtyZXEuX3F1ZXJ5LnRyYW5zcG9ydF0gIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICAgICAgIXRyYW5zcG9ydHNfMS5kZWZhdWx0W3JlcS5fcXVlcnkudHJhbnNwb3J0XS5wcm90b3R5cGUuaGFuZGxlc1VwZ3JhZGVzKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBkb2VzbnQgaGFuZGxlIHVwZ3JhZGVkIHJlcXVlc3RzXCIpO1xuICAgICAgICAgICAgd2Vic29ja2V0LmNsb3NlKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLy8gZ2V0IGNsaWVudCBpZFxuICAgICAgICBjb25zdCBpZCA9IHJlcS5fcXVlcnkuc2lkO1xuICAgICAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSB3cy5Tb2NrZXRcbiAgICAgICAgcmVxLndlYnNvY2tldCA9IHdlYnNvY2tldDtcbiAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNsaWVudHNbaWRdO1xuICAgICAgICAgICAgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYXMgYWxyZWFkeSBiZWVuIHRyeWluZyB0byB1cGdyYWRlXCIpO1xuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY2xpZW50LnVwZ3JhZGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFkIGFscmVhZHkgYmVlbiB1cGdyYWRlZFwiKTtcbiAgICAgICAgICAgICAgICB3ZWJzb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAvLyB0cmFuc3BvcnQgZXJyb3IgaGFuZGxpbmcgdGFrZXMgb3ZlclxuICAgICAgICAgICAgICAgIHdlYnNvY2tldC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uVXBncmFkZUVycm9yKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSB0aGlzLmNyZWF0ZVRyYW5zcG9ydChyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxKTtcbiAgICAgICAgICAgICAgICBpZiAocmVxLl9xdWVyeSAmJiByZXEuX3F1ZXJ5LmI2NCkge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc3VwcG9ydHNCaW5hcnkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zdXBwb3J0c0JpbmFyeSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5wZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMub3B0cy5wZXJNZXNzYWdlRGVmbGF0ZTtcbiAgICAgICAgICAgICAgICBjbGllbnQubWF5YmVVcGdyYWRlKHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBjbG9zZUNvbm5lY3Rpb24gPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IGFib3J0VXBncmFkZShzb2NrZXQsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgIHRoaXMuaGFuZHNoYWtlKHJlcS5fcXVlcnkudHJhbnNwb3J0LCByZXEsIGNsb3NlQ29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gb25VcGdyYWRlRXJyb3IoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIndlYnNvY2tldCBlcnJvciBiZWZvcmUgdXBncmFkZVwiKTtcbiAgICAgICAgICAgIC8vIHdlYnNvY2tldC5jbG9zZSgpIG5vdCBuZWVkZWRcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYXB0dXJlcyB1cGdyYWRlIHJlcXVlc3RzIGZvciBhIGh0dHAuU2VydmVyLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLlNlcnZlcn0gc2VydmVyXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGF0dGFjaChzZXJ2ZXIsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBsZXQgcGF0aCA9IChvcHRpb25zLnBhdGggfHwgXCIvZW5naW5lLmlvXCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZGVzdHJveVVwZ3JhZGVUaW1lb3V0ID0gb3B0aW9ucy5kZXN0cm95VXBncmFkZVRpbWVvdXQgfHwgMTAwMDtcbiAgICAgICAgLy8gbm9ybWFsaXplIHBhdGhcbiAgICAgICAgcGF0aCArPSBcIi9cIjtcbiAgICAgICAgZnVuY3Rpb24gY2hlY2socmVxKSB7XG4gICAgICAgICAgICByZXR1cm4gcGF0aCA9PT0gcmVxLnVybC5zdWJzdHIoMCwgcGF0aC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNhY2hlIGFuZCBjbGVhbiB1cCBsaXN0ZW5lcnNcbiAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gc2VydmVyLmxpc3RlbmVycyhcInJlcXVlc3RcIikuc2xpY2UoMCk7XG4gICAgICAgIHNlcnZlci5yZW1vdmVBbGxMaXN0ZW5lcnMoXCJyZXF1ZXN0XCIpO1xuICAgICAgICBzZXJ2ZXIub24oXCJjbG9zZVwiLCB0aGlzLmNsb3NlLmJpbmQodGhpcykpO1xuICAgICAgICBzZXJ2ZXIub24oXCJsaXN0ZW5pbmdcIiwgdGhpcy5pbml0LmJpbmQodGhpcykpO1xuICAgICAgICAvLyBhZGQgcmVxdWVzdCBoYW5kbGVyXG4gICAgICAgIHNlcnZlci5vbihcInJlcXVlc3RcIiwgKHJlcSwgcmVzKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKCdpbnRlcmNlcHRpbmcgcmVxdWVzdCBmb3IgcGF0aCBcIiVzXCInLCBwYXRoKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlcXVlc3QocmVxLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlcnZlciwgcmVxLCByZXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh+dGhpcy5vcHRzLnRyYW5zcG9ydHMuaW5kZXhPZihcIndlYnNvY2tldFwiKSkge1xuICAgICAgICAgICAgc2VydmVyLm9uKFwidXBncmFkZVwiLCAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY2hlY2socmVxKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChmYWxzZSAhPT0gb3B0aW9ucy5kZXN0cm95VXBncmFkZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBkZWZhdWx0IG5vZGUgYmVoYXZpb3IgaXMgdG8gZGlzY29ubmVjdCB3aGVuIG5vIGhhbmRsZXJzXG4gICAgICAgICAgICAgICAgICAgIC8vIGJ1dCBieSBhZGRpbmcgYSBoYW5kbGVyLCB3ZSBwcmV2ZW50IHRoYXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5kIGlmIG5vIGVpbyB0aGluZyBoYW5kbGVzIHRoZSB1cGdyYWRlXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZW4gdGhlIHNvY2tldCBuZWVkcyB0byBkaWUhXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNvY2tldC53cml0YWJsZSAmJiBzb2NrZXQuYnl0ZXNXcml0dGVuIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc29ja2V0LmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LCBkZXN0cm95VXBncmFkZVRpbWVvdXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIENsb3NlIHRoZSBIVFRQIGxvbmctcG9sbGluZyByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHJlcyAtIHRoZSByZXNwb25zZSBvYmplY3RcbiAqIEBwYXJhbSBlcnJvckNvZGUgLSB0aGUgZXJyb3IgY29kZVxuICogQHBhcmFtIGVycm9yQ29udGV4dCAtIGFkZGl0aW9uYWwgZXJyb3IgY29udGV4dFxuICpcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCkge1xuICAgIGNvbnN0IHN0YXR1c0NvZGUgPSBlcnJvckNvZGUgPT09IFNlcnZlci5lcnJvcnMuRk9SQklEREVOID8gNDAzIDogNDAwO1xuICAgIGNvbnN0IG1lc3NhZ2UgPSBlcnJvckNvbnRleHQgJiYgZXJyb3JDb250ZXh0Lm1lc3NhZ2VcbiAgICAgICAgPyBlcnJvckNvbnRleHQubWVzc2FnZVxuICAgICAgICA6IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgcmVzLndyaXRlSGVhZChzdGF0dXNDb2RlLCB7IFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiIH0pO1xuICAgIHJlcy5lbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgIG1lc3NhZ2VcbiAgICB9KSk7XG59XG4vKipcbiAqIENsb3NlIHRoZSBXZWJTb2NrZXQgY29ubmVjdGlvblxuICpcbiAqIEBwYXJhbSB7bmV0LlNvY2tldH0gc29ja2V0XG4gKiBAcGFyYW0ge3N0cmluZ30gZXJyb3JDb2RlIC0gdGhlIGVycm9yIGNvZGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBlcnJvckNvbnRleHQgLSBhZGRpdGlvbmFsIGVycm9yIGNvbnRleHRcbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRVcGdyYWRlKHNvY2tldCwgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQgPSB7fSkge1xuICAgIHNvY2tldC5vbihcImVycm9yXCIsICgpID0+IHtcbiAgICAgICAgZGVidWcoXCJpZ25vcmluZyBlcnJvciBmcm9tIGNsb3NlZCBjb25uZWN0aW9uXCIpO1xuICAgIH0pO1xuICAgIGlmIChzb2NrZXQud3JpdGFibGUpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGVycm9yQ29udGV4dC5tZXNzYWdlIHx8IFNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKG1lc3NhZ2UpO1xuICAgICAgICBzb2NrZXQud3JpdGUoXCJIVFRQLzEuMSA0MDAgQmFkIFJlcXVlc3RcXHJcXG5cIiArXG4gICAgICAgICAgICBcIkNvbm5lY3Rpb246IGNsb3NlXFxyXFxuXCIgK1xuICAgICAgICAgICAgXCJDb250ZW50LXR5cGU6IHRleHQvaHRtbFxcclxcblwiICtcbiAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGg6IFwiICtcbiAgICAgICAgICAgIGxlbmd0aCArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgbWVzc2FnZSk7XG4gICAgfVxuICAgIHNvY2tldC5kZXN0cm95KCk7XG59XG4vKiBlc2xpbnQtZGlzYWJsZSAqL1xuLyoqXG4gKiBGcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3Y4LjQuMC9saWIvX2h0dHBfY29tbW9uLmpzI0wzMDMtTDM1NFxuICpcbiAqIFRydWUgaWYgdmFsIGNvbnRhaW5zIGFuIGludmFsaWQgZmllbGQtdmNoYXJcbiAqICBmaWVsZC12YWx1ZSAgICA9ICooIGZpZWxkLWNvbnRlbnQgLyBvYnMtZm9sZCApXG4gKiAgZmllbGQtY29udGVudCAgPSBmaWVsZC12Y2hhciBbIDEqKCBTUCAvIEhUQUIgKSBmaWVsZC12Y2hhciBdXG4gKiAgZmllbGQtdmNoYXIgICAgPSBWQ0hBUiAvIG9icy10ZXh0XG4gKlxuICogY2hlY2tJbnZhbGlkSGVhZGVyQ2hhcigpIGlzIGN1cnJlbnRseSBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUgYnkgdjgsXG4gKiBzbyB0YWtlIGNhcmUgd2hlbiBtYWtpbmcgY2hhbmdlcyB0byB0aGUgaW1wbGVtZW50YXRpb24gc28gdGhhdCB0aGUgc291cmNlXG4gKiBjb2RlIHNpemUgZG9lcyBub3QgZXhjZWVkIHY4J3MgZGVmYXVsdCBtYXhfaW5saW5lZF9zb3VyY2Vfc2l6ZSBzZXR0aW5nLlxuICoqL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB2YWxpZEhkckNoYXJzID0gW1xuICAgIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDEsIDAsIDAsIDAsIDAsIDAsIDAsXG4gICAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMCxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsXG4gICAgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSxcbiAgICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLFxuICAgIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEgLy8gLi4uIDI1NVxuXTtcbmZ1bmN0aW9uIGNoZWNrSW52YWxpZEhlYWRlckNoYXIodmFsKSB7XG4gICAgdmFsICs9IFwiXCI7XG4gICAgaWYgKHZhbC5sZW5ndGggPCAxKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDApXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDAsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMCkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCAyKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDEpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDEsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMSkpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCAzKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDIpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDIsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMikpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPCA0KVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KDMpXSkge1xuICAgICAgICBkZWJ1ZygnaW52YWxpZCBoZWFkZXIsIGluZGV4IDMsIGNoYXIgXCIlc1wiJywgdmFsLmNoYXJDb2RlQXQoMykpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDQ7IGkgPCB2YWwubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKCF2YWxpZEhkckNoYXJzW3ZhbC5jaGFyQ29kZUF0KGkpXSkge1xuICAgICAgICAgICAgZGVidWcoJ2ludmFsaWQgaGVhZGVyLCBpbmRleCBcIiVpXCIsIGNoYXIgXCIlc1wiJywgaSwgdmFsLmNoYXJDb2RlQXQoaSkpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCB0aW1lcnNfMSA9IHJlcXVpcmUoXCJ0aW1lcnNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnNvY2tldFwiKTtcbmNsYXNzIFNvY2tldCBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGNsYXNzIChhYnN0cmFjdCkuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihpZCwgc2VydmVyLCB0cmFuc3BvcnQsIHJlcSwgcHJvdG9jb2wpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IGlkO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy51cGdyYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgdGhpcy51cGdyYWRlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcIm9wZW5pbmdcIjtcbiAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICB0aGlzLnBhY2tldHNGbiA9IFtdO1xuICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuID0gW107XG4gICAgICAgIHRoaXMuY2xlYW51cEZuID0gW107XG4gICAgICAgIHRoaXMucmVxdWVzdCA9IHJlcTtcbiAgICAgICAgdGhpcy5wcm90b2NvbCA9IHByb3RvY29sO1xuICAgICAgICAvLyBDYWNoZSBJUCBzaW5jZSBpdCBtaWdodCBub3QgYmUgaW4gdGhlIHJlcSBsYXRlclxuICAgICAgICBpZiAocmVxLndlYnNvY2tldCAmJiByZXEud2Vic29ja2V0Ll9zb2NrZXQpIHtcbiAgICAgICAgICAgIHRoaXMucmVtb3RlQWRkcmVzcyA9IHJlcS53ZWJzb2NrZXQuX3NvY2tldC5yZW1vdGVBZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5yZW1vdGVBZGRyZXNzID0gcmVxLmNvbm5lY3Rpb24ucmVtb3RlQWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrSW50ZXJ2YWxUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMudXBncmFkZVRpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMucGluZ1RpbWVvdXRUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSBudWxsO1xuICAgICAgICB0aGlzLnNldFRyYW5zcG9ydCh0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLm9uT3BlbigpO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIHNldCByZWFkeVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGRlYnVnKFwicmVhZHlTdGF0ZSB1cGRhdGVkIGZyb20gJXMgdG8gJXNcIiwgdGhpcy5fcmVhZHlTdGF0ZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLl9yZWFkeVN0YXRlID0gc3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjb25zaWRlcmVkIG9wZW4uXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbk9wZW4oKSB7XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwib3BlblwiO1xuICAgICAgICAvLyBzZW5kcyBhbiBgb3BlbmAgcGFja2V0XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LnNpZCA9IHRoaXMuaWQ7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm9wZW5cIiwgSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgc2lkOiB0aGlzLmlkLFxuICAgICAgICAgICAgdXBncmFkZXM6IHRoaXMuZ2V0QXZhaWxhYmxlVXBncmFkZXMoKSxcbiAgICAgICAgICAgIHBpbmdJbnRlcnZhbDogdGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwsXG4gICAgICAgICAgICBwaW5nVGltZW91dDogdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dFxuICAgICAgICB9KSk7XG4gICAgICAgIGlmICh0aGlzLnNlcnZlci5vcHRzLmluaXRpYWxQYWNrZXQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgdGhpcy5zZXJ2ZXIub3B0cy5pbml0aWFsUGFja2V0KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgLy8gaW4gcHJvdG9jb2wgdjMsIHRoZSBjbGllbnQgc2VuZHMgYSBwaW5nLCBhbmQgdGhlIHNlcnZlciBhbnN3ZXJzIHdpdGggYSBwb25nXG4gICAgICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQodGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwgKyB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIGluIHByb3RvY29sIHY0LCB0aGUgc2VydmVyIHNlbmRzIGEgcGluZywgYW5kIHRoZSBjbGllbnQgYW5zd2VycyB3aXRoIGEgcG9uZ1xuICAgICAgICAgICAgdGhpcy5zY2hlZHVsZVBpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgdXBvbiB0cmFuc3BvcnQgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUGFja2V0KHBhY2tldCkge1xuICAgICAgICBpZiAoXCJvcGVuXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRlYnVnKFwicGFja2V0IHJlY2VpdmVkIHdpdGggY2xvc2VkIHNvY2tldFwiKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBleHBvcnQgcGFja2V0IGV2ZW50XG4gICAgICAgIGRlYnVnKGByZWNlaXZlZCBwYWNrZXQgJHtwYWNrZXQudHlwZX1gKTtcbiAgICAgICAgdGhpcy5lbWl0KFwicGFja2V0XCIsIHBhY2tldCk7XG4gICAgICAgIC8vIFJlc2V0IHBpbmcgdGltZW91dCBvbiBhbnkgcGFja2V0LCBpbmNvbWluZyBkYXRhIGlzIGEgZ29vZCBzaWduIG9mXG4gICAgICAgIC8vIG90aGVyIHNpZGUncyBsaXZlbmVzc1xuICAgICAgICB0aGlzLnJlc2V0UGluZ1RpbWVvdXQodGhpcy5zZXJ2ZXIub3B0cy5waW5nSW50ZXJ2YWwgKyB0aGlzLnNlcnZlci5vcHRzLnBpbmdUaW1lb3V0KTtcbiAgICAgICAgc3dpdGNoIChwYWNrZXQudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInBpbmdcIjpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy50cmFuc3BvcnQucHJvdG9jb2wgIT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwiaW52YWxpZCBoZWFydGJlYXQgZGlyZWN0aW9uXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiZ290IHBpbmdcIik7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwicG9uZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicG9uZ1wiOlxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnRyYW5zcG9ydC5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJpbnZhbGlkIGhlYXJ0YmVhdCBkaXJlY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgcG9uZ1wiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnBpbmdJbnRlcnZhbFRpbWVyLnJlZnJlc2goKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJoZWFydGJlYXRcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJwYXJzZSBlcnJvclwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGF0YVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibWVzc2FnZVwiLCBwYWNrZXQuZGF0YSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtFcnJvcn0gZXJyb3Igb2JqZWN0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25FcnJvcihlcnIpIHtcbiAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgZXJyb3JcIik7XG4gICAgICAgIHRoaXMub25DbG9zZShcInRyYW5zcG9ydCBlcnJvclwiLCBlcnIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQaW5ncyBjbGllbnQgZXZlcnkgYHRoaXMucGluZ0ludGVydmFsYCBhbmQgZXhwZWN0cyByZXNwb25zZVxuICAgICAqIHdpdGhpbiBgdGhpcy5waW5nVGltZW91dGAgb3IgY2xvc2VzIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzY2hlZHVsZVBpbmcoKSB7XG4gICAgICAgIHRoaXMucGluZ0ludGVydmFsVGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJ3cml0aW5nIHBpbmcgcGFja2V0IC0gZXhwZWN0aW5nIHBvbmcgd2l0aGluICVzbXNcIiwgdGhpcy5zZXJ2ZXIub3B0cy5waW5nVGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLnNlbmRQYWNrZXQoXCJwaW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNldFBpbmdUaW1lb3V0KHRoaXMuc2VydmVyLm9wdHMucGluZ1RpbWVvdXQpO1xuICAgICAgICB9LCB0aGlzLnNlcnZlci5vcHRzLnBpbmdJbnRlcnZhbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc2V0cyBwaW5nIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICByZXNldFBpbmdUaW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgdGhpcy5waW5nVGltZW91dFRpbWVyID0gKDAsIHRpbWVyc18xLnNldFRpbWVvdXQpKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2VkXCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5vbkNsb3NlKFwicGluZyB0aW1lb3V0XCIpO1xuICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgaGFuZGxlcnMgZm9yIHRoZSBnaXZlbiB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1RyYW5zcG9ydH0gdHJhbnNwb3J0XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2V0VHJhbnNwb3J0KHRyYW5zcG9ydCkge1xuICAgICAgICBjb25zdCBvbkVycm9yID0gdGhpcy5vbkVycm9yLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IG9uUGFja2V0ID0gdGhpcy5vblBhY2tldC5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBmbHVzaCA9IHRoaXMuZmx1c2guYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9IHRoaXMub25DbG9zZS5iaW5kKHRoaXMsIFwidHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub25jZShcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0Lm9uKFwiZHJhaW5cIiwgZmx1c2gpO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIC8vIHRoaXMgZnVuY3Rpb24gd2lsbCBtYW5hZ2UgcGFja2V0IGV2ZW50cyAoYWxzbyBtZXNzYWdlIGNhbGxiYWNrcylcbiAgICAgICAgdGhpcy5zZXR1cFNlbmRDYWxsYmFjaygpO1xuICAgICAgICB0aGlzLmNsZWFudXBGbi5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIG9uRXJyb3IpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsIGZsdXNoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBncmFkZXMgc29ja2V0IHRvIHRoZSBnaXZlbiB0cmFuc3BvcnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7VHJhbnNwb3J0fSB0cmFuc3BvcnRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBtYXliZVVwZ3JhZGUodHJhbnNwb3J0KSB7XG4gICAgICAgIGRlYnVnKCdtaWdodCB1cGdyYWRlIHNvY2tldCB0cmFuc3BvcnQgZnJvbSBcIiVzXCIgdG8gXCIlc1wiJywgdGhpcy50cmFuc3BvcnQubmFtZSwgdHJhbnNwb3J0Lm5hbWUpO1xuICAgICAgICB0aGlzLnVwZ3JhZGluZyA9IHRydWU7XG4gICAgICAgIC8vIHNldCB0cmFuc3BvcnQgdXBncmFkZSB0aW1lclxuICAgICAgICB0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIgPSAoMCwgdGltZXJzXzEuc2V0VGltZW91dCkoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJjbGllbnQgZGlkIG5vdCBjb21wbGV0ZSB1cGdyYWRlIC0gY2xvc2luZyB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRyYW5zcG9ydC5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLm9wdHMudXBncmFkZVRpbWVvdXQpO1xuICAgICAgICBjb25zdCBvblBhY2tldCA9IHBhY2tldCA9PiB7XG4gICAgICAgICAgICBpZiAoXCJwaW5nXCIgPT09IHBhY2tldC50eXBlICYmIFwicHJvYmVcIiA9PT0gcGFja2V0LmRhdGEpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImdvdCBwcm9iZSBwaW5nIHBhY2tldCwgc2VuZGluZyBwb25nXCIpO1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwicG9uZ1wiLCBkYXRhOiBcInByb2JlXCIgfV0pO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcInVwZ3JhZGluZ1wiLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyID0gc2V0SW50ZXJ2YWwoY2hlY2ssIDEwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChcInVwZ3JhZGVcIiA9PT0gcGFja2V0LnR5cGUgJiYgdGhpcy5yZWFkeVN0YXRlICE9PSBcImNsb3NlZFwiKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgdXBncmFkZSBwYWNrZXQgLSB1cGdyYWRpbmdcIik7XG4gICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0LmRpc2NhcmQoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnVwZ3JhZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVHJhbnNwb3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRUcmFuc3BvcnQodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJ1cGdyYWRlXCIsIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mbHVzaCgpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFwiY2xvc2luZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoXCJmb3JjZWQgY2xvc2VcIik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLy8gd2UgZm9yY2UgYSBwb2xsaW5nIGN5Y2xlIHRvIGVuc3VyZSBhIGZhc3QgdXBncmFkZVxuICAgICAgICBjb25zdCBjaGVjayA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChcInBvbGxpbmdcIiA9PT0gdGhpcy50cmFuc3BvcnQubmFtZSAmJiB0aGlzLnRyYW5zcG9ydC53cml0YWJsZSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwid3JpdGluZyBhIG5vb3AgcGFja2V0IHRvIHBvbGxpbmcgZm9yIGZhc3QgdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKFt7IHR5cGU6IFwibm9vcFwiIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgY2xlYW51cCA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMudXBncmFkaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tJbnRlcnZhbFRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMudXBncmFkZVRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnVwZ3JhZGVUaW1lb3V0VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwicGFja2V0XCIsIG9uUGFja2V0KTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uVHJhbnNwb3J0Q2xvc2UpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnJlbW92ZUxpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJjbGllbnQgZGlkIG5vdCBjb21wbGV0ZSB1cGdyYWRlIC0gJXNcIiwgZXJyKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5jbG9zZSgpO1xuICAgICAgICAgICAgdHJhbnNwb3J0ID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25UcmFuc3BvcnRDbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIG9uRXJyb3IoXCJ0cmFuc3BvcnQgY2xvc2VkXCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgb25FcnJvcihcInNvY2tldCBjbG9zZWRcIik7XG4gICAgICAgIH07XG4gICAgICAgIHRyYW5zcG9ydC5vbihcInBhY2tldFwiLCBvblBhY2tldCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwiY2xvc2VcIiwgb25UcmFuc3BvcnRDbG9zZSk7XG4gICAgICAgIHRyYW5zcG9ydC5vbmNlKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgIHRoaXMub25jZShcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhcnMgbGlzdGVuZXJzIGFuZCB0aW1lcnMgYXNzb2NpYXRlZCB3aXRoIGN1cnJlbnQgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY2xlYXJUcmFuc3BvcnQoKSB7XG4gICAgICAgIGxldCBjbGVhbnVwO1xuICAgICAgICBjb25zdCB0b0NsZWFuVXAgPSB0aGlzLmNsZWFudXBGbi5sZW5ndGg7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG9DbGVhblVwOyBpKyspIHtcbiAgICAgICAgICAgIGNsZWFudXAgPSB0aGlzLmNsZWFudXBGbi5zaGlmdCgpO1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHNpbGVuY2UgZnVydGhlciB0cmFuc3BvcnQgZXJyb3JzIGFuZCBwcmV2ZW50IHVuY2F1Z2h0IGV4Y2VwdGlvbnNcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJlcnJvclwiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImVycm9yIHRyaWdnZXJlZCBieSBkaXNjYXJkZWQgdHJhbnNwb3J0XCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gZW5zdXJlIHRyYW5zcG9ydCB3b24ndCBzdGF5IG9wZW5cbiAgICAgICAgdGhpcy50cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gdHJhbnNwb3J0IGNvbnNpZGVyZWQgY2xvc2VkLlxuICAgICAqIFBvc3NpYmxlIHJlYXNvbnM6IGBwaW5nIHRpbWVvdXRgLCBgY2xpZW50IGVycm9yYCwgYHBhcnNlIGVycm9yYCxcbiAgICAgKiBgdHJhbnNwb3J0IGVycm9yYCwgYHNlcnZlciBjbG9zZWAsIGB0cmFuc3BvcnQgY2xvc2VgXG4gICAgICovXG4gICAgb25DbG9zZShyZWFzb24sIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgIGlmIChcImNsb3NlZFwiICE9PSB0aGlzLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2VkXCI7XG4gICAgICAgICAgICAvLyBjbGVhciB0aW1lcnNcbiAgICAgICAgICAgICgwLCB0aW1lcnNfMS5jbGVhclRpbWVvdXQpKHRoaXMucGluZ0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy5waW5nVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5jaGVja0ludGVydmFsVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5jaGVja0ludGVydmFsVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgKDAsIHRpbWVyc18xLmNsZWFyVGltZW91dCkodGhpcy51cGdyYWRlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIC8vIGNsZWFuIHdyaXRlQnVmZmVyIGluIG5leHQgdGljaywgc28gZGV2ZWxvcGVycyBjYW4gc3RpbGxcbiAgICAgICAgICAgIC8vIGdyYWIgdGhlIHdyaXRlQnVmZmVyIG9uICdjbG9zZScgZXZlbnRcbiAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIgPSBbXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5wYWNrZXRzRm4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuc2VudENhbGxiYWNrRm4gPSBbXTtcbiAgICAgICAgICAgIHRoaXMuY2xlYXJUcmFuc3BvcnQoKTtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIsIHJlYXNvbiwgZGVzY3JpcHRpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHVwIGFuZCBtYW5hZ2Ugc2VuZCBjYWxsYmFja1xuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgc2V0dXBTZW5kQ2FsbGJhY2soKSB7XG4gICAgICAgIC8vIHRoZSBtZXNzYWdlIHdhcyBzZW50IHN1Y2Nlc3NmdWxseSwgZXhlY3V0ZSB0aGUgY2FsbGJhY2tcbiAgICAgICAgY29uc3Qgb25EcmFpbiA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbnRDYWxsYmFja0ZuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzZXFGbiA9IHRoaXMuc2VudENhbGxiYWNrRm4uc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzZXFGbikge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImV4ZWN1dGluZyBzZW5kIGNhbGxiYWNrXCIpO1xuICAgICAgICAgICAgICAgICAgICBzZXFGbih0aGlzLnRyYW5zcG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc2VxRm4pKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZXhlY3V0aW5nIGJhdGNoIHNlbmQgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGwgPSBzZXFGbi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGxldCBpID0gMDtcbiAgICAgICAgICAgICAgICAgICAgZm9yICg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT09IHR5cGVvZiBzZXFGbltpXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcUZuW2ldKHRoaXMudHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy50cmFuc3BvcnQub24oXCJkcmFpblwiLCBvbkRyYWluKTtcbiAgICAgICAgdGhpcy5jbGVhbnVwRm4ucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5yZW1vdmVMaXN0ZW5lcihcImRyYWluXCIsIG9uRHJhaW4pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBtZXNzYWdlIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqIEByZXR1cm4ge1NvY2tldH0gZm9yIGNoYWluaW5nXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBzZW5kKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuc2VuZFBhY2tldChcIm1lc3NhZ2VcIiwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgd3JpdGUoZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5zZW5kUGFja2V0KFwibWVzc2FnZVwiLCBkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIC0gcGFja2V0IHR5cGVcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gZGF0YVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlbmRQYWNrZXQodHlwZSwgZGF0YSwgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PT0gdHlwZW9mIG9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgICAgICBvcHRpb25zLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdGlvbnMuY29tcHJlc3M7XG4gICAgICAgIGlmIChcImNsb3NpbmdcIiAhPT0gdGhpcy5yZWFkeVN0YXRlICYmIFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgZGVidWcoJ3NlbmRpbmcgcGFja2V0IFwiJXNcIiAoJXMpJywgdHlwZSwgZGF0YSk7XG4gICAgICAgICAgICBjb25zdCBwYWNrZXQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgICAgICBvcHRpb25zXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKGRhdGEpXG4gICAgICAgICAgICAgICAgcGFja2V0LmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgLy8gZXhwb3J0cyBwYWNrZXRDcmVhdGUgZXZlbnRcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBhY2tldENyZWF0ZVwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlci5wdXNoKHBhY2tldCk7XG4gICAgICAgICAgICAvLyBhZGQgc2VuZCBjYWxsYmFjayB0byBvYmplY3QsIGlmIGRlZmluZWRcbiAgICAgICAgICAgIGlmIChjYWxsYmFjaylcbiAgICAgICAgICAgICAgICB0aGlzLnBhY2tldHNGbi5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgICAgIHRoaXMuZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBmbHVzaCB0aGUgcGFja2V0cyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBmbHVzaCgpIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgIT09IHRoaXMucmVhZHlTdGF0ZSAmJlxuICAgICAgICAgICAgdGhpcy50cmFuc3BvcnQud3JpdGFibGUgJiZcbiAgICAgICAgICAgIHRoaXMud3JpdGVCdWZmZXIubGVuZ3RoKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImZsdXNoaW5nIGJ1ZmZlciB0byB0cmFuc3BvcnRcIik7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJmbHVzaFwiLCB0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAgICAgICAgIHRoaXMuc2VydmVyLmVtaXQoXCJmbHVzaFwiLCB0aGlzLCB0aGlzLndyaXRlQnVmZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IHdidWYgPSB0aGlzLndyaXRlQnVmZmVyO1xuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlciA9IFtdO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zcG9ydC5zdXBwb3J0c0ZyYW1pbmcpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbnRDYWxsYmFja0ZuLnB1c2godGhpcy5wYWNrZXRzRm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZW50Q2FsbGJhY2tGbi5wdXNoLmFwcGx5KHRoaXMuc2VudENhbGxiYWNrRm4sIHRoaXMucGFja2V0c0ZuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucGFja2V0c0ZuID0gW107XG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHdidWYpO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICB0aGlzLnNlcnZlci5lbWl0KFwiZHJhaW5cIiwgdGhpcyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IGF2YWlsYWJsZSB1cGdyYWRlcyBmb3IgdGhpcyBzb2NrZXQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBnZXRBdmFpbGFibGVVcGdyYWRlcygpIHtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlVXBncmFkZXMgPSBbXTtcbiAgICAgICAgY29uc3QgYWxsVXBncmFkZXMgPSB0aGlzLnNlcnZlci51cGdyYWRlcyh0aGlzLnRyYW5zcG9ydC5uYW1lKTtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBjb25zdCBsID0gYWxsVXBncmFkZXMubGVuZ3RoO1xuICAgICAgICBmb3IgKDsgaSA8IGw7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgdXBnID0gYWxsVXBncmFkZXNbaV07XG4gICAgICAgICAgICBpZiAodGhpcy5zZXJ2ZXIub3B0cy50cmFuc3BvcnRzLmluZGV4T2YodXBnKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBhdmFpbGFibGVVcGdyYWRlcy5wdXNoKHVwZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZVVwZ3JhZGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIHNvY2tldCBhbmQgdW5kZXJseWluZyB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRpc2NhcmQgLSBvcHRpb25hbCwgZGlzY2FyZCB0aGUgdHJhbnNwb3J0XG4gICAgICogQHJldHVybiB7U29ja2V0fSBmb3IgY2hhaW5pbmdcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGNsb3NlKGRpc2NhcmQpIHtcbiAgICAgICAgaWYgKFwib3BlblwiICE9PSB0aGlzLnJlYWR5U3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmVhZHlTdGF0ZSA9IFwiY2xvc2luZ1wiO1xuICAgICAgICBpZiAodGhpcy53cml0ZUJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMub25jZShcImRyYWluXCIsIHRoaXMuY2xvc2VUcmFuc3BvcnQuYmluZCh0aGlzLCBkaXNjYXJkKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jbG9zZVRyYW5zcG9ydChkaXNjYXJkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gZGlzY2FyZFxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlVHJhbnNwb3J0KGRpc2NhcmQpIHtcbiAgICAgICAgaWYgKGRpc2NhcmQpXG4gICAgICAgICAgICB0aGlzLnRyYW5zcG9ydC5kaXNjYXJkKCk7XG4gICAgICAgIHRoaXMudHJhbnNwb3J0LmNsb3NlKHRoaXMub25DbG9zZS5iaW5kKHRoaXMsIFwiZm9yY2VkIGNsb3NlXCIpKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldCA9IFNvY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5UcmFuc3BvcnQgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBwYXJzZXJfdjQgPSByZXF1aXJlKFwiZW5naW5lLmlvLXBhcnNlclwiKTtcbmNvbnN0IHBhcnNlcl92MyA9IHJlcXVpcmUoXCIuL3BhcnNlci12My9pbmRleFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnRyYW5zcG9ydFwiKTtcbi8qKlxuICogTm9vcCBmdW5jdGlvbi5cbiAqXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxuY2xhc3MgVHJhbnNwb3J0IGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXF1ZXN0XG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJvcGVuXCI7XG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucHJvdG9jb2wgPSByZXEuX3F1ZXJ5LkVJTyA9PT0gXCI0XCIgPyA0IDogMzsgLy8gM3JkIHJldmlzaW9uIGJ5IGRlZmF1bHRcbiAgICAgICAgdGhpcy5wYXJzZXIgPSB0aGlzLnByb3RvY29sID09PSA0ID8gcGFyc2VyX3Y0IDogcGFyc2VyX3YzO1xuICAgIH1cbiAgICBnZXQgcmVhZHlTdGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gICAgfVxuICAgIHNldCByZWFkeVN0YXRlKHN0YXRlKSB7XG4gICAgICAgIGRlYnVnKFwicmVhZHlTdGF0ZSB1cGRhdGVkIGZyb20gJXMgdG8gJXMgKCVzKVwiLCB0aGlzLl9yZWFkeVN0YXRlLCBzdGF0ZSwgdGhpcy5uYW1lKTtcbiAgICAgICAgdGhpcy5fcmVhZHlTdGF0ZSA9IHN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbGFncyB0aGUgdHJhbnNwb3J0IGFzIGRpc2NhcmRlZC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGRpc2NhcmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY2FyZGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggYW4gaW5jb21pbmcgSFRUUCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxdWVzdFxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkge1xuICAgICAgICBkZWJ1ZyhcInNldHRpbmcgcmVxdWVzdFwiKTtcbiAgICAgICAgdGhpcy5yZXEgPSByZXE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY2xvc2UoZm4pIHtcbiAgICAgICAgaWYgKFwiY2xvc2VkXCIgPT09IHRoaXMucmVhZHlTdGF0ZSB8fCBcImNsb3NpbmdcIiA9PT0gdGhpcy5yZWFkeVN0YXRlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnJlYWR5U3RhdGUgPSBcImNsb3NpbmdcIjtcbiAgICAgICAgdGhpcy5kb0Nsb3NlKGZuIHx8IG5vb3ApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBhIHRyYW5zcG9ydCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIGVycm9yXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVycm9yIGRlc2NyaXB0aW9uXG4gICAgICogQGFwaSBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkVycm9yKG1zZywgZGVzYykge1xuICAgICAgICBpZiAodGhpcy5saXN0ZW5lcnMoXCJlcnJvclwiKS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihtc2cpO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgZXJyLnR5cGUgPSBcIlRyYW5zcG9ydEVycm9yXCI7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBlcnIuZGVzY3JpcHRpb24gPSBkZXNjO1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JlZCB0cmFuc3BvcnQgZXJyb3IgJXMgKCVzKVwiLCBtc2csIGRlc2MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aXRoIHBhcnNlZCBvdXQgYSBwYWNrZXRzIGZyb20gdGhlIGRhdGEgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldFxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25QYWNrZXQocGFja2V0KSB7XG4gICAgICAgIHRoaXMuZW1pdChcInBhY2tldFwiLCBwYWNrZXQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCB0aGUgZW5jb2RlZCBwYWNrZXQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhXG4gICAgICogQGFwaSBwcm90ZWN0ZWRcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICB0aGlzLm9uUGFja2V0KHRoaXMucGFyc2VyLmRlY29kZVBhY2tldChkYXRhKSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJvdGVjdGVkXG4gICAgICovXG4gICAgb25DbG9zZSgpIHtcbiAgICAgICAgdGhpcy5yZWFkeVN0YXRlID0gXCJjbG9zZWRcIjtcbiAgICAgICAgdGhpcy5lbWl0KFwiY2xvc2VcIik7XG4gICAgfVxufVxuZXhwb3J0cy5UcmFuc3BvcnQgPSBUcmFuc3BvcnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHBvbGxpbmdfMSA9IHJlcXVpcmUoXCIuL3BvbGxpbmdcIik7XG5jb25zdCB3ZWJzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3dlYnNvY2tldFwiKTtcbmV4cG9ydHMuZGVmYXVsdCA9IHtcbiAgICBwb2xsaW5nOiBwb2xsaW5nXzEuUG9sbGluZyxcbiAgICB3ZWJzb2NrZXQ6IHdlYnNvY2tldF8xLldlYlNvY2tldFxufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qb2xsaW5nID0gdm9pZCAwO1xuY29uc3QgdHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi4vdHJhbnNwb3J0XCIpO1xuY29uc3QgemxpYl8xID0gcmVxdWlyZShcInpsaWJcIik7XG5jb25zdCBhY2NlcHRzID0gcmVxdWlyZShcImFjY2VwdHNcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTpwb2xsaW5nXCIpO1xuY29uc3QgY29tcHJlc3Npb25NZXRob2RzID0ge1xuICAgIGd6aXA6IHpsaWJfMS5jcmVhdGVHemlwLFxuICAgIGRlZmxhdGU6IHpsaWJfMS5jcmVhdGVEZWZsYXRlXG59O1xuY2xhc3MgUG9sbGluZyBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogSFRUUCBwb2xsaW5nIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWMuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuY2xvc2VUaW1lb3V0ID0gMzAgKiAxMDAwO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgbmFtZVxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuIFwicG9sbGluZ1wiO1xuICAgIH1cbiAgICBnZXQgc3VwcG9ydHNGcmFtaW5nKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE92ZXJyaWRlcyBvblJlcXVlc3QuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvblJlcXVlc3QocmVxKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHJlcS5yZXM7XG4gICAgICAgIGlmIChyZXEuZ2V0TWV0aG9kKCkgPT09IFwiZ2V0XCIpIHtcbiAgICAgICAgICAgIHRoaXMub25Qb2xsUmVxdWVzdChyZXEsIHJlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocmVxLmdldE1ldGhvZCgpID09PSBcInBvc3RcIikge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3QgYXdhaXRpbmcgZm9yIHVzIHRvIHNlbmQgZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uUG9sbFJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMucmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInJlcXVlc3Qgb3ZlcmxhcFwiKTtcbiAgICAgICAgICAgIC8vIGFzc2VydDogdGhpcy5yZXMsICcucmVxIGFuZCAucmVzIHNob3VsZCBiZSAodW4pc2V0IHRvZ2V0aGVyJ1xuICAgICAgICAgICAgdGhpcy5vbkVycm9yKFwib3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjUwMCBJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIik7XG4gICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZXR0aW5nIHJlcXVlc3RcIik7XG4gICAgICAgIHRoaXMucmVxID0gcmVxO1xuICAgICAgICB0aGlzLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcInBvbGwgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IGNsZWFudXAgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLmNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgICByZXMub25BYm9ydGVkKG9uQ2xvc2UpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgIC8vIGlmIHdlJ3JlIHN0aWxsIHdyaXRhYmxlIGJ1dCBoYWQgYSBwZW5kaW5nIGNsb3NlLCB0cmlnZ2VyIGFuIGVtcHR5IHNlbmRcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUgJiYgdGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJ0cmlnZ2VyaW5nIGVtcHR5IHNlbmQgdG8gYXBwZW5kIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGNsaWVudCBzZW5kcyBhIHJlcXVlc3Qgd2l0aCBkYXRhLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25EYXRhUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IHRoaXMuZGF0YVJlcywgJy5kYXRhUmVxIGFuZCAuZGF0YVJlcyBzaG91bGQgYmUgKHVuKXNldCB0b2dldGhlcidcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBleHBlY3RlZENvbnRlbnRMZW5ndGggPSBOdW1iZXIocmVxLmhlYWRlcnNbXCJjb250ZW50LWxlbmd0aFwiXSk7XG4gICAgICAgIGlmICghZXhwZWN0ZWRDb250ZW50TGVuZ3RoKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBoZWFkZXIgcmVxdWlyZWRcIik7XG4gICAgICAgICAgICByZXMud3JpdGVTdGF0dXMoXCI0MTEgTGVuZ3RoIFJlcXVpcmVkXCIpLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChleHBlY3RlZENvbnRlbnRMZW5ndGggPiB0aGlzLm1heEh0dHBCdWZmZXJTaXplKSB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwYXlsb2FkIHRvbyBsYXJnZVwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZVN0YXR1cyhcIjQxMyBQYXlsb2FkIFRvbyBMYXJnZVwiKS5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0JpbmFyeSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgPT09IHJlcS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBpZiAoaXNCaW5hcnkgJiYgdGhpcy5wcm90b2NvbCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFSZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZGF0YVJlcyA9IHJlcztcbiAgICAgICAgbGV0IGJ1ZmZlcjtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAvLyB0ZXh0L2h0bWwgaXMgcmVxdWlyZWQgaW5zdGVhZCBvZiB0ZXh0L3BsYWluIHRvIGF2b2lkIGFuXG4gICAgICAgICAgICAvLyB1bndhbnRlZCBkb3dubG9hZCBkaWFsb2cgb24gY2VydGFpbiB1c2VyLWFnZW50cyAoR0gtNDMpXG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaGVhZGVycyhyZXEsIGhlYWRlcnMpO1xuICAgICAgICBmb3IgKGxldCBrZXkgaW4gaGVhZGVycykge1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKGtleSwgU3RyaW5nKGhlYWRlcnNba2V5XSkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9uRW5kID0gYnVmZmVyID0+IHtcbiAgICAgICAgICAgIHRoaXMub25EYXRhKGJ1ZmZlci50b1N0cmluZygpKTtcbiAgICAgICAgICAgIHRoaXMub25EYXRhUmVxdWVzdENsZWFudXAoKTtcbiAgICAgICAgICAgIHJlcy5lbmQoXCJva1wiKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmVzLm9uQWJvcnRlZCgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3QgY29ubmVjdGlvbiBjbG9zZWQgcHJlbWF0dXJlbHlcIik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXMub25EYXRhKChhcnJheUJ1ZmZlciwgaXNMYXN0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCB0b3RhbExlbmd0aCA9IG9mZnNldCArIGFycmF5QnVmZmVyLmJ5dGVMZW5ndGg7XG4gICAgICAgICAgICBpZiAodG90YWxMZW5ndGggPiBleHBlY3RlZENvbnRlbnRMZW5ndGgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICByZXMuY2xvc2UoKTsgLy8gY2FsbHMgb25BYm9ydGVkXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFidWZmZXIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRW5kKEJ1ZmZlci5mcm9tKGFycmF5QnVmZmVyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGV4cGVjdGVkQ29udGVudExlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlcikuY29weShidWZmZXIsIG9mZnNldCk7XG4gICAgICAgICAgICBpZiAoaXNMYXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvdGFsTGVuZ3RoICE9IGV4cGVjdGVkQ29udGVudExlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJjb250ZW50LWxlbmd0aCBtaXNtYXRjaFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiNDAwIENvbnRlbnQtTGVuZ3RoIE1pc21hdGNoXCIpLmVuZCgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRGF0YVJlcXVlc3RDbGVhbnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgb25FbmQoYnVmZmVyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQgPSB0b3RhbExlbmd0aDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsZWFudXAgcmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3RDbGVhbnVwKCkge1xuICAgICAgICB0aGlzLmRhdGFSZXEgPSB0aGlzLmRhdGFSZXMgPSBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFja2V0ID0+IHtcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgeGhyIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uQ2xvc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgcGVuZGluZyBwb2xsIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJhcHBlbmRpbmcgY2xvc2UgcGFja2V0IHRvIHBheWxvYWRcIik7XG4gICAgICAgICAgICBwYWNrZXRzLnB1c2goeyB0eXBlOiBcImNsb3NlXCIgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb1dyaXRlID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHBhY2tldHMuc29tZShwYWNrZXQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcS5jbGVhbnVwKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgd3JpdGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IFVURi04IGlzIHJlcXVpcmVkIGZvciBwYWdlcyBub3Qgc2VydmVkIHVuZGVyIHV0ZlxuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGlzU3RyaW5nXG4gICAgICAgICAgICA/IFwidGV4dC9wbGFpbjsgY2hhcnNldD1VVEYtOFwiXG4gICAgICAgICAgICA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25kID0gZGF0YSA9PiB7XG4gICAgICAgICAgICB0aGlzLmhlYWRlcnModGhpcy5yZXEsIGhlYWRlcnMpO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMoaGVhZGVycykuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgU3RyaW5nKGhlYWRlcnNba2V5XSkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLnJlcy5lbmQoZGF0YSk7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoIXRoaXMuaHR0cENvbXByZXNzaW9uIHx8ICFvcHRpb25zLmNvbXByZXNzKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbiA9IGlzU3RyaW5nID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbiA8IHRoaXMuaHR0cENvbXByZXNzaW9uLnRocmVzaG9sZCkge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbmNvZGluZyA9IGFjY2VwdHModGhpcy5yZXEpLmVuY29kaW5ncyhbXCJnemlwXCIsIFwiZGVmbGF0ZVwiXSk7XG4gICAgICAgIGlmICghZW5jb2RpbmcpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb21wcmVzcyhkYXRhLCBlbmNvZGluZywgKGVyciwgZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVzLndyaXRlU3RhdHVzKFwiNTAwIEludGVybmFsIFNlcnZlciBFcnJvclwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHJlc3NlcyBkYXRhLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRlYnVnKFwiY29tcHJlc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgbGV0IG5yZWFkID0gMDtcbiAgICAgICAgY29tcHJlc3Npb25NZXRob2RzW2VuY29kaW5nXSh0aGlzLmh0dHBDb21wcmVzc2lvbilcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgbGV0IGNsb3NlVGltZW91dFRpbWVyO1xuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjYXJkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRpc2NhcmRlZCAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG5vdCB3cml0YWJsZSAtIGJ1ZmZlcmluZyBvcmRlcmx5IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZXEgLSByZXF1ZXN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IGV4dHJhIGhlYWRlcnNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBoZWFkZXJzKHJlcSwgaGVhZGVycykge1xuICAgICAgICBoZWFkZXJzID0gaGVhZGVycyB8fCB7fTtcbiAgICAgICAgLy8gcHJldmVudCBYU1Mgd2FybmluZ3Mgb24gSUVcbiAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL0xlYXJuQm9vc3Qvc29ja2V0LmlvL3B1bGwvMTMzM1xuICAgICAgICBjb25zdCB1YSA9IHJlcS5oZWFkZXJzW1widXNlci1hZ2VudFwiXTtcbiAgICAgICAgaWYgKHVhICYmICh+dWEuaW5kZXhPZihcIjtNU0lFXCIpIHx8IH51YS5pbmRleE9mKFwiVHJpZGVudC9cIikpKSB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiWC1YU1MtUHJvdGVjdGlvblwiXSA9IFwiMFwiO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImhlYWRlcnNcIiwgaGVhZGVycywgcmVxKTtcbiAgICAgICAgcmV0dXJuIGhlYWRlcnM7XG4gICAgfVxufVxuZXhwb3J0cy5Qb2xsaW5nID0gUG9sbGluZztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5XZWJTb2NrZXQgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCBkZWJ1Z18xID0gcmVxdWlyZShcImRlYnVnXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp3c1wiKTtcbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIHRyYW5zcG9ydF8xLlRyYW5zcG9ydCB7XG4gICAgLyoqXG4gICAgICogV2ViU29ja2V0IHRyYW5zcG9ydFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2ZXJ0aXNlIHVwZ3JhZGUgc3VwcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXNVcGdyYWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSBmcmFtaW5nIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBzdXBwb3J0c0ZyYW1pbmcoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0cy5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIHBhY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHdheXMgY3JlYXRlcyBhIG5ldyBvYmplY3Qgc2luY2Ugd3MgbW9kaWZpZXMgaXRcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCBpc0JpbmFyeSA9IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiO1xuICAgICAgICAgICAgY29uc3QgY29tcHJlc3MgPSB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlICYmXG4gICAgICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgPiB0aGlzLnBlck1lc3NhZ2VEZWZsYXRlLnRocmVzaG9sZDtcbiAgICAgICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCBpc0JpbmFyeSwgY29tcHJlc3MpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKHBhY2tldHMpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMgJiYgdHlwZW9mIHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2VuZChwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgc2VuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICAgICAgLy8gY2FsbCBmbiBmaXJzdCBzaW5jZSBzb2NrZXQuY2xvc2UoKSBpbW1lZGlhdGVseSBlbWl0cyBhIFwiY2xvc2VcIiBldmVudFxuICAgICAgICB0aGlzLnNvY2tldC5jbG9zZSgpO1xuICAgIH1cbn1cbmV4cG9ydHMuV2ViU29ja2V0ID0gV2ViU29ja2V0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3QgcG9sbGluZ19qc29ucF8xID0gcmVxdWlyZShcIi4vcG9sbGluZy1qc29ucFwiKTtcbmNvbnN0IHdlYnNvY2tldF8xID0gcmVxdWlyZShcIi4vd2Vic29ja2V0XCIpO1xuZXhwb3J0cy5kZWZhdWx0ID0ge1xuICAgIHBvbGxpbmc6IHBvbGxpbmcsXG4gICAgd2Vic29ja2V0OiB3ZWJzb2NrZXRfMS5XZWJTb2NrZXRcbn07XG4vKipcbiAqIFBvbGxpbmcgcG9seW1vcnBoaWMgY29uc3RydWN0b3IuXG4gKlxuICogQGFwaSBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHBvbGxpbmcocmVxKSB7XG4gICAgaWYgKFwic3RyaW5nXCIgPT09IHR5cGVvZiByZXEuX3F1ZXJ5LmopIHtcbiAgICAgICAgcmV0dXJuIG5ldyBwb2xsaW5nX2pzb25wXzEuSlNPTlAocmVxKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBuZXcgcG9sbGluZ18xLlBvbGxpbmcocmVxKTtcbiAgICB9XG59XG5wb2xsaW5nLnVwZ3JhZGVzVG8gPSBbXCJ3ZWJzb2NrZXRcIl07XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuSlNPTlAgPSB2b2lkIDA7XG5jb25zdCBwb2xsaW5nXzEgPSByZXF1aXJlKFwiLi9wb2xsaW5nXCIpO1xuY29uc3QgcXMgPSByZXF1aXJlKFwicXVlcnlzdHJpbmdcIik7XG5jb25zdCByRG91YmxlU2xhc2hlcyA9IC9cXFxcXFxcXG4vZztcbmNvbnN0IHJTbGFzaGVzID0gLyhcXFxcKT9cXFxcbi9nO1xuY2xhc3MgSlNPTlAgZXh0ZW5kcyBwb2xsaW5nXzEuUG9sbGluZyB7XG4gICAgLyoqXG4gICAgICogSlNPTi1QIHBvbGxpbmcgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQGFwaSBwdWJsaWNcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5oZWFkID0gXCJfX19laW9bXCIgKyAocmVxLl9xdWVyeS5qIHx8IFwiXCIpLnJlcGxhY2UoL1teMC05XS9nLCBcIlwiKSArIFwiXShcIjtcbiAgICAgICAgdGhpcy5mb290ID0gXCIpO1wiO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGluY29taW5nIGRhdGEuXG4gICAgICogRHVlIHRvIGEgYnVnIGluIFxcbiBoYW5kbGluZyBieSBicm93c2Vycywgd2UgZXhwZWN0IGEgZXNjYXBlZCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICAvLyB3ZSBsZXZlcmFnZSB0aGUgcXMgbW9kdWxlIHNvIHRoYXQgd2UgZ2V0IGJ1aWx0LWluIERvUyBwcm90ZWN0aW9uXG4gICAgICAgIC8vIGFuZCB0aGUgZmFzdCBhbHRlcm5hdGl2ZSB0byBkZWNvZGVVUklDb21wb25lbnRcbiAgICAgICAgZGF0YSA9IHFzLnBhcnNlKGRhdGEpLmQ7XG4gICAgICAgIGlmIChcInN0cmluZ1wiID09PSB0eXBlb2YgZGF0YSkge1xuICAgICAgICAgICAgLy8gY2xpZW50IHdpbGwgc2VuZCBhbHJlYWR5IGVzY2FwZWQgbmV3bGluZXMgYXMgXFxcXFxcXFxuIGFuZCBuZXdsaW5lcyBhcyBcXFxcblxuICAgICAgICAgICAgLy8gXFxcXG4gbXVzdCBiZSByZXBsYWNlZCB3aXRoIFxcbiBhbmQgXFxcXFxcXFxuIHdpdGggXFxcXG5cbiAgICAgICAgICAgIGRhdGEgPSBkYXRhLnJlcGxhY2UoclNsYXNoZXMsIGZ1bmN0aW9uIChtYXRjaCwgc2xhc2hlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzbGFzaGVzID8gbWF0Y2ggOiBcIlxcblwiO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdXBlci5vbkRhdGEoZGF0YS5yZXBsYWNlKHJEb3VibGVTbGFzaGVzLCBcIlxcXFxuXCIpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgd3JpdGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIHdlIG11c3Qgb3V0cHV0IHZhbGlkIGphdmFzY3JpcHQsIG5vdCB2YWxpZCBqc29uXG4gICAgICAgIC8vIHNlZTogaHR0cDovL3RpbWVsZXNzcmVwby5jb20vanNvbi1pc250LWEtamF2YXNjcmlwdC1zdWJzZXRcbiAgICAgICAgY29uc3QganMgPSBKU09OLnN0cmluZ2lmeShkYXRhKVxuICAgICAgICAgICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgXCJcXFxcdTIwMjhcIilcbiAgICAgICAgICAgIC5yZXBsYWNlKC9cXHUyMDI5L2csIFwiXFxcXHUyMDI5XCIpO1xuICAgICAgICAvLyBwcmVwYXJlIHJlc3BvbnNlXG4gICAgICAgIGRhdGEgPSB0aGlzLmhlYWQgKyBqcyArIHRoaXMuZm9vdDtcbiAgICAgICAgc3VwZXIuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfVxufVxuZXhwb3J0cy5KU09OUCA9IEpTT05QO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlBvbGxpbmcgPSB2b2lkIDA7XG5jb25zdCB0cmFuc3BvcnRfMSA9IHJlcXVpcmUoXCIuLi90cmFuc3BvcnRcIik7XG5jb25zdCB6bGliXzEgPSByZXF1aXJlKFwiemxpYlwiKTtcbmNvbnN0IGFjY2VwdHMgPSByZXF1aXJlKFwiYWNjZXB0c1wiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOnBvbGxpbmdcIik7XG5jb25zdCBjb21wcmVzc2lvbk1ldGhvZHMgPSB7XG4gICAgZ3ppcDogemxpYl8xLmNyZWF0ZUd6aXAsXG4gICAgZGVmbGF0ZTogemxpYl8xLmNyZWF0ZURlZmxhdGVcbn07XG5jbGFzcyBQb2xsaW5nIGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBIVFRQIHBvbGxpbmcgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpYy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihyZXEpIHtcbiAgICAgICAgc3VwZXIocmVxKTtcbiAgICAgICAgdGhpcy5jbG9zZVRpbWVvdXQgPSAzMCAqIDEwMDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJwb2xsaW5nXCI7XG4gICAgfVxuICAgIGdldCBzdXBwb3J0c0ZyYW1pbmcoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uUmVxdWVzdC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9XG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25SZXF1ZXN0KHJlcSkge1xuICAgICAgICBjb25zdCByZXMgPSByZXEucmVzO1xuICAgICAgICBpZiAoXCJHRVRcIiA9PT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5vblBvbGxSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChcIlBPU1RcIiA9PT0gcmVxLm1ldGhvZCkge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGFSZXF1ZXN0KHJlcSwgcmVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgY2xpZW50IHNlbmRzIGEgcmVxdWVzdCBhd2FpdGluZyBmb3IgdXMgdG8gc2VuZCBkYXRhLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgb25Qb2xsUmVxdWVzdChyZXEsIHJlcykge1xuICAgICAgICBpZiAodGhpcy5yZXEpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicmVxdWVzdCBvdmVybGFwXCIpO1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLnJlcywgJy5yZXEgYW5kIC5yZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJvdmVybGFwIGZyb20gY2xpZW50XCIpO1xuICAgICAgICAgICAgcmVzLndyaXRlSGVhZCg1MDApO1xuICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2V0dGluZyByZXF1ZXN0XCIpO1xuICAgICAgICB0aGlzLnJlcSA9IHJlcTtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIGNvbnN0IG9uQ2xvc2UgPSAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJwb2xsIGNvbm5lY3Rpb24gY2xvc2VkIHByZW1hdHVyZWx5XCIpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgb25DbG9zZSk7XG4gICAgICAgICAgICB0aGlzLnJlcSA9IHRoaXMucmVzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgcmVxLmNsZWFudXAgPSBjbGVhbnVwO1xuICAgICAgICByZXEub24oXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgIHRoaXMuZW1pdChcImRyYWluXCIpO1xuICAgICAgICAvLyBpZiB3ZSdyZSBzdGlsbCB3cml0YWJsZSBidXQgaGFkIGEgcGVuZGluZyBjbG9zZSwgdHJpZ2dlciBhbiBlbXB0eSBzZW5kXG4gICAgICAgIGlmICh0aGlzLndyaXRhYmxlICYmIHRoaXMuc2hvdWxkQ2xvc2UpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJpZ2dlcmluZyBlbXB0eSBzZW5kIHRvIGFwcGVuZCBjbG9zZSBwYWNrZXRcIik7XG4gICAgICAgICAgICB0aGlzLnNlbmQoW3sgdHlwZTogXCJub29wXCIgfV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRoZSBjbGllbnQgc2VuZHMgYSByZXF1ZXN0IHdpdGggZGF0YS5cbiAgICAgKlxuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uRGF0YVJlcXVlc3QocmVxLCByZXMpIHtcbiAgICAgICAgaWYgKHRoaXMuZGF0YVJlcSkge1xuICAgICAgICAgICAgLy8gYXNzZXJ0OiB0aGlzLmRhdGFSZXMsICcuZGF0YVJlcSBhbmQgLmRhdGFSZXMgc2hvdWxkIGJlICh1bilzZXQgdG9nZXRoZXInXG4gICAgICAgICAgICB0aGlzLm9uRXJyb3IoXCJkYXRhIHJlcXVlc3Qgb3ZlcmxhcCBmcm9tIGNsaWVudFwiKTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpc0JpbmFyeSA9IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCIgPT09IHJlcS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdO1xuICAgICAgICBpZiAoaXNCaW5hcnkgJiYgdGhpcy5wcm90b2NvbCA9PT0gNCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMub25FcnJvcihcImludmFsaWQgY29udGVudFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmRhdGFSZXEgPSByZXE7XG4gICAgICAgIHRoaXMuZGF0YVJlcyA9IHJlcztcbiAgICAgICAgbGV0IGNodW5rcyA9IGlzQmluYXJ5ID8gQnVmZmVyLmNvbmNhdChbXSkgOiBcIlwiO1xuICAgICAgICBjb25zdCBjbGVhbnVwID0gKCkgPT4ge1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICAgICAgcmVxLnJlbW92ZUxpc3RlbmVyKFwiZW5kXCIsIG9uRW5kKTtcbiAgICAgICAgICAgIHJlcS5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxID0gdGhpcy5kYXRhUmVzID0gY2h1bmtzID0gbnVsbDtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25DbG9zZSA9ICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIHRoaXMub25FcnJvcihcImRhdGEgcmVxdWVzdCBjb25uZWN0aW9uIGNsb3NlZCBwcmVtYXR1cmVseVwiKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25EYXRhID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBsZXQgY29udGVudExlbmd0aDtcbiAgICAgICAgICAgIGlmIChpc0JpbmFyeSkge1xuICAgICAgICAgICAgICAgIGNodW5rcyA9IEJ1ZmZlci5jb25jYXQoW2NodW5rcywgZGF0YV0pO1xuICAgICAgICAgICAgICAgIGNvbnRlbnRMZW5ndGggPSBjaHVua3MubGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2h1bmtzICs9IGRhdGE7XG4gICAgICAgICAgICAgICAgY29udGVudExlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGNodW5rcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29udGVudExlbmd0aCA+IHRoaXMubWF4SHR0cEJ1ZmZlclNpemUpIHtcbiAgICAgICAgICAgICAgICBjaHVua3MgPSBpc0JpbmFyeSA/IEJ1ZmZlci5jb25jYXQoW10pIDogXCJcIjtcbiAgICAgICAgICAgICAgICByZXEuY29ubmVjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIGNvbnN0IG9uRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vbkRhdGEoY2h1bmtzKTtcbiAgICAgICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICAgICAgLy8gdGV4dC9odG1sIGlzIHJlcXVpcmVkIGluc3RlYWQgb2YgdGV4dC9wbGFpbiB0byBhdm9pZCBhblxuICAgICAgICAgICAgICAgIC8vIHVud2FudGVkIGRvd25sb2FkIGRpYWxvZyBvbiBjZXJ0YWluIHVzZXItYWdlbnRzIChHSC00MylcbiAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiLFxuICAgICAgICAgICAgICAgIFwiQ29udGVudC1MZW5ndGhcIjogMlxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwLCB0aGlzLmhlYWRlcnMocmVxLCBoZWFkZXJzKSk7XG4gICAgICAgICAgICByZXMuZW5kKFwib2tcIik7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgIH07XG4gICAgICAgIHJlcS5vbihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICBpZiAoIWlzQmluYXJ5KVxuICAgICAgICAgICAgcmVxLnNldEVuY29kaW5nKFwidXRmOFwiKTtcbiAgICAgICAgcmVxLm9uKFwiZGF0YVwiLCBvbkRhdGEpO1xuICAgICAgICByZXEub24oXCJlbmRcIiwgb25FbmQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQcm9jZXNzZXMgdGhlIGluY29taW5nIGRhdGEgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBlbmNvZGVkIHBheWxvYWRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkRhdGEoZGF0YSkge1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZWQgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gcGFja2V0ID0+IHtcbiAgICAgICAgICAgIGlmIChcImNsb3NlXCIgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJnb3QgeGhyIGNsb3NlIHBhY2tldFwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm9uUGFja2V0KHBhY2tldCk7XG4gICAgICAgIH07XG4gICAgICAgIGlmICh0aGlzLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhcnNlci5kZWNvZGVQYXlsb2FkKGRhdGEsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmRlY29kZVBheWxvYWQoZGF0YSkuZm9yRWFjaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogT3ZlcnJpZGVzIG9uQ2xvc2UuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBvbkNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy53cml0YWJsZSkge1xuICAgICAgICAgICAgLy8gY2xvc2UgcGVuZGluZyBwb2xsIHJlcXVlc3RcbiAgICAgICAgICAgIHRoaXMuc2VuZChbeyB0eXBlOiBcIm5vb3BcIiB9XSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIub25DbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zaG91bGRDbG9zZSkge1xuICAgICAgICAgICAgZGVidWcoXCJhcHBlbmRpbmcgY2xvc2UgcGFja2V0IHRvIHBheWxvYWRcIik7XG4gICAgICAgICAgICBwYWNrZXRzLnB1c2goeyB0eXBlOiBcImNsb3NlXCIgfSk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLnNob3VsZENsb3NlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb1dyaXRlID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb21wcmVzcyA9IHBhY2tldHMuc29tZShwYWNrZXQgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBwYWNrZXQub3B0aW9ucyAmJiBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy53cml0ZShkYXRhLCB7IGNvbXByZXNzIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5wcm90b2NvbCA9PT0gMykge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGF5bG9hZChwYWNrZXRzLCB0aGlzLnN1cHBvcnRzQmluYXJ5LCBkb1dyaXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGFyc2VyLmVuY29kZVBheWxvYWQocGFja2V0cywgZG9Xcml0ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV3JpdGVzIGRhdGEgYXMgcmVzcG9uc2UgdG8gcG9sbCByZXF1ZXN0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IGRhdGFcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIHdyaXRlKGRhdGEsIG9wdGlvbnMpIHtcbiAgICAgICAgZGVidWcoJ3dyaXRpbmcgXCIlc1wiJywgZGF0YSk7XG4gICAgICAgIHRoaXMuZG9Xcml0ZShkYXRhLCBvcHRpb25zLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlcS5jbGVhbnVwKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyB0aGUgd3JpdGUuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb1dyaXRlKGRhdGEsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIC8vIGV4cGxpY2l0IFVURi04IGlzIHJlcXVpcmVkIGZvciBwYWdlcyBub3Qgc2VydmVkIHVuZGVyIHV0ZlxuICAgICAgICBjb25zdCBpc1N0cmluZyA9IHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiO1xuICAgICAgICBjb25zdCBjb250ZW50VHlwZSA9IGlzU3RyaW5nXG4gICAgICAgICAgICA/IFwidGV4dC9wbGFpbjsgY2hhcnNldD1VVEYtOFwiXG4gICAgICAgICAgICA6IFwiYXBwbGljYXRpb24vb2N0ZXQtc3RyZWFtXCI7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7XG4gICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBjb250ZW50VHlwZVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCByZXNwb25kID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBoZWFkZXJzW1wiQ29udGVudC1MZW5ndGhcIl0gPVxuICAgICAgICAgICAgICAgIFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZCgyMDAsIHRoaXMuaGVhZGVycyh0aGlzLnJlcSwgaGVhZGVycykpO1xuICAgICAgICAgICAgdGhpcy5yZXMuZW5kKGRhdGEpO1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCF0aGlzLmh0dHBDb21wcmVzc2lvbiB8fCAhb3B0aW9ucy5jb21wcmVzcykge1xuICAgICAgICAgICAgcmVzcG9uZChkYXRhKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBsZW4gPSBpc1N0cmluZyA/IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGlmIChsZW4gPCB0aGlzLmh0dHBDb21wcmVzc2lvbi50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgIHJlc3BvbmQoZGF0YSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHRoaXMucmVxKS5lbmNvZGluZ3MoW1wiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBpZiAoIWVuY29kaW5nKSB7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIChlcnIsIGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy53cml0ZUhlYWQoNTAwKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGhlYWRlcnNbXCJDb250ZW50LUVuY29kaW5nXCJdID0gZW5jb2Rpbmc7XG4gICAgICAgICAgICByZXNwb25kKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29tcHJlc3NlcyBkYXRhLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgY29tcHJlc3MoZGF0YSwgZW5jb2RpbmcsIGNhbGxiYWNrKSB7XG4gICAgICAgIGRlYnVnKFwiY29tcHJlc3NpbmdcIik7XG4gICAgICAgIGNvbnN0IGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgbGV0IG5yZWFkID0gMDtcbiAgICAgICAgY29tcHJlc3Npb25NZXRob2RzW2VuY29kaW5nXSh0aGlzLmh0dHBDb21wcmVzc2lvbilcbiAgICAgICAgICAgIC5vbihcImVycm9yXCIsIGNhbGxiYWNrKVxuICAgICAgICAgICAgLm9uKFwiZGF0YVwiLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgICAgICAgICBucmVhZCArPSBjaHVuay5sZW5ndGg7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAub24oXCJlbmRcIiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgQnVmZmVyLmNvbmNhdChidWZmZXJzLCBucmVhZCkpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmVuZChkYXRhKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgbGV0IGNsb3NlVGltZW91dFRpbWVyO1xuICAgICAgICBpZiAodGhpcy5kYXRhUmVxKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImFib3J0aW5nIG9uZ29pbmcgZGF0YSByZXF1ZXN0XCIpO1xuICAgICAgICAgICAgdGhpcy5kYXRhUmVxLmRlc3Ryb3koKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbkNsb3NlID0gKCkgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KGNsb3NlVGltZW91dFRpbWVyKTtcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgICAgICB0aGlzLm9uQ2xvc2UoKTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IHdyaXRhYmxlIC0gY2xvc2luZyByaWdodCBhd2F5XCIpO1xuICAgICAgICAgICAgdGhpcy5zZW5kKFt7IHR5cGU6IFwiY2xvc2VcIiB9XSk7XG4gICAgICAgICAgICBvbkNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5kaXNjYXJkZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IGRpc2NhcmRlZCAtIGNsb3NpbmcgcmlnaHQgYXdheVwiKTtcbiAgICAgICAgICAgIG9uQ2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwidHJhbnNwb3J0IG5vdCB3cml0YWJsZSAtIGJ1ZmZlcmluZyBvcmRlcmx5IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5zaG91bGRDbG9zZSA9IG9uQ2xvc2U7XG4gICAgICAgICAgICBjbG9zZVRpbWVvdXRUaW1lciA9IHNldFRpbWVvdXQob25DbG9zZSwgdGhpcy5jbG9zZVRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgaGVhZGVycyBmb3IgYSByZXNwb25zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7aHR0cC5JbmNvbWluZ01lc3NhZ2V9IHJlcXVlc3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZXh0cmEgaGVhZGVyc1xuICAgICAqIEBhcGkgcHJpdmF0ZVxuICAgICAqL1xuICAgIGhlYWRlcnMocmVxLCBoZWFkZXJzKSB7XG4gICAgICAgIGhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICAvLyBwcmV2ZW50IFhTUyB3YXJuaW5ncyBvbiBJRVxuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vcHVsbC8xMzMzXG4gICAgICAgIGNvbnN0IHVhID0gcmVxLmhlYWRlcnNbXCJ1c2VyLWFnZW50XCJdO1xuICAgICAgICBpZiAodWEgJiYgKH51YS5pbmRleE9mKFwiO01TSUVcIikgfHwgfnVhLmluZGV4T2YoXCJUcmlkZW50L1wiKSkpIHtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJYLVhTUy1Qcm90ZWN0aW9uXCJdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KFwiaGVhZGVyc1wiLCBoZWFkZXJzLCByZXEpO1xuICAgICAgICByZXR1cm4gaGVhZGVycztcbiAgICB9XG59XG5leHBvcnRzLlBvbGxpbmcgPSBQb2xsaW5nO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLldlYlNvY2tldCA9IHZvaWQgMDtcbmNvbnN0IHRyYW5zcG9ydF8xID0gcmVxdWlyZShcIi4uL3RyYW5zcG9ydFwiKTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwiZW5naW5lOndzXCIpO1xuY2xhc3MgV2ViU29ja2V0IGV4dGVuZHMgdHJhbnNwb3J0XzEuVHJhbnNwb3J0IHtcbiAgICAvKipcbiAgICAgKiBXZWJTb2NrZXQgdHJhbnNwb3J0XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfVxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmVxKSB7XG4gICAgICAgIHN1cGVyKHJlcSk7XG4gICAgICAgIHRoaXMuc29ja2V0ID0gcmVxLndlYnNvY2tldDtcbiAgICAgICAgdGhpcy5zb2NrZXQub24oXCJtZXNzYWdlXCIsIChkYXRhLCBpc0JpbmFyeSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IGlzQmluYXJ5ID8gZGF0YSA6IGRhdGEudG9TdHJpbmcoKTtcbiAgICAgICAgICAgIGRlYnVnKCdyZWNlaXZlZCBcIiVzXCInLCBtZXNzYWdlKTtcbiAgICAgICAgICAgIHN1cGVyLm9uRGF0YShtZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uY2UoXCJjbG9zZVwiLCB0aGlzLm9uQ2xvc2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc29ja2V0Lm9uKFwiZXJyb3JcIiwgdGhpcy5vbkVycm9yLmJpbmQodGhpcykpO1xuICAgICAgICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSA9IG51bGw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBuYW1lXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gXCJ3ZWJzb2NrZXRcIjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWR2ZXJ0aXNlIHVwZ3JhZGUgc3VwcG9ydC5cbiAgICAgKlxuICAgICAqIEBhcGkgcHVibGljXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXNVcGdyYWRlcygpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkdmVydGlzZSBmcmFtaW5nIHN1cHBvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBzdXBwb3J0c0ZyYW1pbmcoKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQgcGF5bG9hZC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhY2tldHNcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBzZW5kKHBhY2tldHMpIHtcbiAgICAgICAgY29uc3QgcGFja2V0ID0gcGFja2V0cy5zaGlmdCgpO1xuICAgICAgICBpZiAodHlwZW9mIHBhY2tldCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBhbHdheXMgY3JlYXRlcyBhIG5ldyBvYmplY3Qgc2luY2Ugd3MgbW9kaWZpZXMgaXRcbiAgICAgICAgY29uc3Qgb3B0cyA9IHt9O1xuICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgIG9wdHMuY29tcHJlc3MgPSBwYWNrZXQub3B0aW9ucy5jb21wcmVzcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZW5kID0gZGF0YSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5wZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxlbiA9IFwic3RyaW5nXCIgPT09IHR5cGVvZiBkYXRhID8gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSkgOiBkYXRhLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBpZiAobGVuIDwgdGhpcy5wZXJNZXNzYWdlRGVmbGF0ZS50aHJlc2hvbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgb3B0cy5jb21wcmVzcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlYnVnKCd3cml0aW5nIFwiJXNcIicsIGRhdGEpO1xuICAgICAgICAgICAgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXQuc2VuZChkYXRhLCBvcHRzLCBlcnIgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm9uRXJyb3IoXCJ3cml0ZSBlcnJvclwiLCBlcnIuc3RhY2spO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChwYWNrZXRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAocGFja2V0Lm9wdGlvbnMgJiYgdHlwZW9mIHBhY2tldC5vcHRpb25zLndzUHJlRW5jb2RlZCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2VuZChwYWNrZXQub3B0aW9ucy53c1ByZUVuY29kZWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYXJzZXIuZW5jb2RlUGFja2V0KHBhY2tldCwgdGhpcy5zdXBwb3J0c0JpbmFyeSwgc2VuZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB0cmFuc3BvcnQuXG4gICAgICpcbiAgICAgKiBAYXBpIHByaXZhdGVcbiAgICAgKi9cbiAgICBkb0Nsb3NlKGZuKSB7XG4gICAgICAgIGRlYnVnKFwiY2xvc2luZ1wiKTtcbiAgICAgICAgdGhpcy5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgZm4gJiYgZm4oKTtcbiAgICB9XG59XG5leHBvcnRzLldlYlNvY2tldCA9IFdlYlNvY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy51U2VydmVyID0gdm9pZCAwO1xuY29uc3QgZGVidWdfMSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHNlcnZlcl8xID0gcmVxdWlyZShcIi4vc2VydmVyXCIpO1xuY29uc3QgdHJhbnNwb3J0c191d3NfMSA9IHJlcXVpcmUoXCIuL3RyYW5zcG9ydHMtdXdzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgZGVidWdfMS5kZWZhdWx0KShcImVuZ2luZTp1d3NcIik7XG5jbGFzcyB1U2VydmVyIGV4dGVuZHMgc2VydmVyXzEuQmFzZVNlcnZlciB7XG4gICAgaW5pdCgpIHsgfVxuICAgIGNsZWFudXAoKSB7IH1cbiAgICAvKipcbiAgICAgKiBQcmVwYXJlcyBhIHJlcXVlc3QgYnkgcHJvY2Vzc2luZyB0aGUgcXVlcnkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQGFwaSBwcml2YXRlXG4gICAgICovXG4gICAgcHJlcGFyZShyZXEsIHJlcykge1xuICAgICAgICByZXEubWV0aG9kID0gcmVxLmdldE1ldGhvZCgpLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMocmVxLmdldFF1ZXJ5KCkpO1xuICAgICAgICByZXEuX3F1ZXJ5ID0gT2JqZWN0LmZyb21FbnRyaWVzKHBhcmFtcy5lbnRyaWVzKCkpO1xuICAgICAgICByZXEuaGVhZGVycyA9IHt9O1xuICAgICAgICByZXEuZm9yRWFjaCgoa2V5LCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgcmVxLmhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVxLmNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICByZW1vdGVBZGRyZXNzOiBCdWZmZXIuZnJvbShyZXMuZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCgpKS50b1N0cmluZygpXG4gICAgICAgIH07XG4gICAgICAgIHJlcy5vbkFib3J0ZWQoKCkgPT4ge1xuICAgICAgICAgICAgZGVidWcoXCJyZXNwb25zZSBoYXMgYmVlbiBhYm9ydGVkXCIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNwb3J0KHRyYW5zcG9ydE5hbWUsIHJlcSkge1xuICAgICAgICByZXR1cm4gbmV3IHRyYW5zcG9ydHNfdXdzXzEuZGVmYXVsdFt0cmFuc3BvcnROYW1lXShyZXEpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2ggdGhlIGVuZ2luZSB0byBhIMK1V2ViU29ja2V0cy5qcyBzZXJ2ZXJcbiAgICAgKiBAcGFyYW0gYXBwXG4gICAgICogQHBhcmFtIG9wdGlvbnNcbiAgICAgKi9cbiAgICBhdHRhY2goYXBwIC8qIDogVGVtcGxhdGVkQXBwICovLCBvcHRpb25zID0ge30pIHtcbiAgICAgICAgY29uc3QgcGF0aCA9IChvcHRpb25zLnBhdGggfHwgXCIvZW5naW5lLmlvXCIpLnJlcGxhY2UoL1xcLyQvLCBcIlwiKSArIFwiL1wiO1xuICAgICAgICBhcHBcbiAgICAgICAgICAgIC5hbnkocGF0aCwgdGhpcy5oYW5kbGVSZXF1ZXN0LmJpbmQodGhpcykpXG4gICAgICAgICAgICAvL1xuICAgICAgICAgICAgLndzKHBhdGgsIHtcbiAgICAgICAgICAgIGNvbXByZXNzaW9uOiBvcHRpb25zLmNvbXByZXNzaW9uLFxuICAgICAgICAgICAgaWRsZVRpbWVvdXQ6IG9wdGlvbnMuaWRsZVRpbWVvdXQsXG4gICAgICAgICAgICBtYXhCYWNrcHJlc3N1cmU6IG9wdGlvbnMubWF4QmFja3ByZXNzdXJlLFxuICAgICAgICAgICAgbWF4UGF5bG9hZExlbmd0aDogdGhpcy5vcHRzLm1heEh0dHBCdWZmZXJTaXplLFxuICAgICAgICAgICAgdXBncmFkZTogdGhpcy5oYW5kbGVVcGdyYWRlLmJpbmQodGhpcyksXG4gICAgICAgICAgICBvcGVuOiB3cyA9PiB7XG4gICAgICAgICAgICAgICAgd3MudHJhbnNwb3J0LnNvY2tldCA9IHdzO1xuICAgICAgICAgICAgICAgIHdzLnRyYW5zcG9ydC53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgd3MudHJhbnNwb3J0LmVtaXQoXCJkcmFpblwiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZXNzYWdlOiAod3MsIG1lc3NhZ2UsIGlzQmluYXJ5KSA9PiB7XG4gICAgICAgICAgICAgICAgd3MudHJhbnNwb3J0Lm9uRGF0YShpc0JpbmFyeSA/IG1lc3NhZ2UgOiBCdWZmZXIuZnJvbShtZXNzYWdlKS50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZTogKHdzLCBjb2RlLCBtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICAgICAgd3MudHJhbnNwb3J0Lm9uQ2xvc2UoY29kZSwgbWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBoYW5kbGVSZXF1ZXN0KHJlcywgcmVxKSB7XG4gICAgICAgIGRlYnVnKCdoYW5kbGluZyBcIiVzXCIgaHR0cCByZXF1ZXN0IFwiJXNcIicsIHJlcS5nZXRNZXRob2QoKSwgcmVxLmdldFVybCgpKTtcbiAgICAgICAgdGhpcy5wcmVwYXJlKHJlcSwgcmVzKTtcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgY29uc3QgY2FsbGJhY2sgPSAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImNvbm5lY3Rpb25fZXJyb3JcIiwge1xuICAgICAgICAgICAgICAgICAgICByZXEsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IGVycm9yQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogc2VydmVyXzEuU2VydmVyLmVycm9yTWVzc2FnZXNbZXJyb3JDb2RlXSxcbiAgICAgICAgICAgICAgICAgICAgY29udGV4dDogZXJyb3JDb250ZXh0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5hYm9ydFJlcXVlc3QocmVxLnJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXEuX3F1ZXJ5LnNpZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic2V0dGluZyBuZXcgcmVxdWVzdCBmb3IgZXhpc3RpbmcgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xpZW50c1tyZXEuX3F1ZXJ5LnNpZF0udHJhbnNwb3J0Lm9uUmVxdWVzdChyZXEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xvc2VDb25uZWN0aW9uID0gKGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KSA9PiB0aGlzLmFib3J0UmVxdWVzdChyZXMsIGVycm9yQ29kZSwgZXJyb3JDb250ZXh0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCBjbG9zZUNvbm5lY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5jb3JzTWlkZGxld2FyZSkge1xuICAgICAgICAgICAgLy8gbmVlZGVkIHRvIGJ1ZmZlciBoZWFkZXJzIHVudGlsIHRoZSBzdGF0dXMgaXMgY29tcHV0ZWRcbiAgICAgICAgICAgIHJlcS5yZXMgPSBuZXcgUmVzcG9uc2VXcmFwcGVyKHJlcyk7XG4gICAgICAgICAgICB0aGlzLmNvcnNNaWRkbGV3YXJlLmNhbGwobnVsbCwgcmVxLCByZXEucmVzLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52ZXJpZnkocmVxLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnZlcmlmeShyZXEsIGZhbHNlLCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaGFuZGxlVXBncmFkZShyZXMsIHJlcSwgY29udGV4dCkge1xuICAgICAgICBkZWJ1ZyhcIm9uIHVwZ3JhZGVcIik7XG4gICAgICAgIHRoaXMucHJlcGFyZShyZXEsIHJlcyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmVxLnJlcyA9IHJlcztcbiAgICAgICAgdGhpcy52ZXJpZnkocmVxLCB0cnVlLCBhc3luYyAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnJvckNvZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uX2Vycm9yXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgcmVxLFxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHQ6IGVycm9yQ29udGV4dFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGlkID0gcmVxLl9xdWVyeS5zaWQ7XG4gICAgICAgICAgICBsZXQgdHJhbnNwb3J0O1xuICAgICAgICAgICAgaWYgKGlkKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2xpZW50ID0gdGhpcy5jbGllbnRzW2lkXTtcbiAgICAgICAgICAgICAgICBpZiAoIWNsaWVudCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInVwZ3JhZGUgYXR0ZW1wdCBmb3IgY2xvc2VkIGNsaWVudFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJ0cmFuc3BvcnQgaGFzIGFscmVhZHkgYmVlbiB0cnlpbmcgdG8gdXBncmFkZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNsaWVudC51cGdyYWRlZCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInRyYW5zcG9ydCBoYWQgYWxyZWFkeSBiZWVuIHVwZ3JhZGVkXCIpO1xuICAgICAgICAgICAgICAgICAgICByZXMuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwidXBncmFkaW5nIGV4aXN0aW5nIHRyYW5zcG9ydFwiKTtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0ID0gdGhpcy5jcmVhdGVUcmFuc3BvcnQocmVxLl9xdWVyeS50cmFuc3BvcnQsIHJlcSk7XG4gICAgICAgICAgICAgICAgICAgIGNsaWVudC5tYXliZVVwZ3JhZGUodHJhbnNwb3J0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQgPSBhd2FpdCB0aGlzLmhhbmRzaGFrZShyZXEuX3F1ZXJ5LnRyYW5zcG9ydCwgcmVxLCAoZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpID0+IHRoaXMuYWJvcnRSZXF1ZXN0KHJlcywgZXJyb3JDb2RlLCBlcnJvckNvbnRleHQpKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzLnVwZ3JhZGUoe1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydFxuICAgICAgICAgICAgfSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQta2V5XCIpLCByZXEuZ2V0SGVhZGVyKFwic2VjLXdlYnNvY2tldC1wcm90b2NvbFwiKSwgcmVxLmdldEhlYWRlcihcInNlYy13ZWJzb2NrZXQtZXh0ZW5zaW9uc1wiKSwgY29udGV4dCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhYm9ydFJlcXVlc3QocmVzLCBlcnJvckNvZGUsIGVycm9yQ29udGV4dCkge1xuICAgICAgICBjb25zdCBzdGF0dXNDb2RlID0gZXJyb3JDb2RlID09PSBzZXJ2ZXJfMS5TZXJ2ZXIuZXJyb3JzLkZPUkJJRERFTlxuICAgICAgICAgICAgPyBcIjQwMyBGb3JiaWRkZW5cIlxuICAgICAgICAgICAgOiBcIjQwMCBCYWQgUmVxdWVzdFwiO1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gZXJyb3JDb250ZXh0ICYmIGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgICAgICA/IGVycm9yQ29udGV4dC5tZXNzYWdlXG4gICAgICAgICAgICA6IHNlcnZlcl8xLlNlcnZlci5lcnJvck1lc3NhZ2VzW2Vycm9yQ29kZV07XG4gICAgICAgIHJlcy53cml0ZVN0YXR1cyhzdGF0dXNDb2RlKTtcbiAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vanNvblwiKTtcbiAgICAgICAgcmVzLmVuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBjb2RlOiBlcnJvckNvZGUsXG4gICAgICAgICAgICBtZXNzYWdlXG4gICAgICAgIH0pKTtcbiAgICB9XG59XG5leHBvcnRzLnVTZXJ2ZXIgPSB1U2VydmVyO1xuY2xhc3MgUmVzcG9uc2VXcmFwcGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZXMpIHtcbiAgICAgICAgdGhpcy5yZXMgPSByZXM7XG4gICAgICAgIHRoaXMuc3RhdHVzV3JpdHRlbiA9IGZhbHNlO1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSBbXTtcbiAgICB9XG4gICAgc2V0IHN0YXR1c0NvZGUoc3RhdHVzKSB7XG4gICAgICAgIHRoaXMud3JpdGVTdGF0dXMoc3RhdHVzID09PSAyMDAgPyBcIjIwMCBPS1wiIDogXCIyMDQgTm8gQ29udGVudFwiKTtcbiAgICB9XG4gICAgc2V0SGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgdGhpcy53cml0ZUhlYWRlcihrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgLy8gbmVlZGVkIGJ5IHZhcnk6IGh0dHBzOi8vZ2l0aHViLmNvbS9qc2h0dHAvdmFyeS9ibG9iLzVkNzI1ZDA1OWIzODcxMDI1Y2Y3NTNlOWRmYTA4OTI0ZDBiY2ZhOGYvaW5kZXguanMjTDEzNFxuICAgIGdldEhlYWRlcigpIHsgfVxuICAgIHdyaXRlU3RhdHVzKHN0YXR1cykge1xuICAgICAgICB0aGlzLnJlcy53cml0ZVN0YXR1cyhzdGF0dXMpO1xuICAgICAgICB0aGlzLnN0YXR1c1dyaXR0ZW4gPSB0cnVlO1xuICAgICAgICB0aGlzLndyaXRlQnVmZmVyZWRIZWFkZXJzKCk7XG4gICAgfVxuICAgIHdyaXRlSGVhZGVyKGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGtleSA9PT0gXCJDb250ZW50LUxlbmd0aFwiKSB7XG4gICAgICAgICAgICAvLyB0aGUgY29udGVudCBsZW5ndGggaXMgYXV0b21hdGljYWxseSBhZGRlZCBieSB1V2ViU29ja2V0cy5qc1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1c1dyaXR0ZW4pIHtcbiAgICAgICAgICAgIHRoaXMucmVzLndyaXRlSGVhZGVyKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkZXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB3cml0ZUJ1ZmZlcmVkSGVhZGVycygpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXMud3JpdGVIZWFkZXIoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbmQoZGF0YSkge1xuICAgICAgICBpZiAoIXRoaXMuc3RhdHVzV3JpdHRlbikge1xuICAgICAgICAgICAgLy8gc3RhdHVzIHdpbGwgYmUgaW5mZXJyZWQgYXMgXCIyMDAgT0tcIlxuICAgICAgICAgICAgdGhpcy53cml0ZUJ1ZmZlcmVkSGVhZGVycygpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVzLmVuZChkYXRhKTtcbiAgICB9XG4gICAgb25EYXRhKGZuKSB7XG4gICAgICAgIHRoaXMucmVzLm9uRGF0YShmbik7XG4gICAgfVxuICAgIG9uQWJvcnRlZChmbikge1xuICAgICAgICB0aGlzLnJlcy5vbkFib3J0ZWQoZm4pO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5SZW1vdGVTb2NrZXQgPSBleHBvcnRzLkJyb2FkY2FzdE9wZXJhdG9yID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5jb25zdCBzb2NrZXRfaW9fcGFyc2VyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLXBhcnNlclwiKTtcbmNsYXNzIEJyb2FkY2FzdE9wZXJhdG9yIHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyLCByb29tcyA9IG5ldyBTZXQoKSwgZXhjZXB0Um9vbXMgPSBuZXcgU2V0KCksIGZsYWdzID0ge30pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gYWRhcHRlcjtcbiAgICAgICAgdGhpcy5yb29tcyA9IHJvb21zO1xuICAgICAgICB0aGlzLmV4Y2VwdFJvb21zID0gZXhjZXB0Um9vbXM7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSBmbGFncztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBhIG5ldyBCcm9hZGNhc3RPcGVyYXRvciBpbnN0YW5jZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIGNvbnN0IHJvb21zID0gbmV3IFNldCh0aGlzLnJvb21zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm9vbSkpIHtcbiAgICAgICAgICAgIHJvb20uZm9yRWFjaCgocikgPT4gcm9vbXMuYWRkKHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJvb21zLmFkZChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgcm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUYXJnZXRzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEV4Y2x1ZGVzIGEgcm9vbSB3aGVuIGVtaXR0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIGNvbnN0IGV4Y2VwdFJvb21zID0gbmV3IFNldCh0aGlzLmV4Y2VwdFJvb21zKTtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocm9vbSkpIHtcbiAgICAgICAgICAgIHJvb20uZm9yRWFjaCgocikgPT4gZXhjZXB0Um9vbXMuYWRkKHIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGV4Y2VwdFJvb21zLmFkZChyb29tKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgZXhjZXB0Um9vbXMsIHRoaXMuZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBjb21wcmVzcyBmbGFnLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvbXByZXNzIC0gaWYgYHRydWVgLCBjb21wcmVzc2VzIHRoZSBzZW5kaW5nIGRhdGFcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNvbXByZXNzKGNvbXByZXNzKSB7XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncywgeyBjb21wcmVzcyB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBCcm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIsIHRoaXMucm9vbXMsIHRoaXMuZXhjZXB0Um9vbXMsIGZsYWdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIGEgbmV3IEJyb2FkY2FzdE9wZXJhdG9yIGluc3RhbmNlXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCB2b2xhdGlsZSgpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzLCB7IHZvbGF0aWxlOiB0cnVlIH0pO1xuICAgICAgICByZXR1cm4gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgdGhpcy5yb29tcywgdGhpcy5leGNlcHRSb29tcywgZmxhZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gYSBuZXcgQnJvYWRjYXN0T3BlcmF0b3IgaW5zdGFuY2VcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICBjb25zdCBmbGFncyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmxhZ3MsIHsgbG9jYWw6IHRydWUgfSk7XG4gICAgICAgIHJldHVybiBuZXcgQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyLCB0aGlzLnJvb21zLCB0aGlzLmV4Y2VwdFJvb21zLCBmbGFncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgdHJ1ZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIGlmIChzb2NrZXRfMS5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZXZ9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc2V0IHVwIHBhY2tldCBvYmplY3RcbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYWxsYmFja3MgYXJlIG5vdCBzdXBwb3J0ZWQgd2hlbiBicm9hZGNhc3RpbmdcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5hZGFwdGVyLmJyb2FkY2FzdChwYWNrZXQsIHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICAgICAgZmxhZ3M6IHRoaXMuZmxhZ3MsXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0cyBhIGxpc3Qgb2YgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBhbGxTb2NrZXRzKCkge1xuICAgICAgICBpZiAoIXRoaXMuYWRhcHRlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gYWRhcHRlciBmb3IgdGhpcyBuYW1lc3BhY2UsIGFyZSB5b3UgdHJ5aW5nIHRvIGdldCB0aGUgbGlzdCBvZiBjbGllbnRzIG9mIGEgZHluYW1pYyBuYW1lc3BhY2U/XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuc29ja2V0cyh0aGlzLnJvb21zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlc1xuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGZldGNoU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlclxuICAgICAgICAgICAgLmZldGNoU29ja2V0cyh7XG4gICAgICAgICAgICByb29tczogdGhpcy5yb29tcyxcbiAgICAgICAgICAgIGV4Y2VwdDogdGhpcy5leGNlcHRSb29tcyxcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC50aGVuKChzb2NrZXRzKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gc29ja2V0cy5tYXAoKHNvY2tldCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChzb2NrZXQgaW5zdGFuY2VvZiBzb2NrZXRfMS5Tb2NrZXQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRklYTUUgdGhlIFR5cGVTY3JpcHQgY29tcGlsZXIgY29tcGxhaW5zIGFib3V0IG1pc3NpbmcgcHJpdmF0ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzb2NrZXQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFJlbW90ZVNvY2tldCh0aGlzLmFkYXB0ZXIsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBqb2luIHRoZSBzcGVjaWZpZWQgcm9vbXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHNvY2tldHNKb2luKHJvb20pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmFkZFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgIH0sIEFycmF5LmlzQXJyYXkocm9vbSkgPyByb29tIDogW3Jvb21dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRlbFNvY2tldHMoe1xuICAgICAgICAgICAgcm9vbXM6IHRoaXMucm9vbXMsXG4gICAgICAgICAgICBleGNlcHQ6IHRoaXMuZXhjZXB0Um9vbXMsXG4gICAgICAgIH0sIEFycmF5LmlzQXJyYXkocm9vbSkgPyByb29tIDogW3Jvb21dKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyLmRpc2Nvbm5lY3RTb2NrZXRzKHtcbiAgICAgICAgICAgIHJvb21zOiB0aGlzLnJvb21zLFxuICAgICAgICAgICAgZXhjZXB0OiB0aGlzLmV4Y2VwdFJvb21zLFxuICAgICAgICB9LCBjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5Ccm9hZGNhc3RPcGVyYXRvciA9IEJyb2FkY2FzdE9wZXJhdG9yO1xuLyoqXG4gKiBFeHBvc2Ugb2Ygc3Vic2V0IG9mIHRoZSBhdHRyaWJ1dGVzIGFuZCBtZXRob2RzIG9mIHRoZSBTb2NrZXQgY2xhc3NcbiAqL1xuY2xhc3MgUmVtb3RlU29ja2V0IHtcbiAgICBjb25zdHJ1Y3RvcihhZGFwdGVyLCBkZXRhaWxzKSB7XG4gICAgICAgIHRoaXMuaWQgPSBkZXRhaWxzLmlkO1xuICAgICAgICB0aGlzLmhhbmRzaGFrZSA9IGRldGFpbHMuaGFuZHNoYWtlO1xuICAgICAgICB0aGlzLnJvb21zID0gbmV3IFNldChkZXRhaWxzLnJvb21zKTtcbiAgICAgICAgdGhpcy5kYXRhID0gZGV0YWlscy5kYXRhO1xuICAgICAgICB0aGlzLm9wZXJhdG9yID0gbmV3IEJyb2FkY2FzdE9wZXJhdG9yKGFkYXB0ZXIsIG5ldyBTZXQoW3RoaXMuaWRdKSk7XG4gICAgfVxuICAgIGVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3IuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEpvaW5zIGEgcm9vbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfEFycmF5fSByb29tIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBqb2luKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub3BlcmF0b3Iuc29ja2V0c0pvaW4ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExlYXZlcyBhIHJvb20uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ30gcm9vbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBsZWF2ZShyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9wZXJhdG9yLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Jvb2xlYW59IGNsb3NlIC0gaWYgYHRydWVgLCBjbG9zZXMgdGhlIHVuZGVybHlpbmcgY29ubmVjdGlvblxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QoY2xvc2UgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLm9wZXJhdG9yLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5SZW1vdGVTb2NrZXQgPSBSZW1vdGVTb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2xpZW50ID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX3BhcnNlcl8xID0gcmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIik7XG5jb25zdCBkZWJ1Z01vZHVsZSA9IHJlcXVpcmUoXCJkZWJ1Z1wiKTtcbmNvbnN0IHVybCA9IHJlcXVpcmUoXCJ1cmxcIik7XG5jb25zdCBkZWJ1ZyA9IGRlYnVnTW9kdWxlKFwic29ja2V0LmlvOmNsaWVudFwiKTtcbmNsYXNzIENsaWVudCB7XG4gICAgLyoqXG4gICAgICogQ2xpZW50IGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHNlcnZlciBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb25uXG4gICAgICogQHBhY2thZ2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIGNvbm4pIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLm5zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuc2VydmVyID0gc2VydmVyO1xuICAgICAgICB0aGlzLmNvbm4gPSBjb25uO1xuICAgICAgICB0aGlzLmVuY29kZXIgPSBzZXJ2ZXIuZW5jb2RlcjtcbiAgICAgICAgdGhpcy5kZWNvZGVyID0gbmV3IHNlcnZlci5fcGFyc2VyLkRlY29kZXIoKTtcbiAgICAgICAgdGhpcy5pZCA9IGNvbm4uaWQ7XG4gICAgICAgIHRoaXMuc2V0dXAoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybiB0aGUgcmVmZXJlbmNlIHRvIHRoZSByZXF1ZXN0IHRoYXQgb3JpZ2luYXRlZCB0aGUgRW5naW5lLklPIGNvbm5lY3Rpb25cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29ubi5yZXF1ZXN0O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIGV2ZW50IGxpc3RlbmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc2V0dXAoKSB7XG4gICAgICAgIHRoaXMub25jbG9zZSA9IHRoaXMub25jbG9zZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZGF0YSA9IHRoaXMub25kYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMub25lcnJvciA9IHRoaXMub25lcnJvci5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLm9uZGVjb2RlZCA9IHRoaXMub25kZWNvZGVkLmJpbmQodGhpcyk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kZWNvZGVyLm9uKFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZCk7XG4gICAgICAgIHRoaXMuY29ubi5vbihcImRhdGFcIiwgdGhpcy5vbmRhdGEpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJlcnJvclwiLCB0aGlzLm9uZXJyb3IpO1xuICAgICAgICB0aGlzLmNvbm4ub24oXCJjbG9zZVwiLCB0aGlzLm9uY2xvc2UpO1xuICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5uc3BzLnNpemUgPT09IDApIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIm5vIG5hbWVzcGFjZSBqb2luZWQgeWV0LCBjbG9zZSB0aGUgY2xpZW50XCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwidGhlIGNsaWVudCBoYXMgYWxyZWFkeSBqb2luZWQgYSBuYW1lc3BhY2UsIG5vdGhpbmcgdG8gZG9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHRoaXMuc2VydmVyLl9jb25uZWN0VGltZW91dCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSB0aGUgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBjb25uZWN0KG5hbWUsIGF1dGggPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5zZXJ2ZXIuX25zcHMuaGFzKG5hbWUpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3RpbmcgdG8gbmFtZXNwYWNlICVzXCIsIG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZG9Db25uZWN0KG5hbWUsIGF1dGgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2VydmVyLl9jaGVja05hbWVzcGFjZShuYW1lLCBhdXRoLCAoZHluYW1pY05zcE5hbWUpID0+IHtcbiAgICAgICAgICAgIGlmIChkeW5hbWljTnNwTmFtZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9Db25uZWN0KG5hbWUsIGF1dGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJjcmVhdGlvbiBvZiBuYW1lc3BhY2UgJXMgd2FzIGRlbmllZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYWNrZXQoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5DT05ORUNUX0VSUk9SLFxuICAgICAgICAgICAgICAgICAgICBuc3A6IG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBuYW1lc3BhY2VcIixcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENvbm5lY3RzIGEgY2xpZW50IHRvIGEgbmFtZXNwYWNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIG5hbWUgLSB0aGUgbmFtZXNwYWNlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGF1dGggLSB0aGUgYXV0aCBwYXJhbWV0ZXJzXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGRvQ29ubmVjdChuYW1lLCBhdXRoKSB7XG4gICAgICAgIGNvbnN0IG5zcCA9IHRoaXMuc2VydmVyLm9mKG5hbWUpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSBuc3AuX2FkZCh0aGlzLCBhdXRoLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNvY2tldHMuc2V0KHNvY2tldC5pZCwgc29ja2V0KTtcbiAgICAgICAgICAgIHRoaXMubnNwcy5zZXQobnNwLm5hbWUsIHNvY2tldCk7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uZWN0VGltZW91dCkge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLmNvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdHMgZnJvbSBhbGwgbmFtZXNwYWNlcyBhbmQgY2xvc2VzIHRyYW5zcG9ydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2Rpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc29ja2V0LiBDYWxsZWQgYnkgZWFjaCBgU29ja2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3JlbW92ZShzb2NrZXQpIHtcbiAgICAgICAgaWYgKHRoaXMuc29ja2V0cy5oYXMoc29ja2V0LmlkKSkge1xuICAgICAgICAgICAgY29uc3QgbnNwID0gdGhpcy5zb2NrZXRzLmdldChzb2NrZXQuaWQpLm5zcC5uYW1lO1xuICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmRlbGV0ZShzb2NrZXQuaWQpO1xuICAgICAgICAgICAgdGhpcy5uc3BzLmRlbGV0ZShuc3ApO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJpZ25vcmluZyByZW1vdmUgZm9yICVzXCIsIHNvY2tldC5pZCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2xvc2VzIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAoXCJvcGVuXCIgPT09IHRoaXMuY29ubi5yZWFkeVN0YXRlKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImZvcmNpbmcgdHJhbnNwb3J0IGNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgICAgICAgICB0aGlzLm9uY2xvc2UoXCJmb3JjZWQgc2VydmVyIGNsb3NlXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdyaXRlcyBhIHBhY2tldCB0byB0aGUgdHJhbnNwb3J0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHBhY2tldCBvYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0c1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX3BhY2tldChwYWNrZXQsIG9wdHMgPSB7fSkge1xuICAgICAgICBpZiAodGhpcy5jb25uLnJlYWR5U3RhdGUgIT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcImlnbm9yaW5nIHBhY2tldCB3cml0ZSAlalwiLCBwYWNrZXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gb3B0cy5wcmVFbmNvZGVkXG4gICAgICAgICAgICA/IHBhY2tldCAvLyBwcmV2aW91cyB2ZXJzaW9ucyBvZiB0aGUgYWRhcHRlciBpbmNvcnJlY3RseSB1c2VkIHNvY2tldC5wYWNrZXQoKSBpbnN0ZWFkIG9mIHdyaXRlVG9FbmdpbmUoKVxuICAgICAgICAgICAgOiB0aGlzLmVuY29kZXIuZW5jb2RlKHBhY2tldCk7XG4gICAgICAgIHRoaXMud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgb3B0cyk7XG4gICAgfVxuICAgIHdyaXRlVG9FbmdpbmUoZW5jb2RlZFBhY2tldHMsIG9wdHMpIHtcbiAgICAgICAgaWYgKG9wdHMudm9sYXRpbGUgJiYgIXRoaXMuY29ubi50cmFuc3BvcnQud3JpdGFibGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwidm9sYXRpbGUgcGFja2V0IGlzIGRpc2NhcmRlZCBzaW5jZSB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjdXJyZW50bHkgd3JpdGFibGVcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFja2V0cyA9IEFycmF5LmlzQXJyYXkoZW5jb2RlZFBhY2tldHMpXG4gICAgICAgICAgICA/IGVuY29kZWRQYWNrZXRzXG4gICAgICAgICAgICA6IFtlbmNvZGVkUGFja2V0c107XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2RlZFBhY2tldCBvZiBwYWNrZXRzKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm4ud3JpdGUoZW5jb2RlZFBhY2tldCwgb3B0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggaW5jb21pbmcgdHJhbnNwb3J0IGRhdGEuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGF0YShkYXRhKSB7XG4gICAgICAgIC8vIHRyeS9jYXRjaCBpcyBuZWVkZWQgZm9yIHByb3RvY29sIHZpb2xhdGlvbnMgKEdILTE4ODApXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLmRlY29kZXIuYWRkKGRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLm9uZXJyb3IoZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gcGFyc2VyIGZ1bGx5IGRlY29kZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZGVjb2RlZChwYWNrZXQpIHtcbiAgICAgICAgaWYgKHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QgPT09IHBhY2tldC50eXBlKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGFyc2VkID0gdXJsLnBhcnNlKHBhY2tldC5uc3AsIHRydWUpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdChwYXJzZWQucGF0aG5hbWUsIHBhcnNlZC5xdWVyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3QocGFja2V0Lm5zcCwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc29ja2V0ID0gdGhpcy5uc3BzLmdldChwYWNrZXQubnNwKTtcbiAgICAgICAgICAgIGlmIChzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0Ll9vbnBhY2tldChwYWNrZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJubyBzb2NrZXQgZm9yIG5hbWVzcGFjZSAlc1wiLCBwYWNrZXQubnNwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciBvYmplY3RcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uZXJyb3IoZXJyKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgc29ja2V0Ll9vbmVycm9yKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25uLmNsb3NlKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIHRyYW5zcG9ydCBjbG9zZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByZWFzb25cbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uY2xvc2UocmVhc29uKSB7XG4gICAgICAgIGRlYnVnKFwiY2xpZW50IGNsb3NlIHdpdGggcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIC8vIGlnbm9yZSBhIHBvdGVudGlhbCBzdWJzZXF1ZW50IGBjbG9zZWAgZXZlbnRcbiAgICAgICAgdGhpcy5kZXN0cm95KCk7XG4gICAgICAgIC8vIGBuc3BzYCBhbmQgYHNvY2tldHNgIGFyZSBjbGVhbmVkIHVwIHNlYW1sZXNzbHlcbiAgICAgICAgZm9yIChjb25zdCBzb2NrZXQgb2YgdGhpcy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UocmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNvY2tldHMuY2xlYXIoKTtcbiAgICAgICAgdGhpcy5kZWNvZGVyLmRlc3Ryb3koKTsgLy8gY2xlYW4gdXAgZGVjb2RlclxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbGVhbnMgdXAgZXZlbnQgbGlzdGVuZXJzLlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5jb25uLnJlbW92ZUxpc3RlbmVyKFwiZGF0YVwiLCB0aGlzLm9uZGF0YSk7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImVycm9yXCIsIHRoaXMub25lcnJvcik7XG4gICAgICAgIHRoaXMuY29ubi5yZW1vdmVMaXN0ZW5lcihcImNsb3NlXCIsIHRoaXMub25jbG9zZSk7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5kZWNvZGVyLnJlbW92ZUxpc3RlbmVyKFwiZGVjb2RlZFwiLCB0aGlzLm9uZGVjb2RlZCk7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5jb25uZWN0VGltZW91dCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RUaW1lb3V0ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DbGllbnQgPSBDbGllbnQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5OYW1lc3BhY2UgPSBleHBvcnRzLlNvY2tldCA9IGV4cG9ydHMuU2VydmVyID0gdm9pZCAwO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoXCJodHRwXCIpO1xuY29uc3QgZnNfMSA9IHJlcXVpcmUoXCJmc1wiKTtcbmNvbnN0IHpsaWJfMSA9IHJlcXVpcmUoXCJ6bGliXCIpO1xuY29uc3QgYWNjZXB0cyA9IHJlcXVpcmUoXCJhY2NlcHRzXCIpO1xuY29uc3Qgc3RyZWFtXzEgPSByZXF1aXJlKFwic3RyZWFtXCIpO1xuY29uc3QgcGF0aCA9IHJlcXVpcmUoXCJwYXRoXCIpO1xuY29uc3QgZW5naW5lX2lvXzEgPSByZXF1aXJlKFwiZW5naW5lLmlvXCIpO1xuY29uc3QgY2xpZW50XzEgPSByZXF1aXJlKFwiLi9jbGllbnRcIik7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIk5hbWVzcGFjZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbmFtZXNwYWNlXzEuTmFtZXNwYWNlOyB9IH0pO1xuY29uc3QgcGFyZW50X25hbWVzcGFjZV8xID0gcmVxdWlyZShcIi4vcGFyZW50LW5hbWVzcGFjZVwiKTtcbmNvbnN0IHNvY2tldF9pb19hZGFwdGVyXzEgPSByZXF1aXJlKFwic29ja2V0LmlvLWFkYXB0ZXJcIik7XG5jb25zdCBwYXJzZXIgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNvY2tldC5pby1wYXJzZXJcIikpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3Qgc29ja2V0XzEgPSByZXF1aXJlKFwiLi9zb2NrZXRcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTb2NrZXRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHNvY2tldF8xLlNvY2tldDsgfSB9KTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgdXdzX2pzXzEgPSByZXF1aXJlKFwiLi91d3MuanNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOnNlcnZlclwiKTtcbmNvbnN0IGNsaWVudFZlcnNpb24gPSByZXF1aXJlKFwiLi4vcGFja2FnZS5qc29uXCIpLnZlcnNpb247XG5jb25zdCBkb3RNYXBSZWdleCA9IC9cXC5tYXAvO1xuY2xhc3MgU2VydmVyIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogQHByaXZhdGVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX25zcHMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMucGFyZW50TnNwcyA9IG5ldyBNYXAoKTtcbiAgICAgICAgaWYgKFwib2JqZWN0XCIgPT09IHR5cGVvZiBzcnYgJiZcbiAgICAgICAgICAgIHNydiBpbnN0YW5jZW9mIE9iamVjdCAmJlxuICAgICAgICAgICAgIXNydi5saXN0ZW4pIHtcbiAgICAgICAgICAgIG9wdHMgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wYXRoKG9wdHMucGF0aCB8fCBcIi9zb2NrZXQuaW9cIik7XG4gICAgICAgIHRoaXMuY29ubmVjdFRpbWVvdXQob3B0cy5jb25uZWN0VGltZW91dCB8fCA0NTAwMCk7XG4gICAgICAgIHRoaXMuc2VydmVDbGllbnQoZmFsc2UgIT09IG9wdHMuc2VydmVDbGllbnQpO1xuICAgICAgICB0aGlzLl9wYXJzZXIgPSBvcHRzLnBhcnNlciB8fCBwYXJzZXI7XG4gICAgICAgIHRoaXMuZW5jb2RlciA9IG5ldyB0aGlzLl9wYXJzZXIuRW5jb2RlcigpO1xuICAgICAgICB0aGlzLmFkYXB0ZXIob3B0cy5hZGFwdGVyIHx8IHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlcik7XG4gICAgICAgIHRoaXMuc29ja2V0cyA9IHRoaXMub2YoXCIvXCIpO1xuICAgICAgICB0aGlzLm9wdHMgPSBvcHRzO1xuICAgICAgICBpZiAoc3J2IHx8IHR5cGVvZiBzcnYgPT0gXCJudW1iZXJcIilcbiAgICAgICAgICAgIHRoaXMuYXR0YWNoKHNydik7XG4gICAgfVxuICAgIHNlcnZlQ2xpZW50KHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3NlcnZlQ2xpZW50O1xuICAgICAgICB0aGlzLl9zZXJ2ZUNsaWVudCA9IHY7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgbmFtZXNwYWNlIG5vdCBhbHJlYWR5IGNyZWF0ZWQgb24gdGhlIHNlcnZlci5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBuYW1lIC0gbmFtZSBvZiBpbmNvbWluZyBuYW1lc3BhY2VcbiAgICAgKiBAcGFyYW0gYXV0aCAtIHRoZSBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKiBAcGFyYW0gZm4gLSBjYWxsYmFja1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfY2hlY2tOYW1lc3BhY2UobmFtZSwgYXV0aCwgZm4pIHtcbiAgICAgICAgaWYgKHRoaXMucGFyZW50TnNwcy5zaXplID09PSAwKVxuICAgICAgICAgICAgcmV0dXJuIGZuKGZhbHNlKTtcbiAgICAgICAgY29uc3Qga2V5c0l0ZXJhdG9yID0gdGhpcy5wYXJlbnROc3BzLmtleXMoKTtcbiAgICAgICAgY29uc3QgcnVuID0gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV4dEZuID0ga2V5c0l0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChuZXh0Rm4uZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbihmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBuZXh0Rm4udmFsdWUobmFtZSwgYXV0aCwgKGVyciwgYWxsb3cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyIHx8ICFhbGxvdykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVuKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uc3BzLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbmFtZXNwYWNlIHdhcyBjcmVhdGVkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImR5bmFtaWMgbmFtZXNwYWNlICVzIGFscmVhZHkgZXhpc3RzXCIsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4odGhpcy5fbnNwcy5nZXQobmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBuYW1lc3BhY2UgPSB0aGlzLnBhcmVudE5zcHMuZ2V0KG5leHRGbi52YWx1ZSkuY3JlYXRlQ2hpbGQobmFtZSk7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJkeW5hbWljIG5hbWVzcGFjZSAlcyB3YXMgY3JlYXRlZFwiLCBuYW1lKTtcbiAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXRSZXNlcnZlZChcIm5ld19uYW1lc3BhY2VcIiwgbmFtZXNwYWNlKTtcbiAgICAgICAgICAgICAgICBmbihuYW1lc3BhY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHJ1bigpO1xuICAgIH1cbiAgICBwYXRoKHYpIHtcbiAgICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuX3BhdGggPSB2LnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbiAgICAgICAgY29uc3QgZXNjYXBlZFBhdGggPSB0aGlzLl9wYXRoLnJlcGxhY2UoL1stXFwvXFxcXF4kKis/LigpfFtcXF17fV0vZywgXCJcXFxcJCZcIik7XG4gICAgICAgIHRoaXMuY2xpZW50UGF0aFJlZ2V4ID0gbmV3IFJlZ0V4cChcIl5cIiArXG4gICAgICAgICAgICBlc2NhcGVkUGF0aCArXG4gICAgICAgICAgICBcIi9zb2NrZXRcXFxcLmlvKFxcXFwubXNncGFja3xcXFxcLmVzbSk/KFxcXFwubWluKT9cXFxcLmpzKFxcXFwubWFwKT8oPzpcXFxcP3wkKVwiKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIGNvbm5lY3RUaW1lb3V0KHYpIHtcbiAgICAgICAgaWYgKHYgPT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0VGltZW91dDtcbiAgICAgICAgdGhpcy5fY29ubmVjdFRpbWVvdXQgPSB2O1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRhcHRlcih2KSB7XG4gICAgICAgIGlmICghYXJndW1lbnRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9hZGFwdGVyO1xuICAgICAgICB0aGlzLl9hZGFwdGVyID0gdjtcbiAgICAgICAgZm9yIChjb25zdCBuc3Agb2YgdGhpcy5fbnNwcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgbnNwLl9pbml0QWRhcHRlcigpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBdHRhY2hlcyBzb2NrZXQuaW8gdG8gYSBzZXJ2ZXIgb3IgcG9ydC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSBzZXJ2ZXIgb3IgcG9ydFxuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGxpc3RlbihzcnYsIG9wdHMgPSB7fSkge1xuICAgICAgICByZXR1cm4gdGhpcy5hdHRhY2goc3J2LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgc29ja2V0LmlvIHRvIGEgc2VydmVyIG9yIHBvcnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IC0gc2VydmVyIG9yIHBvcnRcbiAgICAgKiBAcGFyYW0gb3B0cyAtIG9wdGlvbnMgcGFzc2VkIHRvIGVuZ2luZS5pb1xuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBhdHRhY2goc3J2LCBvcHRzID0ge30pIHtcbiAgICAgICAgaWYgKFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygc3J2KSB7XG4gICAgICAgICAgICBjb25zdCBtc2cgPSBcIllvdSBhcmUgdHJ5aW5nIHRvIGF0dGFjaCBzb2NrZXQuaW8gdG8gYW4gZXhwcmVzcyBcIiArXG4gICAgICAgICAgICAgICAgXCJyZXF1ZXN0IGhhbmRsZXIgZnVuY3Rpb24uIFBsZWFzZSBwYXNzIGEgaHR0cC5TZXJ2ZXIgaW5zdGFuY2UuXCI7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBoYW5kbGUgYSBwb3J0IGFzIGEgc3RyaW5nXG4gICAgICAgIGlmIChOdW1iZXIoc3J2KSA9PSBzcnYpIHtcbiAgICAgICAgICAgIHNydiA9IE51bWJlcihzcnYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChcIm51bWJlclwiID09IHR5cGVvZiBzcnYpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY3JlYXRpbmcgaHR0cCBzZXJ2ZXIgYW5kIGJpbmRpbmcgdG8gJWRcIiwgc3J2KTtcbiAgICAgICAgICAgIGNvbnN0IHBvcnQgPSBzcnY7XG4gICAgICAgICAgICBzcnYgPSBodHRwLmNyZWF0ZVNlcnZlcigocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDQwNCk7XG4gICAgICAgICAgICAgICAgcmVzLmVuZCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzcnYubGlzdGVuKHBvcnQpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIHRoZSBvcHRpb25zIHBhc3NlZCB0byB0aGUgU29ja2V0LklPIHNlcnZlclxuICAgICAgICBPYmplY3QuYXNzaWduKG9wdHMsIHRoaXMub3B0cyk7XG4gICAgICAgIC8vIHNldCBlbmdpbmUuaW8gcGF0aCB0byBgL3NvY2tldC5pb2BcbiAgICAgICAgb3B0cy5wYXRoID0gb3B0cy5wYXRoIHx8IHRoaXMuX3BhdGg7XG4gICAgICAgIHRoaXMuaW5pdEVuZ2luZShzcnYsIG9wdHMpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYXR0YWNoQXBwKGFwcCAvKjogVGVtcGxhdGVkQXBwICovLCBvcHRzID0ge30pIHtcbiAgICAgICAgLy8gbWVyZ2UgdGhlIG9wdGlvbnMgcGFzc2VkIHRvIHRoZSBTb2NrZXQuSU8gc2VydmVyXG4gICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywgdGhpcy5vcHRzKTtcbiAgICAgICAgLy8gc2V0IGVuZ2luZS5pbyBwYXRoIHRvIGAvc29ja2V0LmlvYFxuICAgICAgICBvcHRzLnBhdGggPSBvcHRzLnBhdGggfHwgdGhpcy5fcGF0aDtcbiAgICAgICAgLy8gaW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgICAgZGVidWcoXCJjcmVhdGluZyB1V2ViU29ja2V0cy5qcy1iYXNlZCBlbmdpbmUgd2l0aCBvcHRzICVqXCIsIG9wdHMpO1xuICAgICAgICBjb25zdCBlbmdpbmUgPSBuZXcgZW5naW5lX2lvXzEudVNlcnZlcihvcHRzKTtcbiAgICAgICAgZW5naW5lLmF0dGFjaChhcHAsIG9wdHMpO1xuICAgICAgICAvLyBiaW5kIHRvIGVuZ2luZSBldmVudHNcbiAgICAgICAgdGhpcy5iaW5kKGVuZ2luZSk7XG4gICAgICAgIGlmICh0aGlzLl9zZXJ2ZUNsaWVudCkge1xuICAgICAgICAgICAgLy8gYXR0YWNoIHN0YXRpYyBmaWxlIHNlcnZpbmdcbiAgICAgICAgICAgIGFwcC5nZXQoYCR7dGhpcy5fcGF0aH0vKmAsIChyZXMsIHJlcSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5jbGllbnRQYXRoUmVnZXgudGVzdChyZXEuZ2V0VXJsKCkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5zZXRZaWVsZCh0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmaWxlbmFtZSA9IHJlcVxuICAgICAgICAgICAgICAgICAgICAuZ2V0VXJsKClcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UodGhpcy5fcGF0aCwgXCJcIilcbiAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpXG4gICAgICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9eXFwvLywgXCJcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgaXNNYXAgPSBkb3RNYXBSZWdleC50ZXN0KGZpbGVuYW1lKTtcbiAgICAgICAgICAgICAgICBjb25zdCB0eXBlID0gaXNNYXAgPyBcIm1hcFwiIDogXCJzb3VyY2VcIjtcbiAgICAgICAgICAgICAgICAvLyBQZXIgdGhlIHN0YW5kYXJkLCBFVGFncyBtdXN0IGJlIHF1b3RlZDpcbiAgICAgICAgICAgICAgICAvLyBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNzIzMiNzZWN0aW9uLTIuM1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4cGVjdGVkRXRhZyA9ICdcIicgKyBjbGllbnRWZXJzaW9uICsgJ1wiJztcbiAgICAgICAgICAgICAgICBjb25zdCB3ZWFrRXRhZyA9IFwiVy9cIiArIGV4cGVjdGVkRXRhZztcbiAgICAgICAgICAgICAgICBjb25zdCBldGFnID0gcmVxLmdldEhlYWRlcihcImlmLW5vbmUtbWF0Y2hcIik7XG4gICAgICAgICAgICAgICAgaWYgKGV0YWcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGVjdGVkRXRhZyA9PT0gZXRhZyB8fCB3ZWFrRXRhZyA9PT0gZXRhZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXMgMzA0XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzLndyaXRlU3RhdHVzKFwiMzA0IE5vdCBNb2RpZmllZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInNlcnZlIGNsaWVudCAlc1wiLCB0eXBlKTtcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkZXIoXCJjYWNoZS1jb250cm9sXCIsIFwicHVibGljLCBtYXgtYWdlPTBcIik7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiY29udGVudC10eXBlXCIsIFwiYXBwbGljYXRpb24vXCIgKyAoaXNNYXAgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiKSk7XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZGVyKFwiZXRhZ1wiLCBleHBlY3RlZEV0YWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbGVwYXRoID0gcGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi9jbGllbnQtZGlzdC9cIiwgZmlsZW5hbWUpO1xuICAgICAgICAgICAgICAgICgwLCB1d3NfanNfMS5zZXJ2ZUZpbGUpKHJlcywgZmlsZXBhdGgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgKDAsIHV3c19qc18xLnBhdGNoQWRhcHRlcikoYXBwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZSBlbmdpbmVcbiAgICAgKlxuICAgICAqIEBwYXJhbSBzcnYgLSB0aGUgc2VydmVyIHRvIGF0dGFjaCB0b1xuICAgICAqIEBwYXJhbSBvcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gZW5naW5lLmlvXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBpbml0RW5naW5lKHNydiwgb3B0cykge1xuICAgICAgICAvLyBpbml0aWFsaXplIGVuZ2luZVxuICAgICAgICBkZWJ1ZyhcImNyZWF0aW5nIGVuZ2luZS5pbyBpbnN0YW5jZSB3aXRoIG9wdHMgJWpcIiwgb3B0cyk7XG4gICAgICAgIHRoaXMuZWlvID0gKDAsIGVuZ2luZV9pb18xLmF0dGFjaCkoc3J2LCBvcHRzKTtcbiAgICAgICAgLy8gYXR0YWNoIHN0YXRpYyBmaWxlIHNlcnZpbmdcbiAgICAgICAgaWYgKHRoaXMuX3NlcnZlQ2xpZW50KVxuICAgICAgICAgICAgdGhpcy5hdHRhY2hTZXJ2ZShzcnYpO1xuICAgICAgICAvLyBFeHBvcnQgaHR0cCBzZXJ2ZXJcbiAgICAgICAgdGhpcy5odHRwU2VydmVyID0gc3J2O1xuICAgICAgICAvLyBiaW5kIHRvIGVuZ2luZSBldmVudHNcbiAgICAgICAgdGhpcy5iaW5kKHRoaXMuZWlvKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXR0YWNoZXMgdGhlIHN0YXRpYyBmaWxlIHNlcnZpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc3J2IGh0dHAgc2VydmVyXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBhdHRhY2hTZXJ2ZShzcnYpIHtcbiAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgY2xpZW50IHNlcnZpbmcgcmVxIGhhbmRsZXJcIik7XG4gICAgICAgIGNvbnN0IGV2cyA9IHNydi5saXN0ZW5lcnMoXCJyZXF1ZXN0XCIpLnNsaWNlKDApO1xuICAgICAgICBzcnYucmVtb3ZlQWxsTGlzdGVuZXJzKFwicmVxdWVzdFwiKTtcbiAgICAgICAgc3J2Lm9uKFwicmVxdWVzdFwiLCAocmVxLCByZXMpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNsaWVudFBhdGhSZWdleC50ZXN0KHJlcS51cmwpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXJ2ZShyZXEsIHJlcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGV2cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBldnNbaV0uY2FsbChzcnYsIHJlcSwgcmVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBIYW5kbGVzIGEgcmVxdWVzdCBzZXJ2aW5nIG9mIGNsaWVudCBzb3VyY2UgYW5kIG1hcFxuICAgICAqXG4gICAgICogQHBhcmFtIHJlcVxuICAgICAqIEBwYXJhbSByZXNcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHNlcnZlKHJlcSwgcmVzKSB7XG4gICAgICAgIGNvbnN0IGZpbGVuYW1lID0gcmVxLnVybC5yZXBsYWNlKHRoaXMuX3BhdGgsIFwiXCIpLnJlcGxhY2UoL1xcPy4qJC8sIFwiXCIpO1xuICAgICAgICBjb25zdCBpc01hcCA9IGRvdE1hcFJlZ2V4LnRlc3QoZmlsZW5hbWUpO1xuICAgICAgICBjb25zdCB0eXBlID0gaXNNYXAgPyBcIm1hcFwiIDogXCJzb3VyY2VcIjtcbiAgICAgICAgLy8gUGVyIHRoZSBzdGFuZGFyZCwgRVRhZ3MgbXVzdCBiZSBxdW90ZWQ6XG4gICAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM3MjMyI3NlY3Rpb24tMi4zXG4gICAgICAgIGNvbnN0IGV4cGVjdGVkRXRhZyA9ICdcIicgKyBjbGllbnRWZXJzaW9uICsgJ1wiJztcbiAgICAgICAgY29uc3Qgd2Vha0V0YWcgPSBcIlcvXCIgKyBleHBlY3RlZEV0YWc7XG4gICAgICAgIGNvbnN0IGV0YWcgPSByZXEuaGVhZGVyc1tcImlmLW5vbmUtbWF0Y2hcIl07XG4gICAgICAgIGlmIChldGFnKSB7XG4gICAgICAgICAgICBpZiAoZXhwZWN0ZWRFdGFnID09PSBldGFnIHx8IHdlYWtFdGFnID09PSBldGFnKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzZXJ2ZSBjbGllbnQgJXMgMzA0XCIsIHR5cGUpO1xuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMzA0KTtcbiAgICAgICAgICAgICAgICByZXMuZW5kKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwic2VydmUgY2xpZW50ICVzXCIsIHR5cGUpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiQ2FjaGUtQ29udHJvbFwiLCBcInB1YmxpYywgbWF4LWFnZT0wXCIpO1xuICAgICAgICByZXMuc2V0SGVhZGVyKFwiQ29udGVudC1UeXBlXCIsIFwiYXBwbGljYXRpb24vXCIgKyAoaXNNYXAgPyBcImpzb25cIiA6IFwiamF2YXNjcmlwdFwiKSk7XG4gICAgICAgIHJlcy5zZXRIZWFkZXIoXCJFVGFnXCIsIGV4cGVjdGVkRXRhZyk7XG4gICAgICAgIFNlcnZlci5zZW5kRmlsZShmaWxlbmFtZSwgcmVxLCByZXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcGFyYW0gZmlsZW5hbWVcbiAgICAgKiBAcGFyYW0gcmVxXG4gICAgICogQHBhcmFtIHJlc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgc3RhdGljIHNlbmRGaWxlKGZpbGVuYW1lLCByZXEsIHJlcykge1xuICAgICAgICBjb25zdCByZWFkU3RyZWFtID0gKDAsIGZzXzEuY3JlYXRlUmVhZFN0cmVhbSkocGF0aC5qb2luKF9fZGlybmFtZSwgXCIuLi9jbGllbnQtZGlzdC9cIiwgZmlsZW5hbWUpKTtcbiAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBhY2NlcHRzKHJlcSkuZW5jb2RpbmdzKFtcImJyXCIsIFwiZ3ppcFwiLCBcImRlZmxhdGVcIl0pO1xuICAgICAgICBjb25zdCBvbkVycm9yID0gKGVycikgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJlcy5lbmQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgICAgICAgY2FzZSBcImJyXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiYnJcIiB9KTtcbiAgICAgICAgICAgICAgICByZWFkU3RyZWFtLnBpcGUoKDAsIHpsaWJfMS5jcmVhdGVCcm90bGlDb21wcmVzcykoKSkucGlwZShyZXMpO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVCcm90bGlDb21wcmVzcykoKSwgcmVzLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnemlwXCI6XG4gICAgICAgICAgICAgICAgcmVzLndyaXRlSGVhZCgyMDAsIHsgXCJjb250ZW50LWVuY29kaW5nXCI6IFwiZ3ppcFwiIH0pO1xuICAgICAgICAgICAgICAgICgwLCBzdHJlYW1fMS5waXBlbGluZSkocmVhZFN0cmVhbSwgKDAsIHpsaWJfMS5jcmVhdGVHemlwKSgpLCByZXMsIG9uRXJyb3IpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRlZmxhdGVcIjpcbiAgICAgICAgICAgICAgICByZXMud3JpdGVIZWFkKDIwMCwgeyBcImNvbnRlbnQtZW5jb2RpbmdcIjogXCJkZWZsYXRlXCIgfSk7XG4gICAgICAgICAgICAgICAgKDAsIHN0cmVhbV8xLnBpcGVsaW5lKShyZWFkU3RyZWFtLCAoMCwgemxpYl8xLmNyZWF0ZURlZmxhdGUpKCksIHJlcywgb25FcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHJlcy53cml0ZUhlYWQoMjAwKTtcbiAgICAgICAgICAgICAgICAoMCwgc3RyZWFtXzEucGlwZWxpbmUpKHJlYWRTdHJlYW0sIHJlcywgb25FcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQmluZHMgc29ja2V0LmlvIHRvIGFuIGVuZ2luZS5pbyBpbnN0YW5jZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7ZW5naW5lLlNlcnZlcn0gZW5naW5lIGVuZ2luZS5pbyAob3IgY29tcGF0aWJsZSkgc2VydmVyXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGJpbmQoZW5naW5lKSB7XG4gICAgICAgIHRoaXMuZW5naW5lID0gZW5naW5lO1xuICAgICAgICB0aGlzLmVuZ2luZS5vbihcImNvbm5lY3Rpb25cIiwgdGhpcy5vbmNvbm5lY3Rpb24uYmluZCh0aGlzKSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2l0aCBlYWNoIGluY29taW5nIHRyYW5zcG9ydCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtlbmdpbmUuU29ja2V0fSBjb25uXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmNvbm5lY3Rpb24oY29ubikge1xuICAgICAgICBkZWJ1ZyhcImluY29taW5nIGNvbm5lY3Rpb24gd2l0aCBpZCAlc1wiLCBjb25uLmlkKTtcbiAgICAgICAgY29uc3QgY2xpZW50ID0gbmV3IGNsaWVudF8xLkNsaWVudCh0aGlzLCBjb25uKTtcbiAgICAgICAgaWYgKGNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNsaWVudC5jb25uZWN0KFwiL1wiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9va3MgdXAgYSBuYW1lc3BhY2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xSZWdFeHB8RnVuY3Rpb259IG5hbWUgbnNwIG5hbWVcbiAgICAgKiBAcGFyYW0gZm4gb3B0aW9uYWwsIG5zcCBgY29ubmVjdGlvbmAgZXYgaGFuZGxlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBvZihuYW1lLCBmbikge1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09IFwiZnVuY3Rpb25cIiB8fCBuYW1lIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJlbnROc3AgPSBuZXcgcGFyZW50X25hbWVzcGFjZV8xLlBhcmVudE5hbWVzcGFjZSh0aGlzKTtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5pdGlhbGl6aW5nIHBhcmVudCBuYW1lc3BhY2UgJXNcIiwgcGFyZW50TnNwLm5hbWUpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KG5hbWUsIHBhcmVudE5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE5zcHMuc2V0KChuc3AsIGNvbm4sIG5leHQpID0+IG5leHQobnVsbCwgbmFtZS50ZXN0KG5zcCkpLCBwYXJlbnROc3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZuKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHBhcmVudE5zcC5vbihcImNvbm5lY3RcIiwgZm4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcmVudE5zcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nKG5hbWUpWzBdICE9PSBcIi9cIilcbiAgICAgICAgICAgIG5hbWUgPSBcIi9cIiArIG5hbWU7XG4gICAgICAgIGxldCBuc3AgPSB0aGlzLl9uc3BzLmdldChuYW1lKTtcbiAgICAgICAgaWYgKCFuc3ApIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaW5pdGlhbGl6aW5nIG5hbWVzcGFjZSAlc1wiLCBuYW1lKTtcbiAgICAgICAgICAgIG5zcCA9IG5ldyBuYW1lc3BhY2VfMS5OYW1lc3BhY2UodGhpcywgbmFtZSk7XG4gICAgICAgICAgICB0aGlzLl9uc3BzLnNldChuYW1lLCBuc3ApO1xuICAgICAgICAgICAgaWYgKG5hbWUgIT09IFwiL1wiKSB7XG4gICAgICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cy5lbWl0UmVzZXJ2ZWQoXCJuZXdfbmFtZXNwYWNlXCIsIG5zcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZuKVxuICAgICAgICAgICAgbnNwLm9uKFwiY29ubmVjdFwiLCBmbik7XG4gICAgICAgIHJldHVybiBuc3A7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyBzZXJ2ZXIgY29ubmVjdGlvblxuICAgICAqXG4gICAgICogQHBhcmFtIFtmbl0gb3B0aW9uYWwsIGNhbGxlZCBhcyBgZm4oW2Vycl0pYCBvbiBlcnJvciBPUiBhbGwgY29ubnMgY2xvc2VkXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGNsb3NlKGZuKSB7XG4gICAgICAgIGZvciAoY29uc3Qgc29ja2V0IG9mIHRoaXMuc29ja2V0cy5zb2NrZXRzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBzb2NrZXQuX29uY2xvc2UoXCJzZXJ2ZXIgc2h1dHRpbmcgZG93blwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVuZ2luZS5jbG9zZSgpO1xuICAgICAgICAvLyByZXN0b3JlIHRoZSBBZGFwdGVyIHByb3RvdHlwZVxuICAgICAgICAoMCwgdXdzX2pzXzEucmVzdG9yZUFkYXB0ZXIpKCk7XG4gICAgICAgIGlmICh0aGlzLmh0dHBTZXJ2ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaHR0cFNlcnZlci5jbG9zZShmbik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmbiAmJiBmbigpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgbmFtZXNwYWNlIG1pZGRsZXdhcmUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgdXNlKGZuKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy51c2UoZm4pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHRvKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhjbHVkZXMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbmFtZVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBleGNlcHQobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmV4Y2VwdChuYW1lKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuc29ja2V0cy5lbWl0KFwibWVzc2FnZVwiLCAuLi5hcmdzKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmRzIGEgYG1lc3NhZ2VgIGV2ZW50IHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHdyaXRlKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5zb2NrZXRzLmVtaXQoXCJtZXNzYWdlXCIsIC4uLmFyZ3MpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdCBhIHBhY2tldCB0byBvdGhlciBTb2NrZXQuSU8gc2VydmVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIGV2IC0gdGhlIGV2ZW50IG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyAtIGFuIGFycmF5IG9mIGFyZ3VtZW50cywgd2hpY2ggbWF5IGluY2x1ZGUgYW4gYWNrbm93bGVkZ2VtZW50IGNhbGxiYWNrIGF0IHRoZSBlbmRcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VydmVyU2lkZUVtaXQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5zZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldHMgYSBsaXN0IG9mIHNvY2tldCBpZHMuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgYWxsU29ja2V0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLmNvbXByZXNzKGNvbXByZXNzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSBtYXkgYmUgbG9zdCBpZiB0aGUgY2xpZW50IGlzIG5vdCByZWFkeSB0b1xuICAgICAqIHJlY2VpdmUgbWVzc2FnZXMgKGJlY2F1c2Ugb2YgbmV0d29yayBzbG93bmVzcyBvciBvdGhlciBpc3N1ZXMsIG9yIGJlY2F1c2UgdGhleeKAmXJlIGNvbm5lY3RlZCB0aHJvdWdoIGxvbmcgcG9sbGluZ1xuICAgICAqIGFuZCBpcyBpbiB0aGUgbWlkZGxlIG9mIGEgcmVxdWVzdC1yZXNwb25zZSBjeWNsZSkuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IHZvbGF0aWxlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnZvbGF0aWxlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNvY2tldHMuZmV0Y2hTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1ha2VzIHRoZSBtYXRjaGluZyBzb2NrZXQgaW5zdGFuY2VzIGpvaW4gdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0c0pvaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNKb2luKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNYWtlcyB0aGUgbWF0Y2hpbmcgc29ja2V0IGluc3RhbmNlcyBsZWF2ZSB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzb2NrZXRzTGVhdmUocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29ja2V0cy5kaXNjb25uZWN0U29ja2V0cyhjbG9zZSk7XG4gICAgfVxufVxuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG4vKipcbiAqIEV4cG9zZSBtYWluIG5hbWVzcGFjZSAoLykuXG4gKi9cbmNvbnN0IGVtaXR0ZXJNZXRob2RzID0gT2JqZWN0LmtleXMoZXZlbnRzXzEuRXZlbnRFbWl0dGVyLnByb3RvdHlwZSkuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICByZXR1cm4gdHlwZW9mIGV2ZW50c18xLkV2ZW50RW1pdHRlci5wcm90b3R5cGVba2V5XSA9PT0gXCJmdW5jdGlvblwiO1xufSk7XG5lbWl0dGVyTWV0aG9kcy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xuICAgIFNlcnZlci5wcm90b3R5cGVbZm5dID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zb2NrZXRzW2ZuXS5hcHBseSh0aGlzLnNvY2tldHMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbn0pO1xubW9kdWxlLmV4cG9ydHMgPSAoc3J2LCBvcHRzKSA9PiBuZXcgU2VydmVyKHNydiwgb3B0cyk7XG5tb2R1bGUuZXhwb3J0cy5TZXJ2ZXIgPSBTZXJ2ZXI7XG5tb2R1bGUuZXhwb3J0cy5OYW1lc3BhY2UgPSBuYW1lc3BhY2VfMS5OYW1lc3BhY2U7XG5tb2R1bGUuZXhwb3J0cy5Tb2NrZXQgPSBzb2NrZXRfMS5Tb2NrZXQ7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuTmFtZXNwYWNlID0gZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSB2b2lkIDA7XG5jb25zdCBzb2NrZXRfMSA9IHJlcXVpcmUoXCIuL3NvY2tldFwiKTtcbmNvbnN0IHR5cGVkX2V2ZW50c18xID0gcmVxdWlyZShcIi4vdHlwZWQtZXZlbnRzXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgYnJvYWRjYXN0X29wZXJhdG9yXzEgPSByZXF1aXJlKFwiLi9icm9hZGNhc3Qtb3BlcmF0b3JcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOm5hbWVzcGFjZVwiKTtcbmV4cG9ydHMuUkVTRVJWRURfRVZFTlRTID0gbmV3IFNldChbXCJjb25uZWN0XCIsIFwiY29ubmVjdGlvblwiLCBcIm5ld19uYW1lc3BhY2VcIl0pO1xuY2xhc3MgTmFtZXNwYWNlIGV4dGVuZHMgdHlwZWRfZXZlbnRzXzEuU3RyaWN0RXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBOYW1lc3BhY2UgY29uc3RydWN0b3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2VydmVyIGluc3RhbmNlXG4gICAgICogQHBhcmFtIG5hbWVcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihzZXJ2ZXIsIG5hbWUpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5zb2NrZXRzID0gbmV3IE1hcCgpO1xuICAgICAgICAvKiogQHByaXZhdGUgKi9cbiAgICAgICAgdGhpcy5fZm5zID0gW107XG4gICAgICAgIC8qKiBAcHJpdmF0ZSAqL1xuICAgICAgICB0aGlzLl9pZHMgPSAwO1xuICAgICAgICB0aGlzLnNlcnZlciA9IHNlcnZlcjtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5faW5pdEFkYXB0ZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgdGhlIGBBZGFwdGVyYCBmb3IgdGhpcyBuc3AuXG4gICAgICogUnVuIHVwb24gY2hhbmdpbmcgYWRhcHRlciBieSBgU2VydmVyI2FkYXB0ZXJgXG4gICAgICogaW4gYWRkaXRpb24gdG8gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfaW5pdEFkYXB0ZXIoKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgdGhpcy5hZGFwdGVyID0gbmV3ICh0aGlzLnNlcnZlci5hZGFwdGVyKCkpKHRoaXMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHVwIG5hbWVzcGFjZSBtaWRkbGV3YXJlLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIHVzZShmbikge1xuICAgICAgICB0aGlzLl9mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIHNvY2tldCAtIHRoZSBzb2NrZXQgdGhhdCB3aWxsIGdldCBhZGRlZFxuICAgICAqIEBwYXJhbSBmbiAtIGxhc3QgZm4gY2FsbCBpbiB0aGUgbWlkZGxld2FyZVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcnVuKHNvY2tldCwgZm4pIHtcbiAgICAgICAgY29uc3QgZm5zID0gdGhpcy5fZm5zLnNsaWNlKDApO1xuICAgICAgICBpZiAoIWZucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4obnVsbCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oc29ja2V0LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gdXBvbiBlcnJvciwgc2hvcnQtY2lyY3VpdFxuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihlcnIpO1xuICAgICAgICAgICAgICAgIC8vIGlmIG5vIG1pZGRsZXdhcmUgbGVmdCwgc3VtbW9uIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKCFmbnNbaSArIDFdKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZm4obnVsbCk7XG4gICAgICAgICAgICAgICAgLy8gZ28gb24gdG8gbmV4dFxuICAgICAgICAgICAgICAgIHJ1bihpICsgMSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW4oMCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gZW1pdHRpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS50byhyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGluKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBlbWl0dGluZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSByb29tXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGV4Y2VwdChyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5leGNlcHQocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBuZXcgY2xpZW50LlxuICAgICAqXG4gICAgICogQHJldHVybiB7U29ja2V0fVxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX2FkZChjbGllbnQsIHF1ZXJ5LCBmbikge1xuICAgICAgICBkZWJ1ZyhcImFkZGluZyBzb2NrZXQgdG8gbnNwICVzXCIsIHRoaXMubmFtZSk7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IG5ldyBzb2NrZXRfMS5Tb2NrZXQodGhpcywgY2xpZW50LCBxdWVyeSk7XG4gICAgICAgIHRoaXMucnVuKHNvY2tldCwgKGVycikgPT4ge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKFwib3BlblwiID09IGNsaWVudC5jb25uLnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNsaWVudC5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5fZXJyb3IoZXJyLmRhdGEgfHwgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNvY2tldC5fZXJyb3Ioe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiBlcnIubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YTogZXJyLmRhdGEsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gdHJhY2sgc29ja2V0XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0cy5zZXQoc29ja2V0LmlkLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIHBhcmFtb3VudCB0aGF0IHRoZSBpbnRlcm5hbCBgb25jb25uZWN0YCBsb2dpY1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgdXNlci1zZXQgZXZlbnRzIHRvIHByZXZlbnQgc3RhdGUgb3JkZXJcbiAgICAgICAgICAgICAgICAgICAgLy8gdmlvbGF0aW9ucyAoc3VjaCBhcyBhIGRpc2Nvbm5lY3Rpb24gYmVmb3JlIHRoZSBjb25uZWN0aW9uXG4gICAgICAgICAgICAgICAgICAgIC8vIGxvZ2ljIGlzIGNvbXBsZXRlKVxuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuX29uY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm4pXG4gICAgICAgICAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICAgICAgICAgICAgICAvLyBmaXJlIHVzZXItc2V0IGV2ZW50c1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXRSZXNlcnZlZChcImNvbm5lY3RcIiwgc29ja2V0KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIm5leHQgY2FsbGVkIGFmdGVyIGNsaWVudCB3YXMgY2xvc2VkIC0gaWdub3Jpbmcgc29ja2V0XCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNvY2tldDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhIGNsaWVudC4gQ2FsbGVkIGJ5IGVhY2ggYFNvY2tldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9yZW1vdmUoc29ja2V0KSB7XG4gICAgICAgIGlmICh0aGlzLnNvY2tldHMuaGFzKHNvY2tldC5pZCkpIHtcbiAgICAgICAgICAgIHRoaXMuc29ja2V0cy5kZWxldGUoc29ja2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiaWdub3JpbmcgcmVtb3ZlIGZvciAlc1wiLCBzb2NrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIHRvIGFsbCBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBBbHdheXMgdHJ1ZVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQgdG8gYWxsIGNsaWVudHMuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudCB0byBhbGwgY2xpZW50cy5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IGEgcGFja2V0IHRvIG90aGVyIFNvY2tldC5JTyBzZXJ2ZXJzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXYgLSB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzZXJ2ZXJTaWRlRW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZXZ9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgYXJncy51bnNoaWZ0KGV2KTtcbiAgICAgICAgdGhpcy5hZGFwdGVyLnNlcnZlclNpZGVFbWl0KGFyZ3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gYSBwYWNrZXQgaXMgcmVjZWl2ZWQgZnJvbSBhbm90aGVyIFNvY2tldC5JTyBzZXJ2ZXJcbiAgICAgKlxuICAgICAqIEBwYXJhbSBhcmdzIC0gYW4gYXJyYXkgb2YgYXJndW1lbnRzLCB3aGljaCBtYXkgaW5jbHVkZSBhbiBhY2tub3dsZWRnZW1lbnQgY2FsbGJhY2sgYXQgdGhlIGVuZFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25TZXJ2ZXJTaWRlRW1pdChhcmdzKSB7XG4gICAgICAgIHN1cGVyLmVtaXRVbnR5cGVkLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgbGlzdCBvZiBjbGllbnRzLlxuICAgICAqXG4gICAgICogQHJldHVybiBzZWxmXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGFsbFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5hbGxTb2NrZXRzKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGNvbXByZXNzIGZsYWcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikuY29tcHJlc3MoY29tcHJlc3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS52b2xhdGlsZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIHRoZSBjdXJyZW50IG5vZGUuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZ2V0IGxvY2FsKCkge1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlcikubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXNcbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5mZXRjaFNvY2tldHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgam9pbiB0aGUgc3BlY2lmaWVkIHJvb21zXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBzb2NrZXRzSm9pbihyb29tKSB7XG4gICAgICAgIHJldHVybiBuZXcgYnJvYWRjYXN0X29wZXJhdG9yXzEuQnJvYWRjYXN0T3BlcmF0b3IodGhpcy5hZGFwdGVyKS5zb2NrZXRzSm9pbihyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgbGVhdmUgdGhlIHNwZWNpZmllZCByb29tc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc29ja2V0c0xlYXZlKHJvb20pIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLnNvY2tldHNMZWF2ZShyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZXMgdGhlIG1hdGNoaW5nIHNvY2tldCBpbnN0YW5jZXMgZGlzY29ubmVjdFxuICAgICAqXG4gICAgICogQHBhcmFtIGNsb3NlIC0gd2hldGhlciB0byBjbG9zZSB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlID0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBicm9hZGNhc3Rfb3BlcmF0b3JfMS5Ccm9hZGNhc3RPcGVyYXRvcih0aGlzLmFkYXB0ZXIpLmRpc2Nvbm5lY3RTb2NrZXRzKGNsb3NlKTtcbiAgICB9XG59XG5leHBvcnRzLk5hbWVzcGFjZSA9IE5hbWVzcGFjZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QYXJlbnROYW1lc3BhY2UgPSB2b2lkIDA7XG5jb25zdCBuYW1lc3BhY2VfMSA9IHJlcXVpcmUoXCIuL25hbWVzcGFjZVwiKTtcbmNsYXNzIFBhcmVudE5hbWVzcGFjZSBleHRlbmRzIG5hbWVzcGFjZV8xLk5hbWVzcGFjZSB7XG4gICAgY29uc3RydWN0b3Ioc2VydmVyKSB7XG4gICAgICAgIHN1cGVyKHNlcnZlciwgXCIvX1wiICsgUGFyZW50TmFtZXNwYWNlLmNvdW50KyspO1xuICAgICAgICB0aGlzLmNoaWxkcmVuID0gbmV3IFNldCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9pbml0QWRhcHRlcigpIHtcbiAgICAgICAgY29uc3QgYnJvYWRjYXN0ID0gKHBhY2tldCwgb3B0cykgPT4ge1xuICAgICAgICAgICAgdGhpcy5jaGlsZHJlbi5mb3JFYWNoKChuc3ApID0+IHtcbiAgICAgICAgICAgICAgICBuc3AuYWRhcHRlci5icm9hZGNhc3QocGFja2V0LCBvcHRzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICAvLyBAdHMtaWdub3JlIEZJWE1FIGlzIHRoZXJlIGEgd2F5IHRvIGRlY2xhcmUgYW4gaW5uZXIgY2xhc3MgaW4gVHlwZVNjcmlwdD9cbiAgICAgICAgdGhpcy5hZGFwdGVyID0geyBicm9hZGNhc3QgfTtcbiAgICB9XG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICB0aGlzLmNoaWxkcmVuLmZvckVhY2goKG5zcCkgPT4ge1xuICAgICAgICAgICAgbnNwLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUNoaWxkKG5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gbmV3IG5hbWVzcGFjZV8xLk5hbWVzcGFjZSh0aGlzLnNlcnZlciwgbmFtZSk7XG4gICAgICAgIG5hbWVzcGFjZS5fZm5zID0gdGhpcy5fZm5zLnNsaWNlKDApO1xuICAgICAgICB0aGlzLmxpc3RlbmVycyhcImNvbm5lY3RcIikuZm9yRWFjaCgobGlzdGVuZXIpID0+IG5hbWVzcGFjZS5vbihcImNvbm5lY3RcIiwgbGlzdGVuZXIpKTtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMoXCJjb25uZWN0aW9uXCIpLmZvckVhY2goKGxpc3RlbmVyKSA9PiBuYW1lc3BhY2Uub24oXCJjb25uZWN0aW9uXCIsIGxpc3RlbmVyKSk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uYWRkKG5hbWVzcGFjZSk7XG4gICAgICAgIHRoaXMuc2VydmVyLl9uc3BzLnNldChuYW1lLCBuYW1lc3BhY2UpO1xuICAgICAgICByZXR1cm4gbmFtZXNwYWNlO1xuICAgIH1cbiAgICBmZXRjaFNvY2tldHMoKSB7XG4gICAgICAgIC8vIG5vdGU6IHdlIGNvdWxkIG1ha2UgdGhlIGZldGNoU29ja2V0cygpIG1ldGhvZCB3b3JrIGZvciBkeW5hbWljIG5hbWVzcGFjZXMgY3JlYXRlZCB3aXRoIGEgcmVnZXggKGJ5IHNlbmRpbmcgdGhlXG4gICAgICAgIC8vIHJlZ2V4IHRvIHRoZSBvdGhlciBTb2NrZXQuSU8gc2VydmVycywgYW5kIHJldHVybmluZyB0aGUgc29ja2V0cyBvZiBlYWNoIG1hdGNoaW5nIG5hbWVzcGFjZSBmb3IgZXhhbXBsZSksIGJ1dFxuICAgICAgICAvLyB0aGUgYmVoYXZpb3IgZm9yIG5hbWVzcGFjZXMgY3JlYXRlZCB3aXRoIGEgZnVuY3Rpb24gaXMgbGVzcyBjbGVhclxuICAgICAgICAvLyBub3RlwrI6IHdlIGNhbm5vdCBsb29wIG92ZXIgZWFjaCBjaGlsZHJlbiBuYW1lc3BhY2UsIGJlY2F1c2Ugd2l0aCBtdWx0aXBsZSBTb2NrZXQuSU8gc2VydmVycywgYSBnaXZlbiBuYW1lc3BhY2VcbiAgICAgICAgLy8gbWF5IGV4aXN0IG9uIG9uZSBub2RlIGJ1dCBub3QgZXhpc3Qgb24gYW5vdGhlciAoc2luY2UgaXQgaXMgY3JlYXRlZCB1cG9uIGNsaWVudCBjb25uZWN0aW9uKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZXRjaFNvY2tldHMoKSBpcyBub3Qgc3VwcG9ydGVkIG9uIHBhcmVudCBuYW1lc3BhY2VzXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuUGFyZW50TmFtZXNwYWNlID0gUGFyZW50TmFtZXNwYWNlO1xuUGFyZW50TmFtZXNwYWNlLmNvdW50ID0gMDtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Tb2NrZXQgPSBleHBvcnRzLlJFU0VSVkVEX0VWRU5UUyA9IHZvaWQgMDtcbmNvbnN0IHNvY2tldF9pb19wYXJzZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tcGFyc2VyXCIpO1xuY29uc3QgZGVidWdfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiZGVidWdcIikpO1xuY29uc3QgdHlwZWRfZXZlbnRzXzEgPSByZXF1aXJlKFwiLi90eXBlZC1ldmVudHNcIik7XG5jb25zdCBiYXNlNjRpZF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJiYXNlNjRpZFwiKSk7XG5jb25zdCBicm9hZGNhc3Rfb3BlcmF0b3JfMSA9IHJlcXVpcmUoXCIuL2Jyb2FkY2FzdC1vcGVyYXRvclwiKTtcbmNvbnN0IGRlYnVnID0gKDAsIGRlYnVnXzEuZGVmYXVsdCkoXCJzb2NrZXQuaW86c29ja2V0XCIpO1xuZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMgPSBuZXcgU2V0KFtcbiAgICBcImNvbm5lY3RcIixcbiAgICBcImNvbm5lY3RfZXJyb3JcIixcbiAgICBcImRpc2Nvbm5lY3RcIixcbiAgICBcImRpc2Nvbm5lY3RpbmdcIixcbiAgICBcIm5ld0xpc3RlbmVyXCIsXG4gICAgXCJyZW1vdmVMaXN0ZW5lclwiLFxuXSk7XG5jbGFzcyBTb2NrZXQgZXh0ZW5kcyB0eXBlZF9ldmVudHNfMS5TdHJpY3RFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEludGVyZmFjZSB0byBhIGBDbGllbnRgIGZvciBhIGdpdmVuIGBOYW1lc3BhY2VgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtOYW1lc3BhY2V9IG5zcFxuICAgICAqIEBwYXJhbSB7Q2xpZW50fSBjbGllbnRcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYXV0aFxuICAgICAqIEBwYWNrYWdlXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobnNwLCBjbGllbnQsIGF1dGgpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgdGhpcy5uc3AgPSBuc3A7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgICAgICAvKipcbiAgICAgICAgICogQWRkaXRpb25hbCBpbmZvcm1hdGlvbiB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgU29ja2V0IGluc3RhbmNlIGFuZCB3aGljaCB3aWxsIGJlIHVzZWQgaW4gdGhlIGZldGNoU29ja2V0cyBtZXRob2RcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZGF0YSA9IHt9O1xuICAgICAgICB0aGlzLmNvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmFja3MgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuZm5zID0gW107XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5zZXJ2ZXIgPSBuc3Auc2VydmVyO1xuICAgICAgICB0aGlzLmFkYXB0ZXIgPSB0aGlzLm5zcC5hZGFwdGVyO1xuICAgICAgICBpZiAoY2xpZW50LmNvbm4ucHJvdG9jb2wgPT09IDMpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHRoaXMuaWQgPSBuc3AubmFtZSAhPT0gXCIvXCIgPyBuc3AubmFtZSArIFwiI1wiICsgY2xpZW50LmlkIDogY2xpZW50LmlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pZCA9IGJhc2U2NGlkXzEuZGVmYXVsdC5nZW5lcmF0ZUlkKCk7IC8vIGRvbid0IHJldXNlIHRoZSBFbmdpbmUuSU8gaWQgYmVjYXVzZSBpdCdzIHNlbnNpdGl2ZSBpbmZvcm1hdGlvblxuICAgICAgICB9XG4gICAgICAgIHRoaXMuaGFuZHNoYWtlID0gdGhpcy5idWlsZEhhbmRzaGFrZShhdXRoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQnVpbGRzIHRoZSBgaGFuZHNoYWtlYCBCQyBvYmplY3RcbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgYnVpbGRIYW5kc2hha2UoYXV0aCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVhZGVyczogdGhpcy5yZXF1ZXN0LmhlYWRlcnMsXG4gICAgICAgICAgICB0aW1lOiBuZXcgRGF0ZSgpICsgXCJcIixcbiAgICAgICAgICAgIGFkZHJlc3M6IHRoaXMuY29ubi5yZW1vdGVBZGRyZXNzLFxuICAgICAgICAgICAgeGRvbWFpbjogISF0aGlzLnJlcXVlc3QuaGVhZGVycy5vcmlnaW4sXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICBzZWN1cmU6ICEhdGhpcy5yZXF1ZXN0LmNvbm5lY3Rpb24uZW5jcnlwdGVkLFxuICAgICAgICAgICAgaXNzdWVkOiArbmV3IERhdGUoKSxcbiAgICAgICAgICAgIHVybDogdGhpcy5yZXF1ZXN0LnVybCxcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIHF1ZXJ5OiB0aGlzLnJlcXVlc3QuX3F1ZXJ5LFxuICAgICAgICAgICAgYXV0aCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgdG8gdGhpcyBjbGllbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIEFsd2F5cyByZXR1cm5zIGB0cnVlYC5cbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZW1pdChldiwgLi4uYXJncykge1xuICAgICAgICBpZiAoZXhwb3J0cy5SRVNFUlZFRF9FVkVOVFMuaGFzKGV2KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZXZ9XCIgaXMgYSByZXNlcnZlZCBldmVudCBuYW1lYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IFtldiwgLi4uYXJnc107XG4gICAgICAgIGNvbnN0IHBhY2tldCA9IHtcbiAgICAgICAgICAgIHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkVWRU5ULFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgLy8gYWNjZXNzIGxhc3QgYXJndW1lbnQgdG8gc2VlIGlmIGl0J3MgYW4gQUNLIGNhbGxiYWNrXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtkYXRhLmxlbmd0aCAtIDFdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlkID0gdGhpcy5uc3AuX2lkcysrO1xuICAgICAgICAgICAgZGVidWcoXCJlbWl0dGluZyBwYWNrZXQgd2l0aCBhY2sgaWQgJWRcIiwgaWQpO1xuICAgICAgICAgICAgdGhpcy5yZWdpc3RlckFja0NhbGxiYWNrKGlkLCBkYXRhLnBvcCgpKTtcbiAgICAgICAgICAgIHBhY2tldC5pZCA9IGlkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZsYWdzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5mbGFncyk7XG4gICAgICAgIHRoaXMuZmxhZ3MgPSB7fTtcbiAgICAgICAgdGhpcy5wYWNrZXQocGFja2V0LCBmbGFncyk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIHJlZ2lzdGVyQWNrQ2FsbGJhY2soaWQsIGFjaykge1xuICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5mbGFncy50aW1lb3V0O1xuICAgICAgICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCBhY2spO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBkZWJ1ZyhcImV2ZW50IHdpdGggYWNrIGlkICVkIGhhcyB0aW1lZCBvdXQgYWZ0ZXIgJWQgbXNcIiwgaWQsIHRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5hY2tzLmRlbGV0ZShpZCk7XG4gICAgICAgICAgICBhY2suY2FsbCh0aGlzLCBuZXcgRXJyb3IoXCJvcGVyYXRpb24gaGFzIHRpbWVkIG91dFwiKSk7XG4gICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB0aGlzLmFja3Muc2V0KGlkLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIGFjay5hcHBseSh0aGlzLCBbbnVsbCwgLi4uYXJnc10pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGFyZ2V0cyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0byhyb29tKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkudG8ocm9vbSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRhcmdldHMgYSByb29tIHdoZW4gYnJvYWRjYXN0aW5nLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvb21cbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgaW4ocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmluKHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGNsdWRlcyBhIHJvb20gd2hlbiBicm9hZGNhc3RpbmcuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcm9vbVxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBleGNlcHQocm9vbSkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpLmV4Y2VwdChyb29tKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZHMgYSBgbWVzc2FnZWAgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHNlbGZcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgc2VuZCguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZW5kcyBhIGBtZXNzYWdlYCBldmVudC5cbiAgICAgKlxuICAgICAqIEByZXR1cm4gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB3cml0ZSguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuZW1pdChcIm1lc3NhZ2VcIiwgLi4uYXJncyk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXcml0ZXMgYSBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gcGFja2V0IC0gcGFja2V0IG9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzIC0gb3B0aW9uc1xuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgcGFja2V0KHBhY2tldCwgb3B0cyA9IHt9KSB7XG4gICAgICAgIHBhY2tldC5uc3AgPSB0aGlzLm5zcC5uYW1lO1xuICAgICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2UgIT09IG9wdHMuY29tcHJlc3M7XG4gICAgICAgIHRoaXMuY2xpZW50Ll9wYWNrZXQocGFja2V0LCBvcHRzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSm9pbnMgYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd8QXJyYXl9IHJvb21zIC0gcm9vbSBvciBhcnJheSBvZiByb29tc1xuICAgICAqIEByZXR1cm4gYSBQcm9taXNlIG9yIG5vdGhpbmcsIGRlcGVuZGluZyBvbiB0aGUgYWRhcHRlclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBqb2luKHJvb21zKSB7XG4gICAgICAgIGRlYnVnKFwiam9pbiByb29tICVzXCIsIHJvb21zKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5hZGRBbGwodGhpcy5pZCwgbmV3IFNldChBcnJheS5pc0FycmF5KHJvb21zKSA/IHJvb21zIDogW3Jvb21zXSkpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZXMgYSByb29tLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJvb21cbiAgICAgKiBAcmV0dXJuIGEgUHJvbWlzZSBvciBub3RoaW5nLCBkZXBlbmRpbmcgb24gdGhlIGFkYXB0ZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbGVhdmUocm9vbSkge1xuICAgICAgICBkZWJ1ZyhcImxlYXZlIHJvb20gJXNcIiwgcm9vbSk7XG4gICAgICAgIHJldHVybiB0aGlzLmFkYXB0ZXIuZGVsKHRoaXMuaWQsIHJvb20pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMZWF2ZSBhbGwgcm9vbXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGxlYXZlQWxsKCkge1xuICAgICAgICB0aGlzLmFkYXB0ZXIuZGVsQWxsKHRoaXMuaWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDYWxsZWQgYnkgYE5hbWVzcGFjZWAgdXBvbiBzdWNjZXNzZnVsXG4gICAgICogbWlkZGxld2FyZSBleGVjdXRpb24gKGllOiBhdXRob3JpemF0aW9uKS5cbiAgICAgKiBTb2NrZXQgaXMgYWRkZWQgdG8gbmFtZXNwYWNlIGFycmF5IGJlZm9yZVxuICAgICAqIGNhbGwgdG8gam9pbiwgc28gYWRhcHRlcnMgY2FuIGFjY2VzcyBpdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uY29ubmVjdCgpIHtcbiAgICAgICAgZGVidWcoXCJzb2NrZXQgY29ubmVjdGVkIC0gd3JpdGluZyBwYWNrZXRcIik7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5qb2luKHRoaXMuaWQpO1xuICAgICAgICBpZiAodGhpcy5jb25uLnByb3RvY29sID09PSAzKSB7XG4gICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBhY2tldCh7IHR5cGU6IHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkNPTk5FQ1QsIGRhdGE6IHsgc2lkOiB0aGlzLmlkIH0gfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdpdGggZWFjaCBwYWNrZXQuIENhbGxlZCBieSBgQ2xpZW50YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwYWNrZXRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9vbnBhY2tldChwYWNrZXQpIHtcbiAgICAgICAgZGVidWcoXCJnb3QgcGFja2V0ICVqXCIsIHBhY2tldCk7XG4gICAgICAgIHN3aXRjaCAocGFja2V0LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuRVZFTlQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmV2ZW50KHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkJJTkFSWV9FVkVOVDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uZXZlbnQocGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQUNLOlxuICAgICAgICAgICAgICAgIHRoaXMub25hY2socGFja2V0KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQklOQVJZX0FDSzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uYWNrKHBhY2tldCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHNvY2tldF9pb19wYXJzZXJfMS5QYWNrZXRUeXBlLkRJU0NPTk5FQ1Q6XG4gICAgICAgICAgICAgICAgdGhpcy5vbmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2Ugc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUjpcbiAgICAgICAgICAgICAgICB0aGlzLl9vbmVycm9yKG5ldyBFcnJvcihwYWNrZXQuZGF0YSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGV2ZW50IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UGFja2V0fSBwYWNrZXQgLSBwYWNrZXQgb2JqZWN0XG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBvbmV2ZW50KHBhY2tldCkge1xuICAgICAgICBjb25zdCBhcmdzID0gcGFja2V0LmRhdGEgfHwgW107XG4gICAgICAgIGRlYnVnKFwiZW1pdHRpbmcgZXZlbnQgJWpcIiwgYXJncyk7XG4gICAgICAgIGlmIChudWxsICE9IHBhY2tldC5pZCkge1xuICAgICAgICAgICAgZGVidWcoXCJhdHRhY2hpbmcgYWNrIGNhbGxiYWNrIHRvIGV2ZW50XCIpO1xuICAgICAgICAgICAgYXJncy5wdXNoKHRoaXMuYWNrKHBhY2tldC5pZCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hbnlMaXN0ZW5lcnMgJiYgdGhpcy5fYW55TGlzdGVuZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgY29uc3QgbGlzdGVuZXJzID0gdGhpcy5fYW55TGlzdGVuZXJzLnNsaWNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIGxpc3RlbmVycykge1xuICAgICAgICAgICAgICAgIGxpc3RlbmVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGlzcGF0Y2goYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGFjayBjYWxsYmFjayB0byBlbWl0IHdpdGggYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge051bWJlcn0gaWQgLSBwYWNrZXQgaWRcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIGFjayhpZCkge1xuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgbGV0IHNlbnQgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIC8vIHByZXZlbnQgZG91YmxlIGNhbGxiYWNrc1xuICAgICAgICAgICAgaWYgKHNlbnQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgICAgICBkZWJ1ZyhcInNlbmRpbmcgYWNrICVqXCIsIGFyZ3MpO1xuICAgICAgICAgICAgc2VsZi5wYWNrZXQoe1xuICAgICAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgICAgICB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5BQ0ssXG4gICAgICAgICAgICAgICAgZGF0YTogYXJncyxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VudCA9IHRydWU7XG4gICAgICAgIH07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGFjayBwYWNrZXQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIG9uYWNrKHBhY2tldCkge1xuICAgICAgICBjb25zdCBhY2sgPSB0aGlzLmFja3MuZ2V0KHBhY2tldC5pZCk7XG4gICAgICAgIGlmIChcImZ1bmN0aW9uXCIgPT0gdHlwZW9mIGFjaykge1xuICAgICAgICAgICAgZGVidWcoXCJjYWxsaW5nIGFjayAlcyB3aXRoICVqXCIsIHBhY2tldC5pZCwgcGFja2V0LmRhdGEpO1xuICAgICAgICAgICAgYWNrLmFwcGx5KHRoaXMsIHBhY2tldC5kYXRhKTtcbiAgICAgICAgICAgIHRoaXMuYWNrcy5kZWxldGUocGFja2V0LmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlYnVnKFwiYmFkIGFjayAlc1wiLCBwYWNrZXQuaWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB1cG9uIGNsaWVudCBkaXNjb25uZWN0IHBhY2tldC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgb25kaXNjb25uZWN0KCkge1xuICAgICAgICBkZWJ1ZyhcImdvdCBkaXNjb25uZWN0IHBhY2tldFwiKTtcbiAgICAgICAgdGhpcy5fb25jbG9zZShcImNsaWVudCBuYW1lc3BhY2UgZGlzY29ubmVjdFwiKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSGFuZGxlcyBhIGNsaWVudCBlcnJvci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgX29uZXJyb3IoZXJyKSB7XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycyhcImVycm9yXCIpLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhpcy5lbWl0UmVzZXJ2ZWQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIk1pc3NpbmcgZXJyb3IgaGFuZGxlciBvbiBgc29ja2V0YC5cIik7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKGVyci5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHVwb24gY2xvc2luZy4gQ2FsbGVkIGJ5IGBDbGllbnRgLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtTdHJpbmd9IHJlYXNvblxuICAgICAqIEB0aHJvdyB7RXJyb3J9IG9wdGlvbmFsIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfb25jbG9zZShyZWFzb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICBkZWJ1ZyhcImNsb3Npbmcgc29ja2V0IC0gcmVhc29uICVzXCIsIHJlYXNvbik7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdGluZ1wiLCByZWFzb24pO1xuICAgICAgICB0aGlzLmxlYXZlQWxsKCk7XG4gICAgICAgIHRoaXMubnNwLl9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuY2xpZW50Ll9yZW1vdmUodGhpcyk7XG4gICAgICAgIHRoaXMuY29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdFJlc2VydmVkKFwiZGlzY29ubmVjdFwiLCByZWFzb24pO1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGFuIGBlcnJvcmAgcGFja2V0LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGVyciAtIGVycm9yIG9iamVjdFxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfZXJyb3IoZXJyKSB7XG4gICAgICAgIHRoaXMucGFja2V0KHsgdHlwZTogc29ja2V0X2lvX3BhcnNlcl8xLlBhY2tldFR5cGUuQ09OTkVDVF9FUlJPUiwgZGF0YTogZXJyIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0cyB0aGlzIGNsaWVudC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY2xvc2UgLSBpZiBgdHJ1ZWAsIGNsb3NlcyB0aGUgdW5kZXJseWluZyBjb25uZWN0aW9uXG4gICAgICogQHJldHVybiB7U29ja2V0fSBzZWxmXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgZGlzY29ubmVjdChjbG9zZSA9IGZhbHNlKSB7XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0ZWQpXG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgaWYgKGNsb3NlKSB7XG4gICAgICAgICAgICB0aGlzLmNsaWVudC5fZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5wYWNrZXQoeyB0eXBlOiBzb2NrZXRfaW9fcGFyc2VyXzEuUGFja2V0VHlwZS5ESVNDT05ORUNUIH0pO1xuICAgICAgICAgICAgdGhpcy5fb25jbG9zZShcInNlcnZlciBuYW1lc3BhY2UgZGlzY29ubmVjdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgY29tcHJlc3MgZmxhZy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7Qm9vbGVhbn0gY29tcHJlc3MgLSBpZiBgdHJ1ZWAsIGNvbXByZXNzZXMgdGhlIHNlbmRpbmcgZGF0YVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBjb21wcmVzcyhjb21wcmVzcykge1xuICAgICAgICB0aGlzLmZsYWdzLmNvbXByZXNzID0gY29tcHJlc3M7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIG1heSBiZSBsb3N0IGlmIHRoZSBjbGllbnQgaXMgbm90IHJlYWR5IHRvXG4gICAgICogcmVjZWl2ZSBtZXNzYWdlcyAoYmVjYXVzZSBvZiBuZXR3b3JrIHNsb3duZXNzIG9yIG90aGVyIGlzc3Vlcywgb3IgYmVjYXVzZSB0aGV54oCZcmUgY29ubmVjdGVkIHRocm91Z2ggbG9uZyBwb2xsaW5nXG4gICAgICogYW5kIGlzIGluIHRoZSBtaWRkbGUgb2YgYSByZXF1ZXN0LXJlc3BvbnNlIGN5Y2xlKS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgdm9sYXRpbGUoKSB7XG4gICAgICAgIHRoaXMuZmxhZ3Mudm9sYXRpbGUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyBhIG1vZGlmaWVyIGZvciBhIHN1YnNlcXVlbnQgZXZlbnQgZW1pc3Npb24gdGhhdCB0aGUgZXZlbnQgZGF0YSB3aWxsIG9ubHkgYmUgYnJvYWRjYXN0IHRvIGV2ZXJ5IHNvY2tldHMgYnV0IHRoZVxuICAgICAqIHNlbmRlci5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgYnJvYWRjYXN0KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5uZXdCcm9hZGNhc3RPcGVyYXRvcigpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIGEgbW9kaWZpZXIgZm9yIGEgc3Vic2VxdWVudCBldmVudCBlbWlzc2lvbiB0aGF0IHRoZSBldmVudCBkYXRhIHdpbGwgb25seSBiZSBicm9hZGNhc3QgdG8gdGhlIGN1cnJlbnQgbm9kZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgbG9jYWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm5ld0Jyb2FkY2FzdE9wZXJhdG9yKCkubG9jYWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgYSBtb2RpZmllciBmb3IgYSBzdWJzZXF1ZW50IGV2ZW50IGVtaXNzaW9uIHRoYXQgdGhlIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHdpdGggYW4gZXJyb3Igd2hlbiB0aGVcbiAgICAgKiBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIGhhdmUgZWxhcHNlZCB3aXRob3V0IGFuIGFja25vd2xlZGdlbWVudCBmcm9tIHRoZSBjbGllbnQ6XG4gICAgICpcbiAgICAgKiBgYGBcbiAgICAgKiBzb2NrZXQudGltZW91dCg1MDAwKS5lbWl0KFwibXktZXZlbnRcIiwgKGVycikgPT4ge1xuICAgICAqICAgaWYgKGVycikge1xuICAgICAqICAgICAvLyB0aGUgY2xpZW50IGRpZCBub3QgYWNrbm93bGVkZ2UgdGhlIGV2ZW50IGluIHRoZSBnaXZlbiBkZWxheVxuICAgICAqICAgfVxuICAgICAqIH0pO1xuICAgICAqIGBgYFxuICAgICAqXG4gICAgICogQHJldHVybnMgc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB0aW1lb3V0KHRpbWVvdXQpIHtcbiAgICAgICAgdGhpcy5mbGFncy50aW1lb3V0ID0gdGltZW91dDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc3BhdGNoIGluY29taW5nIGV2ZW50IHRvIHNvY2tldCBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudCAtIGV2ZW50IHRoYXQgd2lsbCBnZXQgZW1pdHRlZFxuICAgICAqIEBwcml2YXRlXG4gICAgICovXG4gICAgZGlzcGF0Y2goZXZlbnQpIHtcbiAgICAgICAgZGVidWcoXCJkaXNwYXRjaGluZyBhbiBldmVudCAlalwiLCBldmVudCk7XG4gICAgICAgIHRoaXMucnVuKGV2ZW50LCAoZXJyKSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9vbmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBzdXBlci5lbWl0VW50eXBlZC5hcHBseSh0aGlzLCBldmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImlnbm9yZSBwYWNrZXQgcmVjZWl2ZWQgYWZ0ZXIgZGlzY29ubmVjdGlvblwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldHMgdXAgc29ja2V0IG1pZGRsZXdhcmUuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIG1pZGRsZXdhcmUgZnVuY3Rpb24gKGV2ZW50LCBuZXh0KVxuICAgICAqIEByZXR1cm4ge1NvY2tldH0gc2VsZlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICB1c2UoZm4pIHtcbiAgICAgICAgdGhpcy5mbnMucHVzaChmbik7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgbWlkZGxld2FyZSBmb3IgYW4gaW5jb21pbmcgZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBldmVudCAtIGV2ZW50IHRoYXQgd2lsbCBnZXQgZW1pdHRlZFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gbGFzdCBmbiBjYWxsIGluIHRoZSBtaWRkbGV3YXJlXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBydW4oZXZlbnQsIGZuKSB7XG4gICAgICAgIGNvbnN0IGZucyA9IHRoaXMuZm5zLnNsaWNlKDApO1xuICAgICAgICBpZiAoIWZucy5sZW5ndGgpXG4gICAgICAgICAgICByZXR1cm4gZm4obnVsbCk7XG4gICAgICAgIGZ1bmN0aW9uIHJ1bihpKSB7XG4gICAgICAgICAgICBmbnNbaV0oZXZlbnQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAvLyB1cG9uIGVycm9yLCBzaG9ydC1jaXJjdWl0XG4gICAgICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZuKGVycik7XG4gICAgICAgICAgICAgICAgLy8gaWYgbm8gbWlkZGxld2FyZSBsZWZ0LCBzdW1tb24gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAoIWZuc1tpICsgMV0pXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmbihudWxsKTtcbiAgICAgICAgICAgICAgICAvLyBnbyBvbiB0byBuZXh0XG4gICAgICAgICAgICAgICAgcnVuKGkgKyAxKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJ1bigwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgc29ja2V0IGlzIGN1cnJlbnRseSBkaXNjb25uZWN0ZWRcbiAgICAgKi9cbiAgICBnZXQgZGlzY29ubmVjdGVkKCkge1xuICAgICAgICByZXR1cm4gIXRoaXMuY29ubmVjdGVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBIHJlZmVyZW5jZSB0byB0aGUgcmVxdWVzdCB0aGF0IG9yaWdpbmF0ZWQgdGhlIHVuZGVybHlpbmcgRW5naW5lLklPIFNvY2tldC5cbiAgICAgKlxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBnZXQgcmVxdWVzdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LnJlcXVlc3Q7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSB1bmRlcmx5aW5nIENsaWVudCB0cmFuc3BvcnQgY29ubmVjdGlvbiAoRW5naW5lLklPIFNvY2tldCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCBjb25uKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY29ubjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQHB1YmxpY1xuICAgICAqL1xuICAgIGdldCByb29tcygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWRhcHRlci5zb2NrZXRSb29tcyh0aGlzLmlkKSB8fCBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBvbkFueShsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9hbnlMaXN0ZW5lcnMgPSB0aGlzLl9hbnlMaXN0ZW5lcnMgfHwgW107XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycy5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZHMgYSBsaXN0ZW5lciB0aGF0IHdpbGwgYmUgZmlyZWQgd2hlbiBhbnkgZXZlbnQgaXMgZW1pdHRlZC4gVGhlIGV2ZW50IG5hbWUgaXMgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGVcbiAgICAgKiBjYWxsYmFjay4gVGhlIGxpc3RlbmVyIGlzIGFkZGVkIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RlbmVycyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAqIEBwdWJsaWNcbiAgICAgKi9cbiAgICBwcmVwZW5kQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FueUxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycyB8fCBbXTtcbiAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgbGlzdGVuZXIgdGhhdCB3aWxsIGJlIGZpcmVkIHdoZW4gYW55IGV2ZW50IGlzIGVtaXR0ZWQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgb2ZmQW55KGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5fYW55TGlzdGVuZXJzKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RlbmVycyA9IHRoaXMuX2FueUxpc3RlbmVycztcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGlzdGVuZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxpc3RlbmVyID09PSBsaXN0ZW5lcnNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fYW55TGlzdGVuZXJzID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYW4gYXJyYXkgb2YgbGlzdGVuZXJzIHRoYXQgYXJlIGxpc3RlbmluZyBmb3IgYW55IGV2ZW50IHRoYXQgaXMgc3BlY2lmaWVkLiBUaGlzIGFycmF5IGNhbiBiZSBtYW5pcHVsYXRlZCxcbiAgICAgKiBlLmcuIHRvIHJlbW92ZSBsaXN0ZW5lcnMuXG4gICAgICpcbiAgICAgKiBAcHVibGljXG4gICAgICovXG4gICAgbGlzdGVuZXJzQW55KCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYW55TGlzdGVuZXJzIHx8IFtdO1xuICAgIH1cbiAgICBuZXdCcm9hZGNhc3RPcGVyYXRvcigpIHtcbiAgICAgICAgY29uc3QgZmxhZ3MgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLmZsYWdzKTtcbiAgICAgICAgdGhpcy5mbGFncyA9IHt9O1xuICAgICAgICByZXR1cm4gbmV3IGJyb2FkY2FzdF9vcGVyYXRvcl8xLkJyb2FkY2FzdE9wZXJhdG9yKHRoaXMuYWRhcHRlciwgbmV3IFNldCgpLCBuZXcgU2V0KFt0aGlzLmlkXSksIGZsYWdzKTtcbiAgICB9XG59XG5leHBvcnRzLlNvY2tldCA9IFNvY2tldDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TdHJpY3RFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG4vKipcbiAqIFN0cmljdGx5IHR5cGVkIHZlcnNpb24gb2YgYW4gYEV2ZW50RW1pdHRlcmAuIEEgYFR5cGVkRXZlbnRFbWl0dGVyYCB0YWtlcyB0eXBlXG4gKiBwYXJhbWV0ZXJzIGZvciBtYXBwaW5ncyBvZiBldmVudCBuYW1lcyB0byBldmVudCBkYXRhIHR5cGVzLCBhbmQgc3RyaWN0bHlcbiAqIHR5cGVzIG1ldGhvZCBjYWxscyB0byB0aGUgYEV2ZW50RW1pdHRlcmAgYWNjb3JkaW5nIHRvIHRoZXNlIGV2ZW50IG1hcHMuXG4gKlxuICogQHR5cGVQYXJhbSBMaXN0ZW5FdmVudHMgLSBgRXZlbnRzTWFwYCBvZiB1c2VyLWRlZmluZWQgZXZlbnRzIHRoYXQgY2FuIGJlXG4gKiBsaXN0ZW5lZCB0byB3aXRoIGBvbmAgb3IgYG9uY2VgXG4gKiBAdHlwZVBhcmFtIEVtaXRFdmVudHMgLSBgRXZlbnRzTWFwYCBvZiB1c2VyLWRlZmluZWQgZXZlbnRzIHRoYXQgY2FuIGJlXG4gKiBlbWl0dGVkIHdpdGggYGVtaXRgXG4gKiBAdHlwZVBhcmFtIFJlc2VydmVkRXZlbnRzIC0gYEV2ZW50c01hcGAgb2YgcmVzZXJ2ZWQgZXZlbnRzLCB0aGF0IGNhbiBiZVxuICogZW1pdHRlZCBieSBzb2NrZXQuaW8gd2l0aCBgZW1pdFJlc2VydmVkYCwgYW5kIGNhbiBiZSBsaXN0ZW5lZCB0byB3aXRoXG4gKiBgbGlzdGVuYC5cbiAqL1xuY2xhc3MgU3RyaWN0RXZlbnRFbWl0dGVyIGV4dGVuZHMgZXZlbnRzXzEuRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBBZGRzIHRoZSBgbGlzdGVuZXJgIGZ1bmN0aW9uIGFzIGFuIGV2ZW50IGxpc3RlbmVyIGZvciBgZXZgLlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIENhbGxiYWNrIGZ1bmN0aW9uXG4gICAgICovXG4gICAgb24oZXYsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbihldiwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGRzIGEgb25lLXRpbWUgYGxpc3RlbmVyYCBmdW5jdGlvbiBhcyBhbiBldmVudCBsaXN0ZW5lciBmb3IgYGV2YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBOYW1lIG9mIHRoZSBldmVudFxuICAgICAqIEBwYXJhbSBsaXN0ZW5lciBDYWxsYmFjayBmdW5jdGlvblxuICAgICAqL1xuICAgIG9uY2UoZXYsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5vbmNlKGV2LCBsaXN0ZW5lcik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEVtaXRzIGFuIGV2ZW50LlxuICAgICAqXG4gICAgICogQHBhcmFtIGV2IE5hbWUgb2YgdGhlIGV2ZW50XG4gICAgICogQHBhcmFtIGFyZ3MgVmFsdWVzIHRvIHNlbmQgdG8gbGlzdGVuZXJzIG9mIHRoaXMgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0KGV2LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBzdXBlci5lbWl0KGV2LCAuLi5hcmdzKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRW1pdHMgYSByZXNlcnZlZCBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGBwcm90ZWN0ZWRgLCBzbyB0aGF0IG9ubHkgYSBjbGFzcyBleHRlbmRpbmdcbiAgICAgKiBgU3RyaWN0RXZlbnRFbWl0dGVyYCBjYW4gZW1pdCBpdHMgb3duIHJlc2VydmVkIGV2ZW50cy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBSZXNlcnZlZCBldmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIGVtaXQgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0UmVzZXJ2ZWQoZXYsIC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVtaXQoZXYsIC4uLmFyZ3MpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0cyBhbiBldmVudC5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGBwcm90ZWN0ZWRgLCBzbyB0aGF0IG9ubHkgYSBjbGFzcyBleHRlbmRpbmdcbiAgICAgKiBgU3RyaWN0RXZlbnRFbWl0dGVyYCBjYW4gZ2V0IGFyb3VuZCB0aGUgc3RyaWN0IHR5cGluZy4gVGhpcyBpcyB1c2VmdWwgZm9yXG4gICAgICogY2FsbGluZyBgZW1pdC5hcHBseWAsIHdoaWNoIGNhbiBiZSBjYWxsZWQgYXMgYGVtaXRVbnR5cGVkLmFwcGx5YC5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBldiBFdmVudCBuYW1lXG4gICAgICogQHBhcmFtIGFyZ3MgQXJndW1lbnRzIHRvIGVtaXQgYWxvbmcgd2l0aCB0aGUgZXZlbnRcbiAgICAgKi9cbiAgICBlbWl0VW50eXBlZChldiwgLi4uYXJncykge1xuICAgICAgICByZXR1cm4gc3VwZXIuZW1pdChldiwgLi4uYXJncyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgdGhlIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYW4gZXZlbnQuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXZlbnQgRXZlbnQgbmFtZVxuICAgICAqIEByZXR1cm5zIEFycmF5IG9mIGxpc3RlbmVycyBzdWJzY3JpYmVkIHRvIGBldmVudGBcbiAgICAgKi9cbiAgICBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmxpc3RlbmVycyhldmVudCk7XG4gICAgfVxufVxuZXhwb3J0cy5TdHJpY3RFdmVudEVtaXR0ZXIgPSBTdHJpY3RFdmVudEVtaXR0ZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuc2VydmVGaWxlID0gZXhwb3J0cy5yZXN0b3JlQWRhcHRlciA9IGV4cG9ydHMucGF0Y2hBZGFwdGVyID0gdm9pZCAwO1xuY29uc3Qgc29ja2V0X2lvX2FkYXB0ZXJfMSA9IHJlcXVpcmUoXCJzb2NrZXQuaW8tYWRhcHRlclwiKTtcbmNvbnN0IGZzXzEgPSByZXF1aXJlKFwiZnNcIik7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBkZWJ1ZyA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKFwic29ja2V0LmlvOmFkYXB0ZXItdXdzXCIpO1xuY29uc3QgU0VQQVJBVE9SID0gXCJcXHgxZlwiOyAvLyBzZWUgaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsaW1pdGVyI0FTQ0lJX2RlbGltaXRlZF90ZXh0XG5jb25zdCB7IGFkZEFsbCwgZGVsLCBicm9hZGNhc3QgfSA9IHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGU7XG5mdW5jdGlvbiBwYXRjaEFkYXB0ZXIoYXBwIC8qIDogVGVtcGxhdGVkQXBwICovKSB7XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5hZGRBbGwgPSBmdW5jdGlvbiAoaWQsIHJvb21zKSB7XG4gICAgICAgIGNvbnN0IGlzTmV3ID0gIXRoaXMuc2lkcy5oYXMoaWQpO1xuICAgICAgICBhZGRBbGwuY2FsbCh0aGlzLCBpZCwgcm9vbXMpO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmICghc29ja2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNvY2tldC5jb25uLnRyYW5zcG9ydC5uYW1lID09PSBcIndlYnNvY2tldFwiKSB7XG4gICAgICAgICAgICBzdWJzY3JpYmUodGhpcy5uc3AubmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgICAgc29ja2V0LmNvbm4ub24oXCJ1cGdyYWRlXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCByb29tcyA9IHRoaXMuc2lkcy5nZXQoaWQpO1xuICAgICAgICAgICAgICAgIHN1YnNjcmliZSh0aGlzLm5zcC5uYW1lLCBzb2NrZXQsIGlzTmV3LCByb29tcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5kZWwgPSBmdW5jdGlvbiAoaWQsIHJvb20pIHtcbiAgICAgICAgZGVsLmNhbGwodGhpcywgaWQsIHJvb20pO1xuICAgICAgICBjb25zdCBzb2NrZXQgPSB0aGlzLm5zcC5zb2NrZXRzLmdldChpZCk7XG4gICAgICAgIGlmIChzb2NrZXQgJiYgc29ja2V0LmNvbm4udHJhbnNwb3J0Lm5hbWUgPT09IFwid2Vic29ja2V0XCIpIHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbnN0IHNlc3Npb25JZCA9IHNvY2tldC5jb25uLmlkO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgY29uc3Qgd2Vic29ja2V0ID0gc29ja2V0LmNvbm4udHJhbnNwb3J0LnNvY2tldDtcbiAgICAgICAgICAgIGNvbnN0IHRvcGljID0gYCR7dGhpcy5uc3AubmFtZX0ke1NFUEFSQVRPUn0ke3Jvb219YDtcbiAgICAgICAgICAgIGRlYnVnKFwidW5zdWJzY3JpYmUgY29ubmVjdGlvbiAlcyBmcm9tIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICAgICAgd2Vic29ja2V0LnVuc3Vic2NyaWJlKHRvcGljKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgc29ja2V0X2lvX2FkYXB0ZXJfMS5BZGFwdGVyLnByb3RvdHlwZS5icm9hZGNhc3QgPSBmdW5jdGlvbiAocGFja2V0LCBvcHRzKSB7XG4gICAgICAgIGNvbnN0IHVzZUZhc3RQdWJsaXNoID0gb3B0cy5yb29tcy5zaXplIDw9IDEgJiYgb3B0cy5leGNlcHQuc2l6ZSA9PT0gMDtcbiAgICAgICAgaWYgKCF1c2VGYXN0UHVibGlzaCkge1xuICAgICAgICAgICAgYnJvYWRjYXN0LmNhbGwodGhpcywgcGFja2V0LCBvcHRzKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGFncyA9IG9wdHMuZmxhZ3MgfHwge307XG4gICAgICAgIGNvbnN0IGJhc2VQYWNrZXRPcHRzID0ge1xuICAgICAgICAgICAgcHJlRW5jb2RlZDogdHJ1ZSxcbiAgICAgICAgICAgIHZvbGF0aWxlOiBmbGFncy52b2xhdGlsZSxcbiAgICAgICAgICAgIGNvbXByZXNzOiBmbGFncy5jb21wcmVzcyxcbiAgICAgICAgfTtcbiAgICAgICAgcGFja2V0Lm5zcCA9IHRoaXMubnNwLm5hbWU7XG4gICAgICAgIGNvbnN0IGVuY29kZWRQYWNrZXRzID0gdGhpcy5lbmNvZGVyLmVuY29kZShwYWNrZXQpO1xuICAgICAgICBjb25zdCB0b3BpYyA9IG9wdHMucm9vbXMuc2l6ZSA9PT0gMFxuICAgICAgICAgICAgPyB0aGlzLm5zcC5uYW1lXG4gICAgICAgICAgICA6IGAke3RoaXMubnNwLm5hbWV9JHtTRVBBUkFUT1J9JHtvcHRzLnJvb21zLmtleXMoKS5uZXh0KCkudmFsdWV9YDtcbiAgICAgICAgZGVidWcoXCJmYXN0IHB1Ymxpc2ggdG8gJXNcIiwgdG9waWMpO1xuICAgICAgICAvLyBmYXN0IHB1Ymxpc2ggZm9yIGNsaWVudHMgY29ubmVjdGVkIHdpdGggV2ViU29ja2V0XG4gICAgICAgIGVuY29kZWRQYWNrZXRzLmZvckVhY2goKGVuY29kZWRQYWNrZXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzQmluYXJ5ID0gdHlwZW9mIGVuY29kZWRQYWNrZXQgIT09IFwic3RyaW5nXCI7XG4gICAgICAgICAgICAvLyBcIjRcIiBiZWluZyB0aGUgbWVzc2FnZSB0eXBlIGluIHRoZSBFbmdpbmUuSU8gcHJvdG9jb2wsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vc29ja2V0aW8vZW5naW5lLmlvLXByb3RvY29sXG4gICAgICAgICAgICBhcHAucHVibGlzaCh0b3BpYywgaXNCaW5hcnkgPyBlbmNvZGVkUGFja2V0IDogXCI0XCIgKyBlbmNvZGVkUGFja2V0LCBpc0JpbmFyeSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmFwcGx5KG9wdHMsIChzb2NrZXQpID0+IHtcbiAgICAgICAgICAgIGlmIChzb2NrZXQuY29ubi50cmFuc3BvcnQubmFtZSAhPT0gXCJ3ZWJzb2NrZXRcIikge1xuICAgICAgICAgICAgICAgIC8vIGNsYXNzaWMgcHVibGlzaCBmb3IgY2xpZW50cyBjb25uZWN0ZWQgd2l0aCBIVFRQIGxvbmctcG9sbGluZ1xuICAgICAgICAgICAgICAgIHNvY2tldC5jbGllbnQud3JpdGVUb0VuZ2luZShlbmNvZGVkUGFja2V0cywgYmFzZVBhY2tldE9wdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xufVxuZXhwb3J0cy5wYXRjaEFkYXB0ZXIgPSBwYXRjaEFkYXB0ZXI7XG5mdW5jdGlvbiBzdWJzY3JpYmUobmFtZXNwYWNlTmFtZSwgc29ja2V0LCBpc05ldywgcm9vbXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3Qgc2Vzc2lvbklkID0gc29ja2V0LmNvbm4uaWQ7XG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIGNvbnN0IHdlYnNvY2tldCA9IHNvY2tldC5jb25uLnRyYW5zcG9ydC5zb2NrZXQ7XG4gICAgaWYgKGlzTmV3KSB7XG4gICAgICAgIGRlYnVnKFwic3Vic2NyaWJlIGNvbm5lY3Rpb24gJXMgdG8gdG9waWMgJXNcIiwgc2Vzc2lvbklkLCBuYW1lc3BhY2VOYW1lKTtcbiAgICAgICAgd2Vic29ja2V0LnN1YnNjcmliZShuYW1lc3BhY2VOYW1lKTtcbiAgICB9XG4gICAgcm9vbXMuZm9yRWFjaCgocm9vbSkgPT4ge1xuICAgICAgICBjb25zdCB0b3BpYyA9IGAke25hbWVzcGFjZU5hbWV9JHtTRVBBUkFUT1J9JHtyb29tfWA7IC8vICcjJyBjYW4gYmUgdXNlZCBhcyB3aWxkY2FyZFxuICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZSBjb25uZWN0aW9uICVzIHRvIHRvcGljICVzXCIsIHNlc3Npb25JZCwgdG9waWMpO1xuICAgICAgICB3ZWJzb2NrZXQuc3Vic2NyaWJlKHRvcGljKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVBZGFwdGVyKCkge1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYWRkQWxsID0gYWRkQWxsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuZGVsID0gZGVsO1xuICAgIHNvY2tldF9pb19hZGFwdGVyXzEuQWRhcHRlci5wcm90b3R5cGUuYnJvYWRjYXN0ID0gYnJvYWRjYXN0O1xufVxuZXhwb3J0cy5yZXN0b3JlQWRhcHRlciA9IHJlc3RvcmVBZGFwdGVyO1xuY29uc3QgdG9BcnJheUJ1ZmZlciA9IChidWZmZXIpID0+IHtcbiAgICBjb25zdCB7IGJ1ZmZlcjogYXJyYXlCdWZmZXIsIGJ5dGVPZmZzZXQsIGJ5dGVMZW5ndGggfSA9IGJ1ZmZlcjtcbiAgICByZXR1cm4gYXJyYXlCdWZmZXIuc2xpY2UoYnl0ZU9mZnNldCwgYnl0ZU9mZnNldCArIGJ5dGVMZW5ndGgpO1xufTtcbi8vIGltcG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL2tvbG9kemllamN6YWstc3ovdXdlYnNvY2tldC1zZXJ2ZVxuZnVuY3Rpb24gc2VydmVGaWxlKHJlcyAvKiA6IEh0dHBSZXNwb25zZSAqLywgZmlsZXBhdGgpIHtcbiAgICBjb25zdCB7IHNpemUgfSA9ICgwLCBmc18xLnN0YXRTeW5jKShmaWxlcGF0aCk7XG4gICAgY29uc3QgcmVhZFN0cmVhbSA9ICgwLCBmc18xLmNyZWF0ZVJlYWRTdHJlYW0pKGZpbGVwYXRoKTtcbiAgICBjb25zdCBkZXN0cm95UmVhZFN0cmVhbSA9ICgpID0+ICFyZWFkU3RyZWFtLmRlc3Ryb3llZCAmJiByZWFkU3RyZWFtLmRlc3Ryb3koKTtcbiAgICBjb25zdCBvbkVycm9yID0gKGVycm9yKSA9PiB7XG4gICAgICAgIGRlc3Ryb3lSZWFkU3RyZWFtKCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH07XG4gICAgY29uc3Qgb25EYXRhQ2h1bmsgPSAoY2h1bmspID0+IHtcbiAgICAgICAgY29uc3QgYXJyYXlCdWZmZXJDaHVuayA9IHRvQXJyYXlCdWZmZXIoY2h1bmspO1xuICAgICAgICBjb25zdCBsYXN0T2Zmc2V0ID0gcmVzLmdldFdyaXRlT2Zmc2V0KCk7XG4gICAgICAgIGNvbnN0IFtvaywgZG9uZV0gPSByZXMudHJ5RW5kKGFycmF5QnVmZmVyQ2h1bmssIHNpemUpO1xuICAgICAgICBpZiAoIWRvbmUgJiYgIW9rKSB7XG4gICAgICAgICAgICByZWFkU3RyZWFtLnBhdXNlKCk7XG4gICAgICAgICAgICByZXMub25Xcml0YWJsZSgob2Zmc2V0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgW29rLCBkb25lXSA9IHJlcy50cnlFbmQoYXJyYXlCdWZmZXJDaHVuay5zbGljZShvZmZzZXQgLSBsYXN0T2Zmc2V0KSwgc2l6ZSk7XG4gICAgICAgICAgICAgICAgaWYgKCFkb25lICYmIG9rKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlYWRTdHJlYW0ucmVzdW1lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBvaztcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXMub25BYm9ydGVkKGRlc3Ryb3lSZWFkU3RyZWFtKTtcbiAgICByZWFkU3RyZWFtXG4gICAgICAgIC5vbihcImRhdGFcIiwgb25EYXRhQ2h1bmspXG4gICAgICAgIC5vbihcImVycm9yXCIsIG9uRXJyb3IpXG4gICAgICAgIC5vbihcImVuZFwiLCBkZXN0cm95UmVhZFN0cmVhbSk7XG59XG5leHBvcnRzLnNlcnZlRmlsZSA9IHNlcnZlRmlsZTtcbiIsImltcG9ydCBpbyBmcm9tIFwiLi9kaXN0L2luZGV4LmpzXCI7XG5cbmV4cG9ydCBjb25zdCB7U2VydmVyLCBOYW1lc3BhY2UsIFNvY2tldH0gPSBpbztcbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJibGFrZTJiXzEiLCJyZXF1aXJlIiwiYmVjaDMyXzEiLCJEQVRBIiwiQXNzZXRGaW5nZXJwcmludCIsImhhc2hCdWYiLCJ3b3JkcyIsImJlY2gzMiIsInRvV29yZHMiLCJlbmNvZGUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJmaW5nZXJwcmludCIsInNsaWNlIiwiaGFzaCIsInBvbGljeUlkIiwiYXNzZXROYW1lIiwidXBkYXRlIiwiVWludDhBcnJheSIsImRpZ2VzdCIsImZyb21IYXNoIiwiZGVjb2RlIiwicHJlZml4IiwiRXJyb3IiLCJmcm9tV29yZHMiLCJjaGFycyIsImxvb2t1cCIsImkiLCJsZW5ndGgiLCJjaGFyQ29kZUF0IiwiYXJyYXlidWZmZXIiLCJieXRlcyIsImxlbiIsImJhc2U2NCIsInN1YnN0cmluZyIsImJ1ZmZlckxlbmd0aCIsInAiLCJlbmNvZGVkMSIsImVuY29kZWQyIiwiZW5jb2RlZDMiLCJlbmNvZGVkNCIsIkFycmF5QnVmZmVyIiwiTmVnb3RpYXRvciIsIm1pbWUiLCJtb2R1bGUiLCJBY2NlcHRzIiwicmVxIiwiaGVhZGVycyIsIm5lZ290aWF0b3IiLCJwcm90b3R5cGUiLCJ0eXBlIiwidHlwZXMiLCJ0eXBlc18iLCJBcnJheSIsImlzQXJyYXkiLCJhcmd1bWVudHMiLCJtZWRpYVR5cGVzIiwiYWNjZXB0IiwibWltZXMiLCJtYXAiLCJleHRUb01pbWUiLCJhY2NlcHRzIiwiZmlsdGVyIiwidmFsaWRNaW1lIiwiZmlyc3QiLCJpbmRleE9mIiwiZW5jb2RpbmciLCJlbmNvZGluZ3MiLCJlbmNvZGluZ3NfIiwiY2hhcnNldCIsImNoYXJzZXRzIiwiY2hhcnNldHNfIiwibGFuZyIsImxhbmdzIiwibGFuZ3VhZ2UiLCJsYW5ndWFnZXMiLCJsYW5ndWFnZXNfIiwidXRpbHMiLCJzZXR0bGUiLCJjb29raWVzIiwiYnVpbGRVUkwiLCJidWlsZEZ1bGxQYXRoIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJ4aHJBZGFwdGVyIiwiY29uZmlnIiwiUHJvbWlzZSIsImRpc3BhdGNoWGhyUmVxdWVzdCIsInJlc29sdmUiLCJyZWplY3QiLCJyZXF1ZXN0RGF0YSIsImRhdGEiLCJyZXF1ZXN0SGVhZGVycyIsInJlc3BvbnNlVHlwZSIsImlzRm9ybURhdGEiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiQXV0aG9yaXphdGlvbiIsImJ0b2EiLCJmdWxsUGF0aCIsImJhc2VVUkwiLCJ1cmwiLCJvcGVuIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJwYXJhbXMiLCJwYXJhbXNTZXJpYWxpemVyIiwidGltZW91dCIsIm9ubG9hZGVuZCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJzZXRUaW1lb3V0Iiwib25hYm9ydCIsImhhbmRsZUFib3J0Iiwib25lcnJvciIsImhhbmRsZUVycm9yIiwib250aW1lb3V0IiwiaGFuZGxlVGltZW91dCIsInRpbWVvdXRFcnJvck1lc3NhZ2UiLCJ0cmFuc2l0aW9uYWwiLCJjbGFyaWZ5VGltZW91dEVycm9yIiwiaXNTdGFuZGFyZEJyb3dzZXJFbnYiLCJ4c3JmVmFsdWUiLCJ3aXRoQ3JlZGVudGlhbHMiLCJ4c3JmQ29va2llTmFtZSIsInJlYWQiLCJ1bmRlZmluZWQiLCJ4c3JmSGVhZGVyTmFtZSIsImZvckVhY2giLCJzZXRSZXF1ZXN0SGVhZGVyIiwidmFsIiwia2V5IiwidG9Mb3dlckNhc2UiLCJpc1VuZGVmaW5lZCIsIm9uRG93bmxvYWRQcm9ncmVzcyIsImFkZEV2ZW50TGlzdGVuZXIiLCJvblVwbG9hZFByb2dyZXNzIiwidXBsb2FkIiwiY2FuY2VsVG9rZW4iLCJwcm9taXNlIiwidGhlbiIsIm9uQ2FuY2VsZWQiLCJjYW5jZWwiLCJhYm9ydCIsInNlbmQiLCJiaW5kIiwiQXhpb3MiLCJtZXJnZUNvbmZpZyIsImRlZmF1bHRzIiwiY3JlYXRlSW5zdGFuY2UiLCJkZWZhdWx0Q29uZmlnIiwiY29udGV4dCIsImluc3RhbmNlIiwiZXh0ZW5kIiwiYXhpb3MiLCJjcmVhdGUiLCJpbnN0YW5jZUNvbmZpZyIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImlzQXhpb3NFcnJvciIsIm1lc3NhZ2UiLCJfX0NBTkNFTF9fIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsInRva2VuIiwicmVhc29uIiwidGhyb3dJZlJlcXVlc3RlZCIsInNvdXJjZSIsImMiLCJJbnRlcmNlcHRvck1hbmFnZXIiLCJkaXNwYXRjaFJlcXVlc3QiLCJ2YWxpZGF0b3IiLCJ2YWxpZGF0b3JzIiwiaW50ZXJjZXB0b3JzIiwiYXNzZXJ0T3B0aW9ucyIsInNpbGVudEpTT05QYXJzaW5nIiwiZm9yY2VkSlNPTlBhcnNpbmciLCJyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiIsInN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyIsInVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzIiwiaW50ZXJjZXB0b3IiLCJydW5XaGVuIiwic3luY2hyb25vdXMiLCJ1bnNoaWZ0IiwiZnVsZmlsbGVkIiwicmVqZWN0ZWQiLCJyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4iLCJwdXNoUmVzcG9uc2VJbnRlcmNlcHRvcnMiLCJwdXNoIiwiY2hhaW4iLCJhcHBseSIsImNvbmNhdCIsInNoaWZ0IiwibmV3Q29uZmlnIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiZXJyb3IiLCJnZXRVcmkiLCJyZXBsYWNlIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsImhhbmRsZXJzIiwidXNlIiwib3B0aW9ucyIsImVqZWN0IiwiaWQiLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsInJlcXVlc3RlZFVSTCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJ0cmFuc2Zvcm1EYXRhIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsImNhbGwiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwibWVyZ2UiLCJjb21tb24iLCJjbGVhbkhlYWRlckNvbmZpZyIsImFkYXB0ZXIiLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJ0b0pTT04iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJudW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJzdGFjayIsImNvbmZpZzEiLCJjb25maWcyIiwidmFsdWVGcm9tQ29uZmlnMktleXMiLCJtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyIsImRlZmF1bHRUb0NvbmZpZzJLZXlzIiwiZGlyZWN0TWVyZ2VLZXlzIiwiZ2V0TWVyZ2VkVmFsdWUiLCJ0YXJnZXQiLCJpc1BsYWluT2JqZWN0IiwibWVyZ2VEZWVwUHJvcGVydGllcyIsInByb3AiLCJ2YWx1ZUZyb21Db25maWcyIiwiZGVmYXVsdFRvQ29uZmlnMiIsImF4aW9zS2V5cyIsIm90aGVyS2V5cyIsImtleXMiLCJmaWx0ZXJBeGlvc0tleXMiLCJ2YWxpZGF0ZVN0YXR1cyIsImZucyIsInRyYW5zZm9ybSIsIm5vcm1hbGl6ZUhlYWRlck5hbWUiLCJERUZBVUxUX0NPTlRFTlRfVFlQRSIsInNldENvbnRlbnRUeXBlSWZVbnNldCIsImdldERlZmF1bHRBZGFwdGVyIiwicHJvY2VzcyIsInN0cmluZ2lmeVNhZmVseSIsInJhd1ZhbHVlIiwicGFyc2VyIiwiZW5jb2RlciIsImlzU3RyaW5nIiwiSlNPTiIsInBhcnNlIiwidHJpbSIsImUiLCJzdHJpbmdpZnkiLCJpc0FycmF5QnVmZmVyIiwiaXNCdWZmZXIiLCJpc1N0cmVhbSIsImlzRmlsZSIsImlzQmxvYiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc09iamVjdCIsInN0cmljdEpTT05QYXJzaW5nIiwibWF4Q29udGVudExlbmd0aCIsIm1heEJvZHlMZW5ndGgiLCJ0aGlzQXJnIiwid3JhcCIsImFyZ3MiLCJzZXJpYWxpemVkUGFyYW1zIiwicGFydHMiLCJzZXJpYWxpemUiLCJwYXJzZVZhbHVlIiwidiIsImlzRGF0ZSIsInRvSVNPU3RyaW5nIiwiam9pbiIsImhhc2htYXJrSW5kZXgiLCJyZWxhdGl2ZVVSTCIsInN0YW5kYXJkQnJvd3NlckVudiIsIndyaXRlIiwiZXhwaXJlcyIsInBhdGgiLCJkb21haW4iLCJzZWN1cmUiLCJjb29raWUiLCJpc051bWJlciIsIkRhdGUiLCJ0b0dNVFN0cmluZyIsImRvY3VtZW50IiwibWF0Y2giLCJSZWdFeHAiLCJkZWNvZGVVUklDb21wb25lbnQiLCJyZW1vdmUiLCJub3ciLCJub25TdGFuZGFyZEJyb3dzZXJFbnYiLCJ0ZXN0IiwicGF5bG9hZCIsIm1zaWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXJzaW5nTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInNldEF0dHJpYnV0ZSIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhvc3RuYW1lIiwicG9ydCIsInBhdGhuYW1lIiwiY2hhckF0Iiwid2luZG93IiwibG9jYXRpb24iLCJyZXF1ZXN0VVJMIiwicGFyc2VkIiwibm9ybWFsaXplZE5hbWUiLCJwcm9jZXNzSGVhZGVyIiwiaWdub3JlRHVwbGljYXRlT2YiLCJzcGxpdCIsImxpbmUiLCJzdWJzdHIiLCJjYWxsYmFjayIsImFyciIsInBrZyIsInRoaW5nIiwiZGVwcmVjYXRlZFdhcm5pbmdzIiwiY3VycmVudFZlckFyciIsInZlcnNpb24iLCJpc09sZGVyVmVyc2lvbiIsInRoYW5WZXJzaW9uIiwicGtnVmVyc2lvbkFyciIsImRlc3RWZXIiLCJpc0RlcHJlY2F0ZWQiLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJjb25zb2xlIiwid2FybiIsInNjaGVtYSIsImFsbG93VW5rbm93biIsInJlc3VsdCIsImNvbnN0cnVjdG9yIiwiRm9ybURhdGEiLCJpc1ZpZXciLCJnZXRQcm90b3R5cGVPZiIsImlzRnVuY3Rpb24iLCJwaXBlIiwiVVJMU2VhcmNoUGFyYW1zIiwic3RyIiwicHJvZHVjdCIsIm9iaiIsImwiLCJoYXNPd25Qcm9wZXJ0eSIsImFzc2lnblZhbHVlIiwiYSIsImIiLCJzdHJpcEJPTSIsImNvbnRlbnQiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwicmV2TG9va3VwIiwiQXJyIiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJjcnlwdG8iLCJCYXNlNjRJZCIsImdldFJhbmRvbUJ5dGVzIiwiQlVGRkVSX1NJWkUiLCJzZWxmIiwicmFuZG9tQnl0ZXMiLCJieXRlc0luQnVmZmVyIiwicGFyc2VJbnQiLCJ0aHJlc2hvbGQiLCJieXRlc0J1ZmZlckluZGV4IiwiYnl0ZXNCdWZmZXIiLCJpc0dlbmVyYXRpbmdCeXRlcyIsImVyciIsImdlbmVyYXRlSWQiLCJyYW5kIiwiYWxsb2MiLCJ3cml0ZUludDMyQkUiLCJNYXRoIiwiYWJzIiwicmFuZG9tIiwic2VxdWVuY2VOdW1iZXIiLCJjb3B5IiwicG93IiwiYmVjaDMybSIsIkFMUEhBQkVUIiwiQUxQSEFCRVRfTUFQIiwieiIsIngiLCJwb2x5bW9kU3RlcCIsInByZSIsInByZWZpeENoayIsImNoayIsImNvbnZlcnQiLCJpbkJpdHMiLCJvdXRCaXRzIiwicGFkIiwiYml0cyIsIm1heFYiLCJmcm9tV29yZHNVbnNhZmUiLCJyZXMiLCJnZXRMaWJyYXJ5RnJvbUVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJMSU1JVCIsIl9fZGVjb2RlIiwibG93ZXJlZCIsInVwcGVyZWQiLCJsYXN0SW5kZXhPZiIsIndvcmRDaGFycyIsImRlY29kZVVuc2FmZSIsImxvYWRXZWJBc3NlbWJseSIsInN1cHBvcnRlZCIsIldlYkFzc2VtYmx5IiwiaW1wIiwiaW1wb3J0cyIsIndhc20iLCJ0b1VpbnQ4QXJyYXkiLCJyZWFkeSIsIm1lbW9yeSIsInJlYWxsb2MiLCJvbmxvYWQiLCJzaXplIiwiZ3JvdyIsImNlaWwiLCJjYiIsImFzeW5jIiwic2V0dXAiLCJJbnN0YW5jZSIsIk1vZHVsZSIsImluc3RhbnRpYXRlIiwidyIsInMiLCJhdG9iIiwiYXNzZXJ0IiwiaGVhZCIsImZyZWVMaXN0IiwiQmxha2UyYiIsIkJZVEVTX01JTiIsIkJZVEVTX01BWCIsIkJZVEVTIiwiS0VZQllURVNfTUlOIiwiS0VZQllURVNfTUFYIiwiS0VZQllURVMiLCJTQUxUQllURVMiLCJQRVJTT05BTEJZVEVTIiwiZGlnZXN0TGVuZ3RoIiwic2FsdCIsInBlcnNvbmFsIiwibm9Bc3NlcnQiLCJmaW5hbGl6ZWQiLCJwb2ludGVyIiwicG9wIiwiZmlsbCIsInNldCIsImJsYWtlMmJfaW5pdCIsImlucHV0IiwiYmxha2UyYl91cGRhdGUiLCJlbmMiLCJibGFrZTJiX2ZpbmFsIiwiaGV4U2xpY2UiLCJXQVNNIiwiU1VQUE9SVEVEIiwibm9vcCIsImJ1ZiIsInRvSGV4IiwibiIsImIyd2FzbSIsIkFERDY0QUEiLCJvMCIsIm8xIiwiQURENjRBQyIsImIwIiwiYjEiLCJCMkJfR0VUMzIiLCJCMkJfRyIsImQiLCJpeCIsIml5IiwieDAiLCJtIiwieDEiLCJ5MCIsInkxIiwieG9yMCIsInhvcjEiLCJCTEFLRTJCX0lWMzIiLCJVaW50MzJBcnJheSIsIlNJR01BOCIsIlNJR01BODIiLCJibGFrZTJiQ29tcHJlc3MiLCJjdHgiLCJsYXN0IiwidCIsInBhcmFtZXRlcl9ibG9jayIsIm91dGxlbiIsImJsYWtlMmJVcGRhdGUiLCJvdXQiLCJibGFrZTJiRmluYWwiLCJQcm90byIsImNyZWF0ZUhhc2giLCJXQVNNX1NVUFBPUlRFRCIsIldBU01fTE9BREVEIiwiaWVlZTc1NCIsImN1c3RvbUluc3BlY3RTeW1ib2wiLCJTeW1ib2wiLCJTbG93QnVmZmVyIiwiSU5TUEVDVF9NQVhfQllURVMiLCJLX01BWF9MRU5HVEgiLCJrTWF4TGVuZ3RoIiwiVFlQRURfQVJSQVlfU1VQUE9SVCIsInR5cGVkQXJyYXlTdXBwb3J0IiwicHJvdG8iLCJmb28iLCJzZXRQcm90b3R5cGVPZiIsImVudW1lcmFibGUiLCJnZXQiLCJieXRlT2Zmc2V0IiwiY3JlYXRlQnVmZmVyIiwiUmFuZ2VFcnJvciIsImFyZyIsImVuY29kaW5nT3JPZmZzZXQiLCJhbGxvY1Vuc2FmZSIsInBvb2xTaXplIiwiZnJvbVN0cmluZyIsImZyb21BcnJheVZpZXciLCJpc0luc3RhbmNlIiwiZnJvbUFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJ2YWx1ZU9mIiwiZnJvbU9iamVjdCIsInRvUHJpbWl0aXZlIiwiYXNzZXJ0U2l6ZSIsImNoZWNrZWQiLCJhbGxvY1Vuc2FmZVNsb3ciLCJzdHJpbmciLCJpc0VuY29kaW5nIiwiYWN0dWFsIiwiZnJvbUFycmF5TGlrZSIsImFycmF5IiwiYXJyYXlWaWV3IiwibnVtYmVySXNOYU4iLCJfaXNCdWZmZXIiLCJjb21wYXJlIiwib2Zmc2V0IiwieSIsIm1pbiIsIlN0cmluZyIsImxpc3QiLCJwb3MiLCJtdXN0TWF0Y2giLCJsb3dlcmVkQ2FzZSIsInV0ZjhUb0J5dGVzIiwiYmFzZTY0VG9CeXRlcyIsInNsb3dUb1N0cmluZyIsInV0ZjhTbGljZSIsImFzY2lpU2xpY2UiLCJsYXRpbjFTbGljZSIsImJhc2U2NFNsaWNlIiwidXRmMTZsZVNsaWNlIiwic3dhcCIsInN3YXAxNiIsInN3YXAzMiIsInN3YXA2NCIsInRvTG9jYWxlU3RyaW5nIiwiZXF1YWxzIiwiaW5zcGVjdCIsIm1heCIsInRoaXNTdGFydCIsInRoaXNFbmQiLCJ0aGlzQ29weSIsInRhcmdldENvcHkiLCJiaWRpcmVjdGlvbmFsSW5kZXhPZiIsImRpciIsImFycmF5SW5kZXhPZiIsImluZGV4U2l6ZSIsImFyckxlbmd0aCIsInZhbExlbmd0aCIsInJlYWRVSW50MTZCRSIsImZvdW5kSW5kZXgiLCJmb3VuZCIsImoiLCJpbmNsdWRlcyIsImhleFdyaXRlIiwiTnVtYmVyIiwicmVtYWluaW5nIiwic3RyTGVuIiwidXRmOFdyaXRlIiwiYmxpdEJ1ZmZlciIsImFzY2lpV3JpdGUiLCJhc2NpaVRvQnl0ZXMiLCJiYXNlNjRXcml0ZSIsInVjczJXcml0ZSIsInV0ZjE2bGVUb0J5dGVzIiwiaXNGaW5pdGUiLCJfYXJyIiwiZmlyc3RCeXRlIiwiY29kZVBvaW50IiwiYnl0ZXNQZXJTZXF1ZW5jZSIsInNlY29uZEJ5dGUiLCJ0aGlyZEJ5dGUiLCJmb3VydGhCeXRlIiwidGVtcENvZGVQb2ludCIsImRlY29kZUNvZGVQb2ludHNBcnJheSIsIk1BWF9BUkdVTUVOVFNfTEVOR1RIIiwiY29kZVBvaW50cyIsImZyb21DaGFyQ29kZSIsInJldCIsImhleFNsaWNlTG9va3VwVGFibGUiLCJuZXdCdWYiLCJzdWJhcnJheSIsImNoZWNrT2Zmc2V0IiwiZXh0IiwicmVhZFVpbnRMRSIsInJlYWRVSW50TEUiLCJtdWwiLCJyZWFkVWludEJFIiwicmVhZFVJbnRCRSIsInJlYWRVaW50OCIsInJlYWRVSW50OCIsInJlYWRVaW50MTZMRSIsInJlYWRVSW50MTZMRSIsInJlYWRVaW50MTZCRSIsInJlYWRVaW50MzJMRSIsInJlYWRVSW50MzJMRSIsInJlYWRVaW50MzJCRSIsInJlYWRVSW50MzJCRSIsInJlYWRCaWdVSW50NjRMRSIsImRlZmluZUJpZ0ludE1ldGhvZCIsInZhbGlkYXRlTnVtYmVyIiwiYm91bmRzRXJyb3IiLCJsbyIsImhpIiwiQmlnSW50IiwicmVhZEJpZ1VJbnQ2NEJFIiwicmVhZEludExFIiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRCaWdJbnQ2NExFIiwicmVhZEJpZ0ludDY0QkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVpbnRMRSIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVpbnRCRSIsIndyaXRlVUludEJFIiwid3JpdGVVaW50OCIsIndyaXRlVUludDgiLCJ3cml0ZVVpbnQxNkxFIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVWludDE2QkUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVaW50MzJMRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVpbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsIndydEJpZ1VJbnQ2NExFIiwiY2hlY2tJbnRCSSIsIndydEJpZ1VJbnQ2NEJFIiwid3JpdGVCaWdVSW50NjRMRSIsIndyaXRlQmlnVUludDY0QkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVCaWdJbnQ2NExFIiwid3JpdGVCaWdJbnQ2NEJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsImxpdHRsZUVuZGlhbiIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsImNvcHlXaXRoaW4iLCJlcnJvcnMiLCJFIiwic3ltIiwiZ2V0TWVzc2FnZSIsIkJhc2UiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInJhbmdlIiwibXNnIiwicmVjZWl2ZWQiLCJpc0ludGVnZXIiLCJhZGROdW1lcmljYWxTZXBhcmF0b3IiLCJjaGVja0JvdW5kcyIsIkVSUl9PVVRfT0ZfUkFOR0UiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImZsb29yIiwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5Iiwic3JjIiwiZHN0IiwiYWxwaGFiZXQiLCJ0YWJsZSIsImkxNiIsIkJ1ZmZlckJpZ0ludE5vdERlZmluZWQiLCJtYXNrIiwidW5tYXNrIiwiX19kaXJuYW1lIiwiRW1pdHRlciIsIm1peGluIiwib24iLCJldmVudCIsIl9jYWxsYmFja3MiLCJvbmNlIiwib2ZmIiwicmVtb3ZlTGlzdGVuZXIiLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY2FsbGJhY2tzIiwic3BsaWNlIiwiZW1pdCIsImxpc3RlbmVycyIsImhhc0xpc3RlbmVycyIsImZpZWxkQ29udGVudFJlZ0V4cCIsInBhaXJzIiwiZGVjIiwicGFpciIsImluZGV4IiwidHJ5RGVjb2RlIiwibWF4QWdlIiwiaXNOYU4iLCJ0b1VUQ1N0cmluZyIsImh0dHBPbmx5Iiwic2FtZVNpdGUiLCJhc3NpZ24iLCJ2YXJ5Iiwib3JpZ2luIiwibWV0aG9kcyIsInByZWZsaWdodENvbnRpbnVlIiwib3B0aW9uc1N1Y2Nlc3NTdGF0dXMiLCJpc09yaWdpbkFsbG93ZWQiLCJhbGxvd2VkT3JpZ2luIiwiY29uZmlndXJlT3JpZ2luIiwicmVxdWVzdE9yaWdpbiIsImlzQWxsb3dlZCIsImNvbmZpZ3VyZU1ldGhvZHMiLCJjb25maWd1cmVDcmVkZW50aWFscyIsImNyZWRlbnRpYWxzIiwiY29uZmlndXJlQWxsb3dlZEhlYWRlcnMiLCJhbGxvd2VkSGVhZGVycyIsImNvbmZpZ3VyZUV4cG9zZWRIZWFkZXJzIiwiZXhwb3NlZEhlYWRlcnMiLCJjb25maWd1cmVNYXhBZ2UiLCJhcHBseUhlYWRlcnMiLCJoZWFkZXIiLCJzZXRIZWFkZXIiLCJjb3JzIiwibmV4dCIsInN0YXR1c0NvZGUiLCJtaWRkbGV3YXJlV3JhcHBlciIsIm8iLCJvcHRpb25zQ2FsbGJhY2siLCJjb3JzTWlkZGxld2FyZSIsImNvcnNPcHRpb25zIiwib3JpZ2luQ2FsbGJhY2siLCJlcnIyIiwiZm9ybWF0QXJncyIsInNhdmUiLCJsb2FkIiwidXNlQ29sb3JzIiwic3RvcmFnZSIsImxvY2Fsc3RvcmFnZSIsImRlc3Ryb3kiLCJ3YXJuZWQiLCJjb2xvcnMiLCJfX253anMiLCJkb2N1bWVudEVsZW1lbnQiLCJzdHlsZSIsIldlYmtpdEFwcGVhcmFuY2UiLCJmaXJlYnVnIiwiZXhjZXB0aW9uIiwiJDEiLCJuYW1lc3BhY2UiLCJodW1hbml6ZSIsImRpZmYiLCJjb2xvciIsImxhc3RDIiwibG9nIiwiZGVidWciLCJuYW1lc3BhY2VzIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJyIiwiZ2V0SXRlbSIsImVudiIsIkRFQlVHIiwibG9jYWxTdG9yYWdlIiwiZm9ybWF0dGVycyIsImNyZWF0ZURlYnVnIiwiY29lcmNlIiwiZGlzYWJsZSIsImVuYWJsZSIsImVuYWJsZWQiLCJuYW1lcyIsInNraXBzIiwic2VsZWN0Q29sb3IiLCJwcmV2VGltZSIsImVuYWJsZU92ZXJyaWRlIiwibmFtZXNwYWNlc0NhY2hlIiwiZW5hYmxlZENhY2hlIiwiY3VyciIsIm1zIiwicHJldiIsImZvcm1hdCIsImZvcm1hdHRlciIsImxvZ0ZuIiwiaW5pdCIsImRlbGltaXRlciIsIm5ld0RlYnVnIiwidG9OYW1lc3BhY2UiLCJyZWdleHAiLCJmbXRMb25nIiwiZm10U2hvcnQiLCJleGVjIiwicGFyc2VGbG9hdCIsIm1zQWJzIiwicm91bmQiLCJwbHVyYWwiLCJpc1BsdXJhbCIsIlIiLCJSZWZsZWN0IiwiUmVmbGVjdEFwcGx5IiwicmVjZWl2ZXIiLCJGdW5jdGlvbiIsIlJlZmxlY3RPd25LZXlzIiwib3duS2V5cyIsImdldE93blByb3BlcnR5U3ltYm9scyIsImdldE93blByb3BlcnR5TmFtZXMiLCJQcm9jZXNzRW1pdFdhcm5pbmciLCJ3YXJuaW5nIiwiTnVtYmVySXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJfZXZlbnRzIiwiX2V2ZW50c0NvdW50IiwiX21heExpc3RlbmVycyIsImRlZmF1bHRNYXhMaXN0ZW5lcnMiLCJjaGVja0xpc3RlbmVyIiwibGlzdGVuZXIiLCJzZXRNYXhMaXN0ZW5lcnMiLCJfZ2V0TWF4TGlzdGVuZXJzIiwidGhhdCIsImdldE1heExpc3RlbmVycyIsImRvRXJyb3IiLCJldmVudHMiLCJlciIsImhhbmRsZXIiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsInByZXBlbmRMaXN0ZW5lciIsIm9uY2VXcmFwcGVyIiwiZmlyZWQiLCJ3cmFwRm4iLCJfb25jZVdyYXAiLCJzdGF0ZSIsIndyYXBwZWQiLCJwcmVwZW5kT25jZUxpc3RlbmVyIiwicG9zaXRpb24iLCJvcmlnaW5hbExpc3RlbmVyIiwic3BsaWNlT25lIiwiX2xpc3RlbmVycyIsInVud3JhcCIsImV2bGlzdGVuZXIiLCJ1bndyYXBMaXN0ZW5lcnMiLCJyYXdMaXN0ZW5lcnMiLCJsaXN0ZW5lckNvdW50IiwiZXZlbnROYW1lcyIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJ3cmFwTGlzdGVuZXIiLCJpc0xFIiwibUxlbiIsIm5CeXRlcyIsImVMZW4iLCJlTWF4IiwiZUJpYXMiLCJuQml0cyIsIk5hTiIsInJ0IiwiTE4yIiwiZGIiLCJleHRuYW1lIiwiRVhUUkFDVF9UWVBFX1JFR0VYUCIsIlRFWFRfVFlQRV9SRUdFWFAiLCJjb250ZW50VHlwZSIsImV4dGVuc2lvbiIsImV4dGVuc2lvbnMiLCJwb3B1bGF0ZU1hcHMiLCJleHRzIiwicHJlZmVyZW5jZSIsImZvckVhY2hNaW1lVHlwZSIsInRvIiwibm90RXF1YWwiLCJub3RPayIsImVxdWFsIiwib2siLCJwcmVmZXJyZWRDaGFyc2V0cyIsInByZWZlcnJlZEVuY29kaW5ncyIsInByZWZlcnJlZExhbmd1YWdlcyIsInByZWZlcnJlZE1lZGlhVHlwZXMiLCJhdmFpbGFibGUiLCJtZWRpYVR5cGUiLCJwcmVmZXJyZWRDaGFyc2V0IiwicHJlZmVycmVkRW5jb2RpbmciLCJwcmVmZXJyZWRMYW5ndWFnZSIsInByZWZlcnJlZE1lZGlhVHlwZSIsInNpbXBsZUNoYXJzZXRSZWdFeHAiLCJwYXJzZUFjY2VwdENoYXJzZXQiLCJwYXJzZUNoYXJzZXQiLCJxIiwiZ2V0Q2hhcnNldFByaW9yaXR5IiwiYWNjZXB0ZWQiLCJwcmlvcml0eSIsInNwZWMiLCJzcGVjaWZ5IiwicHJvdmlkZWQiLCJpc1F1YWxpdHkiLCJzb3J0IiwiY29tcGFyZVNwZWNzIiwiZ2V0RnVsbENoYXJzZXQiLCJwcmlvcml0aWVzIiwiZ2V0UHJpb3JpdHkiLCJnZXRDaGFyc2V0Iiwic2ltcGxlRW5jb2RpbmdSZWdFeHAiLCJwYXJzZUFjY2VwdEVuY29kaW5nIiwiaGFzSWRlbnRpdHkiLCJtaW5RdWFsaXR5IiwicGFyc2VFbmNvZGluZyIsImdldEVuY29kaW5nUHJpb3JpdHkiLCJnZXRGdWxsRW5jb2RpbmciLCJnZXRFbmNvZGluZyIsInNpbXBsZUxhbmd1YWdlUmVnRXhwIiwicGFyc2VBY2NlcHRMYW5ndWFnZSIsInBhcnNlTGFuZ3VhZ2UiLCJzdWZmaXgiLCJmdWxsIiwiZ2V0TGFuZ3VhZ2VQcmlvcml0eSIsImdldEZ1bGxMYW5ndWFnZSIsImdldExhbmd1YWdlIiwic2ltcGxlTWVkaWFUeXBlUmVnRXhwIiwicGFyc2VBY2NlcHQiLCJzcGxpdE1lZGlhVHlwZXMiLCJwYXJzZU1lZGlhVHlwZSIsInN1YnR5cGUiLCJrdnBzIiwic3BsaXRQYXJhbWV0ZXJzIiwic3BsaXRLZXlWYWx1ZVBhaXIiLCJnZXRNZWRpYVR5cGVQcmlvcml0eSIsImV2ZXJ5IiwiayIsImdldEZ1bGxUeXBlIiwiZ2V0VHlwZSIsInF1b3RlQ291bnQiLCJwYXJhbWV0ZXJzIiwiZnMiLCJvcyIsInJ1bnRpbWVSZXF1aXJlIiwiX193ZWJwYWNrX3JlcXVpcmVfXyIsIl9fbm9uX3dlYnBhY2tfcmVxdWlyZV9fIiwidmFycyIsInZhcmlhYmxlcyIsInByZWJ1aWxkc09ubHkiLCJQUkVCVUlMRFNfT05MWSIsImFiaSIsInZlcnNpb25zIiwibW9kdWxlcyIsInJ1bnRpbWUiLCJpc0VsZWN0cm9uIiwiYXJjaCIsInBsYXRmb3JtIiwibGliYyIsIkxJQkMiLCJpc0FscGluZSIsImFybXYiLCJBUk1fVkVSU0lPTiIsImFybV92ZXJzaW9uIiwidXYiLCJyZWxlYXNlIiwiZ2V0Rmlyc3QiLCJtYXRjaEJ1aWxkIiwicHJlYnVpbGQiLCJuZWFyYnkiLCJkaXJuYW1lIiwiZXhlY1BhdGgiLCJub2RlIiwiZWxlY3Ryb24iLCJCb29sZWFuIiwidHVwbGVzIiwicmVhZGRpclN5bmMiLCJwYXJzZVR1cGxlIiwidHVwbGUiLCJtYXRjaFR1cGxlIiwiY29tcGFyZVR1cGxlcyIsInByZWJ1aWxkcyIsInBhcnNlVGFncyIsImNhbmRpZGF0ZXMiLCJtYXRjaFRhZ3MiLCJ3aW5uZXIiLCJjb21wYXJlVGFncyIsImZpbGUiLCJmaWxlcyIsImFyY2hpdGVjdHVyZXMiLCJ0YWdzIiwic3BlY2lmaWNpdHkiLCJ0YWciLCJuYXBpIiwicnVudGltZUFnbm9zdGljIiwiRUxFQ1RST05fUlVOX0FTX05PREUiLCJleGlzdHNTeW5jIiwicHJvcElzRW51bWVyYWJsZSIsInByb3BlcnR5SXNFbnVtZXJhYmxlIiwidG9PYmplY3QiLCJzaG91bGRVc2VOYXRpdmUiLCJ0ZXN0MSIsInRlc3QyIiwib3JkZXIyIiwidGVzdDMiLCJsZXR0ZXIiLCJzeW1ib2xzIiwicXMiLCJzZXAiLCJlcSIsIm1heEtleXMiLCJpZHgiLCJrc3RyIiwidnN0ciIsInN0cmluZ2lmeVByaW1pdGl2ZSIsImtzIiwiQWRhcHRlciIsImV2ZW50c18xIiwibnNwIiwicm9vbXMiLCJNYXAiLCJzaWRzIiwic2VydmVyIiwiaGFzIiwiU2V0Iiwicm9vbSIsImFkZCIsIl9kZWwiLCJfcm9vbSIsImRlbGV0ZWQiLCJwYWNrZXQiLCJwYWNrZXRPcHRzIiwicHJlRW5jb2RlZCIsImNvbXByZXNzIiwiZW5jb2RlZFBhY2tldHMiLCJzb2NrZXQiLCJjbGllbnQiLCJ3cml0ZVRvRW5naW5lIiwic29ja2V0cyIsImxlYXZlIiwiY2xvc2UiLCJkaXNjb25uZWN0IiwiZXhjZXB0IiwiY29tcHV0ZUV4Y2VwdFNpZHMiLCJpZHMiLCJleGNlcHRSb29tcyIsImV4Y2VwdFNpZHMiLCJzaWQiLCJyZWNvbnN0cnVjdFBhY2tldCIsImRlY29uc3RydWN0UGFja2V0IiwiaXNfYmluYXJ5XzEiLCJidWZmZXJzIiwicGFja2V0RGF0YSIsInBhY2siLCJfZGVjb25zdHJ1Y3RQYWNrZXQiLCJhdHRhY2htZW50cyIsImlzQmluYXJ5IiwicGxhY2Vob2xkZXIiLCJfcGxhY2Vob2xkZXIiLCJuZXdEYXRhIiwiX3JlY29uc3RydWN0UGFja2V0IiwiRGVjb2RlciIsIkVuY29kZXIiLCJQYWNrZXRUeXBlIiwiYmluYXJ5XzEiLCJFVkVOVCIsIkFDSyIsImhhc0JpbmFyeSIsIkJJTkFSWV9FVkVOVCIsIkJJTkFSWV9BQ0siLCJlbmNvZGVBc0JpbmFyeSIsImVuY29kZUFzU3RyaW5nIiwiZGVjb25zdHJ1Y3Rpb24iLCJkZWNvZGVTdHJpbmciLCJyZWNvbnN0cnVjdG9yIiwiQmluYXJ5UmVjb25zdHJ1Y3RvciIsInRha2VCaW5hcnlEYXRhIiwidHJ5UGFyc2UiLCJpc1BheWxvYWRWYWxpZCIsImZpbmlzaGVkUmVjb25zdHJ1Y3Rpb24iLCJDT05ORUNUIiwiRElTQ09OTkVDVCIsIkNPTk5FQ1RfRVJST1IiLCJyZWNvblBhY2siLCJiaW5EYXRhIiwid2l0aE5hdGl2ZUFycmF5QnVmZmVyIiwid2l0aE5hdGl2ZUJsb2IiLCJCbG9iIiwid2l0aE5hdGl2ZUZpbGUiLCJGaWxlIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsImdsb2JhbCIsInB1bnljb2RlIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwiY3VycmVudFZhbHVlIiwiaGFuZGxlZENQQ291bnRQbHVzT25lIiwicU1pbnVzVCIsInRvVW5pY29kZSIsInRvQVNDSUkiLCJkZWZpbmUiLCJhbWQiLCJ1dGlsIiwidXJsUGFyc2UiLCJ1cmxSZXNvbHZlIiwicmVzb2x2ZU9iamVjdCIsInVybFJlc29sdmVPYmplY3QiLCJ1cmxGb3JtYXQiLCJVcmwiLCJzbGFzaGVzIiwicXVlcnkiLCJwcm90b2NvbFBhdHRlcm4iLCJwb3J0UGF0dGVybiIsInNpbXBsZVBhdGhQYXR0ZXJuIiwiZGVsaW1zIiwidW53aXNlIiwiYXV0b0VzY2FwZSIsIm5vbkhvc3RDaGFycyIsImhvc3RFbmRpbmdDaGFycyIsImhvc3RuYW1lTWF4TGVuIiwiaG9zdG5hbWVQYXJ0UGF0dGVybiIsImhvc3RuYW1lUGFydFN0YXJ0IiwidW5zYWZlUHJvdG9jb2wiLCJob3N0bGVzc1Byb3RvY29sIiwic2xhc2hlZFByb3RvY29sIiwicXVlcnlzdHJpbmciLCJwYXJzZVF1ZXJ5U3RyaW5nIiwic2xhc2hlc0Rlbm90ZUhvc3QiLCJ1IiwicXVlcnlJbmRleCIsInNwbGl0dGVyIiwidVNwbGl0Iiwic2xhc2hSZWdleCIsInJlc3QiLCJzaW1wbGVQYXRoIiwibG93ZXJQcm90byIsImhvc3RFbmQiLCJoZWMiLCJhdFNpZ24iLCJwYXJzZUhvc3QiLCJpcHY2SG9zdG5hbWUiLCJob3N0cGFydHMiLCJwYXJ0IiwibmV3cGFydCIsInZhbGlkUGFydHMiLCJub3RIb3N0IiwiYml0IiwiYWUiLCJlc2MiLCJlc2NhcGUiLCJxbSIsInJlbGF0aXZlIiwicmVsIiwidGtleXMiLCJ0ayIsInRrZXkiLCJya2V5cyIsInJrIiwicmtleSIsInJlbFBhdGgiLCJpc1NvdXJjZUFicyIsImlzUmVsQWJzIiwibXVzdEVuZEFicyIsInJlbW92ZUFsbERvdHMiLCJzcmNQYXRoIiwicHN5Y2hvdGljIiwiaXNOdWxsT3JVbmRlZmluZWQiLCJhdXRoSW5Ib3N0IiwiaXNOdWxsIiwiaGFzVHJhaWxpbmdTbGFzaCIsInVwIiwiaXNBYnNvbHV0ZSIsImlzVmFsaWRVVEY4IiwiYXBwZW5kIiwiRklFTERfTkFNRV9SRUdFWFAiLCJmaWVsZCIsImZpZWxkcyIsInZhbHMiLCJmbGQiLCJnZXRIZWFkZXIiLCJXZWJTb2NrZXQiLCJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCJTZXJ2ZXIiLCJSZWNlaXZlciIsIlNlbmRlciIsIldlYlNvY2tldFNlcnZlciIsIkVNUFRZX0JVRkZFUiIsInRvdGFsTGVuZ3RoIiwiX21hc2siLCJfdW5tYXNrIiwidG9BcnJheUJ1ZmZlciIsInRvQnVmZmVyIiwicmVhZE9ubHkiLCJidWZmZXJVdGlsIiwiQklOQVJZX1RZUEVTIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCIsImtDb2RlIiwia0RhdGEiLCJrRXJyb3IiLCJrTWVzc2FnZSIsImtSZWFzb24iLCJrVGFyZ2V0Iiwia1R5cGUiLCJrV2FzQ2xlYW4iLCJFdmVudCIsIkNsb3NlRXZlbnQiLCJ3YXNDbGVhbiIsIkVycm9yRXZlbnQiLCJNZXNzYWdlRXZlbnQiLCJFdmVudFRhcmdldCIsIndyYXBwZXIiLCJvbk1lc3NhZ2UiLCJvbkNsb3NlIiwiX2Nsb3NlRnJhbWVSZWNlaXZlZCIsIl9jbG9zZUZyYW1lU2VudCIsIm9uRXJyb3IiLCJvbk9wZW4iLCJ0b2tlbkNoYXJzIiwiZGVzdCIsImVsZW0iLCJvZmZlcnMiLCJtdXN0VW5lc2NhcGUiLCJpc0VzY2FwaW5nIiwiaW5RdW90ZXMiLCJleHRlbnNpb25OYW1lIiwicGFyYW1OYW1lIiwiU3ludGF4RXJyb3IiLCJjb25maWd1cmF0aW9ucyIsInZhbHVlcyIsImtEb25lIiwia1J1biIsIkxpbWl0ZXIiLCJjb25jdXJyZW5jeSIsInBlbmRpbmciLCJqb2JzIiwiam9iIiwiemxpYiIsIlRSQUlMRVIiLCJrUGVyTWVzc2FnZURlZmxhdGUiLCJrVG90YWxMZW5ndGgiLCJrQ2FsbGJhY2siLCJrQnVmZmVycyIsInpsaWJMaW1pdGVyIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJfbWF4UGF5bG9hZCIsIl9vcHRpb25zIiwiX3RocmVzaG9sZCIsIl9pc1NlcnZlciIsIl9kZWZsYXRlIiwiX2luZmxhdGUiLCJjb25jdXJyZW5jeUxpbWl0Iiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciIsImNsaWVudE5vQ29udGV4dFRha2VvdmVyIiwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwic2VydmVyX21heF93aW5kb3dfYml0cyIsImNsaWVudE1heFdpbmRvd0JpdHMiLCJjbGllbnRfbWF4X3dpbmRvd19iaXRzIiwibm9ybWFsaXplUGFyYW1zIiwiYWNjZXB0QXNTZXJ2ZXIiLCJhY2NlcHRBc0NsaWVudCIsImZpbmQiLCJmaW4iLCJkb25lIiwiX2RlY29tcHJlc3MiLCJfY29tcHJlc3MiLCJlbmRwb2ludCIsIndpbmRvd0JpdHMiLCJaX0RFRkFVTFRfV0lORE9XQklUUyIsImNyZWF0ZUluZmxhdGVSYXciLCJ6bGliSW5mbGF0ZU9wdGlvbnMiLCJpbmZsYXRlT25FcnJvciIsImluZmxhdGVPbkRhdGEiLCJmbHVzaCIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsInJlc2V0IiwiY3JlYXRlRGVmbGF0ZVJhdyIsInpsaWJEZWZsYXRlT3B0aW9ucyIsImRlZmxhdGVPbkRhdGEiLCJaX1NZTkNfRkxVU0giLCJjaHVuayIsIldyaXRhYmxlIiwiaXNWYWxpZFN0YXR1c0NvZGUiLCJHRVRfSU5GTyIsIkdFVF9QQVlMT0FEX0xFTkdUSF8xNiIsIkdFVF9QQVlMT0FEX0xFTkdUSF82NCIsIkdFVF9NQVNLIiwiR0VUX0RBVEEiLCJJTkZMQVRJTkciLCJfYmluYXJ5VHlwZSIsImJpbmFyeVR5cGUiLCJfZXh0ZW5zaW9ucyIsIl9za2lwVVRGOFZhbGlkYXRpb24iLCJza2lwVVRGOFZhbGlkYXRpb24iLCJfYnVmZmVyZWRCeXRlcyIsIl9idWZmZXJzIiwiX2NvbXByZXNzZWQiLCJfcGF5bG9hZExlbmd0aCIsIl9mcmFnbWVudGVkIiwiX21hc2tlZCIsIl9maW4iLCJfb3Bjb2RlIiwiX3RvdGFsUGF5bG9hZExlbmd0aCIsIl9tZXNzYWdlTGVuZ3RoIiwiX2ZyYWdtZW50cyIsIl9zdGF0ZSIsIl9sb29wIiwic3RhcnRMb29wIiwiZ2V0SW5mbyIsImdldFBheWxvYWRMZW5ndGgxNiIsImdldFBheWxvYWRMZW5ndGg2NCIsImdldE1hc2siLCJnZXREYXRhIiwiY29uc3VtZSIsImNvbXByZXNzZWQiLCJoYXZlTGVuZ3RoIiwiY29udHJvbE1lc3NhZ2UiLCJkZWNvbXByZXNzIiwiZGF0YU1lc3NhZ2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsIm1lc3NhZ2VMZW5ndGgiLCJmcmFnbWVudHMiLCJFcnJvckN0b3IiLCJlcnJvckNvZGUiLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm5ldCIsInRscyIsInJhbmRvbUZpbGxTeW5jIiwiYXBwbHlNYXNrIiwiX3NvY2tldCIsIl9maXJzdEZyYWdtZW50IiwiX2RlZmxhdGluZyIsIl9xdWV1ZSIsImVucXVldWUiLCJkb0Nsb3NlIiwic2VuZEZyYW1lIiwiZnJhbWUiLCJyc3YxIiwib3Bjb2RlIiwiZG9QaW5nIiwiZG9Qb25nIiwiYmluYXJ5IiwiZGlzcGF0Y2giLCJfIiwiZGVzdHJveWVkIiwiZGVxdWV1ZSIsImNvcmsiLCJ1bmNvcmsiLCJwYXlsb2FkTGVuZ3RoIiwiRHVwbGV4IiwiZW1pdENsb3NlIiwic3RyZWFtIiwiZHVwbGV4T25FbmQiLCJfd3JpdGFibGVTdGF0ZSIsImZpbmlzaGVkIiwiZHVwbGV4T25FcnJvciIsIndzIiwicmVzdW1lT25SZWNlaXZlckRyYWluIiwidGVybWluYXRlT25EZXN0cm95IiwicmVjZWl2ZXJPbkRyYWluIiwicmVzdW1lIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsImR1cGxleCIsImF1dG9EZXN0cm95Iiwib2JqZWN0TW9kZSIsIndyaXRhYmxlT2JqZWN0TW9kZSIsInBhdXNlIiwiX2Rlc3Ryb3kiLCJDTE9TRUQiLCJuZXh0VGljayIsImNhbGxlZCIsInRlcm1pbmF0ZSIsIl9maW5hbCIsImZpbmlzaCIsIl9yZWFkIiwiT1BFTiIsIm5lZWREcmFpbiIsIl93cml0ZSIsInByb3RvY29scyIsIl9pc1ZhbGlkVVRGOCIsImh0dHAiLCJodHRwcyIsInN1YnByb3RvY29sIiwia2V5UmVnZXgiLCJSVU5OSU5HIiwiQ0xPU0lORyIsImhhbmRsZVByb3RvY29scyIsImNsaWVudFRyYWNraW5nIiwidmVyaWZ5Q2xpZW50Iiwibm9TZXJ2ZXIiLCJiYWNrbG9nIiwiX3NlcnZlciIsImNyZWF0ZVNlcnZlciIsImJvZHkiLCJTVEFUVVNfQ09ERVMiLCJ3cml0ZUhlYWQiLCJsaXN0ZW4iLCJlbWl0Q29ubmVjdGlvbiIsIl9yZW1vdmVMaXN0ZW5lcnMiLCJhZGRMaXN0ZW5lcnMiLCJsaXN0ZW5pbmciLCJ1cGdyYWRlIiwiaGFuZGxlVXBncmFkZSIsImNsaWVudHMiLCJfc2hvdWxkRW1pdENsb3NlIiwiYWRkcmVzcyIsInNvY2tldE9uRXJyb3IiLCJzaG91bGRIYW5kbGUiLCJhYm9ydEhhbmRzaGFrZSIsInNlY1dlYlNvY2tldFByb3RvY29sIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsImluZm8iLCJhdXRob3JpemVkIiwiZW5jcnlwdGVkIiwidmVyaWZpZWQiLCJjb21wbGV0ZVVwZ3JhZGUiLCJyZWFkYWJsZSIsIl9wcm90b2NvbCIsInNldFNvY2tldCIsInJlbW92ZUxpc3RlbmVycyIsIkNvbm5lY3Rpb24iLCJSZWFkYWJsZSIsIlVSTCIsInJlYWR5U3RhdGVzIiwic3VicHJvdG9jb2xSZWdleCIsInByb3RvY29sVmVyc2lvbnMiLCJjbG9zZVRpbWVvdXQiLCJfY2xvc2VDb2RlIiwiX2Nsb3NlTWVzc2FnZSIsIl9jbG9zZVRpbWVyIiwiX3JlYWR5U3RhdGUiLCJfc2VuZGVyIiwiX2J1ZmZlcmVkQW1vdW50IiwiX3JlZGlyZWN0cyIsImluaXRBc0NsaWVudCIsIl91cmwiLCJyZWNlaXZlck9uQ29uY2x1ZGUiLCJyZWNlaXZlck9uRXJyb3IiLCJyZWNlaXZlck9uTWVzc2FnZSIsInJlY2VpdmVyT25QaW5nIiwicmVjZWl2ZXJPblBvbmciLCJzZXROb0RlbGF5Iiwic29ja2V0T25DbG9zZSIsInNvY2tldE9uRGF0YSIsInNvY2tldE9uRW5kIiwiY2xlYW51cCIsIl9yZXEiLCJlcnJvckVtaXR0ZWQiLCJzZW5kQWZ0ZXJDbG9zZSIsInBpbmciLCJwb25nIiwicHJvcGVydHkiLCJ3ZWJzb2NrZXQiLCJwcm90b2NvbFZlcnNpb24iLCJmb2xsb3dSZWRpcmVjdHMiLCJtYXhSZWRpcmVjdHMiLCJjcmVhdGVDb25uZWN0aW9uIiwic29ja2V0UGF0aCIsInBhcnNlZFVybCIsImlzU2VjdXJlIiwiaXNVbml4U29ja2V0IiwiZGVmYXVsdFBvcnQiLCJwcm90b2NvbFNldCIsInRsc0Nvbm5lY3QiLCJuZXRDb25uZWN0Iiwic3RhcnRzV2l0aCIsIlVwZ3JhZGUiLCJoYW5kc2hha2VUaW1lb3V0Iiwib2ZmZXIiLCJPcmlnaW4iLCJhYm9ydGVkIiwiYWRkciIsInNlcnZlclByb3QiLCJwcm90RXJyb3IiLCJleHRlbnNpb25OYW1lcyIsImNvbm5lY3QiLCJzZXJ2ZXJuYW1lIiwiaXNJUCIsInJlY2VpdmVyT25GaW5pc2giLCJjbGVhclRpbWVvdXQiLCJFUlJPUl9QQUNLRVQiLCJQQUNLRVRfVFlQRVNfUkVWRVJTRSIsIlBBQ0tFVF9UWVBFUyIsImNvbW1vbnNfanNfMSIsImJhc2U2NF9hcnJheWJ1ZmZlcl8xIiwiZGVjb2RlUGFja2V0IiwiZW5jb2RlZFBhY2tldCIsIm1hcEJpbmFyeSIsImRlY29kZUJhc2U2NFBhY2tldCIsInBhY2tldFR5cGUiLCJkZWNvZGVkIiwiZW5jb2RlUGFja2V0Iiwic3VwcG9ydHNCaW5hcnkiLCJlbmNvZGVCbG9iQXNCYXNlNjQiLCJmaWxlUmVhZGVyIiwiRmlsZVJlYWRlciIsInJlYWRBc0RhdGFVUkwiLCJkZWNvZGVQYXlsb2FkIiwiZW5jb2RlUGF5bG9hZCIsImVuY29kZVBhY2tldF9qc18xIiwiZGVjb2RlUGFja2V0X2pzXzEiLCJTRVBBUkFUT1IiLCJwYWNrZXRzIiwiZW5jb2RlZFBheWxvYWQiLCJkZWNvZGVkUGFja2V0IiwiVHJhbnNwb3J0IiwiU29ja2V0IiwidVNlcnZlciIsImF0dGFjaCIsInRyYW5zcG9ydHMiLCJodHRwXzEiLCJzZXJ2ZXJfMSIsImluZGV4XzEiLCJ1c2VydmVyXzEiLCJzb2NrZXRfMSIsInRyYW5zcG9ydF8xIiwiZW5naW5lIiwiaHR0cFNlcnZlciIsImRlY29kZVBheWxvYWRBc0JpbmFyeSIsImVuY29kZVBheWxvYWRBc0JpbmFyeSIsImVuY29kZUJhc2U2NFBhY2tldCIsInV0ZjgiLCJwYWNrZXRzbGlzdCIsInV0ZjhlbmNvZGUiLCJlbmNvZGVCdWZmZXIiLCJhcnJheUJ1ZmZlclRvQnVmZmVyIiwic3RyaWN0IiwidHlwZUJ1ZmZlciIsInV0ZjhkZWNvZGUiLCJpbnRBcnJheSIsImFidiIsImVuY29kZU9uZSIsImRvbmVDYWxsYmFjayIsInNldExlbmd0aEhlYWRlciIsInJlc3VsdHMiLCJhcnkiLCJlYWNoIiwiY2hyIiwibW9yZSIsImJ1ZmZlclRvU3RyaW5nIiwic3RyaW5nVG9CdWZmZXIiLCJlbmNvZGVPbmVCaW5hcnlQYWNrZXQiLCJvbkJpbmFyeVBhY2tldEVuY29kZSIsImVuY29kaW5nTGVuZ3RoIiwic2l6ZUJ1ZmZlciIsImJ1ZmZlclRhaWwiLCJtc2dMZW5ndGgiLCJ0b3RhbCIsImNoZWNrU2NhbGFyVmFsdWUiLCJjcmVhdGVCeXRlIiwiZW5jb2RlQ29kZVBvaW50Iiwic3ltYm9sIiwiYnl0ZVN0cmluZyIsInJlYWRDb250aW51YXRpb25CeXRlIiwiYnl0ZUluZGV4IiwiYnl0ZUNvdW50IiwiY29udGludWF0aW9uQnl0ZSIsImRlY29kZVN5bWJvbCIsImJ5dGUxIiwiYnl0ZTIiLCJieXRlMyIsImJ5dGU0IiwiQmFzZVNlcnZlciIsInVybF8xIiwiYmFzZTY0aWQiLCJ0cmFuc3BvcnRzXzEiLCJkZWJ1Z18xIiwiY29va2llXzEiLCJ3c18xIiwiY2xpZW50c0NvdW50Iiwid3NFbmdpbmUiLCJwaW5nVGltZW91dCIsInBpbmdJbnRlcnZhbCIsInVwZ3JhZGVUaW1lb3V0IiwibWF4SHR0cEJ1ZmZlclNpemUiLCJhbGxvd1VwZ3JhZGVzIiwiaHR0cENvbXByZXNzaW9uIiwiYWxsb3dFSU8zIiwidHJhbnNwb3J0IiwidXBncmFkZXNUbyIsIl9xdWVyeSIsIlVOS05PV05fVFJBTlNQT1JUIiwiaXNPcmlnaW5JbnZhbGlkIiwiY2hlY2tJbnZhbGlkSGVhZGVyQ2hhciIsIkJBRF9SRVFVRVNUIiwiVU5LTk9XTl9TSUQiLCJwcmV2aW91c1RyYW5zcG9ydCIsIkJBRF9IQU5EU0hBS0VfTUVUSE9EIiwiYWxsb3dSZXF1ZXN0Iiwic3VjY2VzcyIsIkZPUkJJRERFTiIsInRyYW5zcG9ydE5hbWUiLCJjbG9zZUNvbm5lY3Rpb24iLCJFSU8iLCJVTlNVUFBPUlRFRF9QUk9UT0NPTF9WRVJTSU9OIiwiZXJyb3JNZXNzYWdlcyIsImNyZWF0ZVRyYW5zcG9ydCIsImlzSW5pdGlhbFJlcXVlc3QiLCJvblJlcXVlc3QiLCJoZWFkZXJzQXJyYXkiLCJhZGRpdGlvbmFsSGVhZGVycyIsInByZXBhcmUiLCJlcnJvckNvbnRleHQiLCJhYm9ydFJlcXVlc3QiLCJoYW5kc2hha2UiLCJ2ZXJpZnkiLCJ1cGdyYWRlSGVhZCIsImFib3J0VXBncmFkZSIsIm9uV2ViU29ja2V0Iiwib25VcGdyYWRlRXJyb3IiLCJoYW5kbGVzVXBncmFkZXMiLCJ1cGdyYWRpbmciLCJ1cGdyYWRlZCIsIm1heWJlVXBncmFkZSIsImRlc3Ryb3lVcGdyYWRlVGltZW91dCIsImNoZWNrIiwiaGFuZGxlUmVxdWVzdCIsImRlc3Ryb3lVcGdyYWRlIiwiYnl0ZXNXcml0dGVuIiwidmFsaWRIZHJDaGFycyIsInRpbWVyc18xIiwid3JpdGVCdWZmZXIiLCJwYWNrZXRzRm4iLCJzZW50Q2FsbGJhY2tGbiIsImNsZWFudXBGbiIsInJlbW90ZUFkZHJlc3MiLCJjb25uZWN0aW9uIiwiY2hlY2tJbnRlcnZhbFRpbWVyIiwidXBncmFkZVRpbWVvdXRUaW1lciIsInBpbmdUaW1lb3V0VGltZXIiLCJwaW5nSW50ZXJ2YWxUaW1lciIsInNldFRyYW5zcG9ydCIsInNlbmRQYWNrZXQiLCJ1cGdyYWRlcyIsImdldEF2YWlsYWJsZVVwZ3JhZGVzIiwiaW5pdGlhbFBhY2tldCIsInJlc2V0UGluZ1RpbWVvdXQiLCJzY2hlZHVsZVBpbmciLCJyZWZyZXNoIiwib25QYWNrZXQiLCJzZXR1cFNlbmRDYWxsYmFjayIsImNsZWFySW50ZXJ2YWwiLCJzZXRJbnRlcnZhbCIsImRpc2NhcmQiLCJjbGVhclRyYW5zcG9ydCIsIm9uVHJhbnNwb3J0Q2xvc2UiLCJ0b0NsZWFuVXAiLCJvbkRyYWluIiwic2VxRm4iLCJ3YnVmIiwic3VwcG9ydHNGcmFtaW5nIiwiYXZhaWxhYmxlVXBncmFkZXMiLCJhbGxVcGdyYWRlcyIsInVwZyIsImNsb3NlVHJhbnNwb3J0IiwicGFyc2VyX3Y0IiwicGFyc2VyX3YzIiwiZGlzY2FyZGVkIiwicG9sbGluZ18xIiwid2Vic29ja2V0XzEiLCJwb2xsaW5nIiwiUG9sbGluZyIsInpsaWJfMSIsImNvbXByZXNzaW9uTWV0aG9kcyIsImd6aXAiLCJjcmVhdGVHemlwIiwiZGVmbGF0ZSIsImNyZWF0ZURlZmxhdGUiLCJnZXRNZXRob2QiLCJvblBvbGxSZXF1ZXN0Iiwib25EYXRhUmVxdWVzdCIsIndyaXRlU3RhdHVzIiwib25BYm9ydGVkIiwic2hvdWxkQ2xvc2UiLCJkYXRhUmVxIiwiZXhwZWN0ZWRDb250ZW50TGVuZ3RoIiwiZGF0YVJlcyIsIndyaXRlSGVhZGVyIiwib25FbmQiLCJvbkRhdGEiLCJvbkRhdGFSZXF1ZXN0Q2xlYW51cCIsImFycmF5QnVmZmVyIiwiaXNMYXN0IiwiZG9Xcml0ZSIsInNvbWUiLCJyZXNwb25kIiwibnJlYWQiLCJjbG9zZVRpbWVvdXRUaW1lciIsInVhIiwid3NQcmVFbmNvZGVkIiwicG9sbGluZ19qc29ucF8xIiwiSlNPTlAiLCJyRG91YmxlU2xhc2hlcyIsInJTbGFzaGVzIiwiZm9vdCIsImpzIiwiY2h1bmtzIiwiY29udGVudExlbmd0aCIsInNldEVuY29kaW5nIiwidHJhbnNwb3J0c191d3NfMSIsImdldFF1ZXJ5IiwiZnJvbUVudHJpZXMiLCJlbnRyaWVzIiwiZ2V0UmVtb3RlQWRkcmVzc0FzVGV4dCIsImFwcCIsImFueSIsImNvbXByZXNzaW9uIiwiaWRsZVRpbWVvdXQiLCJtYXhCYWNrcHJlc3N1cmUiLCJtYXhQYXlsb2FkTGVuZ3RoIiwiZ2V0VXJsIiwiUmVzcG9uc2VXcmFwcGVyIiwic3RhdHVzV3JpdHRlbiIsIndyaXRlQnVmZmVyZWRIZWFkZXJzIiwiUmVtb3RlU29ja2V0IiwiQnJvYWRjYXN0T3BlcmF0b3IiLCJzb2NrZXRfaW9fcGFyc2VyXzEiLCJsb2NhbCIsImV2IiwiUkVTRVJWRURfRVZFTlRTIiwiYnJvYWRjYXN0IiwiZmV0Y2hTb2NrZXRzIiwiYWRkU29ja2V0cyIsImRlbFNvY2tldHMiLCJkaXNjb25uZWN0U29ja2V0cyIsImRldGFpbHMiLCJvcGVyYXRvciIsInNvY2tldHNKb2luIiwic29ja2V0c0xlYXZlIiwiQ2xpZW50IiwiZGVidWdNb2R1bGUiLCJjb25uIiwibnNwcyIsImRlY29kZXIiLCJfcGFyc2VyIiwib25jbG9zZSIsIm9uZGF0YSIsIm9uZGVjb2RlZCIsImNvbm5lY3RUaW1lb3V0IiwiX2Nvbm5lY3RUaW1lb3V0IiwiX25zcHMiLCJkb0Nvbm5lY3QiLCJfY2hlY2tOYW1lc3BhY2UiLCJkeW5hbWljTnNwTmFtZSIsIl9wYWNrZXQiLCJvZiIsIl9hZGQiLCJjbGVhciIsIl9vbnBhY2tldCIsIl9vbmVycm9yIiwiX29uY2xvc2UiLCJfX2NyZWF0ZUJpbmRpbmciLCJrMiIsIl9fc2V0TW9kdWxlRGVmYXVsdCIsIl9faW1wb3J0U3RhciIsIk5hbWVzcGFjZSIsImZzXzEiLCJzdHJlYW1fMSIsImVuZ2luZV9pb18xIiwiY2xpZW50XzEiLCJuYW1lc3BhY2VfMSIsInBhcmVudF9uYW1lc3BhY2VfMSIsInNvY2tldF9pb19hZGFwdGVyXzEiLCJ0eXBlZF9ldmVudHNfMSIsInV3c19qc18xIiwiY2xpZW50VmVyc2lvbiIsImRvdE1hcFJlZ2V4Iiwic3J2IiwicGFyZW50TnNwcyIsInNlcnZlQ2xpZW50IiwiX3NlcnZlQ2xpZW50Iiwia2V5c0l0ZXJhdG9yIiwicnVuIiwibmV4dEZuIiwiYWxsb3ciLCJjcmVhdGVDaGlsZCIsImVtaXRSZXNlcnZlZCIsIl9wYXRoIiwiZXNjYXBlZFBhdGgiLCJjbGllbnRQYXRoUmVnZXgiLCJfYWRhcHRlciIsIl9pbml0QWRhcHRlciIsImluaXRFbmdpbmUiLCJzZXRZaWVsZCIsImZpbGVuYW1lIiwiaXNNYXAiLCJleHBlY3RlZEV0YWciLCJ3ZWFrRXRhZyIsImV0YWciLCJmaWxlcGF0aCIsInNlcnZlRmlsZSIsInBhdGNoQWRhcHRlciIsImVpbyIsImF0dGFjaFNlcnZlIiwiZXZzIiwic2VydmUiLCJzZW5kRmlsZSIsIm9uY29ubmVjdGlvbiIsInBhcmVudE5zcCIsIlBhcmVudE5hbWVzcGFjZSIsInJlc3RvcmVBZGFwdGVyIiwic2VydmVyU2lkZUVtaXQiLCJhbGxTb2NrZXRzIiwicmVhZFN0cmVhbSIsImNyZWF0ZVJlYWRTdHJlYW0iLCJjcmVhdGVCcm90bGlDb21wcmVzcyIsInBpcGVsaW5lIiwiU3RyaWN0RXZlbnRFbWl0dGVyIiwiZW1pdHRlck1ldGhvZHMiLCJicm9hZGNhc3Rfb3BlcmF0b3JfMSIsIl9mbnMiLCJfaWRzIiwiX2Vycm9yIiwiX29uY29ubmVjdCIsImNoaWxkcmVuIiwiYmFzZTY0aWRfMSIsImNvbm5lY3RlZCIsImFja3MiLCJidWlsZEhhbmRzaGFrZSIsInRpbWUiLCJ4ZG9tYWluIiwiaXNzdWVkIiwicmVnaXN0ZXJBY2tDYWxsYmFjayIsImFjayIsInRpbWVyIiwibmV3QnJvYWRjYXN0T3BlcmF0b3IiLCJhZGRBbGwiLCJkZWwiLCJkZWxBbGwiLCJvbmV2ZW50Iiwib25hY2siLCJvbmRpc2Nvbm5lY3QiLCJfYW55TGlzdGVuZXJzIiwic2VudCIsImxlYXZlQWxsIiwiX3JlbW92ZSIsIl9kaXNjb25uZWN0Iiwic29ja2V0Um9vbXMiLCJpc05ldyIsInN1YnNjcmliZSIsInNlc3Npb25JZCIsInRvcGljIiwidW5zdWJzY3JpYmUiLCJ1c2VGYXN0UHVibGlzaCIsImJhc2VQYWNrZXRPcHRzIiwicHVibGlzaCIsIm5hbWVzcGFjZU5hbWUiLCJzdGF0U3luYyIsImRlc3Ryb3lSZWFkU3RyZWFtIiwib25EYXRhQ2h1bmsiLCJhcnJheUJ1ZmZlckNodW5rIiwibGFzdE9mZnNldCIsImdldFdyaXRlT2Zmc2V0IiwidHJ5RW5kIiwib25Xcml0YWJsZSIsImlvIl0sInNvdXJjZVJvb3QiOiIifQ==