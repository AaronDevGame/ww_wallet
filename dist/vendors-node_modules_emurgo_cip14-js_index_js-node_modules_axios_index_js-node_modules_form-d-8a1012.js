(self["webpackChunkwallet_test"] = self["webpackChunkwallet_test"] || []).push([["vendors-node_modules_emurgo_cip14-js_index_js-node_modules_axios_index_js-node_modules_form-d-8a1012"],{

/***/ "./node_modules/@emurgo/cip14-js/index.js":
/*!************************************************!*\
  !*** ./node_modules/@emurgo/cip14-js/index.js ***!
  \************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {



function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

var __importDefault = this && this.__importDefault || function (mod) {
  return mod && mod.__esModule ? mod : {
    "default": mod
  };
};

Object.defineProperty(exports, "__esModule", ({
  value: true
}));

var blake2b_1 = __importDefault(__webpack_require__(/*! blake2b */ "./node_modules/blake2b/index.js"));

var bech32_1 = __webpack_require__(/*! bech32 */ "./node_modules/bech32/dist/index.js"); /// note: this function can't be inverted due to the hash


var DATA = "asset";

var AssetFingerprint = /*#__PURE__*/function () {
  function AssetFingerprint(hashBuf) {
    _classCallCheck(this, AssetFingerprint);

    this.hashBuf = hashBuf;
  }

  _createClass(AssetFingerprint, [{
    key: "fingerprint",
    value: function fingerprint() {
      var words = bech32_1.bech32.toWords(this.hashBuf);
      return bech32_1.bech32.encode(DATA, words);
    }
  }, {
    key: "hash",
    value: function hash() {
      return Buffer.from(this.hashBuf).toString("hex");
    }
  }, {
    key: "prefix",
    value: function prefix() {
      return DATA;
    } // The last six characters of the data part form a checksum and contain no information

  }, {
    key: "checksum",
    value: function checksum() {
      return this.fingerprint().slice(-6);
    }
  }], [{
    key: "fromHash",
    value: function fromHash(hash) {
      return new AssetFingerprint(hash);
    }
  }, {
    key: "fromParts",
    value: function fromParts(policyId, assetName) {
      // see https://github.com/cardano-foundation/CIPs/pull/64
      var hashBuf = (0, blake2b_1["default"])(20).update(new Uint8Array([].concat(_toConsumableArray(policyId), _toConsumableArray(assetName)))).digest("binary");
      return AssetFingerprint.fromHash(hashBuf);
    }
  }, {
    key: "fromBech32",
    value: function fromBech32(fingerprint) {
      var _bech32_1$bech32$deco = bech32_1.bech32.decode(fingerprint),
          prefix = _bech32_1$bech32$deco.prefix,
          words = _bech32_1$bech32$deco.words;

      if (prefix !== DATA) {
        throw new Error("Invalid asset fingerprint");
      }

      var hashBuf = Buffer.from(bech32_1.bech32.fromWords(words));
      return AssetFingerprint.fromHash(hashBuf);
    }
  }]);

  return AssetFingerprint;
}();

exports["default"] = AssetFingerprint;

/***/ }),

/***/ "./node_modules/axios/index.js":
/*!*************************************!*\
  !*** ./node_modules/axios/index.js ***!
  \*************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! ./lib/axios */ "./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/adapters/xhr.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var settle = __webpack_require__(/*! ./../core/settle */ "./node_modules/axios/lib/core/settle.js");

var cookies = __webpack_require__(/*! ./../helpers/cookies */ "./node_modules/axios/lib/helpers/cookies.js");

var buildURL = __webpack_require__(/*! ./../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ "./node_modules/axios/lib/core/buildFullPath.js");

var parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ "./node_modules/axios/lib/helpers/parseHeaders.js");

var isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ "./node_modules/axios/lib/helpers/isURLSameOrigin.js");

var createError = __webpack_require__(/*! ../core/createError */ "./node_modules/axios/lib/core/createError.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;
    var responseType = config.responseType;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest(); // HTTP basic authentication

    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    var fullPath = buildFullPath(config.baseURL, config.url);
    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true); // Set the request timeout in MS

    request.timeout = config.timeout;

    function onloadend() {
      if (!request) {
        return;
      } // Prepare the response


      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !responseType || responseType === 'text' || responseType === 'json' ? request.responseText : request.response;
      var response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };
      settle(resolve, reject, response); // Clean up request

      request = null;
    }

    if ('onloadend' in request) {
      // Use onloadend if available
      request.onloadend = onloadend;
    } else {
      // Listen for ready state to emulate onloadend
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        } // The request errored out and we didn't get a response, this will be
        // handled by onerror instead
        // With one exception: request that using file: protocol, most browsers
        // will return status as 0 even though it's a successful request


        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
          return;
        } // readystate handler is calling before onerror or ontimeout handlers,
        // so we should call onloadend on the next 'tick'


        setTimeout(onloadend);
      };
    } // Handle browser request cancellation (as opposed to a manual cancellation)


    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }

      reject(createError('Request aborted', config, 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Handle low level network errors


    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request)); // Clean up request

      request = null;
    }; // Handle timeout


    request.ontimeout = function handleTimeout() {
      var timeoutErrorMessage = 'timeout of ' + config.timeout + 'ms exceeded';

      if (config.timeoutErrorMessage) {
        timeoutErrorMessage = config.timeoutErrorMessage;
      }

      reject(createError(timeoutErrorMessage, config, config.transitional && config.transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED', request)); // Clean up request

      request = null;
    }; // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.


    if (utils.isStandardBrowserEnv()) {
      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    } // Add headers to the request


    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    } // Add withCredentials to request if needed


    if (!utils.isUndefined(config.withCredentials)) {
      request.withCredentials = !!config.withCredentials;
    } // Add responseType to request if needed


    if (responseType && responseType !== 'json') {
      request.responseType = config.responseType;
    } // Handle progress if needed


    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    } // Not all browsers support upload events


    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel); // Clean up request

        request = null;
      });
    }

    if (!requestData) {
      requestData = null;
    } // Send the request


    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/axios.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js");

var Axios = __webpack_require__(/*! ./core/Axios */ "./node_modules/axios/lib/core/Axios.js");

var mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var defaults = __webpack_require__(/*! ./defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */


function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context); // Copy axios.prototype to instance

  utils.extend(instance, Axios.prototype, context); // Copy context to instance

  utils.extend(instance, context);
  return instance;
} // Create the default instance to be exported


var axios = createInstance(defaults); // Expose Axios class to allow class inheritance

axios.Axios = Axios; // Factory for creating new instances

axios.create = function create(instanceConfig) {
  return createInstance(mergeConfig(axios.defaults, instanceConfig));
}; // Expose Cancel & CancelToken


axios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ "./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js"); // Expose all/spread

axios.all = function all(promises) {
  return Promise.all(promises);
};

axios.spread = __webpack_require__(/*! ./helpers/spread */ "./node_modules/axios/lib/helpers/spread.js"); // Expose isAxiosError

axios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ "./node_modules/axios/lib/helpers/isAxiosError.js");
module.exports = axios; // Allow use of default import syntax in TypeScript

module.exports["default"] = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/*!*************************************************!*\
  !*** ./node_modules/axios/lib/cancel/Cancel.js ***!
  \*************************************************/
/***/ ((module) => {


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;
module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/cancel/CancelToken.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var Cancel = __webpack_require__(/*! ./Cancel */ "./node_modules/axios/lib/cancel/Cancel.js");
/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */


function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });
  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};
/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */


CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/cancel/isCancel.js ***!
  \***************************************************/
/***/ ((module) => {



module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/*!**********************************************!*\
  !*** ./node_modules/axios/lib/core/Axios.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var buildURL = __webpack_require__(/*! ../helpers/buildURL */ "./node_modules/axios/lib/helpers/buildURL.js");

var InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ "./node_modules/axios/lib/core/InterceptorManager.js");

var dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ "./node_modules/axios/lib/core/dispatchRequest.js");

var mergeConfig = __webpack_require__(/*! ./mergeConfig */ "./node_modules/axios/lib/core/mergeConfig.js");

var validator = __webpack_require__(/*! ../helpers/validator */ "./node_modules/axios/lib/helpers/validator.js");

var validators = validator.validators;
/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */

function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}
/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */


Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = arguments[1] || {};
    config.url = arguments[0];
  } else {
    config = config || {};
  }

  config = mergeConfig(this.defaults, config); // Set config.method

  if (config.method) {
    config.method = config.method.toLowerCase();
  } else if (this.defaults.method) {
    config.method = this.defaults.method.toLowerCase();
  } else {
    config.method = 'get';
  }

  var transitional = config.transitional;

  if (transitional !== undefined) {
    validator.assertOptions(transitional, {
      silentJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      forcedJSONParsing: validators.transitional(validators["boolean"], '1.0.0'),
      clarifyTimeoutError: validators.transitional(validators["boolean"], '1.0.0')
    }, false);
  } // filter out skipped interceptors


  var requestInterceptorChain = [];
  var synchronousRequestInterceptors = true;
  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {
      return;
    }

    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
  });
  var responseInterceptorChain = [];
  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
  });
  var promise;

  if (!synchronousRequestInterceptors) {
    var chain = [dispatchRequest, undefined];
    Array.prototype.unshift.apply(chain, requestInterceptorChain);
    chain = chain.concat(responseInterceptorChain);
    promise = Promise.resolve(config);

    while (chain.length) {
      promise = promise.then(chain.shift(), chain.shift());
    }

    return promise;
  }

  var newConfig = config;

  while (requestInterceptorChain.length) {
    var onFulfilled = requestInterceptorChain.shift();
    var onRejected = requestInterceptorChain.shift();

    try {
      newConfig = onFulfilled(newConfig);
    } catch (error) {
      onRejected(error);
      break;
    }
  }

  try {
    promise = dispatchRequest(newConfig);
  } catch (error) {
    return Promise.reject(error);
  }

  while (responseInterceptorChain.length) {
    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());
  }

  return promise;
};

Axios.prototype.getUri = function getUri(config) {
  config = mergeConfig(this.defaults, config);
  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\?/, '');
}; // Provide aliases for supported request methods


utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: (config || {}).data
    }));
  };
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(mergeConfig(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});
module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/core/InterceptorManager.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}
/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */


InterceptorManager.prototype.use = function use(fulfilled, rejected, options) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected,
    synchronous: options ? options.synchronous : false,
    runWhen: options ? options.runWhen : null
  });
  return this.handlers.length - 1;
};
/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */


InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};
/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */


InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/buildFullPath.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/buildFullPath.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ "./node_modules/axios/lib/helpers/isAbsoluteURL.js");

var combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ "./node_modules/axios/lib/helpers/combineURLs.js");
/**
 * Creates a new URL by combining the baseURL with the requestedURL,
 * only when the requestedURL is not already an absolute URL.
 * If the requestURL is absolute, this function returns the requestedURL untouched.
 *
 * @param {string} baseURL The base URL
 * @param {string} requestedURL Absolute or relative URL to combine
 * @returns {string} The combined full path
 */


module.exports = function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }

  return requestedURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/createError.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var enhanceError = __webpack_require__(/*! ./enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");
/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */


module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/core/dispatchRequest.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var transformData = __webpack_require__(/*! ./transformData */ "./node_modules/axios/lib/core/transformData.js");

var isCancel = __webpack_require__(/*! ../cancel/isCancel */ "./node_modules/axios/lib/cancel/isCancel.js");

var defaults = __webpack_require__(/*! ../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Throws a `Cancel` if cancellation has been requested.
 */


function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}
/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */


module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config); // Ensure headers exist

  config.headers = config.headers || {}; // Transform request data

  config.data = transformData.call(config, config.data, config.headers, config.transformRequest); // Flatten headers

  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers);
  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });
  var adapter = config.adapter || defaults.adapter;
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config); // Transform response data

    response.data = transformData.call(config, response.data, response.headers, config.transformResponse);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config); // Transform response data

      if (reason && reason.response) {
        reason.response.data = transformData.call(config, reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/core/enhanceError.js ***!
  \*****************************************************/
/***/ ((module) => {


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;

  if (code) {
    error.code = code;
  }

  error.request = request;
  error.response = response;
  error.isAxiosError = true;

  error.toJSON = function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: this.config,
      code: this.code
    };
  };

  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/mergeConfig.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/core/mergeConfig.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");
/**
 * Config-specific merge-function which creates a new config-object
 * by merging two configuration objects together.
 *
 * @param {Object} config1
 * @param {Object} config2
 * @returns {Object} New object resulting from merging config2 to config1
 */


module.exports = function mergeConfig(config1, config2) {
  // eslint-disable-next-line no-param-reassign
  config2 = config2 || {};
  var config = {};
  var valueFromConfig2Keys = ['url', 'method', 'data'];
  var mergeDeepPropertiesKeys = ['headers', 'auth', 'proxy', 'params'];
  var defaultToConfig2Keys = ['baseURL', 'transformRequest', 'transformResponse', 'paramsSerializer', 'timeout', 'timeoutMessage', 'withCredentials', 'adapter', 'responseType', 'xsrfCookieName', 'xsrfHeaderName', 'onUploadProgress', 'onDownloadProgress', 'decompress', 'maxContentLength', 'maxBodyLength', 'maxRedirects', 'transport', 'httpAgent', 'httpsAgent', 'cancelToken', 'socketPath', 'responseEncoding'];
  var directMergeKeys = ['validateStatus'];

  function getMergedValue(target, source) {
    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {
      return utils.merge(target, source);
    } else if (utils.isPlainObject(source)) {
      return utils.merge({}, source);
    } else if (utils.isArray(source)) {
      return source.slice();
    }

    return source;
  }

  function mergeDeepProperties(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  }

  utils.forEach(valueFromConfig2Keys, function valueFromConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    }
  });
  utils.forEach(mergeDeepPropertiesKeys, mergeDeepProperties);
  utils.forEach(defaultToConfig2Keys, function defaultToConfig2(prop) {
    if (!utils.isUndefined(config2[prop])) {
      config[prop] = getMergedValue(undefined, config2[prop]);
    } else if (!utils.isUndefined(config1[prop])) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  utils.forEach(directMergeKeys, function merge(prop) {
    if (prop in config2) {
      config[prop] = getMergedValue(config1[prop], config2[prop]);
    } else if (prop in config1) {
      config[prop] = getMergedValue(undefined, config1[prop]);
    }
  });
  var axiosKeys = valueFromConfig2Keys.concat(mergeDeepPropertiesKeys).concat(defaultToConfig2Keys).concat(directMergeKeys);
  var otherKeys = Object.keys(config1).concat(Object.keys(config2)).filter(function filterAxiosKeys(key) {
    return axiosKeys.indexOf(key) === -1;
  });
  utils.forEach(otherKeys, mergeDeepProperties);
  return config;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/*!***********************************************!*\
  !*** ./node_modules/axios/lib/core/settle.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var createError = __webpack_require__(/*! ./createError */ "./node_modules/axios/lib/core/createError.js");
/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */


module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;

  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/*!******************************************************!*\
  !*** ./node_modules/axios/lib/core/transformData.js ***!
  \******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

var defaults = __webpack_require__(/*! ./../defaults */ "./node_modules/axios/lib/defaults.js");
/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */


module.exports = function transformData(data, headers, fns) {
  var context = this || defaults;
  /*eslint no-param-reassign:0*/

  utils.forEach(fns, function transform(fn) {
    data = fn.call(context, data, headers);
  });
  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/*!********************************************!*\
  !*** ./node_modules/axios/lib/defaults.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./utils */ "./node_modules/axios/lib/utils.js");

var normalizeHeaderName = __webpack_require__(/*! ./helpers/normalizeHeaderName */ "./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var enhanceError = __webpack_require__(/*! ./core/enhanceError */ "./node_modules/axios/lib/core/enhanceError.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;

  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__(/*! ./adapters/xhr */ "./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {
    // For node use HTTP adapter
    adapter = __webpack_require__(/*! ./adapters/http */ "./node_modules/axios/lib/adapters/xhr.js");
  }

  return adapter;
}

function stringifySafely(rawValue, parser, encoder) {
  if (utils.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils.trim(rawValue);
    } catch (e) {
      if (e.name !== 'SyntaxError') {
        throw e;
      }
    }
  }

  return (encoder || JSON.stringify)(rawValue);
}

var defaults = {
  transitional: {
    silentJSONParsing: true,
    forcedJSONParsing: true,
    clarifyTimeoutError: false
  },
  adapter: getDefaultAdapter(),
  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Accept');
    normalizeHeaderName(headers, 'Content-Type');

    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }

    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }

    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }

    if (utils.isObject(data) || headers && headers['Content-Type'] === 'application/json') {
      setContentTypeIfUnset(headers, 'application/json');
      return stringifySafely(data);
    }

    return data;
  }],
  transformResponse: [function transformResponse(data) {
    var transitional = this.transitional;
    var silentJSONParsing = transitional && transitional.silentJSONParsing;
    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;
    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';

    if (strictJSONParsing || forcedJSONParsing && utils.isString(data) && data.length) {
      try {
        return JSON.parse(data);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === 'SyntaxError') {
            throw enhanceError(e, this, 'E_JSON_PARSE');
          }

          throw e;
        }
      }
    }

    return data;
  }],

  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',
  maxContentLength: -1,
  maxBodyLength: -1,
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};
defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};
utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});
utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});
module.exports = defaults;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/*!************************************************!*\
  !*** ./node_modules/axios/lib/helpers/bind.js ***!
  \************************************************/
/***/ ((module) => {



module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);

    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }

    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/*!****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/buildURL.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}
/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */


module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;

  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];
    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      } else {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }

        parts.push(encode(key) + '=' + encode(v));
      });
    });
    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    var hashmarkIndex = url.indexOf('#');

    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }

    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/*!*******************************************************!*\
  !*** ./node_modules/axios/lib/helpers/combineURLs.js ***!
  \*******************************************************/
/***/ ((module) => {


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/*!***************************************************!*\
  !*** ./node_modules/axios/lib/helpers/cookies.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },
    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() : // Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/*!*********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAbsoluteURL.js ***!
  \*********************************************************/
/***/ ((module) => {


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return /^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url);
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAxiosError.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isAxiosError.js ***!
  \********************************************************/
/***/ ((module) => {


/**
 * Determines whether the payload is an error thrown by Axios
 *
 * @param {*} payload The value to test
 * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false
 */

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = function isAxiosError(payload) {
  return _typeof(payload) === 'object' && payload.isAxiosError === true;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/*!***********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/isURLSameOrigin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ? // Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;
  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */

  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href); // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils

    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);
  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */

  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() : // Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/*!***************************************************************!*\
  !*** ./node_modules/axios/lib/helpers/normalizeHeaderName.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ../utils */ "./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/*!********************************************************!*\
  !*** ./node_modules/axios/lib/helpers/parseHeaders.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var utils = __webpack_require__(/*! ./../utils */ "./node_modules/axios/lib/utils.js"); // Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers


var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];
/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */

module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }

      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });
  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/*!**************************************************!*\
  !*** ./node_modules/axios/lib/helpers/spread.js ***!
  \**************************************************/
/***/ ((module) => {


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/validator.js":
/*!*****************************************************!*\
  !*** ./node_modules/axios/lib/helpers/validator.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var pkg = __webpack_require__(/*! ./../../package.json */ "./node_modules/axios/package.json");

var validators = {}; // eslint-disable-next-line func-names

['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function (type, i) {
  validators[type] = function validator(thing) {
    return _typeof(thing) === type || 'a' + (i < 1 ? 'n ' : ' ') + type;
  };
});
var deprecatedWarnings = {};
var currentVerArr = pkg.version.split('.');
/**
 * Compare package versions
 * @param {string} version
 * @param {string?} thanVersion
 * @returns {boolean}
 */

function isOlderVersion(version, thanVersion) {
  var pkgVersionArr = thanVersion ? thanVersion.split('.') : currentVerArr;
  var destVer = version.split('.');

  for (var i = 0; i < 3; i++) {
    if (pkgVersionArr[i] > destVer[i]) {
      return true;
    } else if (pkgVersionArr[i] < destVer[i]) {
      return false;
    }
  }

  return false;
}
/**
 * Transitional option validator
 * @param {function|boolean?} validator
 * @param {string?} version
 * @param {string} message
 * @returns {function}
 */


validators.transitional = function transitional(validator, version, message) {
  var isDeprecated = version && isOlderVersion(version);

  function formatMessage(opt, desc) {
    return '[Axios v' + pkg.version + '] Transitional option \'' + opt + '\'' + desc + (message ? '. ' + message : '');
  } // eslint-disable-next-line func-names


  return function (value, opt, opts) {
    if (validator === false) {
      throw new Error(formatMessage(opt, ' has been removed in ' + version));
    }

    if (isDeprecated && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true; // eslint-disable-next-line no-console

      console.warn(formatMessage(opt, ' has been deprecated since v' + version + ' and will be removed in the near future'));
    }

    return validator ? validator(value, opt, opts) : true;
  };
};
/**
 * Assert object's properties type
 * @param {object} options
 * @param {object} schema
 * @param {boolean?} allowUnknown
 */


function assertOptions(options, schema, allowUnknown) {
  if (_typeof(options) !== 'object') {
    throw new TypeError('options must be an object');
  }

  var keys = Object.keys(options);
  var i = keys.length;

  while (i-- > 0) {
    var opt = keys[i];
    var validator = schema[opt];

    if (validator) {
      var value = options[opt];
      var result = value === undefined || validator(value, opt, options);

      if (result !== true) {
        throw new TypeError('option ' + opt + ' must be ' + result);
      }

      continue;
    }

    if (allowUnknown !== true) {
      throw Error('Unknown option ' + opt);
    }
  }
}

module.exports = {
  isOlderVersion: isOlderVersion,
  assertOptions: assertOptions,
  validators: validators
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/*!*****************************************!*\
  !*** ./node_modules/axios/lib/utils.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var bind = __webpack_require__(/*! ./helpers/bind */ "./node_modules/axios/lib/helpers/bind.js"); // utils is a library of generic helper functions non-specific to axios


var toString = Object.prototype.toString;
/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */

function isArray(val) {
  return toString.call(val) === '[object Array]';
}
/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */


function isUndefined(val) {
  return typeof val === 'undefined';
}
/**
 * Determine if a value is a Buffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Buffer, otherwise false
 */


function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);
}
/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */


function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}
/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */


function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}
/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */


function isArrayBufferView(val) {
  var result;

  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }

  return result;
}
/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */


function isString(val) {
  return typeof val === 'string';
}
/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */


function isNumber(val) {
  return typeof val === 'number';
}
/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */


function isObject(val) {
  return val !== null && _typeof(val) === 'object';
}
/**
 * Determine if a value is a plain Object
 *
 * @param {Object} val The value to test
 * @return {boolean} True if value is a plain Object, otherwise false
 */


function isPlainObject(val) {
  if (toString.call(val) !== '[object Object]') {
    return false;
  }

  var prototype = Object.getPrototypeOf(val);
  return prototype === null || prototype === Object.prototype;
}
/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */


function isDate(val) {
  return toString.call(val) === '[object Date]';
}
/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */


function isFile(val) {
  return toString.call(val) === '[object File]';
}
/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */


function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}
/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */


function isFunction(val) {
  return toString.call(val) === '[object Function]';
}
/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */


function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}
/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */


function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}
/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */


function trim(str) {
  return str.trim ? str.trim() : str.replace(/^\s+|\s+$/g, '');
}
/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 * nativescript
 *  navigator.product -> 'NativeScript' or 'NS'
 */


function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' || navigator.product === 'NativeScript' || navigator.product === 'NS')) {
    return false;
  }

  return typeof window !== 'undefined' && typeof document !== 'undefined';
}
/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */


function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  } // Force an array if not already something iterable


  if (_typeof(obj) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}
/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */


function
  /* obj1, obj2, obj3, ... */
merge() {
  var result = {};

  function assignValue(val, key) {
    if (isPlainObject(result[key]) && isPlainObject(val)) {
      result[key] = merge(result[key], val);
    } else if (isPlainObject(val)) {
      result[key] = merge({}, val);
    } else if (isArray(val)) {
      result[key] = val.slice();
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }

  return result;
}
/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */


function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}
/**
 * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)
 *
 * @param {string} content with BOM
 * @return {string} content value without BOM
 */


function stripBOM(content) {
  if (content.charCodeAt(0) === 0xFEFF) {
    content = content.slice(1);
  }

  return content;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim,
  stripBOM: stripBOM
};

/***/ }),

/***/ "./node_modules/base64-js/index.js":
/*!*****************************************!*\
  !*** ./node_modules/base64-js/index.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, exports) => {



exports.byteLength = byteLength;
exports.toByteArray = toByteArray;
exports.fromByteArray = fromByteArray;
var lookup = [];
var revLookup = [];
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i];
  revLookup[code.charCodeAt(i)] = i;
} // Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications


revLookup['-'.charCodeAt(0)] = 62;
revLookup['_'.charCodeAt(0)] = 63;

function getLens(b64) {
  var len = b64.length;

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4');
  } // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42


  var validLen = b64.indexOf('=');
  if (validLen === -1) validLen = len;
  var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
  return [validLen, placeHoldersLen];
} // base64 is 4/3 + up to two characters of the original data


function byteLength(b64) {
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function _byteLength(b64, validLen, placeHoldersLen) {
  return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
}

function toByteArray(b64) {
  var tmp;
  var lens = getLens(b64);
  var validLen = lens[0];
  var placeHoldersLen = lens[1];
  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
  var curByte = 0; // if there are placeholders, only get up to the last complete 4 chars

  var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
  var i;

  for (i = 0; i < len; i += 4) {
    tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
    arr[curByte++] = tmp >> 16 & 0xFF;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 2) {
    tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
    arr[curByte++] = tmp & 0xFF;
  }

  if (placeHoldersLen === 1) {
    tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
    arr[curByte++] = tmp >> 8 & 0xFF;
    arr[curByte++] = tmp & 0xFF;
  }

  return arr;
}

function tripletToBase64(num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
}

function encodeChunk(uint8, start, end) {
  var tmp;
  var output = [];

  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
    output.push(tripletToBase64(tmp));
  }

  return output.join('');
}

function fromByteArray(uint8) {
  var tmp;
  var len = uint8.length;
  var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

  var parts = [];
  var maxChunkLength = 16383; // must be multiple of 3
  // go through the array every three bytes, we'll deal with trailing stuff later

  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
  } // pad the end with zeros, but make sure to not forget the extra bytes


  if (extraBytes === 1) {
    tmp = uint8[len - 1];
    parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1];
    parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
  }

  return parts.join('');
}

/***/ }),

/***/ "./node_modules/bech32/dist/index.js":
/*!*******************************************!*\
  !*** ./node_modules/bech32/dist/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

Object.defineProperty(exports, "__esModule", ({
  value: true
}));
exports.bech32m = exports.bech32 = void 0;
var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';
var ALPHABET_MAP = {};

for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z);
  ALPHABET_MAP[x] = z;
}

function polymodStep(pre) {
  var b = pre >> 25;
  return (pre & 0x1ffffff) << 5 ^ -(b >> 0 & 1) & 0x3b6a57b2 ^ -(b >> 1 & 1) & 0x26508e6d ^ -(b >> 2 & 1) & 0x1ea119fa ^ -(b >> 3 & 1) & 0x3d4233dd ^ -(b >> 4 & 1) & 0x2a1462b3;
}

function prefixChk(prefix) {
  var chk = 1;

  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i);
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')';
    chk = polymodStep(chk) ^ c >> 5;
  }

  chk = polymodStep(chk);

  for (var _i = 0; _i < prefix.length; ++_i) {
    var v = prefix.charCodeAt(_i);
    chk = polymodStep(chk) ^ v & 0x1f;
  }

  return chk;
}

function convert(data, inBits, outBits, pad) {
  var value = 0;
  var bits = 0;
  var maxV = (1 << outBits) - 1;
  var result = [];

  for (var i = 0; i < data.length; ++i) {
    value = value << inBits | data[i];
    bits += inBits;

    while (bits >= outBits) {
      bits -= outBits;
      result.push(value >> bits & maxV);
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push(value << outBits - bits & maxV);
    }
  } else {
    if (bits >= inBits) return 'Excess padding';
    if (value << outBits - bits & maxV) return 'Non-zero padding';
  }

  return result;
}

function toWords(bytes) {
  return convert(bytes, 8, 5, true);
}

function fromWordsUnsafe(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
}

function fromWords(words) {
  var res = convert(words, 5, 8, false);
  if (Array.isArray(res)) return res;
  throw new Error(res);
}

function getLibraryFromEncoding(encoding) {
  var ENCODING_CONST;

  if (encoding === 'bech32') {
    ENCODING_CONST = 1;
  } else {
    ENCODING_CONST = 0x2bc830a3;
  }

  function encode(prefix, words, LIMIT) {
    LIMIT = LIMIT || 90;
    if (prefix.length + 7 + words.length > LIMIT) throw new TypeError('Exceeds length limit');
    prefix = prefix.toLowerCase(); // determine chk mod

    var chk = prefixChk(prefix);
    if (typeof chk === 'string') throw new Error(chk);
    var result = prefix + '1';

    for (var i = 0; i < words.length; ++i) {
      var _x = words[i];
      if (_x >> 5 !== 0) throw new Error('Non 5-bit word');
      chk = polymodStep(chk) ^ _x;
      result += ALPHABET.charAt(_x);
    }

    for (var _i2 = 0; _i2 < 6; ++_i2) {
      chk = polymodStep(chk);
    }

    chk ^= ENCODING_CONST;

    for (var _i3 = 0; _i3 < 6; ++_i3) {
      var v = chk >> (5 - _i3) * 5 & 0x1f;
      result += ALPHABET.charAt(v);
    }

    return result;
  }

  function __decode(str, LIMIT) {
    LIMIT = LIMIT || 90;
    if (str.length < 8) return str + ' too short';
    if (str.length > LIMIT) return 'Exceeds length limit'; // don't allow mixed case

    var lowered = str.toLowerCase();
    var uppered = str.toUpperCase();
    if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str;
    str = lowered;
    var split = str.lastIndexOf('1');
    if (split === -1) return 'No separator character for ' + str;
    if (split === 0) return 'Missing prefix for ' + str;
    var prefix = str.slice(0, split);
    var wordChars = str.slice(split + 1);
    if (wordChars.length < 6) return 'Data too short';
    var chk = prefixChk(prefix);
    if (typeof chk === 'string') return chk;
    var words = [];

    for (var i = 0; i < wordChars.length; ++i) {
      var c = wordChars.charAt(i);
      var v = ALPHABET_MAP[c];
      if (v === undefined) return 'Unknown character ' + c;
      chk = polymodStep(chk) ^ v; // not in the checksum?

      if (i + 6 >= wordChars.length) continue;
      words.push(v);
    }

    if (chk !== ENCODING_CONST) return 'Invalid checksum for ' + str;
    return {
      prefix: prefix,
      words: words
    };
  }

  function decodeUnsafe(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
  }

  function decode(str, LIMIT) {
    var res = __decode(str, LIMIT);

    if (_typeof(res) === 'object') return res;
    throw new Error(res);
  }

  return {
    decodeUnsafe: decodeUnsafe,
    decode: decode,
    encode: encode,
    toWords: toWords,
    fromWordsUnsafe: fromWordsUnsafe,
    fromWords: fromWords
  };
}

exports.bech32 = getLibraryFromEncoding('bech32');
exports.bech32m = getLibraryFromEncoding('bech32m');

/***/ }),

/***/ "./node_modules/blake2b-wasm/blake2b.js":
/*!**********************************************!*\
  !*** ./node_modules/blake2b-wasm/blake2b.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = loadWebAssembly;
loadWebAssembly.supported = typeof WebAssembly !== 'undefined';

function loadWebAssembly(opts) {
  if (!loadWebAssembly.supported) return null;
  var imp = opts && opts.imports;
  var wasm = toUint8Array('AGFzbQEAAAABEANgAn9/AGADf39/AGABfwADBQQAAQICBQUBAQroBwdNBQZtZW1vcnkCAAxibGFrZTJiX2luaXQAAA5ibGFrZTJiX3VwZGF0ZQABDWJsYWtlMmJfZmluYWwAAhBibGFrZTJiX2NvbXByZXNzAAMK00AElgMAIABCADcDACAAQQhqQgA3AwAgAEEQakIANwMAIABBGGpCADcDACAAQSBqQgA3AwAgAEEoakIANwMAIABBMGpCADcDACAAQThqQgA3AwAgAEHAAGpCADcDACAAQcgAakIANwMAIABB0ABqQgA3AwAgAEHYAGpCADcDACAAQeAAakIANwMAIABB6ABqQgA3AwAgAEHwAGpCADcDACAAQfgAakIANwMAIABBgAFqQoiS853/zPmE6gBBACkDAIU3AwAgAEGIAWpCu86qptjQ67O7f0EIKQMAhTcDACAAQZABakKr8NP0r+68tzxBECkDAIU3AwAgAEGYAWpC8e30+KWn/aelf0EYKQMAhTcDACAAQaABakLRhZrv+s+Uh9EAQSApAwCFNwMAIABBqAFqQp/Y+dnCkdqCm39BKCkDAIU3AwAgAEGwAWpC6/qG2r+19sEfQTApAwCFNwMAIABBuAFqQvnC+JuRo7Pw2wBBOCkDAIU3AwAgAEHAAWpCADcDACAAQcgBakIANwMAIABB0AFqQgA3AwALbQEDfyAAQcABaiEDIABByAFqIQQgBCkDAKchBQJAA0AgASACRg0BIAVBgAFGBEAgAyADKQMAIAWtfDcDAEEAIQUgABADCyAAIAVqIAEtAAA6AAAgBUEBaiEFIAFBAWohAQwACwsgBCAFrTcDAAtkAQN/IABBwAFqIQEgAEHIAWohAiABIAEpAwAgAikDAHw3AwAgAEHQAWpCfzcDACACKQMApyEDAkADQCADQYABRg0BIAAgA2pBADoAACADQQFqIQMMAAsLIAIgA603AwAgABADC+U7AiB+CX8gAEGAAWohISAAQYgBaiEiIABBkAFqISMgAEGYAWohJCAAQaABaiElIABBqAFqISYgAEGwAWohJyAAQbgBaiEoICEpAwAhASAiKQMAIQIgIykDACEDICQpAwAhBCAlKQMAIQUgJikDACEGICcpAwAhByAoKQMAIQhCiJLznf/M+YTqACEJQrvOqqbY0Ouzu38hCkKr8NP0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');
  var ready = null;
  var mod = {
    buffer: wasm,
    memory: null,
    exports: null,
    realloc: realloc,
    onload: onload
  };
  onload(function () {});
  return mod;

  function realloc(size) {
    mod.exports.memory.grow(Math.ceil(Math.abs(size - mod.memory.length) / 65536));
    mod.memory = new Uint8Array(mod.exports.memory.buffer);
  }

  function onload(cb) {
    if (mod.exports) return cb();

    if (ready) {
      ready.then(cb.bind(null, null))["catch"](cb);
      return;
    }

    try {
      if (opts && opts.async) throw new Error('async');
      setup({
        instance: new WebAssembly.Instance(new WebAssembly.Module(wasm), imp)
      });
    } catch (err) {
      ready = WebAssembly.instantiate(wasm, imp).then(setup);
    }

    onload(cb);
  }

  function setup(w) {
    mod.exports = w.instance.exports;
    mod.memory = mod.exports.memory && mod.exports.memory.buffer && new Uint8Array(mod.exports.memory.buffer);
  }
}

function toUint8Array(s) {
  if (typeof atob === 'function') return new Uint8Array(atob(s).split('').map(charCodeAt));
  return new ((__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer))(s, 'base64');
}

function charCodeAt(c) {
  return c.charCodeAt(0);
}

/***/ }),

/***/ "./node_modules/blake2b-wasm/index.js":
/*!********************************************!*\
  !*** ./node_modules/blake2b-wasm/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var wasm = __webpack_require__(/*! ./blake2b */ "./node_modules/blake2b-wasm/blake2b.js")();

var head = 64;
var freeList = [];
module.exports = Blake2b;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;

function Blake2b(digestLength, key, salt, personal, noAssert) {
  if (!(this instanceof Blake2b)) return new Blake2b(digestLength, key, salt, personal, noAssert);
  if (!(wasm && wasm.exports)) throw new Error('WASM not loaded. Wait for Blake2b.ready(cb)');
  if (!digestLength) digestLength = 32;

  if (noAssert !== true) {
    assert(digestLength >= BYTES_MIN, 'digestLength must be at least ' + BYTES_MIN + ', was given ' + digestLength);
    assert(digestLength <= BYTES_MAX, 'digestLength must be at most ' + BYTES_MAX + ', was given ' + digestLength);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at least ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  if (!freeList.length) {
    freeList.push(head);
    head += 216;
  }

  this.digestLength = digestLength;
  this.finalized = false;
  this.pointer = freeList.pop();
  wasm.memory.fill(0, 0, 64);
  wasm.memory[0] = this.digestLength;
  wasm.memory[1] = key ? key.length : 0;
  wasm.memory[2] = 1; // fanout

  wasm.memory[3] = 1; // depth

  if (salt) wasm.memory.set(salt, 32);
  if (personal) wasm.memory.set(personal, 48);
  if (this.pointer + 216 > wasm.memory.length) wasm.realloc(this.pointer + 216); // we need 216 bytes for the state

  wasm.exports.blake2b_init(this.pointer, this.digestLength);

  if (key) {
    this.update(key);
    wasm.memory.fill(0, head, head + key.length); // whiteout key

    wasm.memory[this.pointer + 200] = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(this.finalized === false, 'Hash instance finalized');
  assert(input, 'input must be TypedArray or Buffer');
  if (head + input.length > wasm.memory.length) wasm.realloc(head + input.length);
  wasm.memory.set(input, head);
  wasm.exports.blake2b_update(this.pointer, head, head + input.length);
  return this;
};

Blake2b.prototype.digest = function (enc) {
  assert(this.finalized === false, 'Hash instance finalized');
  this.finalized = true;
  freeList.push(this.pointer);
  wasm.exports.blake2b_final(this.pointer);

  if (!enc || enc === 'binary') {
    return wasm.memory.slice(this.pointer + 128, this.pointer + 128 + this.digestLength);
  }

  if (enc === 'hex') {
    return hexSlice(wasm.memory, this.pointer + 128, this.digestLength);
  }

  assert(enc.length >= this.digestLength, 'input must be TypedArray or Buffer');

  for (var i = 0; i < this.digestLength; i++) {
    enc[i] = wasm.memory[this.pointer + 128 + i];
  }

  return enc;
}; // libsodium compat


Blake2b.prototype["final"] = Blake2b.prototype.digest;
Blake2b.WASM = wasm && wasm.buffer;
Blake2b.SUPPORTED = typeof WebAssembly !== 'undefined';

Blake2b.ready = function (cb) {
  if (!cb) cb = noop;
  if (!wasm) return cb(new Error('WebAssembly not supported')); // backwards compat, can be removed in a new major

  var p = new Promise(function (reject, resolve) {
    wasm.onload(function (err) {
      if (err) resolve();else reject();
      cb(err);
    });
  });
  return p;
};

Blake2b.prototype.ready = Blake2b.ready;

function noop() {}

function hexSlice(buf, start, len) {
  var str = '';

  for (var i = 0; i < len; i++) {
    str += toHex(buf[start + i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

/***/ }),

/***/ "./node_modules/blake2b/index.js":
/*!***************************************!*\
  !*** ./node_modules/blake2b/index.js ***!
  \***************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assert = __webpack_require__(/*! nanoassert */ "./node_modules/nanoassert/index.js");

var b2wasm = __webpack_require__(/*! blake2b-wasm */ "./node_modules/blake2b-wasm/index.js"); // 64-bit unsigned addition
// Sets v[a,a+1] += v[b,b+1]
// v should be a Uint32Array


function ADD64AA(v, a, b) {
  var o0 = v[a] + v[b];
  var o1 = v[a + 1] + v[b + 1];

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // 64-bit unsigned addition
// Sets v[a,a+1] += b
// b0 is the low 32 bits of b, b1 represents the high 32 bits


function ADD64AC(v, a, b0, b1) {
  var o0 = v[a] + b0;

  if (b0 < 0) {
    o0 += 0x100000000;
  }

  var o1 = v[a + 1] + b1;

  if (o0 >= 0x100000000) {
    o1++;
  }

  v[a] = o0;
  v[a + 1] = o1;
} // Little-endian byte access


function B2B_GET32(arr, i) {
  return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
} // G Mixing function
// The ROTRs are inlined for speed


function B2B_G(a, b, c, d, ix, iy) {
  var x0 = m[ix];
  var x1 = m[ix + 1];
  var y0 = m[iy];
  var y1 = m[iy + 1];
  ADD64AA(v, a, b); // v[a,a+1] += v[b,b+1] ... in JS we must store a uint64 as two uint32s

  ADD64AC(v, a, x0, x1); // v[a, a+1] += x ... x0 is the low 32 bits of x, x1 is the high 32 bits
  // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated to the right by 32 bits

  var xor0 = v[d] ^ v[a];
  var xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor1;
  v[d + 1] = xor0;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 24 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor0 >>> 24 ^ xor1 << 8;
  v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
  ADD64AA(v, a, b);
  ADD64AC(v, a, y0, y1); // v[d,d+1] = (v[d,d+1] xor v[a,a+1]) rotated right by 16 bits

  xor0 = v[d] ^ v[a];
  xor1 = v[d + 1] ^ v[a + 1];
  v[d] = xor0 >>> 16 ^ xor1 << 16;
  v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
  ADD64AA(v, c, d); // v[b,b+1] = (v[b,b+1] xor v[c,c+1]) rotated right by 63 bits

  xor0 = v[b] ^ v[c];
  xor1 = v[b + 1] ^ v[c + 1];
  v[b] = xor1 >>> 31 ^ xor0 << 1;
  v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
} // Initialization Vector


var BLAKE2B_IV32 = new Uint32Array([0xF3BCC908, 0x6A09E667, 0x84CAA73B, 0xBB67AE85, 0xFE94F82B, 0x3C6EF372, 0x5F1D36F1, 0xA54FF53A, 0xADE682D1, 0x510E527F, 0x2B3E6C1F, 0x9B05688C, 0xFB41BD6B, 0x1F83D9AB, 0x137E2179, 0x5BE0CD19]);
var SIGMA8 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3, 11, 8, 12, 0, 5, 2, 15, 13, 10, 14, 3, 6, 7, 1, 9, 4, 7, 9, 3, 1, 13, 12, 11, 14, 2, 6, 5, 10, 4, 0, 15, 8, 9, 0, 5, 7, 2, 4, 10, 15, 14, 1, 11, 12, 6, 8, 3, 13, 2, 12, 6, 10, 0, 11, 8, 3, 4, 13, 7, 5, 15, 14, 1, 9, 12, 5, 1, 15, 14, 13, 4, 10, 0, 7, 6, 3, 9, 2, 8, 11, 13, 11, 7, 14, 12, 1, 3, 9, 5, 0, 15, 4, 8, 6, 2, 10, 6, 15, 14, 9, 11, 3, 0, 8, 12, 2, 13, 7, 1, 4, 10, 5, 10, 2, 8, 4, 7, 6, 1, 5, 15, 11, 9, 14, 3, 12, 13, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 14, 10, 4, 8, 9, 15, 13, 6, 1, 12, 0, 2, 11, 7, 5, 3]; // These are offsets into a uint64 buffer.
// Multiply them all by 2 to make them offsets into a uint32 buffer,
// because this is Javascript and we don't have uint64s

var SIGMA82 = new Uint8Array(SIGMA8.map(function (x) {
  return x * 2;
})); // Compression function. 'last' flag indicates last block.
// Note we're representing 16 uint64s as 32 uint32s

var v = new Uint32Array(32);
var m = new Uint32Array(32);

function blake2bCompress(ctx, last) {
  var i = 0; // init work variables

  for (i = 0; i < 16; i++) {
    v[i] = ctx.h[i];
    v[i + 16] = BLAKE2B_IV32[i];
  } // low 64 bits of offset


  v[24] = v[24] ^ ctx.t;
  v[25] = v[25] ^ ctx.t / 0x100000000; // high 64 bits not supported, offset may not be higher than 2**53-1
  // last block flag set ?

  if (last) {
    v[28] = ~v[28];
    v[29] = ~v[29];
  } // get little-endian words


  for (i = 0; i < 32; i++) {
    m[i] = B2B_GET32(ctx.b, 4 * i);
  } // twelve rounds of mixing


  for (i = 0; i < 12; i++) {
    B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
    B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
    B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
    B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
    B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
    B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
    B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
    B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
  }

  for (i = 0; i < 16; i++) {
    ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
  }
} // reusable parameter_block


var parameter_block = new Uint8Array([0, 0, 0, 0, //  0: outlen, keylen, fanout, depth
0, 0, 0, 0, //  4: leaf length, sequential mode
0, 0, 0, 0, //  8: node offset
0, 0, 0, 0, // 12: node offset
0, 0, 0, 0, // 16: node depth, inner length, rfu
0, 0, 0, 0, // 20: rfu
0, 0, 0, 0, // 24: rfu
0, 0, 0, 0, // 28: rfu
0, 0, 0, 0, // 32: salt
0, 0, 0, 0, // 36: salt
0, 0, 0, 0, // 40: salt
0, 0, 0, 0, // 44: salt
0, 0, 0, 0, // 48: personal
0, 0, 0, 0, // 52: personal
0, 0, 0, 0, // 56: personal
0, 0, 0, 0 // 60: personal
]); // Creates a BLAKE2b hashing context
// Requires an output length between 1 and 64 bytes
// Takes an optional Uint8Array key

function Blake2b(outlen, key, salt, personal) {
  // zero out parameter_block before usage
  parameter_block.fill(0); // state, 'param block'

  this.b = new Uint8Array(128);
  this.h = new Uint32Array(16);
  this.t = 0; // input count

  this.c = 0; // pointer within buffer

  this.outlen = outlen; // output length in bytes

  parameter_block[0] = outlen;
  if (key) parameter_block[1] = key.length;
  parameter_block[2] = 1; // fanout

  parameter_block[3] = 1; // depth

  if (salt) parameter_block.set(salt, 32);
  if (personal) parameter_block.set(personal, 48); // initialize hash state

  for (var i = 0; i < 16; i++) {
    this.h[i] = BLAKE2B_IV32[i] ^ B2B_GET32(parameter_block, i * 4);
  } // key the hash, if applicable


  if (key) {
    blake2bUpdate(this, key); // at the end

    this.c = 128;
  }
}

Blake2b.prototype.update = function (input) {
  assert(input != null, 'input must be Uint8Array or Buffer');
  blake2bUpdate(this, input);
  return this;
};

Blake2b.prototype.digest = function (out) {
  var buf = !out || out === 'binary' || out === 'hex' ? new Uint8Array(this.outlen) : out;
  assert(buf.length >= this.outlen, 'out must have at least outlen bytes of space');
  blake2bFinal(this, buf);
  if (out === 'hex') return hexSlice(buf);
  return buf;
};

Blake2b.prototype["final"] = Blake2b.prototype.digest;

Blake2b.ready = function (cb) {
  b2wasm.ready(function () {
    cb(); // ignore the error
  });
}; // Updates a BLAKE2b streaming hash
// Requires hash context and Uint8Array (byte array)


function blake2bUpdate(ctx, input) {
  for (var i = 0; i < input.length; i++) {
    if (ctx.c === 128) {
      // buffer full ?
      ctx.t += ctx.c; // add counters

      blake2bCompress(ctx, false); // compress (not last)

      ctx.c = 0; // counter to zero
    }

    ctx.b[ctx.c++] = input[i];
  }
} // Completes a BLAKE2b streaming hash
// Returns a Uint8Array containing the message digest


function blake2bFinal(ctx, out) {
  ctx.t += ctx.c; // mark last block offset

  while (ctx.c < 128) {
    // fill up with zeros
    ctx.b[ctx.c++] = 0;
  }

  blake2bCompress(ctx, true); // final block flag = 1

  for (var i = 0; i < ctx.outlen; i++) {
    out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
  }

  return out;
}

function hexSlice(buf) {
  var str = '';

  for (var i = 0; i < buf.length; i++) {
    str += toHex(buf[i]);
  }

  return str;
}

function toHex(n) {
  if (n < 16) return '0' + n.toString(16);
  return n.toString(16);
}

var Proto = Blake2b;

module.exports = function createHash(outlen, key, salt, personal, noAssert) {
  if (noAssert !== true) {
    assert(outlen >= BYTES_MIN, 'outlen must be at least ' + BYTES_MIN + ', was given ' + outlen);
    assert(outlen <= BYTES_MAX, 'outlen must be at most ' + BYTES_MAX + ', was given ' + outlen);
    if (key != null) assert(key.length >= KEYBYTES_MIN, 'key must be at least ' + KEYBYTES_MIN + ', was given ' + key.length);
    if (key != null) assert(key.length <= KEYBYTES_MAX, 'key must be at most ' + KEYBYTES_MAX + ', was given ' + key.length);
    if (salt != null) assert(salt.length === SALTBYTES, 'salt must be exactly ' + SALTBYTES + ', was given ' + salt.length);
    if (personal != null) assert(personal.length === PERSONALBYTES, 'personal must be exactly ' + PERSONALBYTES + ', was given ' + personal.length);
  }

  return new Proto(outlen, key, salt, personal);
};

module.exports.ready = function (cb) {
  b2wasm.ready(function () {
    // ignore errors
    cb();
  });
};

module.exports.WASM_SUPPORTED = b2wasm.SUPPORTED;
module.exports.WASM_LOADED = false;
var BYTES_MIN = module.exports.BYTES_MIN = 16;
var BYTES_MAX = module.exports.BYTES_MAX = 64;
var BYTES = module.exports.BYTES = 32;
var KEYBYTES_MIN = module.exports.KEYBYTES_MIN = 16;
var KEYBYTES_MAX = module.exports.KEYBYTES_MAX = 64;
var KEYBYTES = module.exports.KEYBYTES = 32;
var SALTBYTES = module.exports.SALTBYTES = 16;
var PERSONALBYTES = module.exports.PERSONALBYTES = 16;
b2wasm.ready(function (err) {
  if (!err) {
    module.exports.WASM_LOADED = true;
    Proto = b2wasm;
  }
});

/***/ }),

/***/ "./node_modules/buffer/index.js":
/*!**************************************!*\
  !*** ./node_modules/buffer/index.js ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

/* eslint-disable no-proto */


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/index.js");

var ieee754 = __webpack_require__(/*! ieee754 */ "./node_modules/ieee754/index.js");

var customInspectSymbol = typeof Symbol === 'function' && typeof Symbol['for'] === 'function' // eslint-disable-line dot-notation
? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation
: null;
exports.Buffer = Buffer;
exports.SlowBuffer = SlowBuffer;
exports.INSPECT_MAX_BYTES = 50;
var K_MAX_LENGTH = 0x7fffffff;
exports.kMaxLength = K_MAX_LENGTH;
/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */

Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport();

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' && typeof console.error === 'function') {
  console.error('This browser lacks typed array (Uint8Array) support which is required by ' + '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.');
}

function typedArraySupport() {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1);
    var proto = {
      foo: function foo() {
        return 42;
      }
    };
    Object.setPrototypeOf(proto, Uint8Array.prototype);
    Object.setPrototypeOf(arr, proto);
    return arr.foo() === 42;
  } catch (e) {
    return false;
  }
}

Object.defineProperty(Buffer.prototype, 'parent', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.buffer;
  }
});
Object.defineProperty(Buffer.prototype, 'offset', {
  enumerable: true,
  get: function get() {
    if (!Buffer.isBuffer(this)) return undefined;
    return this.byteOffset;
  }
});

function createBuffer(length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('The value "' + length + '" is invalid for option "size"');
  } // Return an augmented `Uint8Array` instance


  var buf = new Uint8Array(length);
  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}
/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */


function Buffer(arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new TypeError('The "string" argument must be of type string. Received type number');
    }

    return allocUnsafe(arg);
  }

  return from(arg, encodingOrOffset, length);
}

Buffer.poolSize = 8192; // not used by this implementation

function from(value, encodingOrOffset, length) {
  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset);
  }

  if (ArrayBuffer.isView(value)) {
    return fromArrayView(value);
  }

  if (value == null) {
    throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
  }

  if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof SharedArrayBuffer !== 'undefined' && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
    return fromArrayBuffer(value, encodingOrOffset, length);
  }

  if (typeof value === 'number') {
    throw new TypeError('The "value" argument must not be of type number. Received type number');
  }

  var valueOf = value.valueOf && value.valueOf();

  if (valueOf != null && valueOf !== value) {
    return Buffer.from(valueOf, encodingOrOffset, length);
  }

  var b = fromObject(value);
  if (b) return b;

  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === 'function') {
    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length);
  }

  throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' + 'or Array-like Object. Received type ' + _typeof(value));
}
/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/


Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length);
}; // Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148


Object.setPrototypeOf(Buffer.prototype, Uint8Array.prototype);
Object.setPrototypeOf(Buffer, Uint8Array);

function assertSize(size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be of type number');
  } else if (size < 0) {
    throw new RangeError('The value "' + size + '" is invalid for option "size"');
  }
}

function alloc(size, fill, encoding) {
  assertSize(size);

  if (size <= 0) {
    return createBuffer(size);
  }

  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpreted as a start offset.
    return typeof encoding === 'string' ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
  }

  return createBuffer(size);
}
/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/


Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding);
};

function allocUnsafe(size) {
  assertSize(size);
  return createBuffer(size < 0 ? 0 : checked(size) | 0);
}
/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */


Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size);
};
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */


Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size);
};

function fromString(string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8';
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('Unknown encoding: ' + encoding);
  }

  var length = byteLength(string, encoding) | 0;
  var buf = createBuffer(length);
  var actual = buf.write(string, encoding);

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual);
  }

  return buf;
}

function fromArrayLike(array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0;
  var buf = createBuffer(length);

  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255;
  }

  return buf;
}

function fromArrayView(arrayView) {
  if (isInstance(arrayView, Uint8Array)) {
    var copy = new Uint8Array(arrayView);
    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
  }

  return fromArrayLike(arrayView);
}

function fromArrayBuffer(array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('"offset" is outside of buffer bounds');
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('"length" is outside of buffer bounds');
  }

  var buf;

  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array);
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset);
  } else {
    buf = new Uint8Array(array, byteOffset, length);
  } // Return an augmented `Uint8Array` instance


  Object.setPrototypeOf(buf, Buffer.prototype);
  return buf;
}

function fromObject(obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0;
    var buf = createBuffer(len);

    if (buf.length === 0) {
      return buf;
    }

    obj.copy(buf, 0, 0, len);
    return buf;
  }

  if (obj.length !== undefined) {
    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
      return createBuffer(0);
    }

    return fromArrayLike(obj);
  }

  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
    return fromArrayLike(obj.data);
  }
}

function checked(length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes');
  }

  return length | 0;
}

function SlowBuffer(length) {
  if (+length != length) {
    // eslint-disable-line eqeqeq
    length = 0;
  }

  return Buffer.alloc(+length);
}

Buffer.isBuffer = function isBuffer(b) {
  return b != null && b._isBuffer === true && b !== Buffer.prototype; // so Buffer.isBuffer(Buffer.prototype) will be false
};

Buffer.compare = function compare(a, b) {
  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength);
  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength);

  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
  }

  if (a === b) return 0;
  var x = a.length;
  var y = b.length;

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i];
      y = b[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
};

Buffer.isEncoding = function isEncoding(encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true;

    default:
      return false;
  }
};

Buffer.concat = function concat(list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers');
  }

  if (list.length === 0) {
    return Buffer.alloc(0);
  }

  var i;

  if (length === undefined) {
    length = 0;

    for (i = 0; i < list.length; ++i) {
      length += list[i].length;
    }
  }

  var buffer = Buffer.allocUnsafe(length);
  var pos = 0;

  for (i = 0; i < list.length; ++i) {
    var buf = list[i];

    if (isInstance(buf, Uint8Array)) {
      if (pos + buf.length > buffer.length) {
        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf);
        buf.copy(buffer, pos);
      } else {
        Uint8Array.prototype.set.call(buffer, buf, pos);
      }
    } else if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    } else {
      buf.copy(buffer, pos);
    }

    pos += buf.length;
  }

  return buffer;
};

function byteLength(string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length;
  }

  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
    return string.byteLength;
  }

  if (typeof string !== 'string') {
    throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. ' + 'Received type ' + _typeof(string));
  }

  var len = string.length;
  var mustMatch = arguments.length > 2 && arguments[2] === true;
  if (!mustMatch && len === 0) return 0; // Use a for loop to avoid recursion

  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len;

      case 'utf8':
      case 'utf-8':
        return utf8ToBytes(string).length;

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2;

      case 'hex':
        return len >>> 1;

      case 'base64':
        return base64ToBytes(string).length;

      default:
        if (loweredCase) {
          return mustMatch ? -1 : utf8ToBytes(string).length; // assume utf8
        }

        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
}

Buffer.byteLength = byteLength;

function slowToString(encoding, start, end) {
  var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.
  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

  if (start === undefined || start < 0) {
    start = 0;
  } // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.


  if (start > this.length) {
    return '';
  }

  if (end === undefined || end > this.length) {
    end = this.length;
  }

  if (end <= 0) {
    return '';
  } // Force coercion to uint32. This will also coerce falsey/NaN values to 0.


  end >>>= 0;
  start >>>= 0;

  if (end <= start) {
    return '';
  }

  if (!encoding) encoding = 'utf8';

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end);

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end);

      case 'ascii':
        return asciiSlice(this, start, end);

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end);

      case 'base64':
        return base64Slice(this, start, end);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = (encoding + '').toLowerCase();
        loweredCase = true;
    }
  }
} // This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154


Buffer.prototype._isBuffer = true;

function swap(b, n, m) {
  var i = b[n];
  b[n] = b[m];
  b[m] = i;
}

Buffer.prototype.swap16 = function swap16() {
  var len = this.length;

  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits');
  }

  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1);
  }

  return this;
};

Buffer.prototype.swap32 = function swap32() {
  var len = this.length;

  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits');
  }

  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3);
    swap(this, i + 1, i + 2);
  }

  return this;
};

Buffer.prototype.swap64 = function swap64() {
  var len = this.length;

  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits');
  }

  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7);
    swap(this, i + 1, i + 6);
    swap(this, i + 2, i + 5);
    swap(this, i + 3, i + 4);
  }

  return this;
};

Buffer.prototype.toString = function toString() {
  var length = this.length;
  if (length === 0) return '';
  if (arguments.length === 0) return utf8Slice(this, 0, length);
  return slowToString.apply(this, arguments);
};

Buffer.prototype.toLocaleString = Buffer.prototype.toString;

Buffer.prototype.equals = function equals(b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
  if (this === b) return true;
  return Buffer.compare(this, b) === 0;
};

Buffer.prototype.inspect = function inspect() {
  var str = '';
  var max = exports.INSPECT_MAX_BYTES;
  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim();
  if (this.length > max) str += ' ... ';
  return '<Buffer ' + str + '>';
};

if (customInspectSymbol) {
  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect;
}

Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
  if (isInstance(target, Uint8Array)) {
    target = Buffer.from(target, target.offset, target.byteLength);
  }

  if (!Buffer.isBuffer(target)) {
    throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. ' + 'Received type ' + _typeof(target));
  }

  if (start === undefined) {
    start = 0;
  }

  if (end === undefined) {
    end = target ? target.length : 0;
  }

  if (thisStart === undefined) {
    thisStart = 0;
  }

  if (thisEnd === undefined) {
    thisEnd = this.length;
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index');
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0;
  }

  if (thisStart >= thisEnd) {
    return -1;
  }

  if (start >= end) {
    return 1;
  }

  start >>>= 0;
  end >>>= 0;
  thisStart >>>= 0;
  thisEnd >>>= 0;
  if (this === target) return 0;
  var x = thisEnd - thisStart;
  var y = end - start;
  var len = Math.min(x, y);
  var thisCopy = this.slice(thisStart, thisEnd);
  var targetCopy = target.slice(start, end);

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i];
      y = targetCopy[i];
      break;
    }
  }

  if (x < y) return -1;
  if (y < x) return 1;
  return 0;
}; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf


function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1; // Normalize byteOffset

  if (typeof byteOffset === 'string') {
    encoding = byteOffset;
    byteOffset = 0;
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff;
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000;
  }

  byteOffset = +byteOffset; // Coerce to Number.

  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : buffer.length - 1;
  } // Normalize byteOffset: negative offsets start from the end of the buffer


  if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

  if (byteOffset >= buffer.length) {
    if (dir) return -1;else byteOffset = buffer.length - 1;
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0;else return -1;
  } // Normalize val


  if (typeof val === 'string') {
    val = Buffer.from(val, encoding);
  } // Finally, search either indexOf (if dir is true) or lastIndexOf


  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1;
    }

    return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
  } else if (typeof val === 'number') {
    val = val & 0xFF; // Search for a byte value [0-255]

    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
      }
    }

    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
  }

  throw new TypeError('val must be string, number or Buffer');
}

function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
  var indexSize = 1;
  var arrLength = arr.length;
  var valLength = val.length;

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase();

    if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1;
      }

      indexSize = 2;
      arrLength /= 2;
      valLength /= 2;
      byteOffset /= 2;
    }
  }

  function read(buf, i) {
    if (indexSize === 1) {
      return buf[i];
    } else {
      return buf.readUInt16BE(i * indexSize);
    }
  }

  var i;

  if (dir) {
    var foundIndex = -1;

    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i;
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
      } else {
        if (foundIndex !== -1) i -= i - foundIndex;
        foundIndex = -1;
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

    for (i = byteOffset; i >= 0; i--) {
      var found = true;

      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false;
          break;
        }
      }

      if (found) return i;
    }
  }

  return -1;
}

Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1;
};

Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
};

Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
};

function hexWrite(buf, string, offset, length) {
  offset = Number(offset) || 0;
  var remaining = buf.length - offset;

  if (!length) {
    length = remaining;
  } else {
    length = Number(length);

    if (length > remaining) {
      length = remaining;
    }
  }

  var strLen = string.length;

  if (length > strLen / 2) {
    length = strLen / 2;
  }

  var i;

  for (i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16);
    if (numberIsNaN(parsed)) return i;
    buf[offset + i] = parsed;
  }

  return i;
}

function utf8Write(buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
}

function asciiWrite(buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length);
}

function base64Write(buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length);
}

function ucs2Write(buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
}

Buffer.prototype.write = function write(string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8';
    length = this.length;
    offset = 0; // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset;
    length = this.length;
    offset = 0; // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0;

    if (isFinite(length)) {
      length = length >>> 0;
      if (encoding === undefined) encoding = 'utf8';
    } else {
      encoding = length;
      length = undefined;
    }
  } else {
    throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
  }

  var remaining = this.length - offset;
  if (length === undefined || length > remaining) length = remaining;

  if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds');
  }

  if (!encoding) encoding = 'utf8';
  var loweredCase = false;

  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length);

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length);

      case 'ascii':
      case 'latin1':
      case 'binary':
        return asciiWrite(this, string, offset, length);

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length);

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length);

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
        encoding = ('' + encoding).toLowerCase();
        loweredCase = true;
    }
  }
};

Buffer.prototype.toJSON = function toJSON() {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  };
};

function base64Slice(buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf);
  } else {
    return base64.fromByteArray(buf.slice(start, end));
  }
}

function utf8Slice(buf, start, end) {
  end = Math.min(buf.length, end);
  var res = [];
  var i = start;

  while (i < end) {
    var firstByte = buf[i];
    var codePoint = null;
    var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

    if (i + bytesPerSequence <= end) {
      var secondByte = void 0,
          thirdByte = void 0,
          fourthByte = void 0,
          tempCodePoint = void 0;

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte;
          }

          break;

        case 2:
          secondByte = buf[i + 1];

          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 3:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint;
            }
          }

          break;

        case 4:
          secondByte = buf[i + 1];
          thirdByte = buf[i + 2];
          fourthByte = buf[i + 3];

          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint;
            }
          }

      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD;
      bytesPerSequence = 1;
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000;
      res.push(codePoint >>> 10 & 0x3FF | 0xD800);
      codePoint = 0xDC00 | codePoint & 0x3FF;
    }

    res.push(codePoint);
    i += bytesPerSequence;
  }

  return decodeCodePointsArray(res);
} // Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety


var MAX_ARGUMENTS_LENGTH = 0x1000;

function decodeCodePointsArray(codePoints) {
  var len = codePoints.length;

  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
  } // Decode in chunks to avoid "call stack size exceeded".


  var res = '';
  var i = 0;

  while (i < len) {
    res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
  }

  return res;
}

function asciiSlice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F);
  }

  return ret;
}

function latin1Slice(buf, start, end) {
  var ret = '';
  end = Math.min(buf.length, end);

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i]);
  }

  return ret;
}

function hexSlice(buf, start, end) {
  var len = buf.length;
  if (!start || start < 0) start = 0;
  if (!end || end < 0 || end > len) end = len;
  var out = '';

  for (var i = start; i < end; ++i) {
    out += hexSliceLookupTable[buf[i]];
  }

  return out;
}

function utf16leSlice(buf, start, end) {
  var bytes = buf.slice(start, end);
  var res = ''; // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)

  for (var i = 0; i < bytes.length - 1; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
  }

  return res;
}

Buffer.prototype.slice = function slice(start, end) {
  var len = this.length;
  start = ~~start;
  end = end === undefined ? len : ~~end;

  if (start < 0) {
    start += len;
    if (start < 0) start = 0;
  } else if (start > len) {
    start = len;
  }

  if (end < 0) {
    end += len;
    if (end < 0) end = 0;
  } else if (end > len) {
    end = len;
  }

  if (end < start) end = start;
  var newBuf = this.subarray(start, end); // Return an augmented `Uint8Array` instance

  Object.setPrototypeOf(newBuf, Buffer.prototype);
  return newBuf;
};
/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */


function checkOffset(offset, ext, length) {
  if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
}

Buffer.prototype.readUintLE = Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  return val;
};

Buffer.prototype.readUintBE = Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    checkOffset(offset, byteLength, this.length);
  }

  var val = this[offset + --byteLength];
  var mul = 1;

  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul;
  }

  return val;
};

Buffer.prototype.readUint8 = Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  return this[offset];
};

Buffer.prototype.readUint16LE = Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] | this[offset + 1] << 8;
};

Buffer.prototype.readUint16BE = Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  return this[offset] << 8 | this[offset + 1];
};

Buffer.prototype.readUint32LE = Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
};

Buffer.prototype.readUint32BE = Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
};

Buffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var lo = first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24);
  var hi = this[++offset] + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + last * Math.pow(2, 24);
  return BigInt(lo) + (BigInt(hi) << BigInt(32));
});
Buffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var hi = first * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  var lo = this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last;
  return (BigInt(hi) << BigInt(32)) + BigInt(lo);
});

Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var val = this[offset];
  var mul = 1;
  var i = 0;

  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;
  if (!noAssert) checkOffset(offset, byteLength, this.length);
  var i = byteLength;
  var mul = 1;
  var val = this[offset + --i];

  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul;
  }

  mul *= 0x80;
  if (val >= mul) val -= Math.pow(2, 8 * byteLength);
  return val;
};

Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 1, this.length);
  if (!(this[offset] & 0x80)) return this[offset];
  return (0xff - this[offset] + 1) * -1;
};

Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset] | this[offset + 1] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 2, this.length);
  var val = this[offset + 1] | this[offset] << 8;
  return val & 0x8000 ? val | 0xFFFF0000 : val;
};

Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
};

Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
};

Buffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = this[offset + 4] + this[offset + 5] * Math.pow(2, 8) + this[offset + 6] * Math.pow(2, 16) + (last << 24); // Overflow

  return (BigInt(val) << BigInt(32)) + BigInt(first + this[++offset] * Math.pow(2, 8) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 24));
});
Buffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE(offset) {
  offset = offset >>> 0;
  validateNumber(offset, 'offset');
  var first = this[offset];
  var last = this[offset + 7];

  if (first === undefined || last === undefined) {
    boundsError(offset, this.length - 8);
  }

  var val = (first << 24) + // Overflow
  this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + this[++offset];
  return (BigInt(val) << BigInt(32)) + BigInt(this[++offset] * Math.pow(2, 24) + this[++offset] * Math.pow(2, 16) + this[++offset] * Math.pow(2, 8) + last);
});

Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, true, 23, 4);
};

Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 4, this.length);
  return ieee754.read(this, offset, false, 23, 4);
};

Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, true, 52, 8);
};

Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
  offset = offset >>> 0;
  if (!noAssert) checkOffset(offset, 8, this.length);
  return ieee754.read(this, offset, false, 52, 8);
};

function checkInt(buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
}

Buffer.prototype.writeUintLE = Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var mul = 1;
  var i = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUintBE = Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;
  byteLength = byteLength >>> 0;

  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1;
    checkInt(this, value, offset, byteLength, maxBytes, 0);
  }

  var i = byteLength - 1;
  var mul = 1;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = value / mul & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeUint8 = Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeUint16LE = Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeUint16BE = Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeUint32LE = Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset + 3] = value >>> 24;
  this[offset + 2] = value >>> 16;
  this[offset + 1] = value >>> 8;
  this[offset] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeUint32BE = Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

function wrtBigUInt64LE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  lo = lo >> 8;
  buf[offset++] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  hi = hi >> 8;
  buf[offset++] = hi;
  return offset;
}

function wrtBigUInt64BE(buf, value, offset, min, max) {
  checkIntBI(value, min, max, buf, offset, 7);
  var lo = Number(value & BigInt(0xffffffff));
  buf[offset + 7] = lo;
  lo = lo >> 8;
  buf[offset + 6] = lo;
  lo = lo >> 8;
  buf[offset + 5] = lo;
  lo = lo >> 8;
  buf[offset + 4] = lo;
  var hi = Number(value >> BigInt(32) & BigInt(0xffffffff));
  buf[offset + 3] = hi;
  hi = hi >> 8;
  buf[offset + 2] = hi;
  hi = hi >> 8;
  buf[offset + 1] = hi;
  hi = hi >> 8;
  buf[offset] = hi;
  return offset + 8;
}

Buffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});
Buffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'));
});

Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = 0;
  var mul = 1;
  var sub = 0;
  this[offset] = value & 0xFF;

  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1);
    checkInt(this, value, offset, byteLength, limit - 1, -limit);
  }

  var i = byteLength - 1;
  var mul = 1;
  var sub = 0;
  this[offset + i] = value & 0xFF;

  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1;
    }

    this[offset + i] = (value / mul >> 0) - sub & 0xFF;
  }

  return offset + byteLength;
};

Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
  if (value < 0) value = 0xff + value + 1;
  this[offset] = value & 0xff;
  return offset + 1;
};

Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  return offset + 2;
};

Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
  this[offset] = value >>> 8;
  this[offset + 1] = value & 0xff;
  return offset + 2;
};

Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  this[offset] = value & 0xff;
  this[offset + 1] = value >>> 8;
  this[offset + 2] = value >>> 16;
  this[offset + 3] = value >>> 24;
  return offset + 4;
};

Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
  value = +value;
  offset = offset >>> 0;
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
  if (value < 0) value = 0xffffffff + value + 1;
  this[offset] = value >>> 24;
  this[offset + 1] = value >>> 16;
  this[offset + 2] = value >>> 8;
  this[offset + 3] = value & 0xff;
  return offset + 4;
};

Buffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});
Buffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE(value) {
  var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'));
});

function checkIEEE754(buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range');
  if (offset < 0) throw new RangeError('Index out of range');
}

function writeFloat(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
  }

  ieee754.write(buf, value, offset, littleEndian, 23, 4);
  return offset + 4;
}

Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert);
};

Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert);
};

function writeDouble(buf, value, offset, littleEndian, noAssert) {
  value = +value;
  offset = offset >>> 0;

  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
  }

  ieee754.write(buf, value, offset, littleEndian, 52, 8);
  return offset + 8;
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert);
};

Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert);
}; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


Buffer.prototype.copy = function copy(target, targetStart, start, end) {
  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer');
  if (!start) start = 0;
  if (!end && end !== 0) end = this.length;
  if (targetStart >= target.length) targetStart = target.length;
  if (!targetStart) targetStart = 0;
  if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

  if (end === start) return 0;
  if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds');
  }

  if (start < 0 || start >= this.length) throw new RangeError('Index out of range');
  if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

  if (end > this.length) end = this.length;

  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start;
  }

  var len = end - start;

  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {
    // Use built-in when available, missing from IE11
    this.copyWithin(targetStart, start, end);
  } else {
    Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
  }

  return len;
}; // Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])


Buffer.prototype.fill = function fill(val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start;
      start = 0;
      end = this.length;
    } else if (typeof end === 'string') {
      encoding = end;
      end = this.length;
    }

    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string');
    }

    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding);
    }

    if (val.length === 1) {
      var code = val.charCodeAt(0);

      if (encoding === 'utf8' && code < 128 || encoding === 'latin1') {
        // Fast path: If `val` fits into a single byte, use that numeric value.
        val = code;
      }
    }
  } else if (typeof val === 'number') {
    val = val & 255;
  } else if (typeof val === 'boolean') {
    val = Number(val);
  } // Invalid ranges are not set to a default, so can range check early.


  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index');
  }

  if (end <= start) {
    return this;
  }

  start = start >>> 0;
  end = end === undefined ? this.length : end >>> 0;
  if (!val) val = 0;
  var i;

  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val;
    }
  } else {
    var bytes = Buffer.isBuffer(val) ? val : Buffer.from(val, encoding);
    var len = bytes.length;

    if (len === 0) {
      throw new TypeError('The value "' + val + '" is invalid for argument "value"');
    }

    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len];
    }
  }

  return this;
}; // CUSTOM ERRORS
// =============
// Simplified versions from Node, changed for Buffer-only usage


var errors = {};

function E(sym, getMessage, Base) {
  errors[sym] = /*#__PURE__*/function (_Base) {
    _inherits(NodeError, _Base);

    var _super = _createSuper(NodeError);

    function NodeError() {
      var _this;

      _classCallCheck(this, NodeError);

      _this = _super.call(this);
      Object.defineProperty(_assertThisInitialized(_this), 'message', {
        value: getMessage.apply(_assertThisInitialized(_this), arguments),
        writable: true,
        configurable: true
      }); // Add the error code to the name to include it in the stack trace.

      _this.name = "".concat(_this.name, " [").concat(sym, "]"); // Access the stack to generate the error message including the error code
      // from the name.

      _this.stack; // eslint-disable-line no-unused-expressions
      // Reset the name to the actual name.

      delete _this.name;
      return _this;
    }

    _createClass(NodeError, [{
      key: "code",
      get: function get() {
        return sym;
      },
      set: function set(value) {
        Object.defineProperty(this, 'code', {
          configurable: true,
          enumerable: true,
          value: value,
          writable: true
        });
      }
    }, {
      key: "toString",
      value: function toString() {
        return "".concat(this.name, " [").concat(sym, "]: ").concat(this.message);
      }
    }]);

    return NodeError;
  }(Base);
}

E('ERR_BUFFER_OUT_OF_BOUNDS', function (name) {
  if (name) {
    return "".concat(name, " is outside of buffer bounds");
  }

  return 'Attempt to access memory outside buffer bounds';
}, RangeError);
E('ERR_INVALID_ARG_TYPE', function (name, actual) {
  return "The \"".concat(name, "\" argument must be of type number. Received type ").concat(_typeof(actual));
}, TypeError);
E('ERR_OUT_OF_RANGE', function (str, range, input) {
  var msg = "The value of \"".concat(str, "\" is out of range.");
  var received = input;

  if (Number.isInteger(input) && Math.abs(input) > Math.pow(2, 32)) {
    received = addNumericalSeparator(String(input));
  } else if (typeof input === 'bigint') {
    received = String(input);

    if (input > Math.pow(BigInt(2), BigInt(32)) || input < -Math.pow(BigInt(2), BigInt(32))) {
      received = addNumericalSeparator(received);
    }

    received += 'n';
  }

  msg += " It must be ".concat(range, ". Received ").concat(received);
  return msg;
}, RangeError);

function addNumericalSeparator(val) {
  var res = '';
  var i = val.length;
  var start = val[0] === '-' ? 1 : 0;

  for (; i >= start + 4; i -= 3) {
    res = "_".concat(val.slice(i - 3, i)).concat(res);
  }

  return "".concat(val.slice(0, i)).concat(res);
} // CHECK FUNCTIONS
// ===============


function checkBounds(buf, offset, byteLength) {
  validateNumber(offset, 'offset');

  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {
    boundsError(offset, buf.length - (byteLength + 1));
  }
}

function checkIntBI(value, min, max, buf, offset, byteLength) {
  if (value > max || value < min) {
    var n = typeof min === 'bigint' ? 'n' : '';
    var range;

    if (byteLength > 3) {
      if (min === 0 || min === BigInt(0)) {
        range = ">= 0".concat(n, " and < 2").concat(n, " ** ").concat((byteLength + 1) * 8).concat(n);
      } else {
        range = ">= -(2".concat(n, " ** ").concat((byteLength + 1) * 8 - 1).concat(n, ") and < 2 ** ") + "".concat((byteLength + 1) * 8 - 1).concat(n);
      }
    } else {
      range = ">= ".concat(min).concat(n, " and <= ").concat(max).concat(n);
    }

    throw new errors.ERR_OUT_OF_RANGE('value', range, value);
  }

  checkBounds(buf, offset, byteLength);
}

function validateNumber(value, name) {
  if (typeof value !== 'number') {
    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value);
  }
}

function boundsError(value, length, type) {
  if (Math.floor(value) !== value) {
    validateNumber(value, type);
    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value);
  }

  if (length < 0) {
    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS();
  }

  throw new errors.ERR_OUT_OF_RANGE(type || 'offset', ">= ".concat(type ? 1 : 0, " and <= ").concat(length), value);
} // HELPER FUNCTIONS
// ================


var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;

function base64clean(str) {
  // Node takes equal signs as end of the Base64 encoding
  str = str.split('=')[0]; // Node strips out invalid characters like \n and \t from the string, base64-js does not

  str = str.trim().replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

  if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

  while (str.length % 4 !== 0) {
    str = str + '=';
  }

  return str;
}

function utf8ToBytes(string, units) {
  units = units || Infinity;
  var codePoint;
  var length = string.length;
  var leadSurrogate = null;
  var bytes = [];

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i); // is surrogate component

    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          continue;
        } // valid lead


        leadSurrogate = codePoint;
        continue;
      } // 2 leads in a row


      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
        leadSurrogate = codePoint;
        continue;
      } // valid surrogate pair


      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
    }

    leadSurrogate = null; // encode utf8

    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break;
      bytes.push(codePoint);
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break;
      bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break;
      bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break;
      bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
    } else {
      throw new Error('Invalid code point');
    }
  }

  return bytes;
}

function asciiToBytes(str) {
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF);
  }

  return byteArray;
}

function utf16leToBytes(str, units) {
  var c, hi, lo;
  var byteArray = [];

  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break;
    c = str.charCodeAt(i);
    hi = c >> 8;
    lo = c % 256;
    byteArray.push(lo);
    byteArray.push(hi);
  }

  return byteArray;
}

function base64ToBytes(str) {
  return base64.toByteArray(base64clean(str));
}

function blitBuffer(src, dst, offset, length) {
  var i;

  for (i = 0; i < length; ++i) {
    if (i + offset >= dst.length || i >= src.length) break;
    dst[i + offset] = src[i];
  }

  return i;
} // ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass
// the `instanceof` check but they should be treated as of that type.
// See: https://github.com/feross/buffer/issues/166


function isInstance(obj, type) {
  return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
}

function numberIsNaN(obj) {
  // For IE11 support
  return obj !== obj; // eslint-disable-line no-self-compare
} // Create lookup table for `toString('hex')`
// See: https://github.com/feross/buffer/issues/219


var hexSliceLookupTable = function () {
  var alphabet = '0123456789abcdef';
  var table = new Array(256);

  for (var i = 0; i < 16; ++i) {
    var i16 = i * 16;

    for (var j = 0; j < 16; ++j) {
      table[i16 + j] = alphabet[i] + alphabet[j];
    }
  }

  return table;
}(); // Return not function with Error if BigInt not supported


function defineBigIntMethod(fn) {
  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn;
}

function BufferBigIntNotDefined() {
  throw new Error('BigInt not supported');
}

/***/ }),

/***/ "./node_modules/builtin-status-codes/browser.js":
/*!******************************************************!*\
  !*** ./node_modules/builtin-status-codes/browser.js ***!
  \******************************************************/
/***/ ((module) => {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};

/***/ }),

/***/ "./node_modules/events/events.js":
/*!***************************************!*\
  !*** ./node_modules/events/events.js ***!
  \***************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var R = (typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === 'object' ? Reflect : null;
var ReflectApply = R && typeof R.apply === 'function' ? R.apply : function ReflectApply(target, receiver, args) {
  return Function.prototype.apply.call(target, receiver, args);
};
var ReflectOwnKeys;

if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys;
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
};

function EventEmitter() {
  EventEmitter.init.call(this);
}

module.exports = EventEmitter;
module.exports.once = once; // Backwards-compat with node 0.10.x

EventEmitter.EventEmitter = EventEmitter;
EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined; // By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.

var defaultMaxListeners = 10;

function checkListener(listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + _typeof(listener));
  }
}

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function get() {
    return defaultMaxListeners;
  },
  set: function set(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }

    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function () {
  if (this._events === undefined || this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
}; // Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.


EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }

  this._maxListeners = n;
  return this;
};

function _getMaxListeners(that) {
  if (that._maxListeners === undefined) return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return _getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];

  for (var i = 1; i < arguments.length; i++) {
    args.push(arguments[i]);
  }

  var doError = type === 'error';
  var events = this._events;
  if (events !== undefined) doError = doError && events.error === undefined;else if (!doError) return false; // If there is no 'error' event listener then throw.

  if (doError) {
    var er;
    if (args.length > 0) er = args[0];

    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    } // At least give some kind of context to the user


    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];
  if (handler === undefined) return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);

    for (var i = 0; i < len; ++i) {
      ReflectApply(listeners[i], this, args);
    }
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;
  checkListener(listener);
  events = target._events;

  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type, listener.listener ? listener.listener : listener); // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object

      events = target._events;
    }

    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] = prepend ? [listener, existing] : [existing, listener]; // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    } // Check for listener leak


    m = _getMaxListeners(target);

    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true; // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax

      var w = new Error('Possible EventEmitter memory leak detected. ' + existing.length + ' ' + String(type) + ' listeners ' + 'added. Use emitter.setMaxListeners() to ' + 'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener = function prependListener(type, listener) {
  return _addListener(this, type, listener, true);
};

function onceWrapper() {
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    if (arguments.length === 0) return this.listener.call(this.target);
    return this.listener.apply(this.target, arguments);
  }
}

function _onceWrap(target, type, listener) {
  var state = {
    fired: false,
    wrapFn: undefined,
    target: target,
    type: type,
    listener: listener
  };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  checkListener(listener);
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
  checkListener(listener);
  this.prependListener(type, _onceWrap(this, type, listener));
  return this;
}; // Emits a 'removeListener' event if and only if the listener was removed.


EventEmitter.prototype.removeListener = function removeListener(type, listener) {
  var list, events, position, i, originalListener;
  checkListener(listener);
  events = this._events;
  if (events === undefined) return this;
  list = events[type];
  if (list === undefined) return this;

  if (list === listener || list.listener === listener) {
    if (--this._eventsCount === 0) this._events = Object.create(null);else {
      delete events[type];
      if (events.removeListener) this.emit('removeListener', type, list.listener || listener);
    }
  } else if (typeof list !== 'function') {
    position = -1;

    for (i = list.length - 1; i >= 0; i--) {
      if (list[i] === listener || list[i].listener === listener) {
        originalListener = list[i].listener;
        position = i;
        break;
      }
    }

    if (position < 0) return this;
    if (position === 0) list.shift();else {
      spliceOne(list, position);
    }
    if (list.length === 1) events[type] = list[0];
    if (events.removeListener !== undefined) this.emit('removeListener', type, originalListener || listener);
  }

  return this;
};

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
  var listeners, events, i;
  events = this._events;
  if (events === undefined) return this; // not listening for removeListener, no need to emit

  if (events.removeListener === undefined) {
    if (arguments.length === 0) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    } else if (events[type] !== undefined) {
      if (--this._eventsCount === 0) this._events = Object.create(null);else delete events[type];
    }

    return this;
  } // emit removeListener for all listeners on all events


  if (arguments.length === 0) {
    var keys = Object.keys(events);
    var key;

    for (i = 0; i < keys.length; ++i) {
      key = keys[i];
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }

    this.removeAllListeners('removeListener');
    this._events = Object.create(null);
    this._eventsCount = 0;
    return this;
  }

  listeners = events[type];

  if (typeof listeners === 'function') {
    this.removeListener(type, listeners);
  } else if (listeners !== undefined) {
    // LIFO order
    for (i = listeners.length - 1; i >= 0; i--) {
      this.removeListener(type, listeners[i]);
    }
  }

  return this;
};

function _listeners(target, type, unwrap) {
  var events = target._events;
  if (events === undefined) return [];
  var evlistener = events[type];
  if (evlistener === undefined) return [];
  if (typeof evlistener === 'function') return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function (emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;

function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);

  for (var i = 0; i < n; ++i) {
    copy[i] = arr[i];
  }

  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++) {
    list[index] = list[index + 1];
  }

  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);

  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }

  return ret;
}

function once(emitter, name) {
  return new Promise(function (resolve, reject) {
    function errorListener(err) {
      emitter.removeListener(name, resolver);
      reject(err);
    }

    function resolver() {
      if (typeof emitter.removeListener === 'function') {
        emitter.removeListener('error', errorListener);
      }

      resolve([].slice.call(arguments));
    }

    ;
    eventTargetAgnosticAddListener(emitter, name, resolver, {
      once: true
    });

    if (name !== 'error') {
      addErrorHandlerIfEventEmitter(emitter, errorListener, {
        once: true
      });
    }
  });
}

function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
  if (typeof emitter.on === 'function') {
    eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
  }
}

function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
  if (typeof emitter.on === 'function') {
    if (flags.once) {
      emitter.once(name, listener);
    } else {
      emitter.on(name, listener);
    }
  } else if (typeof emitter.addEventListener === 'function') {
    // EventTarget does not have `error` event semantics like Node
    // EventEmitters, we do not listen for `error` events here.
    emitter.addEventListener(name, function wrapListener(arg) {
      // IE does not have builtin `{ once: true }` support so we
      // have to do it manually.
      if (flags.once) {
        emitter.removeEventListener(name, wrapListener);
      }

      listener(arg);
    });
  } else {
    throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + _typeof(emitter));
  }
}

/***/ }),

/***/ "./node_modules/form-data/lib/browser.js":
/*!***********************************************!*\
  !*** ./node_modules/form-data/lib/browser.js ***!
  \***********************************************/
/***/ ((module) => {

function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/* eslint-env browser */
module.exports = (typeof self === "undefined" ? "undefined" : _typeof(self)) == 'object' ? self.FormData : window.FormData;

/***/ }),

/***/ "./node_modules/ieee754/index.js":
/*!***************************************!*\
  !*** ./node_modules/ieee754/index.js ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var nBits = -7;
  var i = isLE ? nBytes - 1 : 0;
  var d = isLE ? -1 : 1;
  var s = buffer[offset + i];
  i += d;
  e = s & (1 << -nBits) - 1;
  s >>= -nBits;
  nBits += eLen;

  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & (1 << -nBits) - 1;
  e >>= -nBits;
  nBits += mLen;

  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias;
  } else if (e === eMax) {
    return m ? NaN : (s ? -1 : 1) * Infinity;
  } else {
    m = m + Math.pow(2, mLen);
    e = e - eBias;
  }

  return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
};

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c;
  var eLen = nBytes * 8 - mLen - 1;
  var eMax = (1 << eLen) - 1;
  var eBias = eMax >> 1;
  var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
  var i = isLE ? 0 : nBytes - 1;
  var d = isLE ? 1 : -1;
  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
  value = Math.abs(value);

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0;
    e = eMax;
  } else {
    e = Math.floor(Math.log(value) / Math.LN2);

    if (value * (c = Math.pow(2, -e)) < 1) {
      e--;
      c *= 2;
    }

    if (e + eBias >= 1) {
      value += rt / c;
    } else {
      value += rt * Math.pow(2, 1 - eBias);
    }

    if (value * c >= 2) {
      e++;
      c /= 2;
    }

    if (e + eBias >= eMax) {
      m = 0;
      e = eMax;
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen);
      e = e + eBias;
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
      e = 0;
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = e << mLen | m;
  eLen += mLen;

  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128;
};

/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/***/ ((module) => {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;

      var TempCtor = function TempCtor() {};

      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}

/***/ }),

/***/ "./node_modules/nanoassert/index.js":
/*!******************************************!*\
  !*** ./node_modules/nanoassert/index.js ***!
  \******************************************/
/***/ ((module) => {

assert.notEqual = notEqual;
assert.notOk = notOk;
assert.equal = equal;
assert.ok = assert;
module.exports = assert;

function equal(a, b, m) {
  assert(a == b, m); // eslint-disable-line eqeqeq
}

function notEqual(a, b, m) {
  assert(a != b, m); // eslint-disable-line eqeqeq
}

function notOk(t, m) {
  assert(!t, m);
}

function assert(t, m) {
  if (!t) throw new Error(m || 'AssertionError');
}

/***/ }),

/***/ "./node_modules/querystring/decode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/decode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
 // If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function (qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);
  var maxKeys = 1000;

  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length; // maxKeys <= 0 means that we should not limit keys count

  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr,
        vstr,
        k,
        v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (Array.isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

/***/ }),

/***/ "./node_modules/querystring/encode.js":
/*!********************************************!*\
  !*** ./node_modules/querystring/encode.js ***!
  \********************************************/
/***/ ((module) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var stringifyPrimitive = function stringifyPrimitive(v) {
  switch (_typeof(v)) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function (obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';

  if (obj === null) {
    obj = undefined;
  }

  if (_typeof(obj) === 'object') {
    return Object.keys(obj).map(function (k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;

      if (Array.isArray(obj[k])) {
        return obj[k].map(function (v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);
  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
};

/***/ }),

/***/ "./node_modules/querystring/index.js":
/*!*******************************************!*\
  !*** ./node_modules/querystring/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {



exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "./node_modules/querystring/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "./node_modules/querystring/encode.js");

/***/ }),

/***/ "./node_modules/readable-stream/errors-browser.js":
/*!********************************************************!*\
  !*** ./node_modules/readable-stream/errors-browser.js ***!
  \********************************************************/
/***/ ((module) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

var codes = {};

function createErrorType(code, message, Base) {
  if (!Base) {
    Base = Error;
  }

  function getMessage(arg1, arg2, arg3) {
    if (typeof message === 'string') {
      return message;
    } else {
      return message(arg1, arg2, arg3);
    }
  }

  var NodeError = /*#__PURE__*/function (_Base) {
    _inheritsLoose(NodeError, _Base);

    function NodeError(arg1, arg2, arg3) {
      return _Base.call(this, getMessage(arg1, arg2, arg3)) || this;
    }

    return NodeError;
  }(Base);

  NodeError.prototype.name = Base.name;
  NodeError.prototype.code = code;
  codes[code] = NodeError;
} // https://github.com/nodejs/node/blob/v10.8.0/lib/internal/errors.js


function oneOf(expected, thing) {
  if (Array.isArray(expected)) {
    var len = expected.length;
    expected = expected.map(function (i) {
      return String(i);
    });

    if (len > 2) {
      return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(', '), ", or ") + expected[len - 1];
    } else if (len === 2) {
      return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
    } else {
      return "of ".concat(thing, " ").concat(expected[0]);
    }
  } else {
    return "of ".concat(thing, " ").concat(String(expected));
  }
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith


function startsWith(str, search, pos) {
  return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith


function endsWith(str, search, this_len) {
  if (this_len === undefined || this_len > str.length) {
    this_len = str.length;
  }

  return str.substring(this_len - search.length, this_len) === search;
} // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/includes


function includes(str, search, start) {
  if (typeof start !== 'number') {
    start = 0;
  }

  if (start + search.length > str.length) {
    return false;
  } else {
    return str.indexOf(search, start) !== -1;
  }
}

createErrorType('ERR_INVALID_OPT_VALUE', function (name, value) {
  return 'The value "' + value + '" is invalid for option "' + name + '"';
}, TypeError);
createErrorType('ERR_INVALID_ARG_TYPE', function (name, expected, actual) {
  // determiner: 'must be' or 'must not be'
  var determiner;

  if (typeof expected === 'string' && startsWith(expected, 'not ')) {
    determiner = 'must not be';
    expected = expected.replace(/^not /, '');
  } else {
    determiner = 'must be';
  }

  var msg;

  if (endsWith(name, ' argument')) {
    // For cases like 'first argument'
    msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  } else {
    var type = includes(name, '.') ? 'property' : 'argument';
    msg = "The \"".concat(name, "\" ").concat(type, " ").concat(determiner, " ").concat(oneOf(expected, 'type'));
  }

  msg += ". Received type ".concat(_typeof(actual));
  return msg;
}, TypeError);
createErrorType('ERR_STREAM_PUSH_AFTER_EOF', 'stream.push() after EOF');
createErrorType('ERR_METHOD_NOT_IMPLEMENTED', function (name) {
  return 'The ' + name + ' method is not implemented';
});
createErrorType('ERR_STREAM_PREMATURE_CLOSE', 'Premature close');
createErrorType('ERR_STREAM_DESTROYED', function (name) {
  return 'Cannot call ' + name + ' after a stream was destroyed';
});
createErrorType('ERR_MULTIPLE_CALLBACK', 'Callback called multiple times');
createErrorType('ERR_STREAM_CANNOT_PIPE', 'Cannot pipe, not readable');
createErrorType('ERR_STREAM_WRITE_AFTER_END', 'write after end');
createErrorType('ERR_STREAM_NULL_VALUES', 'May not write null values to stream', TypeError);
createErrorType('ERR_UNKNOWN_ENCODING', function (arg) {
  return 'Unknown encoding: ' + arg;
}, TypeError);
createErrorType('ERR_STREAM_UNSHIFT_AFTER_END_EVENT', 'stream.unshift() after end event');
module.exports.codes = codes;

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_duplex.js":
/*!************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_duplex.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

/*<replacement>*/

var objectKeys = Object.keys || function (obj) {
  var keys = [];

  for (var key in obj) {
    keys.push(key);
  }

  return keys;
};
/*</replacement>*/


module.exports = Duplex;

var Readable = __webpack_require__(/*! ./_stream_readable */ "./node_modules/readable-stream/lib/_stream_readable.js");

var Writable = __webpack_require__(/*! ./_stream_writable */ "./node_modules/readable-stream/lib/_stream_writable.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Duplex, Readable);

{
  // Allow the keys array to be GC'ed.
  var keys = objectKeys(Writable.prototype);

  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);
  Readable.call(this, options);
  Writable.call(this, options);
  this.allowHalfOpen = true;

  if (options) {
    if (options.readable === false) this.readable = false;
    if (options.writable === false) this.writable = false;

    if (options.allowHalfOpen === false) {
      this.allowHalfOpen = false;
      this.once('end', onend);
    }
  }
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
});
Object.defineProperty(Duplex.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});
Object.defineProperty(Duplex.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
}); // the no-half-open enforcer

function onend() {
  // If the writable side ended, then we're ok.
  if (this._writableState.ended) return; // no more data can be written.
  // But allow more writes to happen in this tick.

  process.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }

    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_passthrough.js":
/*!*****************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \*****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.


module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "./node_modules/readable-stream/lib/_stream_transform.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);
  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_readable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_readable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


module.exports = Readable;
/*<replacement>*/

var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;
/*<replacement>*/

var EE = (__webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter);

var EElistenerCount = function EElistenerCount(emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/


var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*<replacement>*/


var debugUtil = __webpack_require__(/*! util */ "?d17e");

var debug;

if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function debug() {};
}
/*</replacement>*/


var BufferList = __webpack_require__(/*! ./internal/streams/buffer_list */ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js");

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT; // Lazy loaded to improve the startup performance.


var StringDecoder;
var createReadableStreamAsyncIterator;
var from;

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Readable, Stream);

var errorOrDestroy = destroyImpl.errorOrDestroy;
var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn); // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.

  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode; // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"

  this.highWaterMark = getHighWaterMark(this, options, 'readableHighWaterMark', isDuplex); // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()

  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false; // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.

  this.sync = true; // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.

  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;
  this.paused = true; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'end' (and potentially 'finish')

  this.autoDestroy = !!options.autoDestroy; // has it been destroyed

  this.destroyed = false; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // the number of writers that are awaiting a drain event in .pipe()s

  this.awaitDrain = 0; // if true, a maybeReadMore has been scheduled

  this.readingMore = false;
  this.decoder = null;
  this.encoding = null;

  if (options.encoding) {
    if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  if (!(this instanceof Readable)) return new Readable(options); // Checking for a Stream.Duplex instance is faster here instead of inside
  // the ReadableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  this._readableState = new ReadableState(options, this, isDuplex); // legacy

  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._readableState === undefined) {
      return false;
    }

    return this._readableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._readableState.destroyed = value;
  }
});
Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;

Readable.prototype._destroy = function (err, cb) {
  cb(err);
}; // Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.


Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;

      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }

      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
}; // Unshift should *always* be something directly out of read()


Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  debug('readableAddChunk', chunk);
  var state = stream._readableState;

  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);

    if (er) {
      errorOrDestroy(stream, er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
      } else if (state.destroyed) {
        return false;
      } else {
        state.reading = false;

        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
      maybeReadMore(stream, state);
    }
  } // We can push more data if we are below the highWaterMark.
  // Also, if we have no data yet, we can stand some more bytes.
  // This is to work around cases where hwm=0, such as the repl.


  return !state.ended && (state.length < state.highWaterMark || state.length === 0);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    state.awaitDrain = 0;
    stream.emit('data', chunk);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
    if (state.needReadable) emitReadable(stream);
  }

  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;

  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer', 'Uint8Array'], chunk);
  }

  return er;
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
}; // backwards compatibility.


Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = (__webpack_require__(/*! string_decoder/ */ "./node_modules/string_decoder/lib/string_decoder.js").StringDecoder);
  var decoder = new StringDecoder(enc);
  this._readableState.decoder = decoder; // If setEncoding(null), decoder.encoding equals utf8

  this._readableState.encoding = this._readableState.decoder.encoding; // Iterate over current buffer to convert already stored Buffers:

  var p = this._readableState.buffer.head;
  var content = '';

  while (p !== null) {
    content += decoder.write(p.data);
    p = p.next;
  }

  this._readableState.buffer.clear();

  if (content !== '') this._readableState.buffer.push(content);
  this._readableState.length = content.length;
  return this;
}; // Don't raise the hwm > 1GB


var MAX_HWM = 0x40000000;

function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    // TODO(ronag): Throw ERR_VALUE_OUT_OF_RANGE.
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }

  return n;
} // This function is designed to be inlinable, so please take care when making
// changes to the function body.


function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;

  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  } // If we're asking for more than the current hwm, then raise the hwm.


  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n; // Don't have enough

  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }

  return state.length;
} // you can override either this method, or the async _read(n) below.


Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;
  if (n !== 0) state.emittedReadable = false; // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.

  if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state); // if we've ended, and we're now clear, then finish it up.

  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  } // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.
  // if we need a readable event, then we need to do some reading.


  var doRead = state.needReadable;
  debug('need readable', doRead); // if we currently have less than the highWaterMark, then also read some

  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  } // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.


  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true; // if the length is currently zero, then we *need* a readable event.

    if (state.length === 0) state.needReadable = true; // call internal read method

    this._read(state.highWaterMark);

    state.sync = false; // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.

    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = state.length <= state.highWaterMark;
    n = 0;
  } else {
    state.length -= n;
    state.awaitDrain = 0;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true; // If we tried to read() past the EOF, then emit end on the next tick.

    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);
  return ret;
};

function onEofChunk(stream, state) {
  debug('onEofChunk');
  if (state.ended) return;

  if (state.decoder) {
    var chunk = state.decoder.end();

    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }

  state.ended = true;

  if (state.sync) {
    // if we are sync, wait until next tick to emit the data.
    // Otherwise we risk emitting data in the flow()
    // the readable code triggers during a read() call
    emitReadable(stream);
  } else {
    // emit 'readable' now to make sure it gets picked up.
    state.needReadable = false;

    if (!state.emittedReadable) {
      state.emittedReadable = true;
      emitReadable_(stream);
    }
  }
} // Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.


function emitReadable(stream) {
  var state = stream._readableState;
  debug('emitReadable', state.needReadable, state.emittedReadable);
  state.needReadable = false;

  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    process.nextTick(emitReadable_, stream);
  }
}

function emitReadable_(stream) {
  var state = stream._readableState;
  debug('emitReadable_', state.destroyed, state.length, state.ended);

  if (!state.destroyed && (state.length || state.ended)) {
    stream.emit('readable');
    state.emittedReadable = false;
  } // The stream needs another readable event if
  // 1. It is not flowing, as the flow mechanism will take
  //    care of it.
  // 2. It is not ended.
  // 3. It is below the highWaterMark, so we can schedule
  //    another readable later.


  state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
  flow(stream);
} // at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.


function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    process.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  // Attempt to read more data if we should.
  //
  // The conditions for reading more data are (one of):
  // - Not enough data buffered (state.length < state.highWaterMark). The loop
  //   is responsible for filling the buffer with enough data if such data
  //   is available. If highWaterMark is 0 and we are not in the flowing mode
  //   we should _not_ attempt to buffer any extra data. We'll get more data
  //   when the stream consumer calls read() instead.
  // - No data in the buffer, and the stream is in flowing mode. In this mode
  //   the loop below is responsible for ensuring read() is called. Failing to
  //   call read here would abort the flow and there's no other mechanism for
  //   continuing the flow if the stream consumer has just subscribed to the
  //   'data' event.
  //
  // In addition to the above conditions to keep reading data, the following
  // conditions prevent the data from being read:
  // - The stream has ended (state.ended).
  // - There is already a pending 'read' operation (state.reading). This is a
  //   case where the the stream has called the implementation defined _read()
  //   method, but they are processing the call asynchronously and have _not_
  //   called push() with new data. In this case we skip performing more
  //   read()s. The execution ends in this method again after the _read() ends
  //   up calling push() with more data.
  while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
    var len = state.length;
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length) // didn't get any data, stop spinning.
      break;
  }

  state.readingMore = false;
} // abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.


Readable.prototype._read = function (n) {
  errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED('_read()'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;

    case 1:
      state.pipes = [state.pipes, dest];
      break;

    default:
      state.pipes.push(dest);
      break;
  }

  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) process.nextTick(endFn);else src.once('end', endFn);
  dest.on('unpipe', onunpipe);

  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');

    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  } // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.


  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);
  var cleanedUp = false;

  function cleanup() {
    debug('cleanup'); // cleanup event handlers once the pipe is broken

    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);
    cleanedUp = true; // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.

    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  src.on('data', ondata);

  function ondata(chunk) {
    debug('ondata');
    var ret = dest.write(chunk);
    debug('dest.write', ret);

    if (ret === false) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', state.awaitDrain);
        state.awaitDrain++;
      }

      src.pause();
    }
  } // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.


  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) errorOrDestroy(dest, er);
  } // Make sure our error handler is attached before userland ones.


  prependListener(dest, 'error', onerror); // Both close and finish should trigger unpipe, but only once.

  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }

  dest.once('close', onclose);

  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }

  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  } // tell the dest that it's being piped to


  dest.emit('pipe', src); // start the flow if it hasn't been started already.

  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function pipeOnDrainFunctionResult() {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;

    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = {
    hasUnpiped: false
  }; // if we're not piping anywhere, then do nothing.

  if (state.pipesCount === 0) return this; // just one destination.  most common case.

  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;
    if (!dest) dest = state.pipes; // got a match.

    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  } // slow case. multiple pipe destinations.


  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, {
        hasUnpiped: false
      });
    }

    return this;
  } // try to find the right one.


  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;
  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];
  dest.emit('unpipe', this, unpipeInfo);
  return this;
}; // set up data events if they are asked for
// Ensure readable listeners eventually get something


Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);
  var state = this._readableState;

  if (ev === 'data') {
    // update readableListening so that resume() may be a no-op
    // a few lines down. This is needed to support once('readable').
    state.readableListening = this.listenerCount('readable') > 0; // Try start flowing on next tick if stream isn't explicitly paused

    if (state.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.flowing = false;
      state.emittedReadable = false;
      debug('on readable', state.length, state.reading);

      if (state.length) {
        emitReadable(this);
      } else if (!state.reading) {
        process.nextTick(nReadingNextTick, this);
      }
    }
  }

  return res;
};

Readable.prototype.addListener = Readable.prototype.on;

Readable.prototype.removeListener = function (ev, fn) {
  var res = Stream.prototype.removeListener.call(this, ev, fn);

  if (ev === 'readable') {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

Readable.prototype.removeAllListeners = function (ev) {
  var res = Stream.prototype.removeAllListeners.apply(this, arguments);

  if (ev === 'readable' || ev === undefined) {
    // We need to check if there is someone still listening to
    // readable and reset the state. However this needs to happen
    // after readable has been emitted but before I/O (nextTick) to
    // support once('readable', fn) cycles. This means that calling
    // resume within the same tick will have no
    // effect.
    process.nextTick(updateReadableListening, this);
  }

  return res;
};

function updateReadableListening(self) {
  var state = self._readableState;
  state.readableListening = self.listenerCount('readable') > 0;

  if (state.resumeScheduled && !state.paused) {
    // flowing needs to be set to true now, otherwise
    // the upcoming resume will not flow.
    state.flowing = true; // crude way to check if we should resume
  } else if (self.listenerCount('data') > 0) {
    self.resume();
  }
}

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
} // pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.


Readable.prototype.resume = function () {
  var state = this._readableState;

  if (!state.flowing) {
    debug('resume'); // we flow only if there is no one listening
    // for readable, but we still have to call
    // resume()

    state.flowing = !state.readableListening;
    resume(this, state);
  }

  state.paused = false;
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    process.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  debug('resume', state.reading);

  if (!state.reading) {
    stream.read(0);
  }

  state.resumeScheduled = false;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);

  if (this._readableState.flowing !== false) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }

  this._readableState.paused = true;
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);

  while (state.flowing && stream.read() !== null) {
    ;
  }
} // wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.


Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;
  stream.on('end', function () {
    debug('wrapped end');

    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });
  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk); // don't skip over falsy values in objectMode

    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);

    if (!ret) {
      paused = true;
      stream.pause();
    }
  }); // proxy all the other methods.
  // important when wrapping filters and duplexes.

  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function methodWrap(method) {
        return function methodWrapReturnFunction() {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  } // proxy certain important events.


  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  } // when we try to consume some more bytes, simply unpause the
  // underlying stream.


  this._read = function (n) {
    debug('wrapped _read', n);

    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

if (typeof Symbol === 'function') {
  Readable.prototype[Symbol.asyncIterator] = function () {
    if (createReadableStreamAsyncIterator === undefined) {
      createReadableStreamAsyncIterator = __webpack_require__(/*! ./internal/streams/async_iterator */ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js");
    }

    return createReadableStreamAsyncIterator(this);
  };
}

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.highWaterMark;
  }
});
Object.defineProperty(Readable.prototype, 'readableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState && this._readableState.buffer;
  }
});
Object.defineProperty(Readable.prototype, 'readableFlowing', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.flowing;
  },
  set: function set(state) {
    if (this._readableState) {
      this._readableState.flowing = state;
    }
  }
}); // exposed for testing purposes only.

Readable._fromList = fromList;
Object.defineProperty(Readable.prototype, 'readableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._readableState.length;
  }
}); // Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.

function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;
  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.first();else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = state.buffer.consume(n, state.decoder);
  }
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;
  debug('endReadable', state.endEmitted);

  if (!state.endEmitted) {
    state.ended = true;
    process.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  debug('endReadableNT', state.endEmitted, state.length); // Check that we didn't get one last unshift.

  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');

    if (state.autoDestroy) {
      // In case of duplex streams we need a way to detect
      // if the writable side is ready for autoDestroy as well
      var wState = stream._writableState;

      if (!wState || wState.autoDestroy && wState.finished) {
        stream.destroy();
      }
    }
  }
}

if (typeof Symbol === 'function') {
  Readable.from = function (iterable, opts) {
    if (from === undefined) {
      from = __webpack_require__(/*! ./internal/streams/from */ "./node_modules/readable-stream/lib/internal/streams/from-browser.js");
    }

    return from(Readable, iterable, opts);
  };
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }

  return -1;
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_transform.js":
/*!***************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_transform.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.


module.exports = Transform;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING,
    ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;
  var cb = ts.writecb;

  if (cb === null) {
    return this.emit('error', new ERR_MULTIPLE_CALLBACK());
  }

  ts.writechunk = null;
  ts.writecb = null;
  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);
  cb(er);
  var rs = this._readableState;
  rs.reading = false;

  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);
  Duplex.call(this, options);
  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  }; // start out asking for a readable event once data is transformed.

  this._readableState.needReadable = true; // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.

  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;
    if (typeof options.flush === 'function') this._flush = options.flush;
  } // When the writable side finishes, then flush out anything remaining.


  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function' && !this._readableState.destroyed) {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
}; // This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.


Transform.prototype._transform = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_transform()'));
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;

  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
}; // Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.


Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && !ts.transforming) {
    ts.transforming = true;

    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);
  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data); // TODO(BridgeAR): Write a test for these two error cases
  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided

  if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
  if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
  return stream.push(null);
}

/***/ }),

/***/ "./node_modules/readable-stream/lib/_stream_writable.js":
/*!**************************************************************!*\
  !*** ./node_modules/readable-stream/lib/_stream_writable.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.


module.exports = Writable;
/* <replacement> */

function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
} // It seems a linked list but it is not
// there will be only 2 of these for each stream


function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;

  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/


var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;
/*<replacement>*/

var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "./node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/

var Stream = __webpack_require__(/*! ./internal/streams/stream */ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/


var Buffer = (__webpack_require__(/*! buffer */ "./node_modules/buffer/index.js").Buffer);

var OurUint8Array = __webpack_require__.g.Uint8Array || function () {};

function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}

function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "./node_modules/readable-stream/lib/internal/streams/destroy.js");

var _require = __webpack_require__(/*! ./internal/streams/state */ "./node_modules/readable-stream/lib/internal/streams/state.js"),
    getHighWaterMark = _require.getHighWaterMark;

var _require$codes = (__webpack_require__(/*! ../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE,
    ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED,
    ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK,
    ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED,
    ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES,
    ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END,
    ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;

var errorOrDestroy = destroyImpl.errorOrDestroy;

__webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js")(Writable, Stream);

function nop() {}

function WritableState(options, stream, isDuplex) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js");
  options = options || {}; // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream,
  // e.g. options.readableObjectMode vs. options.writableObjectMode, etc.

  if (typeof isDuplex !== 'boolean') isDuplex = stream instanceof Duplex; // object stream flag to indicate whether or not this stream
  // contains buffers or objects.

  this.objectMode = !!options.objectMode;
  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode; // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()

  this.highWaterMark = getHighWaterMark(this, options, 'writableHighWaterMark', isDuplex); // if _final has been called

  this.finalCalled = false; // drain event flag.

  this.needDrain = false; // at the start of calling end()

  this.ending = false; // when end() has been called, and returned

  this.ended = false; // when 'finish' is emitted

  this.finished = false; // has it been destroyed

  this.destroyed = false; // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.

  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode; // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.

  this.defaultEncoding = options.defaultEncoding || 'utf8'; // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.

  this.length = 0; // a flag to see when we're in the middle of a write.

  this.writing = false; // when true all writes will be buffered until .uncork() call

  this.corked = 0; // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.

  this.sync = true; // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.

  this.bufferProcessing = false; // the callback that's passed to _write(chunk,cb)

  this.onwrite = function (er) {
    onwrite(stream, er);
  }; // the callback that the user supplies to write(chunk,encoding,cb)


  this.writecb = null; // the amount that is being written when _write is called.

  this.writelen = 0;
  this.bufferedRequest = null;
  this.lastBufferedRequest = null; // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted

  this.pendingcb = 0; // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams

  this.prefinished = false; // True if the error was already emitted and should not be thrown again

  this.errorEmitted = false; // Should close be emitted on destroy. Defaults to true.

  this.emitClose = options.emitClose !== false; // Should .destroy() be called after 'finish' (and potentially 'end')

  this.autoDestroy = !!options.autoDestroy; // count buffered requests

  this.bufferedRequestCount = 0; // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two

  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];

  while (current) {
    out.push(current);
    current = current.next;
  }

  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function writableStateBufferGetter() {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})(); // Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.


var realHasInstance;

if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function value(object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;
      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function realHasInstance(object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "./node_modules/readable-stream/lib/_stream_duplex.js"); // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.
  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  // Checking for a Stream.Duplex instance is faster here instead of inside
  // the WritableState constructor, at least with V8 6.5

  var isDuplex = this instanceof Duplex;
  if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
  this._writableState = new WritableState(options, this, isDuplex); // legacy.

  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;
    if (typeof options.writev === 'function') this._writev = options.writev;
    if (typeof options.destroy === 'function') this._destroy = options.destroy;
    if (typeof options["final"] === 'function') this._final = options["final"];
  }

  Stream.call(this);
} // Otherwise people can pipe Writable streams, which is just wrong.


Writable.prototype.pipe = function () {
  errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
};

function writeAfterEnd(stream, cb) {
  var er = new ERR_STREAM_WRITE_AFTER_END(); // TODO: defer error events consistently everywhere, not just the cb

  errorOrDestroy(stream, er);
  process.nextTick(cb, er);
} // Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.


function validChunk(stream, state, chunk, cb) {
  var er;

  if (chunk === null) {
    er = new ERR_STREAM_NULL_VALUES();
  } else if (typeof chunk !== 'string' && !state.objectMode) {
    er = new ERR_INVALID_ARG_TYPE('chunk', ['string', 'Buffer'], chunk);
  }

  if (er) {
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
    return false;
  }

  return true;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;

  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
  if (typeof cb !== 'function') cb = nop;
  if (state.ending) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }
  return ret;
};

Writable.prototype.cork = function () {
  this._writableState.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;
    if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

Object.defineProperty(Writable.prototype, 'writableBuffer', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState && this._writableState.getBuffer();
  }
});

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }

  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.highWaterMark;
  }
}); // if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.

function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);

    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }

  var len = state.objectMode ? 1 : chunk.length;
  state.length += len;
  var ret = state.length < state.highWaterMark; // we must ensure that previous needDrain will not be reset to false.

  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };

    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }

    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED('write'));else if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    process.nextTick(cb, er); // this can emit finish, and it will always happen
    // after error

    process.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    errorOrDestroy(stream, er); // this can emit finish, but finish must
    // always follow error

    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;
  if (typeof cb !== 'function') throw new ERR_MULTIPLE_CALLBACK();
  onwriteStateUpdate(state);
  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state) || stream.destroyed;

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      process.nextTick(afterWrite, stream, state, finished, cb);
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
} // Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.


function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
} // if there's something in the buffer waiting, then process it


function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;
    var count = 0;
    var allBuffers = true;

    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }

    buffer.allBuffers = allBuffers;
    doWrite(stream, state, true, state.length, buffer, '', holder.finish); // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite

    state.pendingcb++;
    state.lastBufferedRequest = null;

    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }

    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;
      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--; // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.

      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new ERR_METHOD_NOT_IMPLEMENTED('_write()'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding); // .end() fully uncorks

  if (state.corked) {
    state.corked = 1;
    this.uncork();
  } // ignore unnecessary end() calls.


  if (!state.ending) endWritable(this, state, cb);
  return this;
};

Object.defineProperty(Writable.prototype, 'writableLength', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    return this._writableState.length;
  }
});

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}

function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;

    if (err) {
      errorOrDestroy(stream, err);
    }

    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}

function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function' && !state.destroyed) {
      state.pendingcb++;
      state.finalCalled = true;
      process.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);

  if (need) {
    prefinish(stream, state);

    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');

      if (state.autoDestroy) {
        // In case of duplex streams we need a way to detect
        // if the readable side is ready for autoDestroy as well
        var rState = stream._readableState;

        if (!rState || rState.autoDestroy && rState.endEmitted) {
          stream.destroy();
        }
      }
    }
  }

  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);

  if (cb) {
    if (state.finished) process.nextTick(cb);else stream.once('finish', cb);
  }

  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;

  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  } // reuse the free corkReq.


  state.corkedRequestsFree.next = corkReq;
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function get() {
    if (this._writableState === undefined) {
      return false;
    }

    return this._writableState.destroyed;
  },
  set: function set(value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    } // backward compatibility, the user is explicitly
    // managing destroyed


    this._writableState.destroyed = value;
  }
});
Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;

Writable.prototype._destroy = function (err, cb) {
  cb(err);
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/async_iterator.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/async_iterator.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var _Object$setPrototypeO;

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var finished = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");

var kLastResolve = Symbol('lastResolve');
var kLastReject = Symbol('lastReject');
var kError = Symbol('error');
var kEnded = Symbol('ended');
var kLastPromise = Symbol('lastPromise');
var kHandlePromise = Symbol('handlePromise');
var kStream = Symbol('stream');

function createIterResult(value, done) {
  return {
    value: value,
    done: done
  };
}

function readAndResolve(iter) {
  var resolve = iter[kLastResolve];

  if (resolve !== null) {
    var data = iter[kStream].read(); // we defer if data is null
    // we can be expecting either 'end' or
    // 'error'

    if (data !== null) {
      iter[kLastPromise] = null;
      iter[kLastResolve] = null;
      iter[kLastReject] = null;
      resolve(createIterResult(data, false));
    }
  }
}

function onReadable(iter) {
  // we wait for the next tick, because it might
  // emit an error with process.nextTick
  process.nextTick(readAndResolve, iter);
}

function wrapForNext(lastPromise, iter) {
  return function (resolve, reject) {
    lastPromise.then(function () {
      if (iter[kEnded]) {
        resolve(createIterResult(undefined, true));
        return;
      }

      iter[kHandlePromise](resolve, reject);
    }, reject);
  };
}

var AsyncIteratorPrototype = Object.getPrototypeOf(function () {});
var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
  get stream() {
    return this[kStream];
  },

  next: function next() {
    var _this = this; // if we have detected an error in the meanwhile
    // reject straight away


    var error = this[kError];

    if (error !== null) {
      return Promise.reject(error);
    }

    if (this[kEnded]) {
      return Promise.resolve(createIterResult(undefined, true));
    }

    if (this[kStream].destroyed) {
      // We need to defer via nextTick because if .destroy(err) is
      // called, the error will be emitted via nextTick, and
      // we cannot guarantee that there is no error lingering around
      // waiting to be emitted.
      return new Promise(function (resolve, reject) {
        process.nextTick(function () {
          if (_this[kError]) {
            reject(_this[kError]);
          } else {
            resolve(createIterResult(undefined, true));
          }
        });
      });
    } // if we have multiple next() calls
    // we will wait for the previous Promise to finish
    // this logic is optimized to support for await loops,
    // where next() is only called once at a time


    var lastPromise = this[kLastPromise];
    var promise;

    if (lastPromise) {
      promise = new Promise(wrapForNext(lastPromise, this));
    } else {
      // fast path needed to support multiple this.push()
      // without triggering the next() queue
      var data = this[kStream].read();

      if (data !== null) {
        return Promise.resolve(createIterResult(data, false));
      }

      promise = new Promise(this[kHandlePromise]);
    }

    this[kLastPromise] = promise;
    return promise;
  }
}, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function () {
  return this;
}), _defineProperty(_Object$setPrototypeO, "return", function _return() {
  var _this2 = this; // destroy(err, cb) is a private API
  // we can guarantee we have that here, because we control the
  // Readable class this is attached to


  return new Promise(function (resolve, reject) {
    _this2[kStream].destroy(null, function (err) {
      if (err) {
        reject(err);
        return;
      }

      resolve(createIterResult(undefined, true));
    });
  });
}), _Object$setPrototypeO), AsyncIteratorPrototype);

var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator(stream) {
  var _Object$create;

  var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
    value: stream,
    writable: true
  }), _defineProperty(_Object$create, kLastResolve, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kLastReject, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kError, {
    value: null,
    writable: true
  }), _defineProperty(_Object$create, kEnded, {
    value: stream._readableState.endEmitted,
    writable: true
  }), _defineProperty(_Object$create, kHandlePromise, {
    value: function value(resolve, reject) {
      var data = iterator[kStream].read();

      if (data) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(data, false));
      } else {
        iterator[kLastResolve] = resolve;
        iterator[kLastReject] = reject;
      }
    },
    writable: true
  }), _Object$create));
  iterator[kLastPromise] = null;
  finished(stream, function (err) {
    if (err && err.code !== 'ERR_STREAM_PREMATURE_CLOSE') {
      var reject = iterator[kLastReject]; // reject if we are waiting for data in the Promise
      // returned by next() and store the error

      if (reject !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        reject(err);
      }

      iterator[kError] = err;
      return;
    }

    var resolve = iterator[kLastResolve];

    if (resolve !== null) {
      iterator[kLastPromise] = null;
      iterator[kLastResolve] = null;
      iterator[kLastReject] = null;
      resolve(createIterResult(undefined, true));
    }

    iterator[kEnded] = true;
  });
  stream.on('readable', onReadable.bind(null, iterator));
  return iterator;
};

module.exports = createReadableStreamAsyncIterator;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/buffer_list.js":
/*!**************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/buffer_list.js ***!
  \**************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



function ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly) symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    });
    keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      ownKeys(Object(source), true).forEach(function (key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

var _require = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js"),
    Buffer = _require.Buffer;

var _require2 = __webpack_require__(/*! util */ "?ed1b"),
    inspect = _require2.inspect;

var custom = inspect && inspect.custom || 'inspect';

function copyBuffer(src, target, offset) {
  Buffer.prototype.copy.call(src, target, offset);
}

module.exports = /*#__PURE__*/function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  _createClass(BufferList, [{
    key: "push",
    value: function push(v) {
      var entry = {
        data: v,
        next: null
      };
      if (this.length > 0) this.tail.next = entry;else this.head = entry;
      this.tail = entry;
      ++this.length;
    }
  }, {
    key: "unshift",
    value: function unshift(v) {
      var entry = {
        data: v,
        next: this.head
      };
      if (this.length === 0) this.tail = entry;
      this.head = entry;
      ++this.length;
    }
  }, {
    key: "shift",
    value: function shift() {
      if (this.length === 0) return;
      var ret = this.head.data;
      if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
      --this.length;
      return ret;
    }
  }, {
    key: "clear",
    value: function clear() {
      this.head = this.tail = null;
      this.length = 0;
    }
  }, {
    key: "join",
    value: function join(s) {
      if (this.length === 0) return '';
      var p = this.head;
      var ret = '' + p.data;

      while (p = p.next) {
        ret += s + p.data;
      }

      return ret;
    }
  }, {
    key: "concat",
    value: function concat(n) {
      if (this.length === 0) return Buffer.alloc(0);
      var ret = Buffer.allocUnsafe(n >>> 0);
      var p = this.head;
      var i = 0;

      while (p) {
        copyBuffer(p.data, ret, i);
        i += p.data.length;
        p = p.next;
      }

      return ret;
    } // Consumes a specified amount of bytes or characters from the buffered data.

  }, {
    key: "consume",
    value: function consume(n, hasStrings) {
      var ret;

      if (n < this.head.data.length) {
        // `slice` is the same for buffers and strings.
        ret = this.head.data.slice(0, n);
        this.head.data = this.head.data.slice(n);
      } else if (n === this.head.data.length) {
        // First chunk is a perfect match.
        ret = this.shift();
      } else {
        // Result spans more than one buffer.
        ret = hasStrings ? this._getString(n) : this._getBuffer(n);
      }

      return ret;
    }
  }, {
    key: "first",
    value: function first() {
      return this.head.data;
    } // Consumes a specified amount of characters from the buffered data.

  }, {
    key: "_getString",
    value: function _getString(n) {
      var p = this.head;
      var c = 1;
      var ret = p.data;
      n -= ret.length;

      while (p = p.next) {
        var str = p.data;
        var nb = n > str.length ? str.length : n;
        if (nb === str.length) ret += str;else ret += str.slice(0, n);
        n -= nb;

        if (n === 0) {
          if (nb === str.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = str.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Consumes a specified amount of bytes from the buffered data.

  }, {
    key: "_getBuffer",
    value: function _getBuffer(n) {
      var ret = Buffer.allocUnsafe(n);
      var p = this.head;
      var c = 1;
      p.data.copy(ret);
      n -= p.data.length;

      while (p = p.next) {
        var buf = p.data;
        var nb = n > buf.length ? buf.length : n;
        buf.copy(ret, ret.length - n, 0, nb);
        n -= nb;

        if (n === 0) {
          if (nb === buf.length) {
            ++c;
            if (p.next) this.head = p.next;else this.head = this.tail = null;
          } else {
            this.head = p;
            p.data = buf.slice(nb);
          }

          break;
        }

        ++c;
      }

      this.length -= c;
      return ret;
    } // Make sure the linked list only shows the minimal necessary information.

  }, {
    key: custom,
    value: function value(_, options) {
      return inspect(this, _objectSpread({}, options, {
        // Only inspect one level.
        depth: 0,
        // It should not recurse.
        customInspect: false
      }));
    }
  }]);

  return BufferList;
}();

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!**********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \**********************************************************************/
/***/ ((module) => {

 // undocumented cb() API, needed for core, not for public API

function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err) {
      if (!this._writableState) {
        process.nextTick(emitErrorNT, this, err);
      } else if (!this._writableState.errorEmitted) {
        this._writableState.errorEmitted = true;
        process.nextTick(emitErrorNT, this, err);
      }
    }

    return this;
  } // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks


  if (this._readableState) {
    this._readableState.destroyed = true;
  } // if this is a duplex stream mark the writable part as destroyed as well


  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      if (!_this._writableState) {
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else if (!_this._writableState.errorEmitted) {
        _this._writableState.errorEmitted = true;
        process.nextTick(emitErrorAndCloseNT, _this, err);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    } else if (cb) {
      process.nextTick(emitCloseNT, _this);
      cb(err);
    } else {
      process.nextTick(emitCloseNT, _this);
    }
  });

  return this;
}

function emitErrorAndCloseNT(self, err) {
  emitErrorNT(self, err);
  emitCloseNT(self);
}

function emitCloseNT(self) {
  if (self._writableState && !self._writableState.emitClose) return;
  if (self._readableState && !self._readableState.emitClose) return;
  self.emit('close');
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finalCalled = false;
    this._writableState.prefinished = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

function errorOrDestroy(stream, err) {
  // We have tests that rely on errors being emitted
  // in the same tick, so changing this is semver major.
  // For now when you opt-in to autoDestroy we allow
  // the error to be emitted nextTick. In a future
  // semver major update we should change the default to this.
  var rState = stream._readableState;
  var wState = stream._writableState;
  if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);else stream.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy,
  errorOrDestroy: errorOrDestroy
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js":
/*!****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/end-of-stream.js ***!
  \****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Ported from https://github.com/mafintosh/end-of-stream with
// permission from the author, Mathias Buus (@mafintosh).


var ERR_STREAM_PREMATURE_CLOSE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes.ERR_STREAM_PREMATURE_CLOSE);

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    callback.apply(this, args);
  };
}

function noop() {}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function eos(stream, opts, callback) {
  if (typeof opts === 'function') return eos(stream, null, opts);
  if (!opts) opts = {};
  callback = once(callback || noop);
  var readable = opts.readable || opts.readable !== false && stream.readable;
  var writable = opts.writable || opts.writable !== false && stream.writable;

  var onlegacyfinish = function onlegacyfinish() {
    if (!stream.writable) onfinish();
  };

  var writableEnded = stream._writableState && stream._writableState.finished;

  var onfinish = function onfinish() {
    writable = false;
    writableEnded = true;
    if (!readable) callback.call(stream);
  };

  var readableEnded = stream._readableState && stream._readableState.endEmitted;

  var onend = function onend() {
    readable = false;
    readableEnded = true;
    if (!writable) callback.call(stream);
  };

  var onerror = function onerror(err) {
    callback.call(stream, err);
  };

  var onclose = function onclose() {
    var err;

    if (readable && !readableEnded) {
      if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }

    if (writable && !writableEnded) {
      if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
      return callback.call(stream, err);
    }
  };

  var onrequest = function onrequest() {
    stream.req.on('finish', onfinish);
  };

  if (isRequest(stream)) {
    stream.on('complete', onfinish);
    stream.on('abort', onclose);
    if (stream.req) onrequest();else stream.on('request', onrequest);
  } else if (writable && !stream._writableState) {
    // legacy streams
    stream.on('end', onlegacyfinish);
    stream.on('close', onlegacyfinish);
  }

  stream.on('end', onend);
  stream.on('finish', onfinish);
  if (opts.error !== false) stream.on('error', onerror);
  stream.on('close', onclose);
  return function () {
    stream.removeListener('complete', onfinish);
    stream.removeListener('abort', onclose);
    stream.removeListener('request', onrequest);
    if (stream.req) stream.req.removeListener('finish', onfinish);
    stream.removeListener('end', onlegacyfinish);
    stream.removeListener('close', onlegacyfinish);
    stream.removeListener('finish', onfinish);
    stream.removeListener('end', onend);
    stream.removeListener('error', onerror);
    stream.removeListener('close', onclose);
  };
}

module.exports = eos;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/from-browser.js":
/*!***************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/from-browser.js ***!
  \***************************************************************************/
/***/ ((module) => {

module.exports = function () {
  throw new Error('Readable.from is not available in the browser');
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/pipeline.js":
/*!***********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/pipeline.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Ported from https://github.com/mafintosh/pump with
// permission from the author, Mathias Buus (@mafintosh).


var eos;

function once(callback) {
  var called = false;
  return function () {
    if (called) return;
    called = true;
    callback.apply(void 0, arguments);
  };
}

var _require$codes = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes),
    ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS,
    ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;

function noop(err) {
  // Rethrow the error if it exists to avoid swallowing it
  if (err) throw err;
}

function isRequest(stream) {
  return stream.setHeader && typeof stream.abort === 'function';
}

function destroyer(stream, reading, writing, callback) {
  callback = once(callback);
  var closed = false;
  stream.on('close', function () {
    closed = true;
  });
  if (eos === undefined) eos = __webpack_require__(/*! ./end-of-stream */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
  eos(stream, {
    readable: reading,
    writable: writing
  }, function (err) {
    if (err) return callback(err);
    closed = true;
    callback();
  });
  var destroyed = false;
  return function (err) {
    if (closed) return;
    if (destroyed) return;
    destroyed = true; // request.destroy just do .end - .abort is what we want

    if (isRequest(stream)) return stream.abort();
    if (typeof stream.destroy === 'function') return stream.destroy();
    callback(err || new ERR_STREAM_DESTROYED('pipe'));
  };
}

function call(fn) {
  fn();
}

function pipe(from, to) {
  return from.pipe(to);
}

function popCallback(streams) {
  if (!streams.length) return noop;
  if (typeof streams[streams.length - 1] !== 'function') return noop;
  return streams.pop();
}

function pipeline() {
  for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
    streams[_key] = arguments[_key];
  }

  var callback = popCallback(streams);
  if (Array.isArray(streams[0])) streams = streams[0];

  if (streams.length < 2) {
    throw new ERR_MISSING_ARGS('streams');
  }

  var error;
  var destroys = streams.map(function (stream, i) {
    var reading = i < streams.length - 1;
    var writing = i > 0;
    return destroyer(stream, reading, writing, function (err) {
      if (!error) error = err;
      if (err) destroys.forEach(call);
      if (reading) return;
      destroys.forEach(call);
      callback(error);
    });
  });
  return streams.reduce(pipe);
}

module.exports = pipeline;

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/state.js":
/*!********************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/state.js ***!
  \********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {



var ERR_INVALID_OPT_VALUE = (__webpack_require__(/*! ../../../errors */ "./node_modules/readable-stream/errors-browser.js").codes.ERR_INVALID_OPT_VALUE);

function highWaterMarkFrom(options, isDuplex, duplexKey) {
  return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
}

function getHighWaterMark(state, options, duplexKey, isDuplex) {
  var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);

  if (hwm != null) {
    if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
      var name = isDuplex ? duplexKey : 'highWaterMark';
      throw new ERR_INVALID_OPT_VALUE(name, hwm);
    }

    return Math.floor(hwm);
  } // Default value


  return state.objectMode ? 16 : 16 * 1024;
}

module.exports = {
  getHighWaterMark: getHighWaterMark
};

/***/ }),

/***/ "./node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

module.exports = __webpack_require__(/*! events */ "./node_modules/events/events.js").EventEmitter;

/***/ }),

/***/ "./node_modules/readable-stream/readable-browser.js":
/*!**********************************************************!*\
  !*** ./node_modules/readable-stream/readable-browser.js ***!
  \**********************************************************/
/***/ ((module, exports, __webpack_require__) => {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "./node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "./node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "./node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "./node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "./node_modules/readable-stream/lib/_stream_passthrough.js");
exports.finished = __webpack_require__(/*! ./lib/internal/streams/end-of-stream.js */ "./node_modules/readable-stream/lib/internal/streams/end-of-stream.js");
exports.pipeline = __webpack_require__(/*! ./lib/internal/streams/pipeline.js */ "./node_modules/readable-stream/lib/internal/streams/pipeline.js");

/***/ }),

/***/ "./node_modules/safe-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/safe-buffer/index.js ***!
  \*******************************************/
/***/ ((module, exports, __webpack_require__) => {

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js");

var Buffer = buffer.Buffer; // alternative to using Object.keys for old browsers

function copyProps(src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}

if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer(arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length);
}

SafeBuffer.prototype = Object.create(Buffer.prototype); // Copy static methods from Buffer

copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number');
  }

  return Buffer(arg, encodingOrOffset, length);
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  var buf = Buffer(size);

  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }

  return buf;
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return Buffer(size);
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number');
  }

  return buffer.SlowBuffer(size);
};

/***/ }),

/***/ "./node_modules/stream-http/index.js":
/*!*******************************************!*\
  !*** ./node_modules/stream-http/index.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var ClientRequest = __webpack_require__(/*! ./lib/request */ "./node_modules/stream-http/lib/request.js");

var response = __webpack_require__(/*! ./lib/response */ "./node_modules/stream-http/lib/response.js");

var extend = __webpack_require__(/*! xtend */ "./node_modules/xtend/immutable.js");

var statusCodes = __webpack_require__(/*! builtin-status-codes */ "./node_modules/builtin-status-codes/browser.js");

var url = __webpack_require__(/*! url */ "./node_modules/url/url.js");

var http = exports;

http.request = function (opts, cb) {
  if (typeof opts === 'string') opts = url.parse(opts);else opts = extend(opts); // Normally, the page is loaded from http or https, so not specifying a protocol
  // will result in a (valid) protocol-relative url. However, this won't work if
  // the protocol is something else, like 'file:'

  var defaultProtocol = __webpack_require__.g.location.protocol.search(/^https?:$/) === -1 ? 'http:' : '';
  var protocol = opts.protocol || defaultProtocol;
  var host = opts.hostname || opts.host;
  var port = opts.port;
  var path = opts.path || '/'; // Necessary for IPv6 addresses

  if (host && host.indexOf(':') !== -1) host = '[' + host + ']'; // This may be a relative url. The browser should always be able to interpret it correctly.

  opts.url = (host ? protocol + '//' + host : '') + (port ? ':' + port : '') + path;
  opts.method = (opts.method || 'GET').toUpperCase();
  opts.headers = opts.headers || {}; // Also valid opts.auth, opts.mode

  var req = new ClientRequest(opts);
  if (cb) req.on('response', cb);
  return req;
};

http.get = function get(opts, cb) {
  var req = http.request(opts, cb);
  req.end();
  return req;
};

http.ClientRequest = ClientRequest;
http.IncomingMessage = response.IncomingMessage;

http.Agent = function () {};

http.Agent.defaultMaxSockets = 4;
http.globalAgent = new http.Agent();
http.STATUS_CODES = statusCodes;
http.METHODS = ['CHECKOUT', 'CONNECT', 'COPY', 'DELETE', 'GET', 'HEAD', 'LOCK', 'M-SEARCH', 'MERGE', 'MKACTIVITY', 'MKCOL', 'MOVE', 'NOTIFY', 'OPTIONS', 'PATCH', 'POST', 'PROPFIND', 'PROPPATCH', 'PURGE', 'PUT', 'REPORT', 'SEARCH', 'SUBSCRIBE', 'TRACE', 'UNLOCK', 'UNSUBSCRIBE'];

/***/ }),

/***/ "./node_modules/stream-http/lib/capability.js":
/*!****************************************************!*\
  !*** ./node_modules/stream-http/lib/capability.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.fetch = isFunction(__webpack_require__.g.fetch) && isFunction(__webpack_require__.g.ReadableStream);
exports.writableStream = isFunction(__webpack_require__.g.WritableStream);
exports.abortController = isFunction(__webpack_require__.g.AbortController); // The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.

var xhr;

function getXHR() {
  // Cache the xhr value
  if (xhr !== undefined) return xhr;

  if (__webpack_require__.g.XMLHttpRequest) {
    xhr = new __webpack_require__.g.XMLHttpRequest(); // If XDomainRequest is available (ie only, where xhr might not work
    // cross domain), use the page location. Otherwise use example.com
    // Note: this doesn't actually make an http request.

    try {
      xhr.open('GET', __webpack_require__.g.XDomainRequest ? '/' : 'https://example.com');
    } catch (e) {
      xhr = null;
    }
  } else {
    // Service workers don't have XHR
    xhr = null;
  }

  return xhr;
}

function checkTypeSupport(type) {
  var xhr = getXHR();
  if (!xhr) return false;

  try {
    xhr.responseType = type;
    return xhr.responseType === type;
  } catch (e) {}

  return false;
} // If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().


exports.arraybuffer = exports.fetch || checkTypeSupport('arraybuffer'); // These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.

exports.msstream = !exports.fetch && checkTypeSupport('ms-stream');
exports.mozchunkedarraybuffer = !exports.fetch && checkTypeSupport('moz-chunked-arraybuffer'); // If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().

exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false);

function isFunction(value) {
  return typeof value === 'function';
}

xhr = null; // Help gc

/***/ }),

/***/ "./node_modules/stream-http/lib/request.js":
/*!*************************************************!*\
  !*** ./node_modules/stream-http/lib/request.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var response = __webpack_require__(/*! ./response */ "./node_modules/stream-http/lib/response.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var IncomingMessage = response.IncomingMessage;
var rStates = response.readyStates;

function decideMode(preferBinary, useFetch) {
  if (capability.fetch && useFetch) {
    return 'fetch';
  } else if (capability.mozchunkedarraybuffer) {
    return 'moz-chunked-arraybuffer';
  } else if (capability.msstream) {
    return 'ms-stream';
  } else if (capability.arraybuffer && preferBinary) {
    return 'arraybuffer';
  } else {
    return 'text';
  }
}

var ClientRequest = module.exports = function (opts) {
  var self = this;
  stream.Writable.call(self);
  self._opts = opts;
  self._body = [];
  self._headers = {};
  if (opts.auth) self.setHeader('Authorization', 'Basic ' + Buffer.from(opts.auth).toString('base64'));
  Object.keys(opts.headers).forEach(function (name) {
    self.setHeader(name, opts.headers[name]);
  });
  var preferBinary;
  var useFetch = true;

  if (opts.mode === 'disable-fetch' || 'requestTimeout' in opts && !capability.abortController) {
    // If the use of XHR should be preferred. Not typically needed.
    useFetch = false;
    preferBinary = true;
  } else if (opts.mode === 'prefer-streaming') {
    // If streaming is a high priority but binary compatibility and
    // the accuracy of the 'content-type' header aren't
    preferBinary = false;
  } else if (opts.mode === 'allow-wrong-content-type') {
    // If streaming is more important than preserving the 'content-type' header
    preferBinary = !capability.overrideMimeType;
  } else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
    // Use binary if text streaming may corrupt data or the content-type header, or for speed
    preferBinary = true;
  } else {
    throw new Error('Invalid value for opts.mode');
  }

  self._mode = decideMode(preferBinary, useFetch);
  self._fetchTimer = null;
  self._socketTimeout = null;
  self._socketTimer = null;
  self.on('finish', function () {
    self._onFinish();
  });
};

inherits(ClientRequest, stream.Writable);

ClientRequest.prototype.setHeader = function (name, value) {
  var self = this;
  var lowerName = name.toLowerCase(); // This check is not necessary, but it prevents warnings from browsers about setting unsafe
  // headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
  // http-browserify did it, so I will too.

  if (unsafeHeaders.indexOf(lowerName) !== -1) return;
  self._headers[lowerName] = {
    name: name,
    value: value
  };
};

ClientRequest.prototype.getHeader = function (name) {
  var header = this._headers[name.toLowerCase()];

  if (header) return header.value;
  return null;
};

ClientRequest.prototype.removeHeader = function (name) {
  var self = this;
  delete self._headers[name.toLowerCase()];
};

ClientRequest.prototype._onFinish = function () {
  var self = this;
  if (self._destroyed) return;
  var opts = self._opts;

  if ('timeout' in opts && opts.timeout !== 0) {
    self.setTimeout(opts.timeout);
  }

  var headersObj = self._headers;
  var body = null;

  if (opts.method !== 'GET' && opts.method !== 'HEAD') {
    body = new Blob(self._body, {
      type: (headersObj['content-type'] || {}).value || ''
    });
  } // create flattened list of headers


  var headersList = [];
  Object.keys(headersObj).forEach(function (keyName) {
    var name = headersObj[keyName].name;
    var value = headersObj[keyName].value;

    if (Array.isArray(value)) {
      value.forEach(function (v) {
        headersList.push([name, v]);
      });
    } else {
      headersList.push([name, value]);
    }
  });

  if (self._mode === 'fetch') {
    var signal = null;

    if (capability.abortController) {
      var controller = new AbortController();
      signal = controller.signal;
      self._fetchAbortController = controller;

      if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
        self._fetchTimer = __webpack_require__.g.setTimeout(function () {
          self.emit('requestTimeout');
          if (self._fetchAbortController) self._fetchAbortController.abort();
        }, opts.requestTimeout);
      }
    }

    __webpack_require__.g.fetch(self._opts.url, {
      method: self._opts.method,
      headers: headersList,
      body: body || undefined,
      mode: 'cors',
      credentials: opts.withCredentials ? 'include' : 'same-origin',
      signal: signal
    }).then(function (response) {
      self._fetchResponse = response;

      self._resetTimers(false);

      self._connect();
    }, function (reason) {
      self._resetTimers(true);

      if (!self._destroyed) self.emit('error', reason);
    });
  } else {
    var xhr = self._xhr = new __webpack_require__.g.XMLHttpRequest();

    try {
      xhr.open(self._opts.method, self._opts.url, true);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    } // Can't set responseType on really old browsers


    if ('responseType' in xhr) xhr.responseType = self._mode;
    if ('withCredentials' in xhr) xhr.withCredentials = !!opts.withCredentials;
    if (self._mode === 'text' && 'overrideMimeType' in xhr) xhr.overrideMimeType('text/plain; charset=x-user-defined');

    if ('requestTimeout' in opts) {
      xhr.timeout = opts.requestTimeout;

      xhr.ontimeout = function () {
        self.emit('requestTimeout');
      };
    }

    headersList.forEach(function (header) {
      xhr.setRequestHeader(header[0], header[1]);
    });
    self._response = null;

    xhr.onreadystatechange = function () {
      switch (xhr.readyState) {
        case rStates.LOADING:
        case rStates.DONE:
          self._onXHRProgress();

          break;
      }
    }; // Necessary for streaming in Firefox, since xhr.response is ONLY defined
    // in onprogress, not in onreadystatechange with xhr.readyState = 3


    if (self._mode === 'moz-chunked-arraybuffer') {
      xhr.onprogress = function () {
        self._onXHRProgress();
      };
    }

    xhr.onerror = function () {
      if (self._destroyed) return;

      self._resetTimers(true);

      self.emit('error', new Error('XHR error'));
    };

    try {
      xhr.send(body);
    } catch (err) {
      process.nextTick(function () {
        self.emit('error', err);
      });
      return;
    }
  }
};
/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */


function statusValid(xhr) {
  try {
    var status = xhr.status;
    return status !== null && status !== 0;
  } catch (e) {
    return false;
  }
}

ClientRequest.prototype._onXHRProgress = function () {
  var self = this;

  self._resetTimers(false);

  if (!statusValid(self._xhr) || self._destroyed) return;
  if (!self._response) self._connect();

  self._response._onXHRProgress(self._resetTimers.bind(self));
};

ClientRequest.prototype._connect = function () {
  var self = this;
  if (self._destroyed) return;
  self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._resetTimers.bind(self));

  self._response.on('error', function (err) {
    self.emit('error', err);
  });

  self.emit('response', self._response);
};

ClientRequest.prototype._write = function (chunk, encoding, cb) {
  var self = this;

  self._body.push(chunk);

  cb();
};

ClientRequest.prototype._resetTimers = function (done) {
  var self = this;
  __webpack_require__.g.clearTimeout(self._socketTimer);
  self._socketTimer = null;

  if (done) {
    __webpack_require__.g.clearTimeout(self._fetchTimer);
    self._fetchTimer = null;
  } else if (self._socketTimeout) {
    self._socketTimer = __webpack_require__.g.setTimeout(function () {
      self.emit('timeout');
    }, self._socketTimeout);
  }
};

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function (err) {
  var self = this;
  self._destroyed = true;

  self._resetTimers(true);

  if (self._response) self._response._destroyed = true;
  if (self._xhr) self._xhr.abort();else if (self._fetchAbortController) self._fetchAbortController.abort();
  if (err) self.emit('error', err);
};

ClientRequest.prototype.end = function (data, encoding, cb) {
  var self = this;

  if (typeof data === 'function') {
    cb = data;
    data = undefined;
  }

  stream.Writable.prototype.end.call(self, data, encoding, cb);
};

ClientRequest.prototype.setTimeout = function (timeout, cb) {
  var self = this;
  if (cb) self.once('timeout', cb);
  self._socketTimeout = timeout;

  self._resetTimers(false);
};

ClientRequest.prototype.flushHeaders = function () {};

ClientRequest.prototype.setNoDelay = function () {};

ClientRequest.prototype.setSocketKeepAlive = function () {}; // Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method


var unsafeHeaders = ['accept-charset', 'accept-encoding', 'access-control-request-headers', 'access-control-request-method', 'connection', 'content-length', 'cookie', 'cookie2', 'date', 'dnt', 'expect', 'host', 'keep-alive', 'origin', 'referer', 'te', 'trailer', 'transfer-encoding', 'upgrade', 'via'];

/***/ }),

/***/ "./node_modules/stream-http/lib/response.js":
/*!**************************************************!*\
  !*** ./node_modules/stream-http/lib/response.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var capability = __webpack_require__(/*! ./capability */ "./node_modules/stream-http/lib/capability.js");

var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

var stream = __webpack_require__(/*! readable-stream */ "./node_modules/readable-stream/readable-browser.js");

var rStates = exports.readyStates = {
  UNSENT: 0,
  OPENED: 1,
  HEADERS_RECEIVED: 2,
  LOADING: 3,
  DONE: 4
};

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, resetTimers) {
  var self = this;
  stream.Readable.call(self);
  self._mode = mode;
  self.headers = {};
  self.rawHeaders = [];
  self.trailers = {};
  self.rawTrailers = []; // Fake the 'close' event, but only once 'end' fires

  self.on('end', function () {
    // The nextTick is necessary to prevent the 'request' module from causing an infinite loop
    process.nextTick(function () {
      self.emit('close');
    });
  });

  if (mode === 'fetch') {
    var read = function read() {
      reader.read().then(function (result) {
        if (self._destroyed) return;
        resetTimers(result.done);

        if (result.done) {
          self.push(null);
          return;
        }

        self.push(Buffer.from(result.value));
        read();
      })["catch"](function (err) {
        resetTimers(true);
        if (!self._destroyed) self.emit('error', err);
      });
    };

    self._fetchResponse = response;
    self.url = response.url;
    self.statusCode = response.status;
    self.statusMessage = response.statusText;
    response.headers.forEach(function (header, key) {
      self.headers[key.toLowerCase()] = header;
      self.rawHeaders.push(key, header);
    });

    if (capability.writableStream) {
      var writable = new WritableStream({
        write: function write(chunk) {
          resetTimers(false);
          return new Promise(function (resolve, reject) {
            if (self._destroyed) {
              reject();
            } else if (self.push(Buffer.from(chunk))) {
              resolve();
            } else {
              self._resumeFetch = resolve;
            }
          });
        },
        close: function close() {
          resetTimers(true);
          if (!self._destroyed) self.push(null);
        },
        abort: function abort(err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        }
      });

      try {
        response.body.pipeTo(writable)["catch"](function (err) {
          resetTimers(true);
          if (!self._destroyed) self.emit('error', err);
        });
        return;
      } catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this

    } // fallback for when writableStream or pipeTo aren't available


    var reader = response.body.getReader();
    read();
  } else {
    self._xhr = xhr;
    self._pos = 0;
    self.url = xhr.responseURL;
    self.statusCode = xhr.status;
    self.statusMessage = xhr.statusText;
    var headers = xhr.getAllResponseHeaders().split(/\r?\n/);
    headers.forEach(function (header) {
      var matches = header.match(/^([^:]+):\s*(.*)/);

      if (matches) {
        var key = matches[1].toLowerCase();

        if (key === 'set-cookie') {
          if (self.headers[key] === undefined) {
            self.headers[key] = [];
          }

          self.headers[key].push(matches[2]);
        } else if (self.headers[key] !== undefined) {
          self.headers[key] += ', ' + matches[2];
        } else {
          self.headers[key] = matches[2];
        }

        self.rawHeaders.push(matches[1], matches[2]);
      }
    });
    self._charset = 'x-user-defined';

    if (!capability.overrideMimeType) {
      var mimeType = self.rawHeaders['mime-type'];

      if (mimeType) {
        var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/);

        if (charsetMatch) {
          self._charset = charsetMatch[1].toLowerCase();
        }
      }

      if (!self._charset) self._charset = 'utf-8'; // best guess
    }
  }
};

inherits(IncomingMessage, stream.Readable);

IncomingMessage.prototype._read = function () {
  var self = this;
  var resolve = self._resumeFetch;

  if (resolve) {
    self._resumeFetch = null;
    resolve();
  }
};

IncomingMessage.prototype._onXHRProgress = function (resetTimers) {
  var self = this;
  var xhr = self._xhr;
  var response = null;

  switch (self._mode) {
    case 'text':
      response = xhr.responseText;

      if (response.length > self._pos) {
        var newData = response.substr(self._pos);

        if (self._charset === 'x-user-defined') {
          var buffer = Buffer.alloc(newData.length);

          for (var i = 0; i < newData.length; i++) {
            buffer[i] = newData.charCodeAt(i) & 0xff;
          }

          self.push(buffer);
        } else {
          self.push(newData, self._charset);
        }

        self._pos = response.length;
      }

      break;

    case 'arraybuffer':
      if (xhr.readyState !== rStates.DONE || !xhr.response) break;
      response = xhr.response;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'moz-chunked-arraybuffer':
      // take whole
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING || !response) break;
      self.push(Buffer.from(new Uint8Array(response)));
      break;

    case 'ms-stream':
      response = xhr.response;
      if (xhr.readyState !== rStates.LOADING) break;
      var reader = new __webpack_require__.g.MSStreamReader();

      reader.onprogress = function () {
        if (reader.result.byteLength > self._pos) {
          self.push(Buffer.from(new Uint8Array(reader.result.slice(self._pos))));
          self._pos = reader.result.byteLength;
        }
      };

      reader.onload = function () {
        resetTimers(true);
        self.push(null);
      }; // reader.onerror = ??? // TODO: this


      reader.readAsArrayBuffer(response);
      break;
  } // The ms-stream case handles end separately in reader.onload()


  if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
    resetTimers(true);
    self.push(null);
  }
};

/***/ }),

/***/ "./node_modules/string_decoder/lib/string_decoder.js":
/*!***********************************************************!*\
  !*** ./node_modules/string_decoder/lib/string_decoder.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

/*<replacement>*/

var Buffer = (__webpack_require__(/*! safe-buffer */ "./node_modules/safe-buffer/index.js").Buffer);
/*</replacement>*/


var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;

  switch (encoding && encoding.toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
    case 'raw':
      return true;

    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;

  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';

      case 'latin1':
      case 'binary':
        return 'latin1';

      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;

      default:
        if (retried) return; // undefined

        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
}

; // Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings

function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);

  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
} // StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.


exports.StringDecoder = StringDecoder;

function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;

  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;

    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;

    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;

    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }

  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;

  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }

  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End; // Returns only complete characters in a Buffer

StringDecoder.prototype.text = utf8Text; // Attempts to complete a partial non-UTF-8 character using bytes from a Buffer

StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
}; // Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.


function utf8CheckByte(_byte) {
  if (_byte <= 0x7F) return 0;else if (_byte >> 5 === 0x06) return 2;else if (_byte >> 4 === 0x0E) return 3;else if (_byte >> 3 === 0x1E) return 4;
  return _byte >> 6 === 0x02 ? -1 : -2;
} // Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.


function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }

  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);

  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }

    return nb;
  }

  return 0;
} // Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.


function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return "\uFFFD";
  }

  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return "\uFFFD";
    }

    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return "\uFFFD";
      }
    }
  }
} // Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.


function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;

  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }

  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
} // Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.


function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
} // For UTF-8, a replacement character is added when ending on a partial
// character.


function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + "\uFFFD";
  return r;
} // UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.


function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);

    if (r) {
      var c = r.charCodeAt(r.length - 1);

      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }

    return r;
  }

  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
} // For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.


function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';

  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }

  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;

  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }

  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
} // Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)


function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "./node_modules/url/node_modules/punycode/punycode.js":
/*!************************************************************!*\
  !*** ./node_modules/url/node_modules/punycode/punycode.js ***!
  \************************************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

/*! https://mths.be/punycode v1.3.2 by @mathias */
;

(function (root) {
  /** Detect free variables */
  var freeExports = ( false ? 0 : _typeof(exports)) == 'object' && exports && !exports.nodeType && exports;
  var freeModule = ( false ? 0 : _typeof(module)) == 'object' && module && !module.nodeType && module;
  var freeGlobal = (typeof __webpack_require__.g === "undefined" ? "undefined" : _typeof(__webpack_require__.g)) == 'object' && __webpack_require__.g;

  if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
    root = freeGlobal;
  }
  /**
   * The `punycode` object.
   * @name punycode
   * @type Object
   */


  var punycode,

  /** Highest positive signed 32-bit float value */
  maxInt = 2147483647,
      // aka. 0x7FFFFFFF or 2^31-1

  /** Bootstring parameters */
  base = 36,
      tMin = 1,
      tMax = 26,
      skew = 38,
      damp = 700,
      initialBias = 72,
      initialN = 128,
      // 0x80
  delimiter = '-',
      // '\x2D'

  /** Regular expressions */
  regexPunycode = /^xn--/,
      regexNonASCII = /[^\x20-\x7E]/,
      // unprintable ASCII chars + non-ASCII chars
  regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
      // RFC 3490 separators

  /** Error messages */
  errors = {
    'overflow': 'Overflow: input needs wider integers to process',
    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
    'invalid-input': 'Invalid input'
  },

  /** Convenience shortcuts */
  baseMinusTMin = base - tMin,
      floor = Math.floor,
      stringFromCharCode = String.fromCharCode,

  /** Temporary variable */
  key;
  /*--------------------------------------------------------------------------*/

  /**
   * A generic error utility function.
   * @private
   * @param {String} type The error type.
   * @returns {Error} Throws a `RangeError` with the applicable error message.
   */

  function error(type) {
    throw RangeError(errors[type]);
  }
  /**
   * A generic `Array#map` utility function.
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function that gets called for every array
   * item.
   * @returns {Array} A new array of values returned by the callback function.
   */


  function map(array, fn) {
    var length = array.length;
    var result = [];

    while (length--) {
      result[length] = fn(array[length]);
    }

    return result;
  }
  /**
   * A simple `Array#map`-like wrapper to work with domain name strings or email
   * addresses.
   * @private
   * @param {String} domain The domain name or email address.
   * @param {Function} callback The function that gets called for every
   * character.
   * @returns {Array} A new string of characters returned by the callback
   * function.
   */


  function mapDomain(string, fn) {
    var parts = string.split('@');
    var result = '';

    if (parts.length > 1) {
      // In email addresses, only the domain name should be punycoded. Leave
      // the local part (i.e. everything up to `@`) intact.
      result = parts[0] + '@';
      string = parts[1];
    } // Avoid `split(regex)` for IE8 compatibility. See #17.


    string = string.replace(regexSeparators, '\x2E');
    var labels = string.split('.');
    var encoded = map(labels, fn).join('.');
    return result + encoded;
  }
  /**
   * Creates an array containing the numeric code points of each Unicode
   * character in the string. While JavaScript uses UCS-2 internally,
   * this function will convert a pair of surrogate halves (each of which
   * UCS-2 exposes as separate characters) into a single code point,
   * matching UTF-16.
   * @see `punycode.ucs2.encode`
   * @see <https://mathiasbynens.be/notes/javascript-encoding>
   * @memberOf punycode.ucs2
   * @name decode
   * @param {String} string The Unicode input string (UCS-2).
   * @returns {Array} The new array of code points.
   */


  function ucs2decode(string) {
    var output = [],
        counter = 0,
        length = string.length,
        value,
        extra;

    while (counter < length) {
      value = string.charCodeAt(counter++);

      if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
        // high surrogate, and there is a next character
        extra = string.charCodeAt(counter++);

        if ((extra & 0xFC00) == 0xDC00) {
          // low surrogate
          output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
        } else {
          // unmatched surrogate; only append this code unit, in case the next
          // code unit is the high surrogate of a surrogate pair
          output.push(value);
          counter--;
        }
      } else {
        output.push(value);
      }
    }

    return output;
  }
  /**
   * Creates a string based on an array of numeric code points.
   * @see `punycode.ucs2.decode`
   * @memberOf punycode.ucs2
   * @name encode
   * @param {Array} codePoints The array of numeric code points.
   * @returns {String} The new Unicode string (UCS-2).
   */


  function ucs2encode(array) {
    return map(array, function (value) {
      var output = '';

      if (value > 0xFFFF) {
        value -= 0x10000;
        output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
        value = 0xDC00 | value & 0x3FF;
      }

      output += stringFromCharCode(value);
      return output;
    }).join('');
  }
  /**
   * Converts a basic code point into a digit/integer.
   * @see `digitToBasic()`
   * @private
   * @param {Number} codePoint The basic numeric code point value.
   * @returns {Number} The numeric value of a basic code point (for use in
   * representing integers) in the range `0` to `base - 1`, or `base` if
   * the code point does not represent a value.
   */


  function basicToDigit(codePoint) {
    if (codePoint - 48 < 10) {
      return codePoint - 22;
    }

    if (codePoint - 65 < 26) {
      return codePoint - 65;
    }

    if (codePoint - 97 < 26) {
      return codePoint - 97;
    }

    return base;
  }
  /**
   * Converts a digit/integer into a basic code point.
   * @see `basicToDigit()`
   * @private
   * @param {Number} digit The numeric value of a basic code point.
   * @returns {Number} The basic code point whose value (when used for
   * representing integers) is `digit`, which needs to be in the range
   * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
   * used; else, the lowercase form is used. The behavior is undefined
   * if `flag` is non-zero and `digit` has no uppercase form.
   */


  function digitToBasic(digit, flag) {
    //  0..25 map to ASCII a..z or A..Z
    // 26..35 map to ASCII 0..9
    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
  }
  /**
   * Bias adaptation function as per section 3.4 of RFC 3492.
   * http://tools.ietf.org/html/rfc3492#section-3.4
   * @private
   */


  function adapt(delta, numPoints, firstTime) {
    var k = 0;
    delta = firstTime ? floor(delta / damp) : delta >> 1;
    delta += floor(delta / numPoints);

    for (; delta > baseMinusTMin * tMax >> 1; k += base) {
      delta = floor(delta / baseMinusTMin);
    }

    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
  }
  /**
   * Converts a Punycode string of ASCII-only symbols to a string of Unicode
   * symbols.
   * @memberOf punycode
   * @param {String} input The Punycode string of ASCII-only symbols.
   * @returns {String} The resulting string of Unicode symbols.
   */


  function decode(input) {
    // Don't use UCS-2
    var output = [],
        inputLength = input.length,
        out,
        i = 0,
        n = initialN,
        bias = initialBias,
        basic,
        j,
        index,
        oldi,
        w,
        k,
        digit,
        t,

    /** Cached calculation results */
    baseMinusT; // Handle the basic code points: let `basic` be the number of input code
    // points before the last delimiter, or `0` if there is none, then copy
    // the first basic code points to the output.

    basic = input.lastIndexOf(delimiter);

    if (basic < 0) {
      basic = 0;
    }

    for (j = 0; j < basic; ++j) {
      // if it's not a basic code point
      if (input.charCodeAt(j) >= 0x80) {
        error('not-basic');
      }

      output.push(input.charCodeAt(j));
    } // Main decoding loop: start just after the last delimiter if any basic code
    // points were copied; start at the beginning otherwise.


    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) {
      // `index` is the index of the next character to be consumed.
      // Decode a generalized variable-length integer into `delta`,
      // which gets added to `i`. The overflow checking is easier
      // if we increase `i` as we go, then subtract off its starting
      // value at the end to obtain `delta`.
      for (oldi = i, w = 1, k = base;; k += base) {
        if (index >= inputLength) {
          error('invalid-input');
        }

        digit = basicToDigit(input.charCodeAt(index++));

        if (digit >= base || digit > floor((maxInt - i) / w)) {
          error('overflow');
        }

        i += digit * w;
        t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

        if (digit < t) {
          break;
        }

        baseMinusT = base - t;

        if (w > floor(maxInt / baseMinusT)) {
          error('overflow');
        }

        w *= baseMinusT;
      }

      out = output.length + 1;
      bias = adapt(i - oldi, out, oldi == 0); // `i` was supposed to wrap around from `out` to `0`,
      // incrementing `n` each time, so we'll fix that now:

      if (floor(i / out) > maxInt - n) {
        error('overflow');
      }

      n += floor(i / out);
      i %= out; // Insert `n` at position `i` of the output

      output.splice(i++, 0, n);
    }

    return ucs2encode(output);
  }
  /**
   * Converts a string of Unicode symbols (e.g. a domain name label) to a
   * Punycode string of ASCII-only symbols.
   * @memberOf punycode
   * @param {String} input The string of Unicode symbols.
   * @returns {String} The resulting Punycode string of ASCII-only symbols.
   */


  function encode(input) {
    var n,
        delta,
        handledCPCount,
        basicLength,
        bias,
        j,
        m,
        q,
        k,
        t,
        currentValue,
        output = [],

    /** `inputLength` will hold the number of code points in `input`. */
    inputLength,

    /** Cached calculation results */
    handledCPCountPlusOne,
        baseMinusT,
        qMinusT; // Convert the input in UCS-2 to Unicode

    input = ucs2decode(input); // Cache the length

    inputLength = input.length; // Initialize the state

    n = initialN;
    delta = 0;
    bias = initialBias; // Handle the basic code points

    for (j = 0; j < inputLength; ++j) {
      currentValue = input[j];

      if (currentValue < 0x80) {
        output.push(stringFromCharCode(currentValue));
      }
    }

    handledCPCount = basicLength = output.length; // `handledCPCount` is the number of code points that have been handled;
    // `basicLength` is the number of basic code points.
    // Finish the basic string - if it is not empty - with a delimiter

    if (basicLength) {
      output.push(delimiter);
    } // Main encoding loop:


    while (handledCPCount < inputLength) {
      // All non-basic code points < n have been handled already. Find the next
      // larger one:
      for (m = maxInt, j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue >= n && currentValue < m) {
          m = currentValue;
        }
      } // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
      // but guard against overflow


      handledCPCountPlusOne = handledCPCount + 1;

      if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
        error('overflow');
      }

      delta += (m - n) * handledCPCountPlusOne;
      n = m;

      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];

        if (currentValue < n && ++delta > maxInt) {
          error('overflow');
        }

        if (currentValue == n) {
          // Represent delta as a generalized variable-length integer
          for (q = delta, k = base;; k += base) {
            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

            if (q < t) {
              break;
            }

            qMinusT = q - t;
            baseMinusT = base - t;
            output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
            q = floor(qMinusT / baseMinusT);
          }

          output.push(stringFromCharCode(digitToBasic(q, 0)));
          bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
          delta = 0;
          ++handledCPCount;
        }
      }

      ++delta;
      ++n;
    }

    return output.join('');
  }
  /**
   * Converts a Punycode string representing a domain name or an email address
   * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
   * it doesn't matter if you call it on a string that has already been
   * converted to Unicode.
   * @memberOf punycode
   * @param {String} input The Punycoded domain name or email address to
   * convert to Unicode.
   * @returns {String} The Unicode representation of the given Punycode
   * string.
   */


  function toUnicode(input) {
    return mapDomain(input, function (string) {
      return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
    });
  }
  /**
   * Converts a Unicode string representing a domain name or an email address to
   * Punycode. Only the non-ASCII parts of the domain name will be converted,
   * i.e. it doesn't matter if you call it with a domain that's already in
   * ASCII.
   * @memberOf punycode
   * @param {String} input The domain name or email address to convert, as a
   * Unicode string.
   * @returns {String} The Punycode representation of the given domain name or
   * email address.
   */


  function toASCII(input) {
    return mapDomain(input, function (string) {
      return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
    });
  }
  /*--------------------------------------------------------------------------*/

  /** Define the public API */


  punycode = {
    /**
     * A string representing the current Punycode.js version number.
     * @memberOf punycode
     * @type String
     */
    'version': '1.3.2',

    /**
     * An object of methods to convert from JavaScript's internal character
     * representation (UCS-2) to Unicode code points, and back.
     * @see <https://mathiasbynens.be/notes/javascript-encoding>
     * @memberOf punycode
     * @type Object
     */
    'ucs2': {
      'decode': ucs2decode,
      'encode': ucs2encode
    },
    'decode': decode,
    'encode': encode,
    'toASCII': toASCII,
    'toUnicode': toUnicode
  };
  /** Expose `punycode` */
  // Some AMD build optimizers, like r.js, check for specific condition patterns
  // like the following:

  if ( true && _typeof(__webpack_require__.amdO) == 'object' && __webpack_require__.amdO) {
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
      return punycode;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else if (freeExports && freeModule) {
    if (module.exports == freeExports) {
      // in Node.js or RingoJS v0.8.0+
      freeModule.exports = punycode;
    } else {
      // in Narwhal or RingoJS v0.7.0-
      for (key in punycode) {
        punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
      }
    }
  } else {
    // in Rhino or a web browser
    root.punycode = punycode;
  }
})(this);

/***/ }),

/***/ "./node_modules/url/url.js":
/*!*********************************!*\
  !*** ./node_modules/url/url.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.


function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

var punycode = __webpack_require__(/*! punycode */ "./node_modules/url/node_modules/punycode/punycode.js");

var util = __webpack_require__(/*! ./util */ "./node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;
exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
} // Reference: RFC 3986, RFC 1808, RFC 2396
// define these here so at least they only have to be
// compiled once on the first module load.


var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,
    // Special case for a simple path URL
simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    // RFC 2396: characters reserved for delimiting URLs.
// We actually just auto-escape these.
delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],
    // RFC 2396: characters not allowed for various reasons.
unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),
    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
// Note that any invalid chars are also handled, but these
// are the ones that are *expected* to be seen, so we fast-path
// them.
nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
unsafeProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that never have a hostname.
hostlessProtocol = {
  'javascript': true,
  'javascript:': true
},
    // protocols that always contain a // bit.
slashedProtocol = {
  'http': true,
  'https': true,
  'ftp': true,
  'gopher': true,
  'file': true,
  'http:': true,
  'https:': true,
  'ftp:': true,
  'gopher:': true,
  'file:': true
},
    querystring = __webpack_require__(/*! querystring */ "./node_modules/querystring/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;
  var u = new Url();
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + _typeof(url));
  } // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916


  var queryIndex = url.indexOf('?'),
      splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);
  var rest = url; // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"

  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);

    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];

      if (simplePath[2]) {
        this.search = simplePath[2];

        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }

      return this;
    }
  }

  var proto = protocolPattern.exec(rest);

  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  } // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.


  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';

    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c
    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.
    // find the first instance of any hostEndingChars
    var hostEnd = -1;

    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.


    var auth, atSign;

    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    } // Now we have a portion which is definitely the auth.
    // Pull that off.


    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    } // the host is the remaining to the left of the first non-host char


    hostEnd = -1;

    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
    } // if we still have not hit it, then the entire thing is a host.


    if (hostEnd === -1) hostEnd = rest.length;
    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd); // pull out port.

    this.parseHost(); // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.

    this.hostname = this.hostname || ''; // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.

    var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']'; // validate a little.

    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);

      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;

        if (!part.match(hostnamePartPattern)) {
          var newpart = '';

          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          } // we test again with ASCII char only


          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);

            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }

            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }

            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host; // strip [ and ] from the hostname
    // the host field still retains them, though

    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);

      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  } // now rest is set to the post-host stuff.
  // chop off any delim chars.


  if (!unsafeProtocol[lowerProto]) {
    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1) continue;
      var esc = encodeURIComponent(ae);

      if (esc === ae) {
        esc = escape(ae);
      }

      rest = rest.split(ae).join(esc);
    }
  } // chop off from the tail first.


  var hash = rest.indexOf('#');

  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }

  var qm = rest.indexOf('?');

  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);

    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }

    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }

  if (rest) this.pathname = rest;

  if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
    this.pathname = '/';
  } //to support http.request


  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  } // finally, reconstruct the href based on what has been validated.


  this.href = this.format();
  return this;
}; // format a parsed object into a url string


function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function () {
  var auth = this.auth || '';

  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');

    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || query && '?' + query || '';
  if (protocol && protocol.substr(-1) !== ':') protocol += ':'; // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.

  if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;
  pathname = pathname.replace(/[?#]/g, function (match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');
  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function (relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function (relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);

  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  } // hash is always overridden, no matter what.
  // even href="" will remove it.


  result.hash = relative.hash; // if the relative url is empty, then there's nothing left to do here.

  if (relative.href === '') {
    result.href = result.format();
    return result;
  } // hrefs like //foo/bar always cut to the protocol.


  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);

    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol') result[rkey] = relative[rkey];
    } //urlParse appends trailing / to urls like http://www.example.com


    if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);

      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }

      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;

    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');

      while (relPath.length && !(relative.host = relPath.shift())) {
        ;
      }

      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }

    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port; // to support http.request

    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }

    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
      isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
      mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol]; // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.

  if (psychotic) {
    result.hostname = '';
    result.port = null;

    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
    }

    result.host = '';

    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;

      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
      }

      relative.host = null;
    }

    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = relative.host || relative.host === '' ? relative.host : result.host;
    result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath; // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift(); //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

      var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }

    result.search = relative.search;
    result.query = relative.query; //to support http.request

    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
    }

    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null; //to support http.request

    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }

    result.href = result.format();
    return result;
  } // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.


  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === ''; // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0

  var up = 0;

  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];

    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  } // if the path is allowed to go above the root, restore leading ..s


  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/'; // put the host back

  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : ''; //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')

    var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;

    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || result.host && srcPath.length;

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  } //to support request.http


  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
  }

  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function () {
  var host = this.host;
  var port = portPattern.exec(host);

  if (port) {
    port = port[0];

    if (port !== ':') {
      this.port = port.substr(1);
    }

    host = host.substr(0, host.length - port.length);
  }

  if (host) this.hostname = host;
};

/***/ }),

/***/ "./node_modules/url/util.js":
/*!**********************************!*\
  !*** ./node_modules/url/util.js ***!
  \**********************************/
/***/ ((module) => {



function _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }

module.exports = {
  isString: function isString(arg) {
    return typeof arg === 'string';
  },
  isObject: function isObject(arg) {
    return _typeof(arg) === 'object' && arg !== null;
  },
  isNull: function isNull(arg) {
    return arg === null;
  },
  isNullOrUndefined: function isNullOrUndefined(arg) {
    return arg == null;
  }
};

/***/ }),

/***/ "./node_modules/util-deprecate/browser.js":
/*!************************************************!*\
  !*** ./node_modules/util-deprecate/browser.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * Module exports.
 */
module.exports = deprecate;
/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate(fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;

  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }

      warned = true;
    }

    return fn.apply(this, arguments);
  }

  return deprecated;
}
/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */


function config(name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!__webpack_require__.g.localStorage) return false;
  } catch (_) {
    return false;
  }

  var val = __webpack_require__.g.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/***/ }),

/***/ "./node_modules/xtend/immutable.js":
/*!*****************************************!*\
  !*** ./node_modules/xtend/immutable.js ***!
  \*****************************************/
/***/ ((module) => {

module.exports = extend;
var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
  var target = {};

  for (var i = 0; i < arguments.length; i++) {
    var source = arguments[i];

    for (var key in source) {
      if (hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }

  return target;
}

/***/ }),

/***/ "./node_modules/axios/package.json":
/*!*****************************************!*\
  !*** ./node_modules/axios/package.json ***!
  \*****************************************/
/***/ ((module) => {

module.exports = JSON.parse('{"_from":"axios@^0.21.1","_id":"axios@0.21.4","_inBundle":false,"_integrity":"sha512-ut5vewkiu8jjGBdqpM44XxjuCjq9LAKeHVmoVfHVzy8eHgxxq8SbAVQNovDA8mVi05kP0Ea/n/UzcSHcTJQfNg==","_location":"/axios","_phantomChildren":{},"_requested":{"type":"range","registry":true,"raw":"axios@^0.21.1","name":"axios","escapedName":"axios","rawSpec":"^0.21.1","saveSpec":null,"fetchSpec":"^0.21.1"},"_requiredBy":["/"],"_resolved":"https://registry.npmjs.org/axios/-/axios-0.21.4.tgz","_shasum":"c67b90dc0568e5c1cf2b0b858c43ba28e2eda575","_spec":"axios@^0.21.1","_where":"C:\\\\xampp2\\\\htdocs\\\\FM-Wallet-Connector","author":{"name":"Matt Zabriskie"},"browser":{"./lib/adapters/http.js":"./lib/adapters/xhr.js"},"bugs":{"url":"https://github.com/axios/axios/issues"},"bundleDependencies":false,"bundlesize":[{"path":"./dist/axios.min.js","threshold":"5kB"}],"dependencies":{"follow-redirects":"^1.14.0"},"deprecated":false,"description":"Promise based HTTP client for the browser and node.js","devDependencies":{"coveralls":"^3.0.0","es6-promise":"^4.2.4","grunt":"^1.3.0","grunt-banner":"^0.6.0","grunt-cli":"^1.2.0","grunt-contrib-clean":"^1.1.0","grunt-contrib-watch":"^1.0.0","grunt-eslint":"^23.0.0","grunt-karma":"^4.0.0","grunt-mocha-test":"^0.13.3","grunt-ts":"^6.0.0-beta.19","grunt-webpack":"^4.0.2","istanbul-instrumenter-loader":"^1.0.0","jasmine-core":"^2.4.1","karma":"^6.3.2","karma-chrome-launcher":"^3.1.0","karma-firefox-launcher":"^2.1.0","karma-jasmine":"^1.1.1","karma-jasmine-ajax":"^0.1.13","karma-safari-launcher":"^1.0.0","karma-sauce-launcher":"^4.3.6","karma-sinon":"^1.0.5","karma-sourcemap-loader":"^0.3.8","karma-webpack":"^4.0.2","load-grunt-tasks":"^3.5.2","minimist":"^1.2.0","mocha":"^8.2.1","sinon":"^4.5.0","terser-webpack-plugin":"^4.2.3","typescript":"^4.0.5","url-search-params":"^0.10.0","webpack":"^4.44.2","webpack-dev-server":"^3.11.0"},"homepage":"https://axios-http.com","jsdelivr":"dist/axios.min.js","keywords":["xhr","http","ajax","promise","node"],"license":"MIT","main":"index.js","name":"axios","repository":{"type":"git","url":"git+https://github.com/axios/axios.git"},"scripts":{"build":"NODE_ENV=production grunt build","coveralls":"cat coverage/lcov.info | ./node_modules/coveralls/bin/coveralls.js","examples":"node ./examples/server.js","fix":"eslint --fix lib/**/*.js","postversion":"git push && git push --tags","preversion":"npm test","start":"node ./sandbox/server.js","test":"grunt test","version":"npm run build && grunt version && git add -A dist && git add CHANGELOG.md bower.json package.json"},"typings":"./index.d.ts","unpkg":"dist/axios.min.js","version":"0.21.4"}');

/***/ })

}])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfZW11cmdvX2NpcDE0LWpzX2luZGV4X2pzLW5vZGVfbW9kdWxlc19heGlvc19pbmRleF9qcy1ub2RlX21vZHVsZXNfZm9ybS1kLThhMTAxMi5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFhOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNiLElBQUlBLGVBQWUsR0FBSSxRQUFRLEtBQUtBLGVBQWQsSUFBa0MsVUFBVUMsR0FBVixFQUFlO0FBQ25FLFNBQVFBLEdBQUcsSUFBSUEsR0FBRyxDQUFDQyxVQUFaLEdBQTBCRCxHQUExQixHQUFnQztBQUFFLGVBQVdBO0FBQWIsR0FBdkM7QUFDSCxDQUZEOztBQUdBRSw4Q0FBNkM7QUFBRUcsRUFBQUEsS0FBSyxFQUFFO0FBQVQsQ0FBN0M7O0FBQ0EsSUFBTUMsU0FBUyxHQUFHUCxlQUFlLENBQUNRLG1CQUFPLENBQUMsZ0RBQUQsQ0FBUixDQUFqQzs7QUFDQSxJQUFNQyxRQUFRLEdBQUdELG1CQUFPLENBQUMsbURBQUQsQ0FBeEIsRUFDQTs7O0FBQ0EsSUFBTUUsSUFBSSxHQUFHLE9BQWI7O0lBQ01DO0FBQ0YsNEJBQVlDLE9BQVosRUFBcUI7QUFBQTs7QUFDakIsU0FBS0EsT0FBTCxHQUFlQSxPQUFmO0FBQ0g7Ozs7V0FtQkQsdUJBQWM7QUFDVixVQUFNQyxLQUFLLEdBQUdKLFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkMsT0FBaEIsQ0FBd0IsS0FBS0gsT0FBN0IsQ0FBZDtBQUNBLGFBQU9ILFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQkUsTUFBaEIsQ0FBdUJOLElBQXZCLEVBQTZCRyxLQUE3QixDQUFQO0FBQ0g7OztXQUNELGdCQUFPO0FBQ0gsYUFBT0ksTUFBTSxDQUFDQyxJQUFQLENBQVksS0FBS04sT0FBakIsRUFBMEJPLFFBQTFCLENBQW1DLEtBQW5DLENBQVA7QUFDSDs7O1dBQ0Qsa0JBQVM7QUFDTCxhQUFPVCxJQUFQO0FBQ0gsTUFDRDs7OztXQUNBLG9CQUFXO0FBQ1AsYUFBTyxLQUFLVSxXQUFMLEdBQW1CQyxLQUFuQixDQUF5QixDQUFDLENBQTFCLENBQVA7QUFDSDs7O1dBL0JELGtCQUFnQkMsSUFBaEIsRUFBc0I7QUFDbEIsYUFBTyxJQUFJWCxnQkFBSixDQUFxQlcsSUFBckIsQ0FBUDtBQUNIOzs7V0FDRCxtQkFBaUJDLFFBQWpCLEVBQTJCQyxTQUEzQixFQUFzQztBQUNsQztBQUNBLFVBQU1aLE9BQU8sR0FBRyxDQUFDLEdBQUdMLFNBQVMsV0FBYixFQUF1QixFQUF2QixFQUNYa0IsTUFEVyxDQUNKLElBQUlDLFVBQUosOEJBQW1CSCxRQUFuQixzQkFBZ0NDLFNBQWhDLEdBREksRUFFWEcsTUFGVyxDQUVKLFFBRkksQ0FBaEI7QUFHQSxhQUFPaEIsZ0JBQWdCLENBQUNpQixRQUFqQixDQUEwQmhCLE9BQTFCLENBQVA7QUFDSDs7O1dBQ0Qsb0JBQWtCUSxXQUFsQixFQUErQjtBQUMzQixrQ0FBMEJYLFFBQVEsQ0FBQ0ssTUFBVCxDQUFnQmUsTUFBaEIsQ0FBdUJULFdBQXZCLENBQTFCO0FBQUEsVUFBUVUsTUFBUix5QkFBUUEsTUFBUjtBQUFBLFVBQWdCakIsS0FBaEIseUJBQWdCQSxLQUFoQjs7QUFDQSxVQUFJaUIsTUFBTSxLQUFLcEIsSUFBZixFQUFxQjtBQUNqQixjQUFNLElBQUlxQixLQUFKLENBQVUsMkJBQVYsQ0FBTjtBQUNIOztBQUNELFVBQU1uQixPQUFPLEdBQUdLLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZVCxRQUFRLENBQUNLLE1BQVQsQ0FBZ0JrQixTQUFoQixDQUEwQm5CLEtBQTFCLENBQVosQ0FBaEI7QUFDQSxhQUFPRixnQkFBZ0IsQ0FBQ2lCLFFBQWpCLENBQTBCaEIsT0FBMUIsQ0FBUDtBQUNIOzs7Ozs7QUFnQkxQLGtCQUFBLEdBQWtCTSxnQkFBbEI7Ozs7Ozs7Ozs7QUM5Q0FzQiw0RkFBQTs7Ozs7Ozs7OztBQ0FhOztBQUViLElBQUlDLEtBQUssR0FBRzFCLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7O0FBQ0EsSUFBSTJCLE1BQU0sR0FBRzNCLG1CQUFPLENBQUMsaUVBQUQsQ0FBcEI7O0FBQ0EsSUFBSTRCLE9BQU8sR0FBRzVCLG1CQUFPLENBQUMseUVBQUQsQ0FBckI7O0FBQ0EsSUFBSTZCLFFBQVEsR0FBRzdCLG1CQUFPLENBQUMsMkVBQUQsQ0FBdEI7O0FBQ0EsSUFBSThCLGFBQWEsR0FBRzlCLG1CQUFPLENBQUMsNkVBQUQsQ0FBM0I7O0FBQ0EsSUFBSStCLFlBQVksR0FBRy9CLG1CQUFPLENBQUMsbUZBQUQsQ0FBMUI7O0FBQ0EsSUFBSWdDLGVBQWUsR0FBR2hDLG1CQUFPLENBQUMseUZBQUQsQ0FBN0I7O0FBQ0EsSUFBSWlDLFdBQVcsR0FBR2pDLG1CQUFPLENBQUMseUVBQUQsQ0FBekI7O0FBRUF5QixNQUFNLENBQUM1QixPQUFQLEdBQWlCLFNBQVNxQyxVQUFULENBQW9CQyxNQUFwQixFQUE0QjtBQUMzQyxTQUFPLElBQUlDLE9BQUosQ0FBWSxTQUFTQyxrQkFBVCxDQUE0QkMsT0FBNUIsRUFBcUNDLE1BQXJDLEVBQTZDO0FBQzlELFFBQUlDLFdBQVcsR0FBR0wsTUFBTSxDQUFDTSxJQUF6QjtBQUNBLFFBQUlDLGNBQWMsR0FBR1AsTUFBTSxDQUFDUSxPQUE1QjtBQUNBLFFBQUlDLFlBQVksR0FBR1QsTUFBTSxDQUFDUyxZQUExQjs7QUFFQSxRQUFJbEIsS0FBSyxDQUFDbUIsVUFBTixDQUFpQkwsV0FBakIsQ0FBSixFQUFtQztBQUNqQyxhQUFPRSxjQUFjLENBQUMsY0FBRCxDQUFyQixDQURpQyxDQUNNO0FBQ3hDOztBQUVELFFBQUlJLE9BQU8sR0FBRyxJQUFJQyxjQUFKLEVBQWQsQ0FUOEQsQ0FXOUQ7O0FBQ0EsUUFBSVosTUFBTSxDQUFDYSxJQUFYLEVBQWlCO0FBQ2YsVUFBSUMsUUFBUSxHQUFHZCxNQUFNLENBQUNhLElBQVAsQ0FBWUMsUUFBWixJQUF3QixFQUF2QztBQUNBLFVBQUlDLFFBQVEsR0FBR2YsTUFBTSxDQUFDYSxJQUFQLENBQVlFLFFBQVosR0FBdUJDLFFBQVEsQ0FBQ0Msa0JBQWtCLENBQUNqQixNQUFNLENBQUNhLElBQVAsQ0FBWUUsUUFBYixDQUFuQixDQUEvQixHQUE0RSxFQUEzRjtBQUNBUixNQUFBQSxjQUFjLENBQUNXLGFBQWYsR0FBK0IsV0FBV0MsSUFBSSxDQUFDTCxRQUFRLEdBQUcsR0FBWCxHQUFpQkMsUUFBbEIsQ0FBOUM7QUFDRDs7QUFFRCxRQUFJSyxRQUFRLEdBQUd6QixhQUFhLENBQUNLLE1BQU0sQ0FBQ3FCLE9BQVIsRUFBaUJyQixNQUFNLENBQUNzQixHQUF4QixDQUE1QjtBQUNBWCxJQUFBQSxPQUFPLENBQUNZLElBQVIsQ0FBYXZCLE1BQU0sQ0FBQ3dCLE1BQVAsQ0FBY0MsV0FBZCxFQUFiLEVBQTBDL0IsUUFBUSxDQUFDMEIsUUFBRCxFQUFXcEIsTUFBTSxDQUFDMEIsTUFBbEIsRUFBMEIxQixNQUFNLENBQUMyQixnQkFBakMsQ0FBbEQsRUFBc0csSUFBdEcsRUFuQjhELENBcUI5RDs7QUFDQWhCLElBQUFBLE9BQU8sQ0FBQ2lCLE9BQVIsR0FBa0I1QixNQUFNLENBQUM0QixPQUF6Qjs7QUFFQSxhQUFTQyxTQUFULEdBQXFCO0FBQ25CLFVBQUksQ0FBQ2xCLE9BQUwsRUFBYztBQUNaO0FBQ0QsT0FIa0IsQ0FJbkI7OztBQUNBLFVBQUltQixlQUFlLEdBQUcsMkJBQTJCbkIsT0FBM0IsR0FBcUNmLFlBQVksQ0FBQ2UsT0FBTyxDQUFDb0IscUJBQVIsRUFBRCxDQUFqRCxHQUFxRixJQUEzRztBQUNBLFVBQUlDLFlBQVksR0FBRyxDQUFDdkIsWUFBRCxJQUFpQkEsWUFBWSxLQUFLLE1BQWxDLElBQTZDQSxZQUFZLEtBQUssTUFBOUQsR0FDakJFLE9BQU8sQ0FBQ3NCLFlBRFMsR0FDTXRCLE9BQU8sQ0FBQ3VCLFFBRGpDO0FBRUEsVUFBSUEsUUFBUSxHQUFHO0FBQ2I1QixRQUFBQSxJQUFJLEVBQUUwQixZQURPO0FBRWJHLFFBQUFBLE1BQU0sRUFBRXhCLE9BQU8sQ0FBQ3dCLE1BRkg7QUFHYkMsUUFBQUEsVUFBVSxFQUFFekIsT0FBTyxDQUFDeUIsVUFIUDtBQUliNUIsUUFBQUEsT0FBTyxFQUFFc0IsZUFKSTtBQUtiOUIsUUFBQUEsTUFBTSxFQUFFQSxNQUxLO0FBTWJXLFFBQUFBLE9BQU8sRUFBRUE7QUFOSSxPQUFmO0FBU0FuQixNQUFBQSxNQUFNLENBQUNXLE9BQUQsRUFBVUMsTUFBVixFQUFrQjhCLFFBQWxCLENBQU4sQ0FqQm1CLENBbUJuQjs7QUFDQXZCLE1BQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0Q7O0FBRUQsUUFBSSxlQUFlQSxPQUFuQixFQUE0QjtBQUMxQjtBQUNBQSxNQUFBQSxPQUFPLENBQUNrQixTQUFSLEdBQW9CQSxTQUFwQjtBQUNELEtBSEQsTUFHTztBQUNMO0FBQ0FsQixNQUFBQSxPQUFPLENBQUMwQixrQkFBUixHQUE2QixTQUFTQyxVQUFULEdBQXNCO0FBQ2pELFlBQUksQ0FBQzNCLE9BQUQsSUFBWUEsT0FBTyxDQUFDNEIsVUFBUixLQUF1QixDQUF2QyxFQUEwQztBQUN4QztBQUNELFNBSGdELENBS2pEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxZQUFJNUIsT0FBTyxDQUFDd0IsTUFBUixLQUFtQixDQUFuQixJQUF3QixFQUFFeEIsT0FBTyxDQUFDNkIsV0FBUixJQUF1QjdCLE9BQU8sQ0FBQzZCLFdBQVIsQ0FBb0JDLE9BQXBCLENBQTRCLE9BQTVCLE1BQXlDLENBQWxFLENBQTVCLEVBQWtHO0FBQ2hHO0FBQ0QsU0FYZ0QsQ0FZakQ7QUFDQTs7O0FBQ0FDLFFBQUFBLFVBQVUsQ0FBQ2IsU0FBRCxDQUFWO0FBQ0QsT0FmRDtBQWdCRCxLQXBFNkQsQ0FzRTlEOzs7QUFDQWxCLElBQUFBLE9BQU8sQ0FBQ2dDLE9BQVIsR0FBa0IsU0FBU0MsV0FBVCxHQUF1QjtBQUN2QyxVQUFJLENBQUNqQyxPQUFMLEVBQWM7QUFDWjtBQUNEOztBQUVEUCxNQUFBQSxNQUFNLENBQUNOLFdBQVcsQ0FBQyxpQkFBRCxFQUFvQkUsTUFBcEIsRUFBNEIsY0FBNUIsRUFBNENXLE9BQTVDLENBQVosQ0FBTixDQUx1QyxDQU92Qzs7QUFDQUEsTUFBQUEsT0FBTyxHQUFHLElBQVY7QUFDRCxLQVRELENBdkU4RCxDQWtGOUQ7OztBQUNBQSxJQUFBQSxPQUFPLENBQUNrQyxPQUFSLEdBQWtCLFNBQVNDLFdBQVQsR0FBdUI7QUFDdkM7QUFDQTtBQUNBMUMsTUFBQUEsTUFBTSxDQUFDTixXQUFXLENBQUMsZUFBRCxFQUFrQkUsTUFBbEIsRUFBMEIsSUFBMUIsRUFBZ0NXLE9BQWhDLENBQVosQ0FBTixDQUh1QyxDQUt2Qzs7QUFDQUEsTUFBQUEsT0FBTyxHQUFHLElBQVY7QUFDRCxLQVBELENBbkY4RCxDQTRGOUQ7OztBQUNBQSxJQUFBQSxPQUFPLENBQUNvQyxTQUFSLEdBQW9CLFNBQVNDLGFBQVQsR0FBeUI7QUFDM0MsVUFBSUMsbUJBQW1CLEdBQUcsZ0JBQWdCakQsTUFBTSxDQUFDNEIsT0FBdkIsR0FBaUMsYUFBM0Q7O0FBQ0EsVUFBSTVCLE1BQU0sQ0FBQ2lELG1CQUFYLEVBQWdDO0FBQzlCQSxRQUFBQSxtQkFBbUIsR0FBR2pELE1BQU0sQ0FBQ2lELG1CQUE3QjtBQUNEOztBQUNEN0MsTUFBQUEsTUFBTSxDQUFDTixXQUFXLENBQ2hCbUQsbUJBRGdCLEVBRWhCakQsTUFGZ0IsRUFHaEJBLE1BQU0sQ0FBQ2tELFlBQVAsSUFBdUJsRCxNQUFNLENBQUNrRCxZQUFQLENBQW9CQyxtQkFBM0MsR0FBaUUsV0FBakUsR0FBK0UsY0FIL0QsRUFJaEJ4QyxPQUpnQixDQUFaLENBQU4sQ0FMMkMsQ0FXM0M7O0FBQ0FBLE1BQUFBLE9BQU8sR0FBRyxJQUFWO0FBQ0QsS0FiRCxDQTdGOEQsQ0E0RzlEO0FBQ0E7QUFDQTs7O0FBQ0EsUUFBSXBCLEtBQUssQ0FBQzZELG9CQUFOLEVBQUosRUFBa0M7QUFDaEM7QUFDQSxVQUFJQyxTQUFTLEdBQUcsQ0FBQ3JELE1BQU0sQ0FBQ3NELGVBQVAsSUFBMEJ6RCxlQUFlLENBQUN1QixRQUFELENBQTFDLEtBQXlEcEIsTUFBTSxDQUFDdUQsY0FBaEUsR0FDZDlELE9BQU8sQ0FBQytELElBQVIsQ0FBYXhELE1BQU0sQ0FBQ3VELGNBQXBCLENBRGMsR0FFZEUsU0FGRjs7QUFJQSxVQUFJSixTQUFKLEVBQWU7QUFDYjlDLFFBQUFBLGNBQWMsQ0FBQ1AsTUFBTSxDQUFDMEQsY0FBUixDQUFkLEdBQXdDTCxTQUF4QztBQUNEO0FBQ0YsS0F4SDZELENBMEg5RDs7O0FBQ0EsUUFBSSxzQkFBc0IxQyxPQUExQixFQUFtQztBQUNqQ3BCLE1BQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBY3BELGNBQWQsRUFBOEIsU0FBU3FELGdCQUFULENBQTBCQyxHQUExQixFQUErQkMsR0FBL0IsRUFBb0M7QUFDaEUsWUFBSSxPQUFPekQsV0FBUCxLQUF1QixXQUF2QixJQUFzQ3lELEdBQUcsQ0FBQ0MsV0FBSixPQUFzQixjQUFoRSxFQUFnRjtBQUM5RTtBQUNBLGlCQUFPeEQsY0FBYyxDQUFDdUQsR0FBRCxDQUFyQjtBQUNELFNBSEQsTUFHTztBQUNMO0FBQ0FuRCxVQUFBQSxPQUFPLENBQUNpRCxnQkFBUixDQUF5QkUsR0FBekIsRUFBOEJELEdBQTlCO0FBQ0Q7QUFDRixPQVJEO0FBU0QsS0FySTZELENBdUk5RDs7O0FBQ0EsUUFBSSxDQUFDdEUsS0FBSyxDQUFDeUUsV0FBTixDQUFrQmhFLE1BQU0sQ0FBQ3NELGVBQXpCLENBQUwsRUFBZ0Q7QUFDOUMzQyxNQUFBQSxPQUFPLENBQUMyQyxlQUFSLEdBQTBCLENBQUMsQ0FBQ3RELE1BQU0sQ0FBQ3NELGVBQW5DO0FBQ0QsS0ExSTZELENBNEk5RDs7O0FBQ0EsUUFBSTdDLFlBQVksSUFBSUEsWUFBWSxLQUFLLE1BQXJDLEVBQTZDO0FBQzNDRSxNQUFBQSxPQUFPLENBQUNGLFlBQVIsR0FBdUJULE1BQU0sQ0FBQ1MsWUFBOUI7QUFDRCxLQS9JNkQsQ0FpSjlEOzs7QUFDQSxRQUFJLE9BQU9ULE1BQU0sQ0FBQ2lFLGtCQUFkLEtBQXFDLFVBQXpDLEVBQXFEO0FBQ25EdEQsTUFBQUEsT0FBTyxDQUFDdUQsZ0JBQVIsQ0FBeUIsVUFBekIsRUFBcUNsRSxNQUFNLENBQUNpRSxrQkFBNUM7QUFDRCxLQXBKNkQsQ0FzSjlEOzs7QUFDQSxRQUFJLE9BQU9qRSxNQUFNLENBQUNtRSxnQkFBZCxLQUFtQyxVQUFuQyxJQUFpRHhELE9BQU8sQ0FBQ3lELE1BQTdELEVBQXFFO0FBQ25FekQsTUFBQUEsT0FBTyxDQUFDeUQsTUFBUixDQUFlRixnQkFBZixDQUFnQyxVQUFoQyxFQUE0Q2xFLE1BQU0sQ0FBQ21FLGdCQUFuRDtBQUNEOztBQUVELFFBQUluRSxNQUFNLENBQUNxRSxXQUFYLEVBQXdCO0FBQ3RCO0FBQ0FyRSxNQUFBQSxNQUFNLENBQUNxRSxXQUFQLENBQW1CQyxPQUFuQixDQUEyQkMsSUFBM0IsQ0FBZ0MsU0FBU0MsVUFBVCxDQUFvQkMsTUFBcEIsRUFBNEI7QUFDMUQsWUFBSSxDQUFDOUQsT0FBTCxFQUFjO0FBQ1o7QUFDRDs7QUFFREEsUUFBQUEsT0FBTyxDQUFDK0QsS0FBUjtBQUNBdEUsUUFBQUEsTUFBTSxDQUFDcUUsTUFBRCxDQUFOLENBTjBELENBTzFEOztBQUNBOUQsUUFBQUEsT0FBTyxHQUFHLElBQVY7QUFDRCxPQVREO0FBVUQ7O0FBRUQsUUFBSSxDQUFDTixXQUFMLEVBQWtCO0FBQ2hCQSxNQUFBQSxXQUFXLEdBQUcsSUFBZDtBQUNELEtBM0s2RCxDQTZLOUQ7OztBQUNBTSxJQUFBQSxPQUFPLENBQUNnRSxJQUFSLENBQWF0RSxXQUFiO0FBQ0QsR0EvS00sQ0FBUDtBQWdMRCxDQWpMRDs7Ozs7Ozs7OztBQ1hhOztBQUViLElBQUlkLEtBQUssR0FBRzFCLG1CQUFPLENBQUMsa0RBQUQsQ0FBbkI7O0FBQ0EsSUFBSStHLElBQUksR0FBRy9HLG1CQUFPLENBQUMsZ0VBQUQsQ0FBbEI7O0FBQ0EsSUFBSWdILEtBQUssR0FBR2hILG1CQUFPLENBQUMsNERBQUQsQ0FBbkI7O0FBQ0EsSUFBSWlILFdBQVcsR0FBR2pILG1CQUFPLENBQUMsd0VBQUQsQ0FBekI7O0FBQ0EsSUFBSWtILFFBQVEsR0FBR2xILG1CQUFPLENBQUMsd0RBQUQsQ0FBdEI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNtSCxjQUFULENBQXdCQyxhQUF4QixFQUF1QztBQUNyQyxNQUFJQyxPQUFPLEdBQUcsSUFBSUwsS0FBSixDQUFVSSxhQUFWLENBQWQ7QUFDQSxNQUFJRSxRQUFRLEdBQUdQLElBQUksQ0FBQ0MsS0FBSyxDQUFDTyxTQUFOLENBQWdCekUsT0FBakIsRUFBMEJ1RSxPQUExQixDQUFuQixDQUZxQyxDQUlyQzs7QUFDQTNGLEVBQUFBLEtBQUssQ0FBQzhGLE1BQU4sQ0FBYUYsUUFBYixFQUF1Qk4sS0FBSyxDQUFDTyxTQUE3QixFQUF3Q0YsT0FBeEMsRUFMcUMsQ0FPckM7O0FBQ0EzRixFQUFBQSxLQUFLLENBQUM4RixNQUFOLENBQWFGLFFBQWIsRUFBdUJELE9BQXZCO0FBRUEsU0FBT0MsUUFBUDtBQUNELEVBRUQ7OztBQUNBLElBQUlHLEtBQUssR0FBR04sY0FBYyxDQUFDRCxRQUFELENBQTFCLEVBRUE7O0FBQ0FPLEtBQUssQ0FBQ1QsS0FBTixHQUFjQSxLQUFkLEVBRUE7O0FBQ0FTLEtBQUssQ0FBQ0MsTUFBTixHQUFlLFNBQVNBLE1BQVQsQ0FBZ0JDLGNBQWhCLEVBQWdDO0FBQzdDLFNBQU9SLGNBQWMsQ0FBQ0YsV0FBVyxDQUFDUSxLQUFLLENBQUNQLFFBQVAsRUFBaUJTLGNBQWpCLENBQVosQ0FBckI7QUFDRCxDQUZELEVBSUE7OztBQUNBRixLQUFLLENBQUNHLE1BQU4sR0FBZTVILG1CQUFPLENBQUMsa0VBQUQsQ0FBdEI7QUFDQXlILEtBQUssQ0FBQ0ksV0FBTixHQUFvQjdILG1CQUFPLENBQUMsNEVBQUQsQ0FBM0I7QUFDQXlILEtBQUssQ0FBQ0ssUUFBTixHQUFpQjlILG1CQUFPLENBQUMsc0VBQUQsQ0FBeEIsRUFFQTs7QUFDQXlILEtBQUssQ0FBQ00sR0FBTixHQUFZLFNBQVNBLEdBQVQsQ0FBYUMsUUFBYixFQUF1QjtBQUNqQyxTQUFPNUYsT0FBTyxDQUFDMkYsR0FBUixDQUFZQyxRQUFaLENBQVA7QUFDRCxDQUZEOztBQUdBUCxLQUFLLENBQUNRLE1BQU4sR0FBZWpJLG1CQUFPLENBQUMsb0VBQUQsQ0FBdEIsRUFFQTs7QUFDQXlILEtBQUssQ0FBQ1MsWUFBTixHQUFxQmxJLG1CQUFPLENBQUMsZ0ZBQUQsQ0FBNUI7QUFFQXlCLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUI0SCxLQUFqQixFQUVBOztBQUNBaEcseUJBQUEsR0FBeUJnRyxLQUF6Qjs7Ozs7Ozs7OztBQ3ZEYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTRyxNQUFULENBQWdCTyxPQUFoQixFQUF5QjtBQUN2QixPQUFLQSxPQUFMLEdBQWVBLE9BQWY7QUFDRDs7QUFFRFAsTUFBTSxDQUFDTCxTQUFQLENBQWlCNUcsUUFBakIsR0FBNEIsU0FBU0EsUUFBVCxHQUFvQjtBQUM5QyxTQUFPLFlBQVksS0FBS3dILE9BQUwsR0FBZSxPQUFPLEtBQUtBLE9BQTNCLEdBQXFDLEVBQWpELENBQVA7QUFDRCxDQUZEOztBQUlBUCxNQUFNLENBQUNMLFNBQVAsQ0FBaUJhLFVBQWpCLEdBQThCLElBQTlCO0FBRUEzRyxNQUFNLENBQUM1QixPQUFQLEdBQWlCK0gsTUFBakI7Ozs7Ozs7Ozs7QUNsQmE7O0FBRWIsSUFBSUEsTUFBTSxHQUFHNUgsbUJBQU8sQ0FBQywyREFBRCxDQUFwQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzZILFdBQVQsQ0FBcUJRLFFBQXJCLEVBQStCO0FBQzdCLE1BQUksT0FBT0EsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQyxVQUFNLElBQUlDLFNBQUosQ0FBYyw4QkFBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSUMsY0FBSjtBQUNBLE9BQUs5QixPQUFMLEdBQWUsSUFBSXJFLE9BQUosQ0FBWSxTQUFTb0csZUFBVCxDQUF5QmxHLE9BQXpCLEVBQWtDO0FBQzNEaUcsSUFBQUEsY0FBYyxHQUFHakcsT0FBakI7QUFDRCxHQUZjLENBQWY7QUFJQSxNQUFJbUcsS0FBSyxHQUFHLElBQVo7QUFDQUosRUFBQUEsUUFBUSxDQUFDLFNBQVN6QixNQUFULENBQWdCdUIsT0FBaEIsRUFBeUI7QUFDaEMsUUFBSU0sS0FBSyxDQUFDQyxNQUFWLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDRDs7QUFFREQsSUFBQUEsS0FBSyxDQUFDQyxNQUFOLEdBQWUsSUFBSWQsTUFBSixDQUFXTyxPQUFYLENBQWY7QUFDQUksSUFBQUEsY0FBYyxDQUFDRSxLQUFLLENBQUNDLE1BQVAsQ0FBZDtBQUNELEdBUk8sQ0FBUjtBQVNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQWIsV0FBVyxDQUFDTixTQUFaLENBQXNCb0IsZ0JBQXRCLEdBQXlDLFNBQVNBLGdCQUFULEdBQTRCO0FBQ25FLE1BQUksS0FBS0QsTUFBVCxFQUFpQjtBQUNmLFVBQU0sS0FBS0EsTUFBWDtBQUNEO0FBQ0YsQ0FKRDtBQU1BO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQWIsV0FBVyxDQUFDZSxNQUFaLEdBQXFCLFNBQVNBLE1BQVQsR0FBa0I7QUFDckMsTUFBSWhDLE1BQUo7QUFDQSxNQUFJNkIsS0FBSyxHQUFHLElBQUlaLFdBQUosQ0FBZ0IsU0FBU1EsUUFBVCxDQUFrQlEsQ0FBbEIsRUFBcUI7QUFDL0NqQyxJQUFBQSxNQUFNLEdBQUdpQyxDQUFUO0FBQ0QsR0FGVyxDQUFaO0FBR0EsU0FBTztBQUNMSixJQUFBQSxLQUFLLEVBQUVBLEtBREY7QUFFTDdCLElBQUFBLE1BQU0sRUFBRUE7QUFGSCxHQUFQO0FBSUQsQ0FURDs7QUFXQW5GLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUJnSSxXQUFqQjs7Ozs7Ozs7OztBQ3hEYTs7QUFFYnBHLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBU2lJLFFBQVQsQ0FBa0JoSSxLQUFsQixFQUF5QjtBQUN4QyxTQUFPLENBQUMsRUFBRUEsS0FBSyxJQUFJQSxLQUFLLENBQUNzSSxVQUFqQixDQUFSO0FBQ0QsQ0FGRDs7Ozs7Ozs7OztBQ0ZhOztBQUViLElBQUkxRyxLQUFLLEdBQUcxQixtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUNBLElBQUk2QixRQUFRLEdBQUc3QixtQkFBTyxDQUFDLHlFQUFELENBQXRCOztBQUNBLElBQUk4SSxrQkFBa0IsR0FBRzlJLG1CQUFPLENBQUMsaUZBQUQsQ0FBaEM7O0FBQ0EsSUFBSStJLGVBQWUsR0FBRy9JLG1CQUFPLENBQUMsMkVBQUQsQ0FBN0I7O0FBQ0EsSUFBSWlILFdBQVcsR0FBR2pILG1CQUFPLENBQUMsbUVBQUQsQ0FBekI7O0FBQ0EsSUFBSWdKLFNBQVMsR0FBR2hKLG1CQUFPLENBQUMsMkVBQUQsQ0FBdkI7O0FBRUEsSUFBSWlKLFVBQVUsR0FBR0QsU0FBUyxDQUFDQyxVQUEzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsU0FBU2pDLEtBQVQsQ0FBZVcsY0FBZixFQUErQjtBQUM3QixPQUFLVCxRQUFMLEdBQWdCUyxjQUFoQjtBQUNBLE9BQUt1QixZQUFMLEdBQW9CO0FBQ2xCcEcsSUFBQUEsT0FBTyxFQUFFLElBQUlnRyxrQkFBSixFQURTO0FBRWxCekUsSUFBQUEsUUFBUSxFQUFFLElBQUl5RSxrQkFBSjtBQUZRLEdBQXBCO0FBSUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQTlCLEtBQUssQ0FBQ08sU0FBTixDQUFnQnpFLE9BQWhCLEdBQTBCLFNBQVNBLE9BQVQsQ0FBaUJYLE1BQWpCLEVBQXlCO0FBQ2pEO0FBQ0E7QUFDQSxNQUFJLE9BQU9BLE1BQVAsS0FBa0IsUUFBdEIsRUFBZ0M7QUFDOUJBLElBQUFBLE1BQU0sR0FBR2dILFNBQVMsQ0FBQyxDQUFELENBQVQsSUFBZ0IsRUFBekI7QUFDQWhILElBQUFBLE1BQU0sQ0FBQ3NCLEdBQVAsR0FBYTBGLFNBQVMsQ0FBQyxDQUFELENBQXRCO0FBQ0QsR0FIRCxNQUdPO0FBQ0xoSCxJQUFBQSxNQUFNLEdBQUdBLE1BQU0sSUFBSSxFQUFuQjtBQUNEOztBQUVEQSxFQUFBQSxNQUFNLEdBQUc4RSxXQUFXLENBQUMsS0FBS0MsUUFBTixFQUFnQi9FLE1BQWhCLENBQXBCLENBVmlELENBWWpEOztBQUNBLE1BQUlBLE1BQU0sQ0FBQ3dCLE1BQVgsRUFBbUI7QUFDakJ4QixJQUFBQSxNQUFNLENBQUN3QixNQUFQLEdBQWdCeEIsTUFBTSxDQUFDd0IsTUFBUCxDQUFjdUMsV0FBZCxFQUFoQjtBQUNELEdBRkQsTUFFTyxJQUFJLEtBQUtnQixRQUFMLENBQWN2RCxNQUFsQixFQUEwQjtBQUMvQnhCLElBQUFBLE1BQU0sQ0FBQ3dCLE1BQVAsR0FBZ0IsS0FBS3VELFFBQUwsQ0FBY3ZELE1BQWQsQ0FBcUJ1QyxXQUFyQixFQUFoQjtBQUNELEdBRk0sTUFFQTtBQUNML0QsSUFBQUEsTUFBTSxDQUFDd0IsTUFBUCxHQUFnQixLQUFoQjtBQUNEOztBQUVELE1BQUkwQixZQUFZLEdBQUdsRCxNQUFNLENBQUNrRCxZQUExQjs7QUFFQSxNQUFJQSxZQUFZLEtBQUtPLFNBQXJCLEVBQWdDO0FBQzlCb0QsSUFBQUEsU0FBUyxDQUFDSSxhQUFWLENBQXdCL0QsWUFBeEIsRUFBc0M7QUFDcENnRSxNQUFBQSxpQkFBaUIsRUFBRUosVUFBVSxDQUFDNUQsWUFBWCxDQUF3QjRELFVBQVUsV0FBbEMsRUFBNEMsT0FBNUMsQ0FEaUI7QUFFcENLLE1BQUFBLGlCQUFpQixFQUFFTCxVQUFVLENBQUM1RCxZQUFYLENBQXdCNEQsVUFBVSxXQUFsQyxFQUE0QyxPQUE1QyxDQUZpQjtBQUdwQzNELE1BQUFBLG1CQUFtQixFQUFFMkQsVUFBVSxDQUFDNUQsWUFBWCxDQUF3QjRELFVBQVUsV0FBbEMsRUFBNEMsT0FBNUM7QUFIZSxLQUF0QyxFQUlHLEtBSkg7QUFLRCxHQTdCZ0QsQ0ErQmpEOzs7QUFDQSxNQUFJTSx1QkFBdUIsR0FBRyxFQUE5QjtBQUNBLE1BQUlDLDhCQUE4QixHQUFHLElBQXJDO0FBQ0EsT0FBS04sWUFBTCxDQUFrQnBHLE9BQWxCLENBQTBCZ0QsT0FBMUIsQ0FBa0MsU0FBUzJELDBCQUFULENBQW9DQyxXQUFwQyxFQUFpRDtBQUNqRixRQUFJLE9BQU9BLFdBQVcsQ0FBQ0MsT0FBbkIsS0FBK0IsVUFBL0IsSUFBNkNELFdBQVcsQ0FBQ0MsT0FBWixDQUFvQnhILE1BQXBCLE1BQWdDLEtBQWpGLEVBQXdGO0FBQ3RGO0FBQ0Q7O0FBRURxSCxJQUFBQSw4QkFBOEIsR0FBR0EsOEJBQThCLElBQUlFLFdBQVcsQ0FBQ0UsV0FBL0U7QUFFQUwsSUFBQUEsdUJBQXVCLENBQUNNLE9BQXhCLENBQWdDSCxXQUFXLENBQUNJLFNBQTVDLEVBQXVESixXQUFXLENBQUNLLFFBQW5FO0FBQ0QsR0FSRDtBQVVBLE1BQUlDLHdCQUF3QixHQUFHLEVBQS9CO0FBQ0EsT0FBS2QsWUFBTCxDQUFrQjdFLFFBQWxCLENBQTJCeUIsT0FBM0IsQ0FBbUMsU0FBU21FLHdCQUFULENBQWtDUCxXQUFsQyxFQUErQztBQUNoRk0sSUFBQUEsd0JBQXdCLENBQUNFLElBQXpCLENBQThCUixXQUFXLENBQUNJLFNBQTFDLEVBQXFESixXQUFXLENBQUNLLFFBQWpFO0FBQ0QsR0FGRDtBQUlBLE1BQUl0RCxPQUFKOztBQUVBLE1BQUksQ0FBQytDLDhCQUFMLEVBQXFDO0FBQ25DLFFBQUlXLEtBQUssR0FBRyxDQUFDcEIsZUFBRCxFQUFrQm5ELFNBQWxCLENBQVo7QUFFQXdFLElBQUFBLEtBQUssQ0FBQzdDLFNBQU4sQ0FBZ0JzQyxPQUFoQixDQUF3QlEsS0FBeEIsQ0FBOEJGLEtBQTlCLEVBQXFDWix1QkFBckM7QUFDQVksSUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUNHLE1BQU4sQ0FBYU4sd0JBQWIsQ0FBUjtBQUVBdkQsSUFBQUEsT0FBTyxHQUFHckUsT0FBTyxDQUFDRSxPQUFSLENBQWdCSCxNQUFoQixDQUFWOztBQUNBLFdBQU9nSSxLQUFLLENBQUNJLE1BQWIsRUFBcUI7QUFDbkI5RCxNQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0MsSUFBUixDQUFheUQsS0FBSyxDQUFDSyxLQUFOLEVBQWIsRUFBNEJMLEtBQUssQ0FBQ0ssS0FBTixFQUE1QixDQUFWO0FBQ0Q7O0FBRUQsV0FBTy9ELE9BQVA7QUFDRDs7QUFHRCxNQUFJZ0UsU0FBUyxHQUFHdEksTUFBaEI7O0FBQ0EsU0FBT29ILHVCQUF1QixDQUFDZ0IsTUFBL0IsRUFBdUM7QUFDckMsUUFBSUcsV0FBVyxHQUFHbkIsdUJBQXVCLENBQUNpQixLQUF4QixFQUFsQjtBQUNBLFFBQUlHLFVBQVUsR0FBR3BCLHVCQUF1QixDQUFDaUIsS0FBeEIsRUFBakI7O0FBQ0EsUUFBSTtBQUNGQyxNQUFBQSxTQUFTLEdBQUdDLFdBQVcsQ0FBQ0QsU0FBRCxDQUF2QjtBQUNELEtBRkQsQ0FFRSxPQUFPRyxLQUFQLEVBQWM7QUFDZEQsTUFBQUEsVUFBVSxDQUFDQyxLQUFELENBQVY7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSTtBQUNGbkUsSUFBQUEsT0FBTyxHQUFHc0MsZUFBZSxDQUFDMEIsU0FBRCxDQUF6QjtBQUNELEdBRkQsQ0FFRSxPQUFPRyxLQUFQLEVBQWM7QUFDZCxXQUFPeEksT0FBTyxDQUFDRyxNQUFSLENBQWVxSSxLQUFmLENBQVA7QUFDRDs7QUFFRCxTQUFPWix3QkFBd0IsQ0FBQ08sTUFBaEMsRUFBd0M7QUFDdEM5RCxJQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ0MsSUFBUixDQUFhc0Qsd0JBQXdCLENBQUNRLEtBQXpCLEVBQWIsRUFBK0NSLHdCQUF3QixDQUFDUSxLQUF6QixFQUEvQyxDQUFWO0FBQ0Q7O0FBRUQsU0FBTy9ELE9BQVA7QUFDRCxDQXpGRDs7QUEyRkFPLEtBQUssQ0FBQ08sU0FBTixDQUFnQnNELE1BQWhCLEdBQXlCLFNBQVNBLE1BQVQsQ0FBZ0IxSSxNQUFoQixFQUF3QjtBQUMvQ0EsRUFBQUEsTUFBTSxHQUFHOEUsV0FBVyxDQUFDLEtBQUtDLFFBQU4sRUFBZ0IvRSxNQUFoQixDQUFwQjtBQUNBLFNBQU9OLFFBQVEsQ0FBQ00sTUFBTSxDQUFDc0IsR0FBUixFQUFhdEIsTUFBTSxDQUFDMEIsTUFBcEIsRUFBNEIxQixNQUFNLENBQUMyQixnQkFBbkMsQ0FBUixDQUE2RGdILE9BQTdELENBQXFFLEtBQXJFLEVBQTRFLEVBQTVFLENBQVA7QUFDRCxDQUhELEVBS0E7OztBQUNBcEosS0FBSyxDQUFDb0UsT0FBTixDQUFjLENBQUMsUUFBRCxFQUFXLEtBQVgsRUFBa0IsTUFBbEIsRUFBMEIsU0FBMUIsQ0FBZCxFQUFvRCxTQUFTaUYsbUJBQVQsQ0FBNkJwSCxNQUE3QixFQUFxQztBQUN2RjtBQUNBcUQsRUFBQUEsS0FBSyxDQUFDTyxTQUFOLENBQWdCNUQsTUFBaEIsSUFBMEIsVUFBU0YsR0FBVCxFQUFjdEIsTUFBZCxFQUFzQjtBQUM5QyxXQUFPLEtBQUtXLE9BQUwsQ0FBYW1FLFdBQVcsQ0FBQzlFLE1BQU0sSUFBSSxFQUFYLEVBQWU7QUFDNUN3QixNQUFBQSxNQUFNLEVBQUVBLE1BRG9DO0FBRTVDRixNQUFBQSxHQUFHLEVBQUVBLEdBRnVDO0FBRzVDaEIsTUFBQUEsSUFBSSxFQUFFLENBQUNOLE1BQU0sSUFBSSxFQUFYLEVBQWVNO0FBSHVCLEtBQWYsQ0FBeEIsQ0FBUDtBQUtELEdBTkQ7QUFPRCxDQVREO0FBV0FmLEtBQUssQ0FBQ29FLE9BQU4sQ0FBYyxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQWdCLE9BQWhCLENBQWQsRUFBd0MsU0FBU2tGLHFCQUFULENBQStCckgsTUFBL0IsRUFBdUM7QUFDN0U7QUFDQXFELEVBQUFBLEtBQUssQ0FBQ08sU0FBTixDQUFnQjVELE1BQWhCLElBQTBCLFVBQVNGLEdBQVQsRUFBY2hCLElBQWQsRUFBb0JOLE1BQXBCLEVBQTRCO0FBQ3BELFdBQU8sS0FBS1csT0FBTCxDQUFhbUUsV0FBVyxDQUFDOUUsTUFBTSxJQUFJLEVBQVgsRUFBZTtBQUM1Q3dCLE1BQUFBLE1BQU0sRUFBRUEsTUFEb0M7QUFFNUNGLE1BQUFBLEdBQUcsRUFBRUEsR0FGdUM7QUFHNUNoQixNQUFBQSxJQUFJLEVBQUVBO0FBSHNDLEtBQWYsQ0FBeEIsQ0FBUDtBQUtELEdBTkQ7QUFPRCxDQVREO0FBV0FoQixNQUFNLENBQUM1QixPQUFQLEdBQWlCbUgsS0FBakI7Ozs7Ozs7Ozs7QUNuSmE7O0FBRWIsSUFBSXRGLEtBQUssR0FBRzFCLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7O0FBRUEsU0FBUzhJLGtCQUFULEdBQThCO0FBQzVCLE9BQUttQyxRQUFMLEdBQWdCLEVBQWhCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQW5DLGtCQUFrQixDQUFDdkIsU0FBbkIsQ0FBNkIyRCxHQUE3QixHQUFtQyxTQUFTQSxHQUFULENBQWFwQixTQUFiLEVBQXdCQyxRQUF4QixFQUFrQ29CLE9BQWxDLEVBQTJDO0FBQzVFLE9BQUtGLFFBQUwsQ0FBY2YsSUFBZCxDQUFtQjtBQUNqQkosSUFBQUEsU0FBUyxFQUFFQSxTQURNO0FBRWpCQyxJQUFBQSxRQUFRLEVBQUVBLFFBRk87QUFHakJILElBQUFBLFdBQVcsRUFBRXVCLE9BQU8sR0FBR0EsT0FBTyxDQUFDdkIsV0FBWCxHQUF5QixLQUg1QjtBQUlqQkQsSUFBQUEsT0FBTyxFQUFFd0IsT0FBTyxHQUFHQSxPQUFPLENBQUN4QixPQUFYLEdBQXFCO0FBSnBCLEdBQW5CO0FBTUEsU0FBTyxLQUFLc0IsUUFBTCxDQUFjVixNQUFkLEdBQXVCLENBQTlCO0FBQ0QsQ0FSRDtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBekIsa0JBQWtCLENBQUN2QixTQUFuQixDQUE2QjZELEtBQTdCLEdBQXFDLFNBQVNBLEtBQVQsQ0FBZUMsRUFBZixFQUFtQjtBQUN0RCxNQUFJLEtBQUtKLFFBQUwsQ0FBY0ksRUFBZCxDQUFKLEVBQXVCO0FBQ3JCLFNBQUtKLFFBQUwsQ0FBY0ksRUFBZCxJQUFvQixJQUFwQjtBQUNEO0FBQ0YsQ0FKRDtBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBdkMsa0JBQWtCLENBQUN2QixTQUFuQixDQUE2QnpCLE9BQTdCLEdBQXVDLFNBQVNBLE9BQVQsQ0FBaUJ3RixFQUFqQixFQUFxQjtBQUMxRDVKLEVBQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBYyxLQUFLbUYsUUFBbkIsRUFBNkIsU0FBU00sY0FBVCxDQUF3QkMsQ0FBeEIsRUFBMkI7QUFDdEQsUUFBSUEsQ0FBQyxLQUFLLElBQVYsRUFBZ0I7QUFDZEYsTUFBQUEsRUFBRSxDQUFDRSxDQUFELENBQUY7QUFDRDtBQUNGLEdBSkQ7QUFLRCxDQU5EOztBQVFBL0osTUFBTSxDQUFDNUIsT0FBUCxHQUFpQmlKLGtCQUFqQjs7Ozs7Ozs7OztBQ3JEYTs7QUFFYixJQUFJMkMsYUFBYSxHQUFHekwsbUJBQU8sQ0FBQyxtRkFBRCxDQUEzQjs7QUFDQSxJQUFJMEwsV0FBVyxHQUFHMUwsbUJBQU8sQ0FBQywrRUFBRCxDQUF6QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0F5QixNQUFNLENBQUM1QixPQUFQLEdBQWlCLFNBQVNpQyxhQUFULENBQXVCMEIsT0FBdkIsRUFBZ0NtSSxZQUFoQyxFQUE4QztBQUM3RCxNQUFJbkksT0FBTyxJQUFJLENBQUNpSSxhQUFhLENBQUNFLFlBQUQsQ0FBN0IsRUFBNkM7QUFDM0MsV0FBT0QsV0FBVyxDQUFDbEksT0FBRCxFQUFVbUksWUFBVixDQUFsQjtBQUNEOztBQUNELFNBQU9BLFlBQVA7QUFDRCxDQUxEOzs7Ozs7Ozs7O0FDZGE7O0FBRWIsSUFBSUMsWUFBWSxHQUFHNUwsbUJBQU8sQ0FBQyxxRUFBRCxDQUExQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXlCLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBU29DLFdBQVQsQ0FBcUJrRyxPQUFyQixFQUE4QmhHLE1BQTlCLEVBQXNDMEosSUFBdEMsRUFBNEMvSSxPQUE1QyxFQUFxRHVCLFFBQXJELEVBQStEO0FBQzlFLE1BQUl1RyxLQUFLLEdBQUcsSUFBSXJKLEtBQUosQ0FBVTRHLE9BQVYsQ0FBWjtBQUNBLFNBQU95RCxZQUFZLENBQUNoQixLQUFELEVBQVF6SSxNQUFSLEVBQWdCMEosSUFBaEIsRUFBc0IvSSxPQUF0QixFQUErQnVCLFFBQS9CLENBQW5CO0FBQ0QsQ0FIRDs7Ozs7Ozs7OztBQ2RhOztBQUViLElBQUkzQyxLQUFLLEdBQUcxQixtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUNBLElBQUk4TCxhQUFhLEdBQUc5TCxtQkFBTyxDQUFDLHVFQUFELENBQTNCOztBQUNBLElBQUk4SCxRQUFRLEdBQUc5SCxtQkFBTyxDQUFDLHVFQUFELENBQXRCOztBQUNBLElBQUlrSCxRQUFRLEdBQUdsSCxtQkFBTyxDQUFDLHlEQUFELENBQXRCO0FBRUE7QUFDQTtBQUNBOzs7QUFDQSxTQUFTK0wsNEJBQVQsQ0FBc0M1SixNQUF0QyxFQUE4QztBQUM1QyxNQUFJQSxNQUFNLENBQUNxRSxXQUFYLEVBQXdCO0FBQ3RCckUsSUFBQUEsTUFBTSxDQUFDcUUsV0FBUCxDQUFtQm1DLGdCQUFuQjtBQUNEO0FBQ0Y7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBbEgsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTa0osZUFBVCxDQUF5QjVHLE1BQXpCLEVBQWlDO0FBQ2hENEosRUFBQUEsNEJBQTRCLENBQUM1SixNQUFELENBQTVCLENBRGdELENBR2hEOztBQUNBQSxFQUFBQSxNQUFNLENBQUNRLE9BQVAsR0FBaUJSLE1BQU0sQ0FBQ1EsT0FBUCxJQUFrQixFQUFuQyxDQUpnRCxDQU1oRDs7QUFDQVIsRUFBQUEsTUFBTSxDQUFDTSxJQUFQLEdBQWNxSixhQUFhLENBQUNFLElBQWQsQ0FDWjdKLE1BRFksRUFFWkEsTUFBTSxDQUFDTSxJQUZLLEVBR1pOLE1BQU0sQ0FBQ1EsT0FISyxFQUlaUixNQUFNLENBQUM4SixnQkFKSyxDQUFkLENBUGdELENBY2hEOztBQUNBOUosRUFBQUEsTUFBTSxDQUFDUSxPQUFQLEdBQWlCakIsS0FBSyxDQUFDd0ssS0FBTixDQUNmL0osTUFBTSxDQUFDUSxPQUFQLENBQWV3SixNQUFmLElBQXlCLEVBRFYsRUFFZmhLLE1BQU0sQ0FBQ1EsT0FBUCxDQUFlUixNQUFNLENBQUN3QixNQUF0QixLQUFpQyxFQUZsQixFQUdmeEIsTUFBTSxDQUFDUSxPQUhRLENBQWpCO0FBTUFqQixFQUFBQSxLQUFLLENBQUNvRSxPQUFOLENBQ0UsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixNQUFsQixFQUEwQixNQUExQixFQUFrQyxLQUFsQyxFQUF5QyxPQUF6QyxFQUFrRCxRQUFsRCxDQURGLEVBRUUsU0FBU3NHLGlCQUFULENBQTJCekksTUFBM0IsRUFBbUM7QUFDakMsV0FBT3hCLE1BQU0sQ0FBQ1EsT0FBUCxDQUFlZ0IsTUFBZixDQUFQO0FBQ0QsR0FKSDtBQU9BLE1BQUkwSSxPQUFPLEdBQUdsSyxNQUFNLENBQUNrSyxPQUFQLElBQWtCbkYsUUFBUSxDQUFDbUYsT0FBekM7QUFFQSxTQUFPQSxPQUFPLENBQUNsSyxNQUFELENBQVAsQ0FBZ0J1RSxJQUFoQixDQUFxQixTQUFTNEYsbUJBQVQsQ0FBNkJqSSxRQUE3QixFQUF1QztBQUNqRTBILElBQUFBLDRCQUE0QixDQUFDNUosTUFBRCxDQUE1QixDQURpRSxDQUdqRTs7QUFDQWtDLElBQUFBLFFBQVEsQ0FBQzVCLElBQVQsR0FBZ0JxSixhQUFhLENBQUNFLElBQWQsQ0FDZDdKLE1BRGMsRUFFZGtDLFFBQVEsQ0FBQzVCLElBRkssRUFHZDRCLFFBQVEsQ0FBQzFCLE9BSEssRUFJZFIsTUFBTSxDQUFDb0ssaUJBSk8sQ0FBaEI7QUFPQSxXQUFPbEksUUFBUDtBQUNELEdBWk0sRUFZSixTQUFTbUksa0JBQVQsQ0FBNEI5RCxNQUE1QixFQUFvQztBQUNyQyxRQUFJLENBQUNaLFFBQVEsQ0FBQ1ksTUFBRCxDQUFiLEVBQXVCO0FBQ3JCcUQsTUFBQUEsNEJBQTRCLENBQUM1SixNQUFELENBQTVCLENBRHFCLENBR3JCOztBQUNBLFVBQUl1RyxNQUFNLElBQUlBLE1BQU0sQ0FBQ3JFLFFBQXJCLEVBQStCO0FBQzdCcUUsUUFBQUEsTUFBTSxDQUFDckUsUUFBUCxDQUFnQjVCLElBQWhCLEdBQXVCcUosYUFBYSxDQUFDRSxJQUFkLENBQ3JCN0osTUFEcUIsRUFFckJ1RyxNQUFNLENBQUNyRSxRQUFQLENBQWdCNUIsSUFGSyxFQUdyQmlHLE1BQU0sQ0FBQ3JFLFFBQVAsQ0FBZ0IxQixPQUhLLEVBSXJCUixNQUFNLENBQUNvSyxpQkFKYyxDQUF2QjtBQU1EO0FBQ0Y7O0FBRUQsV0FBT25LLE9BQU8sQ0FBQ0csTUFBUixDQUFlbUcsTUFBZixDQUFQO0FBQ0QsR0E1Qk0sQ0FBUDtBQTZCRCxDQTNERDs7Ozs7Ozs7OztBQ3RCYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBakgsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTK0wsWUFBVCxDQUFzQmhCLEtBQXRCLEVBQTZCekksTUFBN0IsRUFBcUMwSixJQUFyQyxFQUEyQy9JLE9BQTNDLEVBQW9EdUIsUUFBcEQsRUFBOEQ7QUFDN0V1RyxFQUFBQSxLQUFLLENBQUN6SSxNQUFOLEdBQWVBLE1BQWY7O0FBQ0EsTUFBSTBKLElBQUosRUFBVTtBQUNSakIsSUFBQUEsS0FBSyxDQUFDaUIsSUFBTixHQUFhQSxJQUFiO0FBQ0Q7O0FBRURqQixFQUFBQSxLQUFLLENBQUM5SCxPQUFOLEdBQWdCQSxPQUFoQjtBQUNBOEgsRUFBQUEsS0FBSyxDQUFDdkcsUUFBTixHQUFpQkEsUUFBakI7QUFDQXVHLEVBQUFBLEtBQUssQ0FBQzFDLFlBQU4sR0FBcUIsSUFBckI7O0FBRUEwQyxFQUFBQSxLQUFLLENBQUM2QixNQUFOLEdBQWUsU0FBU0EsTUFBVCxHQUFrQjtBQUMvQixXQUFPO0FBQ0w7QUFDQXRFLE1BQUFBLE9BQU8sRUFBRSxLQUFLQSxPQUZUO0FBR0x1RSxNQUFBQSxJQUFJLEVBQUUsS0FBS0EsSUFITjtBQUlMO0FBQ0FDLE1BQUFBLFdBQVcsRUFBRSxLQUFLQSxXQUxiO0FBTUxDLE1BQUFBLE1BQU0sRUFBRSxLQUFLQSxNQU5SO0FBT0w7QUFDQUMsTUFBQUEsUUFBUSxFQUFFLEtBQUtBLFFBUlY7QUFTTEMsTUFBQUEsVUFBVSxFQUFFLEtBQUtBLFVBVFo7QUFVTEMsTUFBQUEsWUFBWSxFQUFFLEtBQUtBLFlBVmQ7QUFXTEMsTUFBQUEsS0FBSyxFQUFFLEtBQUtBLEtBWFA7QUFZTDtBQUNBN0ssTUFBQUEsTUFBTSxFQUFFLEtBQUtBLE1BYlI7QUFjTDBKLE1BQUFBLElBQUksRUFBRSxLQUFLQTtBQWROLEtBQVA7QUFnQkQsR0FqQkQ7O0FBa0JBLFNBQU9qQixLQUFQO0FBQ0QsQ0E3QkQ7Ozs7Ozs7Ozs7QUNaYTs7QUFFYixJQUFJbEosS0FBSyxHQUFHMUIsbUJBQU8sQ0FBQyxtREFBRCxDQUFuQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBeUIsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTb0gsV0FBVCxDQUFxQmdHLE9BQXJCLEVBQThCQyxPQUE5QixFQUF1QztBQUN0RDtBQUNBQSxFQUFBQSxPQUFPLEdBQUdBLE9BQU8sSUFBSSxFQUFyQjtBQUNBLE1BQUkvSyxNQUFNLEdBQUcsRUFBYjtBQUVBLE1BQUlnTCxvQkFBb0IsR0FBRyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLE1BQWxCLENBQTNCO0FBQ0EsTUFBSUMsdUJBQXVCLEdBQUcsQ0FBQyxTQUFELEVBQVksTUFBWixFQUFvQixPQUFwQixFQUE2QixRQUE3QixDQUE5QjtBQUNBLE1BQUlDLG9CQUFvQixHQUFHLENBQ3pCLFNBRHlCLEVBQ2Qsa0JBRGMsRUFDTSxtQkFETixFQUMyQixrQkFEM0IsRUFFekIsU0FGeUIsRUFFZCxnQkFGYyxFQUVJLGlCQUZKLEVBRXVCLFNBRnZCLEVBRWtDLGNBRmxDLEVBRWtELGdCQUZsRCxFQUd6QixnQkFIeUIsRUFHUCxrQkFITyxFQUdhLG9CQUhiLEVBR21DLFlBSG5DLEVBSXpCLGtCQUp5QixFQUlMLGVBSkssRUFJWSxjQUpaLEVBSTRCLFdBSjVCLEVBSXlDLFdBSnpDLEVBS3pCLFlBTHlCLEVBS1gsYUFMVyxFQUtJLFlBTEosRUFLa0Isa0JBTGxCLENBQTNCO0FBT0EsTUFBSUMsZUFBZSxHQUFHLENBQUMsZ0JBQUQsQ0FBdEI7O0FBRUEsV0FBU0MsY0FBVCxDQUF3QkMsTUFBeEIsRUFBZ0M1RSxNQUFoQyxFQUF3QztBQUN0QyxRQUFJbEgsS0FBSyxDQUFDK0wsYUFBTixDQUFvQkQsTUFBcEIsS0FBK0I5TCxLQUFLLENBQUMrTCxhQUFOLENBQW9CN0UsTUFBcEIsQ0FBbkMsRUFBZ0U7QUFDOUQsYUFBT2xILEtBQUssQ0FBQ3dLLEtBQU4sQ0FBWXNCLE1BQVosRUFBb0I1RSxNQUFwQixDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlsSCxLQUFLLENBQUMrTCxhQUFOLENBQW9CN0UsTUFBcEIsQ0FBSixFQUFpQztBQUN0QyxhQUFPbEgsS0FBSyxDQUFDd0ssS0FBTixDQUFZLEVBQVosRUFBZ0J0RCxNQUFoQixDQUFQO0FBQ0QsS0FGTSxNQUVBLElBQUlsSCxLQUFLLENBQUNnTSxPQUFOLENBQWM5RSxNQUFkLENBQUosRUFBMkI7QUFDaEMsYUFBT0EsTUFBTSxDQUFDL0gsS0FBUCxFQUFQO0FBQ0Q7O0FBQ0QsV0FBTytILE1BQVA7QUFDRDs7QUFFRCxXQUFTK0UsbUJBQVQsQ0FBNkJDLElBQTdCLEVBQW1DO0FBQ2pDLFFBQUksQ0FBQ2xNLEtBQUssQ0FBQ3lFLFdBQU4sQ0FBa0IrRyxPQUFPLENBQUNVLElBQUQsQ0FBekIsQ0FBTCxFQUF1QztBQUNyQ3pMLE1BQUFBLE1BQU0sQ0FBQ3lMLElBQUQsQ0FBTixHQUFlTCxjQUFjLENBQUNOLE9BQU8sQ0FBQ1csSUFBRCxDQUFSLEVBQWdCVixPQUFPLENBQUNVLElBQUQsQ0FBdkIsQ0FBN0I7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDbE0sS0FBSyxDQUFDeUUsV0FBTixDQUFrQjhHLE9BQU8sQ0FBQ1csSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQzVDekwsTUFBQUEsTUFBTSxDQUFDeUwsSUFBRCxDQUFOLEdBQWVMLGNBQWMsQ0FBQzNILFNBQUQsRUFBWXFILE9BQU8sQ0FBQ1csSUFBRCxDQUFuQixDQUE3QjtBQUNEO0FBQ0Y7O0FBRURsTSxFQUFBQSxLQUFLLENBQUNvRSxPQUFOLENBQWNxSCxvQkFBZCxFQUFvQyxTQUFTVSxnQkFBVCxDQUEwQkQsSUFBMUIsRUFBZ0M7QUFDbEUsUUFBSSxDQUFDbE0sS0FBSyxDQUFDeUUsV0FBTixDQUFrQitHLE9BQU8sQ0FBQ1UsSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQ3JDekwsTUFBQUEsTUFBTSxDQUFDeUwsSUFBRCxDQUFOLEdBQWVMLGNBQWMsQ0FBQzNILFNBQUQsRUFBWXNILE9BQU8sQ0FBQ1UsSUFBRCxDQUFuQixDQUE3QjtBQUNEO0FBQ0YsR0FKRDtBQU1BbE0sRUFBQUEsS0FBSyxDQUFDb0UsT0FBTixDQUFjc0gsdUJBQWQsRUFBdUNPLG1CQUF2QztBQUVBak0sRUFBQUEsS0FBSyxDQUFDb0UsT0FBTixDQUFjdUgsb0JBQWQsRUFBb0MsU0FBU1MsZ0JBQVQsQ0FBMEJGLElBQTFCLEVBQWdDO0FBQ2xFLFFBQUksQ0FBQ2xNLEtBQUssQ0FBQ3lFLFdBQU4sQ0FBa0IrRyxPQUFPLENBQUNVLElBQUQsQ0FBekIsQ0FBTCxFQUF1QztBQUNyQ3pMLE1BQUFBLE1BQU0sQ0FBQ3lMLElBQUQsQ0FBTixHQUFlTCxjQUFjLENBQUMzSCxTQUFELEVBQVlzSCxPQUFPLENBQUNVLElBQUQsQ0FBbkIsQ0FBN0I7QUFDRCxLQUZELE1BRU8sSUFBSSxDQUFDbE0sS0FBSyxDQUFDeUUsV0FBTixDQUFrQjhHLE9BQU8sQ0FBQ1csSUFBRCxDQUF6QixDQUFMLEVBQXVDO0FBQzVDekwsTUFBQUEsTUFBTSxDQUFDeUwsSUFBRCxDQUFOLEdBQWVMLGNBQWMsQ0FBQzNILFNBQUQsRUFBWXFILE9BQU8sQ0FBQ1csSUFBRCxDQUFuQixDQUE3QjtBQUNEO0FBQ0YsR0FORDtBQVFBbE0sRUFBQUEsS0FBSyxDQUFDb0UsT0FBTixDQUFjd0gsZUFBZCxFQUErQixTQUFTcEIsS0FBVCxDQUFlMEIsSUFBZixFQUFxQjtBQUNsRCxRQUFJQSxJQUFJLElBQUlWLE9BQVosRUFBcUI7QUFDbkIvSyxNQUFBQSxNQUFNLENBQUN5TCxJQUFELENBQU4sR0FBZUwsY0FBYyxDQUFDTixPQUFPLENBQUNXLElBQUQsQ0FBUixFQUFnQlYsT0FBTyxDQUFDVSxJQUFELENBQXZCLENBQTdCO0FBQ0QsS0FGRCxNQUVPLElBQUlBLElBQUksSUFBSVgsT0FBWixFQUFxQjtBQUMxQjlLLE1BQUFBLE1BQU0sQ0FBQ3lMLElBQUQsQ0FBTixHQUFlTCxjQUFjLENBQUMzSCxTQUFELEVBQVlxSCxPQUFPLENBQUNXLElBQUQsQ0FBbkIsQ0FBN0I7QUFDRDtBQUNGLEdBTkQ7QUFRQSxNQUFJRyxTQUFTLEdBQUdaLG9CQUFvQixDQUNqQzdDLE1BRGEsQ0FDTjhDLHVCQURNLEVBRWI5QyxNQUZhLENBRU4rQyxvQkFGTSxFQUdiL0MsTUFIYSxDQUdOZ0QsZUFITSxDQUFoQjtBQUtBLE1BQUlVLFNBQVMsR0FBR3JPLE1BQU0sQ0FDbkJzTyxJQURhLENBQ1JoQixPQURRLEVBRWIzQyxNQUZhLENBRU4zSyxNQUFNLENBQUNzTyxJQUFQLENBQVlmLE9BQVosQ0FGTSxFQUdiZ0IsTUFIYSxDQUdOLFNBQVNDLGVBQVQsQ0FBeUJsSSxHQUF6QixFQUE4QjtBQUNwQyxXQUFPOEgsU0FBUyxDQUFDbkosT0FBVixDQUFrQnFCLEdBQWxCLE1BQTJCLENBQUMsQ0FBbkM7QUFDRCxHQUxhLENBQWhCO0FBT0F2RSxFQUFBQSxLQUFLLENBQUNvRSxPQUFOLENBQWNrSSxTQUFkLEVBQXlCTCxtQkFBekI7QUFFQSxTQUFPeEwsTUFBUDtBQUNELENBMUVEOzs7Ozs7Ozs7O0FDWmE7O0FBRWIsSUFBSUYsV0FBVyxHQUFHakMsbUJBQU8sQ0FBQyxtRUFBRCxDQUF6QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQXlCLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBUzhCLE1BQVQsQ0FBZ0JXLE9BQWhCLEVBQXlCQyxNQUF6QixFQUFpQzhCLFFBQWpDLEVBQTJDO0FBQzFELE1BQUkrSixjQUFjLEdBQUcvSixRQUFRLENBQUNsQyxNQUFULENBQWdCaU0sY0FBckM7O0FBQ0EsTUFBSSxDQUFDL0osUUFBUSxDQUFDQyxNQUFWLElBQW9CLENBQUM4SixjQUFyQixJQUF1Q0EsY0FBYyxDQUFDL0osUUFBUSxDQUFDQyxNQUFWLENBQXpELEVBQTRFO0FBQzFFaEMsSUFBQUEsT0FBTyxDQUFDK0IsUUFBRCxDQUFQO0FBQ0QsR0FGRCxNQUVPO0FBQ0w5QixJQUFBQSxNQUFNLENBQUNOLFdBQVcsQ0FDaEIscUNBQXFDb0MsUUFBUSxDQUFDQyxNQUQ5QixFQUVoQkQsUUFBUSxDQUFDbEMsTUFGTyxFQUdoQixJQUhnQixFQUloQmtDLFFBQVEsQ0FBQ3ZCLE9BSk8sRUFLaEJ1QixRQUxnQixDQUFaLENBQU47QUFPRDtBQUNGLENBYkQ7Ozs7Ozs7Ozs7QUNYYTs7QUFFYixJQUFJM0MsS0FBSyxHQUFHMUIsbUJBQU8sQ0FBQyxxREFBRCxDQUFuQjs7QUFDQSxJQUFJa0gsUUFBUSxHQUFHbEgsbUJBQU8sQ0FBQywyREFBRCxDQUF0QjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBeUIsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTaU0sYUFBVCxDQUF1QnJKLElBQXZCLEVBQTZCRSxPQUE3QixFQUFzQzBMLEdBQXRDLEVBQTJDO0FBQzFELE1BQUloSCxPQUFPLEdBQUcsUUFBUUgsUUFBdEI7QUFDQTs7QUFDQXhGLEVBQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBY3VJLEdBQWQsRUFBbUIsU0FBU0MsU0FBVCxDQUFtQmhELEVBQW5CLEVBQXVCO0FBQ3hDN0ksSUFBQUEsSUFBSSxHQUFHNkksRUFBRSxDQUFDVSxJQUFILENBQVEzRSxPQUFSLEVBQWlCNUUsSUFBakIsRUFBdUJFLE9BQXZCLENBQVA7QUFDRCxHQUZEO0FBSUEsU0FBT0YsSUFBUDtBQUNELENBUkQ7Ozs7Ozs7Ozs7QUNiYTs7QUFFYixJQUFJZixLQUFLLEdBQUcxQixtQkFBTyxDQUFDLGtEQUFELENBQW5COztBQUNBLElBQUl1TyxtQkFBbUIsR0FBR3ZPLG1CQUFPLENBQUMsOEZBQUQsQ0FBakM7O0FBQ0EsSUFBSTRMLFlBQVksR0FBRzVMLG1CQUFPLENBQUMsMEVBQUQsQ0FBMUI7O0FBRUEsSUFBSXdPLG9CQUFvQixHQUFHO0FBQ3pCLGtCQUFnQjtBQURTLENBQTNCOztBQUlBLFNBQVNDLHFCQUFULENBQStCOUwsT0FBL0IsRUFBd0M3QyxLQUF4QyxFQUErQztBQUM3QyxNQUFJLENBQUM0QixLQUFLLENBQUN5RSxXQUFOLENBQWtCeEQsT0FBbEIsQ0FBRCxJQUErQmpCLEtBQUssQ0FBQ3lFLFdBQU4sQ0FBa0J4RCxPQUFPLENBQUMsY0FBRCxDQUF6QixDQUFuQyxFQUErRTtBQUM3RUEsSUFBQUEsT0FBTyxDQUFDLGNBQUQsQ0FBUCxHQUEwQjdDLEtBQTFCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNE8saUJBQVQsR0FBNkI7QUFDM0IsTUFBSXJDLE9BQUo7O0FBQ0EsTUFBSSxPQUFPdEosY0FBUCxLQUEwQixXQUE5QixFQUEyQztBQUN6QztBQUNBc0osSUFBQUEsT0FBTyxHQUFHck0sbUJBQU8sQ0FBQyxnRUFBRCxDQUFqQjtBQUNELEdBSEQsTUFHTyxJQUFJLE9BQU8yTyxPQUFQLEtBQW1CLFdBQW5CLElBQWtDaFAsTUFBTSxDQUFDNEgsU0FBUCxDQUFpQjVHLFFBQWpCLENBQTBCcUwsSUFBMUIsQ0FBK0IyQyxPQUEvQixNQUE0QyxrQkFBbEYsRUFBc0c7QUFDM0c7QUFDQXRDLElBQUFBLE9BQU8sR0FBR3JNLG1CQUFPLENBQUMsaUVBQUQsQ0FBakI7QUFDRDs7QUFDRCxTQUFPcU0sT0FBUDtBQUNEOztBQUVELFNBQVN1QyxlQUFULENBQXlCQyxRQUF6QixFQUFtQ0MsTUFBbkMsRUFBMkNDLE9BQTNDLEVBQW9EO0FBQ2xELE1BQUlyTixLQUFLLENBQUNzTixRQUFOLENBQWVILFFBQWYsQ0FBSixFQUE4QjtBQUM1QixRQUFJO0FBQ0YsT0FBQ0MsTUFBTSxJQUFJRyxJQUFJLENBQUNDLEtBQWhCLEVBQXVCTCxRQUF2QjtBQUNBLGFBQU9uTixLQUFLLENBQUN5TixJQUFOLENBQVdOLFFBQVgsQ0FBUDtBQUNELEtBSEQsQ0FHRSxPQUFPTyxDQUFQLEVBQVU7QUFDVixVQUFJQSxDQUFDLENBQUMxQyxJQUFGLEtBQVcsYUFBZixFQUE4QjtBQUM1QixjQUFNMEMsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxTQUFPLENBQUNMLE9BQU8sSUFBSUUsSUFBSSxDQUFDSSxTQUFqQixFQUE0QlIsUUFBNUIsQ0FBUDtBQUNEOztBQUVELElBQUkzSCxRQUFRLEdBQUc7QUFFYjdCLEVBQUFBLFlBQVksRUFBRTtBQUNaZ0UsSUFBQUEsaUJBQWlCLEVBQUUsSUFEUDtBQUVaQyxJQUFBQSxpQkFBaUIsRUFBRSxJQUZQO0FBR1poRSxJQUFBQSxtQkFBbUIsRUFBRTtBQUhULEdBRkQ7QUFRYitHLEVBQUFBLE9BQU8sRUFBRXFDLGlCQUFpQixFQVJiO0FBVWJ6QyxFQUFBQSxnQkFBZ0IsRUFBRSxDQUFDLFNBQVNBLGdCQUFULENBQTBCeEosSUFBMUIsRUFBZ0NFLE9BQWhDLEVBQXlDO0FBQzFENEwsSUFBQUEsbUJBQW1CLENBQUM1TCxPQUFELEVBQVUsUUFBVixDQUFuQjtBQUNBNEwsSUFBQUEsbUJBQW1CLENBQUM1TCxPQUFELEVBQVUsY0FBVixDQUFuQjs7QUFFQSxRQUFJakIsS0FBSyxDQUFDbUIsVUFBTixDQUFpQkosSUFBakIsS0FDRmYsS0FBSyxDQUFDNE4sYUFBTixDQUFvQjdNLElBQXBCLENBREUsSUFFRmYsS0FBSyxDQUFDNk4sUUFBTixDQUFlOU0sSUFBZixDQUZFLElBR0ZmLEtBQUssQ0FBQzhOLFFBQU4sQ0FBZS9NLElBQWYsQ0FIRSxJQUlGZixLQUFLLENBQUMrTixNQUFOLENBQWFoTixJQUFiLENBSkUsSUFLRmYsS0FBSyxDQUFDZ08sTUFBTixDQUFhak4sSUFBYixDQUxGLEVBTUU7QUFDQSxhQUFPQSxJQUFQO0FBQ0Q7O0FBQ0QsUUFBSWYsS0FBSyxDQUFDaU8saUJBQU4sQ0FBd0JsTixJQUF4QixDQUFKLEVBQW1DO0FBQ2pDLGFBQU9BLElBQUksQ0FBQ21OLE1BQVo7QUFDRDs7QUFDRCxRQUFJbE8sS0FBSyxDQUFDbU8saUJBQU4sQ0FBd0JwTixJQUF4QixDQUFKLEVBQW1DO0FBQ2pDZ00sTUFBQUEscUJBQXFCLENBQUM5TCxPQUFELEVBQVUsaURBQVYsQ0FBckI7QUFDQSxhQUFPRixJQUFJLENBQUM5QixRQUFMLEVBQVA7QUFDRDs7QUFDRCxRQUFJZSxLQUFLLENBQUNvTyxRQUFOLENBQWVyTixJQUFmLEtBQXlCRSxPQUFPLElBQUlBLE9BQU8sQ0FBQyxjQUFELENBQVAsS0FBNEIsa0JBQXBFLEVBQXlGO0FBQ3ZGOEwsTUFBQUEscUJBQXFCLENBQUM5TCxPQUFELEVBQVUsa0JBQVYsQ0FBckI7QUFDQSxhQUFPaU0sZUFBZSxDQUFDbk0sSUFBRCxDQUF0QjtBQUNEOztBQUNELFdBQU9BLElBQVA7QUFDRCxHQXpCaUIsQ0FWTDtBQXFDYjhKLEVBQUFBLGlCQUFpQixFQUFFLENBQUMsU0FBU0EsaUJBQVQsQ0FBMkI5SixJQUEzQixFQUFpQztBQUNuRCxRQUFJNEMsWUFBWSxHQUFHLEtBQUtBLFlBQXhCO0FBQ0EsUUFBSWdFLGlCQUFpQixHQUFHaEUsWUFBWSxJQUFJQSxZQUFZLENBQUNnRSxpQkFBckQ7QUFDQSxRQUFJQyxpQkFBaUIsR0FBR2pFLFlBQVksSUFBSUEsWUFBWSxDQUFDaUUsaUJBQXJEO0FBQ0EsUUFBSXlHLGlCQUFpQixHQUFHLENBQUMxRyxpQkFBRCxJQUFzQixLQUFLekcsWUFBTCxLQUFzQixNQUFwRTs7QUFFQSxRQUFJbU4saUJBQWlCLElBQUt6RyxpQkFBaUIsSUFBSTVILEtBQUssQ0FBQ3NOLFFBQU4sQ0FBZXZNLElBQWYsQ0FBckIsSUFBNkNBLElBQUksQ0FBQzhILE1BQTVFLEVBQXFGO0FBQ25GLFVBQUk7QUFDRixlQUFPMEUsSUFBSSxDQUFDQyxLQUFMLENBQVd6TSxJQUFYLENBQVA7QUFDRCxPQUZELENBRUUsT0FBTzJNLENBQVAsRUFBVTtBQUNWLFlBQUlXLGlCQUFKLEVBQXVCO0FBQ3JCLGNBQUlYLENBQUMsQ0FBQzFDLElBQUYsS0FBVyxhQUFmLEVBQThCO0FBQzVCLGtCQUFNZCxZQUFZLENBQUN3RCxDQUFELEVBQUksSUFBSixFQUFVLGNBQVYsQ0FBbEI7QUFDRDs7QUFDRCxnQkFBTUEsQ0FBTjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRCxXQUFPM00sSUFBUDtBQUNELEdBcEJrQixDQXJDTjs7QUEyRGI7QUFDRjtBQUNBO0FBQ0E7QUFDRXNCLEVBQUFBLE9BQU8sRUFBRSxDQS9ESTtBQWlFYjJCLEVBQUFBLGNBQWMsRUFBRSxZQWpFSDtBQWtFYkcsRUFBQUEsY0FBYyxFQUFFLGNBbEVIO0FBb0VibUssRUFBQUEsZ0JBQWdCLEVBQUUsQ0FBQyxDQXBFTjtBQXFFYkMsRUFBQUEsYUFBYSxFQUFFLENBQUMsQ0FyRUg7QUF1RWI3QixFQUFBQSxjQUFjLEVBQUUsU0FBU0EsY0FBVCxDQUF3QjlKLE1BQXhCLEVBQWdDO0FBQzlDLFdBQU9BLE1BQU0sSUFBSSxHQUFWLElBQWlCQSxNQUFNLEdBQUcsR0FBakM7QUFDRDtBQXpFWSxDQUFmO0FBNEVBNEMsUUFBUSxDQUFDdkUsT0FBVCxHQUFtQjtBQUNqQndKLEVBQUFBLE1BQU0sRUFBRTtBQUNOLGNBQVU7QUFESjtBQURTLENBQW5CO0FBTUF6SyxLQUFLLENBQUNvRSxPQUFOLENBQWMsQ0FBQyxRQUFELEVBQVcsS0FBWCxFQUFrQixNQUFsQixDQUFkLEVBQXlDLFNBQVNpRixtQkFBVCxDQUE2QnBILE1BQTdCLEVBQXFDO0FBQzVFdUQsRUFBQUEsUUFBUSxDQUFDdkUsT0FBVCxDQUFpQmdCLE1BQWpCLElBQTJCLEVBQTNCO0FBQ0QsQ0FGRDtBQUlBakMsS0FBSyxDQUFDb0UsT0FBTixDQUFjLENBQUMsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsT0FBaEIsQ0FBZCxFQUF3QyxTQUFTa0YscUJBQVQsQ0FBK0JySCxNQUEvQixFQUF1QztBQUM3RXVELEVBQUFBLFFBQVEsQ0FBQ3ZFLE9BQVQsQ0FBaUJnQixNQUFqQixJQUEyQmpDLEtBQUssQ0FBQ3dLLEtBQU4sQ0FBWXNDLG9CQUFaLENBQTNCO0FBQ0QsQ0FGRDtBQUlBL00sTUFBTSxDQUFDNUIsT0FBUCxHQUFpQnFILFFBQWpCOzs7Ozs7Ozs7O0FDcklhOztBQUViekYsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTa0gsSUFBVCxDQUFjdUUsRUFBZCxFQUFrQjRFLE9BQWxCLEVBQTJCO0FBQzFDLFNBQU8sU0FBU0MsSUFBVCxHQUFnQjtBQUNyQixRQUFJQyxJQUFJLEdBQUcsSUFBSWhHLEtBQUosQ0FBVWpCLFNBQVMsQ0FBQ29CLE1BQXBCLENBQVg7O0FBQ0EsU0FBSyxJQUFJOEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0QsSUFBSSxDQUFDN0YsTUFBekIsRUFBaUM4RixDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDRCxNQUFBQSxJQUFJLENBQUNDLENBQUQsQ0FBSixHQUFVbEgsU0FBUyxDQUFDa0gsQ0FBRCxDQUFuQjtBQUNEOztBQUNELFdBQU8vRSxFQUFFLENBQUNqQixLQUFILENBQVM2RixPQUFULEVBQWtCRSxJQUFsQixDQUFQO0FBQ0QsR0FORDtBQU9ELENBUkQ7Ozs7Ozs7Ozs7QUNGYTs7QUFFYixJQUFJMU8sS0FBSyxHQUFHMUIsbUJBQU8sQ0FBQyxxREFBRCxDQUFuQjs7QUFFQSxTQUFTUSxNQUFULENBQWdCd0YsR0FBaEIsRUFBcUI7QUFDbkIsU0FBTzVDLGtCQUFrQixDQUFDNEMsR0FBRCxDQUFsQixDQUNMOEUsT0FESyxDQUNHLE9BREgsRUFDWSxHQURaLEVBRUxBLE9BRkssQ0FFRyxNQUZILEVBRVcsR0FGWCxFQUdMQSxPQUhLLENBR0csT0FISCxFQUdZLEdBSFosRUFJTEEsT0FKSyxDQUlHLE1BSkgsRUFJVyxHQUpYLEVBS0xBLE9BTEssQ0FLRyxPQUxILEVBS1ksR0FMWixFQU1MQSxPQU5LLENBTUcsT0FOSCxFQU1ZLEdBTlosQ0FBUDtBQU9EO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBckosTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTZ0MsUUFBVCxDQUFrQjRCLEdBQWxCLEVBQXVCSSxNQUF2QixFQUErQkMsZ0JBQS9CLEVBQWlEO0FBQ2hFO0FBQ0EsTUFBSSxDQUFDRCxNQUFMLEVBQWE7QUFDWCxXQUFPSixHQUFQO0FBQ0Q7O0FBRUQsTUFBSTZNLGdCQUFKOztBQUNBLE1BQUl4TSxnQkFBSixFQUFzQjtBQUNwQndNLElBQUFBLGdCQUFnQixHQUFHeE0sZ0JBQWdCLENBQUNELE1BQUQsQ0FBbkM7QUFDRCxHQUZELE1BRU8sSUFBSW5DLEtBQUssQ0FBQ21PLGlCQUFOLENBQXdCaE0sTUFBeEIsQ0FBSixFQUFxQztBQUMxQ3lNLElBQUFBLGdCQUFnQixHQUFHek0sTUFBTSxDQUFDbEQsUUFBUCxFQUFuQjtBQUNELEdBRk0sTUFFQTtBQUNMLFFBQUk0UCxLQUFLLEdBQUcsRUFBWjtBQUVBN08sSUFBQUEsS0FBSyxDQUFDb0UsT0FBTixDQUFjakMsTUFBZCxFQUFzQixTQUFTMk0sU0FBVCxDQUFtQnhLLEdBQW5CLEVBQXdCQyxHQUF4QixFQUE2QjtBQUNqRCxVQUFJRCxHQUFHLEtBQUssSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsV0FBbkMsRUFBZ0Q7QUFDOUM7QUFDRDs7QUFFRCxVQUFJdEUsS0FBSyxDQUFDZ00sT0FBTixDQUFjMUgsR0FBZCxDQUFKLEVBQXdCO0FBQ3RCQyxRQUFBQSxHQUFHLEdBQUdBLEdBQUcsR0FBRyxJQUFaO0FBQ0QsT0FGRCxNQUVPO0FBQ0xELFFBQUFBLEdBQUcsR0FBRyxDQUFDQSxHQUFELENBQU47QUFDRDs7QUFFRHRFLE1BQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBY0UsR0FBZCxFQUFtQixTQUFTeUssVUFBVCxDQUFvQkMsQ0FBcEIsRUFBdUI7QUFDeEMsWUFBSWhQLEtBQUssQ0FBQ2lQLE1BQU4sQ0FBYUQsQ0FBYixDQUFKLEVBQXFCO0FBQ25CQSxVQUFBQSxDQUFDLEdBQUdBLENBQUMsQ0FBQ0UsV0FBRixFQUFKO0FBQ0QsU0FGRCxNQUVPLElBQUlsUCxLQUFLLENBQUNvTyxRQUFOLENBQWVZLENBQWYsQ0FBSixFQUF1QjtBQUM1QkEsVUFBQUEsQ0FBQyxHQUFHekIsSUFBSSxDQUFDSSxTQUFMLENBQWVxQixDQUFmLENBQUo7QUFDRDs7QUFDREgsUUFBQUEsS0FBSyxDQUFDckcsSUFBTixDQUFXMUosTUFBTSxDQUFDeUYsR0FBRCxDQUFOLEdBQWMsR0FBZCxHQUFvQnpGLE1BQU0sQ0FBQ2tRLENBQUQsQ0FBckM7QUFDRCxPQVBEO0FBUUQsS0FuQkQ7QUFxQkFKLElBQUFBLGdCQUFnQixHQUFHQyxLQUFLLENBQUNNLElBQU4sQ0FBVyxHQUFYLENBQW5CO0FBQ0Q7O0FBRUQsTUFBSVAsZ0JBQUosRUFBc0I7QUFDcEIsUUFBSVEsYUFBYSxHQUFHck4sR0FBRyxDQUFDbUIsT0FBSixDQUFZLEdBQVosQ0FBcEI7O0FBQ0EsUUFBSWtNLGFBQWEsS0FBSyxDQUFDLENBQXZCLEVBQTBCO0FBQ3hCck4sTUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUM1QyxLQUFKLENBQVUsQ0FBVixFQUFhaVEsYUFBYixDQUFOO0FBQ0Q7O0FBRURyTixJQUFBQSxHQUFHLElBQUksQ0FBQ0EsR0FBRyxDQUFDbUIsT0FBSixDQUFZLEdBQVosTUFBcUIsQ0FBQyxDQUF0QixHQUEwQixHQUExQixHQUFnQyxHQUFqQyxJQUF3QzBMLGdCQUEvQztBQUNEOztBQUVELFNBQU83TSxHQUFQO0FBQ0QsQ0FoREQ7Ozs7Ozs7Ozs7QUNyQmE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQWhDLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBUzZMLFdBQVQsQ0FBcUJsSSxPQUFyQixFQUE4QnVOLFdBQTlCLEVBQTJDO0FBQzFELFNBQU9BLFdBQVcsR0FDZHZOLE9BQU8sQ0FBQ3NILE9BQVIsQ0FBZ0IsTUFBaEIsRUFBd0IsRUFBeEIsSUFBOEIsR0FBOUIsR0FBb0NpRyxXQUFXLENBQUNqRyxPQUFaLENBQW9CLE1BQXBCLEVBQTRCLEVBQTVCLENBRHRCLEdBRWR0SCxPQUZKO0FBR0QsQ0FKRDs7Ozs7Ozs7OztBQ1RhOztBQUViLElBQUk5QixLQUFLLEdBQUcxQixtQkFBTyxDQUFDLHFEQUFELENBQW5COztBQUVBeUIsTUFBTSxDQUFDNUIsT0FBUCxHQUNFNkIsS0FBSyxDQUFDNkQsb0JBQU4sS0FFQTtBQUNHLFNBQVN5TCxrQkFBVCxHQUE4QjtBQUM3QixTQUFPO0FBQ0xDLElBQUFBLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWV2RSxJQUFmLEVBQXFCNU0sS0FBckIsRUFBNEJvUixPQUE1QixFQUFxQ0MsSUFBckMsRUFBMkNDLE1BQTNDLEVBQW1EQyxNQUFuRCxFQUEyRDtBQUNoRSxVQUFJQyxNQUFNLEdBQUcsRUFBYjtBQUNBQSxNQUFBQSxNQUFNLENBQUNwSCxJQUFQLENBQVl3QyxJQUFJLEdBQUcsR0FBUCxHQUFhdEosa0JBQWtCLENBQUN0RCxLQUFELENBQTNDOztBQUVBLFVBQUk0QixLQUFLLENBQUM2UCxRQUFOLENBQWVMLE9BQWYsQ0FBSixFQUE2QjtBQUMzQkksUUFBQUEsTUFBTSxDQUFDcEgsSUFBUCxDQUFZLGFBQWEsSUFBSXNILElBQUosQ0FBU04sT0FBVCxFQUFrQk8sV0FBbEIsRUFBekI7QUFDRDs7QUFFRCxVQUFJL1AsS0FBSyxDQUFDc04sUUFBTixDQUFlbUMsSUFBZixDQUFKLEVBQTBCO0FBQ3hCRyxRQUFBQSxNQUFNLENBQUNwSCxJQUFQLENBQVksVUFBVWlILElBQXRCO0FBQ0Q7O0FBRUQsVUFBSXpQLEtBQUssQ0FBQ3NOLFFBQU4sQ0FBZW9DLE1BQWYsQ0FBSixFQUE0QjtBQUMxQkUsUUFBQUEsTUFBTSxDQUFDcEgsSUFBUCxDQUFZLFlBQVlrSCxNQUF4QjtBQUNEOztBQUVELFVBQUlDLE1BQU0sS0FBSyxJQUFmLEVBQXFCO0FBQ25CQyxRQUFBQSxNQUFNLENBQUNwSCxJQUFQLENBQVksUUFBWjtBQUNEOztBQUVEd0gsTUFBQUEsUUFBUSxDQUFDSixNQUFULEdBQWtCQSxNQUFNLENBQUNULElBQVAsQ0FBWSxJQUFaLENBQWxCO0FBQ0QsS0F0Qkk7QUF3QkxsTCxJQUFBQSxJQUFJLEVBQUUsU0FBU0EsSUFBVCxDQUFjK0csSUFBZCxFQUFvQjtBQUN4QixVQUFJaUYsS0FBSyxHQUFHRCxRQUFRLENBQUNKLE1BQVQsQ0FBZ0JLLEtBQWhCLENBQXNCLElBQUlDLE1BQUosQ0FBVyxlQUFlbEYsSUFBZixHQUFzQixXQUFqQyxDQUF0QixDQUFaO0FBQ0EsYUFBUWlGLEtBQUssR0FBR0Usa0JBQWtCLENBQUNGLEtBQUssQ0FBQyxDQUFELENBQU4sQ0FBckIsR0FBa0MsSUFBL0M7QUFDRCxLQTNCSTtBQTZCTEcsSUFBQUEsTUFBTSxFQUFFLFNBQVNBLE1BQVQsQ0FBZ0JwRixJQUFoQixFQUFzQjtBQUM1QixXQUFLdUUsS0FBTCxDQUFXdkUsSUFBWCxFQUFpQixFQUFqQixFQUFxQjhFLElBQUksQ0FBQ08sR0FBTCxLQUFhLFFBQWxDO0FBQ0Q7QUEvQkksR0FBUDtBQWlDRCxDQWxDRCxFQUhGLEdBdUNBO0FBQ0csU0FBU0MscUJBQVQsR0FBaUM7QUFDaEMsU0FBTztBQUNMZixJQUFBQSxLQUFLLEVBQUUsU0FBU0EsS0FBVCxHQUFpQixDQUFFLENBRHJCO0FBRUx0TCxJQUFBQSxJQUFJLEVBQUUsU0FBU0EsSUFBVCxHQUFnQjtBQUFFLGFBQU8sSUFBUDtBQUFjLEtBRmpDO0FBR0xtTSxJQUFBQSxNQUFNLEVBQUUsU0FBU0EsTUFBVCxHQUFrQixDQUFFO0FBSHZCLEdBQVA7QUFLRCxDQU5ELEVBekNKOzs7Ozs7Ozs7O0FDSmE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0FyUSxNQUFNLENBQUM1QixPQUFQLEdBQWlCLFNBQVM0TCxhQUFULENBQXVCaEksR0FBdkIsRUFBNEI7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsU0FBTyxnQ0FBZ0N3TyxJQUFoQyxDQUFxQ3hPLEdBQXJDLENBQVA7QUFDRCxDQUxEOzs7Ozs7Ozs7O0FDUmE7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUFDQWhDLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBU3FJLFlBQVQsQ0FBc0JnSyxPQUF0QixFQUErQjtBQUM5QyxTQUFRLFFBQU9BLE9BQVAsTUFBbUIsUUFBcEIsSUFBa0NBLE9BQU8sQ0FBQ2hLLFlBQVIsS0FBeUIsSUFBbEU7QUFDRCxDQUZEOzs7Ozs7Ozs7O0FDUmE7O0FBRWIsSUFBSXhHLEtBQUssR0FBRzFCLG1CQUFPLENBQUMscURBQUQsQ0FBbkI7O0FBRUF5QixNQUFNLENBQUM1QixPQUFQLEdBQ0U2QixLQUFLLENBQUM2RCxvQkFBTixLQUVBO0FBQ0E7QUFDRyxTQUFTeUwsa0JBQVQsR0FBOEI7QUFDN0IsTUFBSW1CLElBQUksR0FBRyxrQkFBa0JGLElBQWxCLENBQXVCRyxTQUFTLENBQUNDLFNBQWpDLENBQVg7QUFDQSxNQUFJQyxjQUFjLEdBQUdaLFFBQVEsQ0FBQ2EsYUFBVCxDQUF1QixHQUF2QixDQUFyQjtBQUNBLE1BQUlDLFNBQUo7QUFFQTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ00sV0FBU0MsVUFBVCxDQUFvQmhQLEdBQXBCLEVBQXlCO0FBQ3ZCLFFBQUlpUCxJQUFJLEdBQUdqUCxHQUFYOztBQUVBLFFBQUkwTyxJQUFKLEVBQVU7QUFDVjtBQUNFRyxNQUFBQSxjQUFjLENBQUNLLFlBQWYsQ0FBNEIsTUFBNUIsRUFBb0NELElBQXBDO0FBQ0FBLE1BQUFBLElBQUksR0FBR0osY0FBYyxDQUFDSSxJQUF0QjtBQUNEOztBQUVESixJQUFBQSxjQUFjLENBQUNLLFlBQWYsQ0FBNEIsTUFBNUIsRUFBb0NELElBQXBDLEVBVHVCLENBV3ZCOztBQUNBLFdBQU87QUFDTEEsTUFBQUEsSUFBSSxFQUFFSixjQUFjLENBQUNJLElBRGhCO0FBRUxFLE1BQUFBLFFBQVEsRUFBRU4sY0FBYyxDQUFDTSxRQUFmLEdBQTBCTixjQUFjLENBQUNNLFFBQWYsQ0FBd0I5SCxPQUF4QixDQUFnQyxJQUFoQyxFQUFzQyxFQUF0QyxDQUExQixHQUFzRSxFQUYzRTtBQUdMK0gsTUFBQUEsSUFBSSxFQUFFUCxjQUFjLENBQUNPLElBSGhCO0FBSUxDLE1BQUFBLE1BQU0sRUFBRVIsY0FBYyxDQUFDUSxNQUFmLEdBQXdCUixjQUFjLENBQUNRLE1BQWYsQ0FBc0JoSSxPQUF0QixDQUE4QixLQUE5QixFQUFxQyxFQUFyQyxDQUF4QixHQUFtRSxFQUp0RTtBQUtMaEssTUFBQUEsSUFBSSxFQUFFd1IsY0FBYyxDQUFDeFIsSUFBZixHQUFzQndSLGNBQWMsQ0FBQ3hSLElBQWYsQ0FBb0JnSyxPQUFwQixDQUE0QixJQUE1QixFQUFrQyxFQUFsQyxDQUF0QixHQUE4RCxFQUwvRDtBQU1MaUksTUFBQUEsUUFBUSxFQUFFVCxjQUFjLENBQUNTLFFBTnBCO0FBT0xDLE1BQUFBLElBQUksRUFBRVYsY0FBYyxDQUFDVSxJQVBoQjtBQVFMQyxNQUFBQSxRQUFRLEVBQUdYLGNBQWMsQ0FBQ1csUUFBZixDQUF3QkMsTUFBeEIsQ0FBK0IsQ0FBL0IsTUFBc0MsR0FBdkMsR0FDUlosY0FBYyxDQUFDVyxRQURQLEdBRVIsTUFBTVgsY0FBYyxDQUFDVztBQVZsQixLQUFQO0FBWUQ7O0FBRURULEVBQUFBLFNBQVMsR0FBR0MsVUFBVSxDQUFDVSxNQUFNLENBQUNDLFFBQVAsQ0FBZ0JWLElBQWpCLENBQXRCO0FBRUE7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNNLFNBQU8sU0FBUzFRLGVBQVQsQ0FBeUJxUixVQUF6QixFQUFxQztBQUMxQyxRQUFJQyxNQUFNLEdBQUk1UixLQUFLLENBQUNzTixRQUFOLENBQWVxRSxVQUFmLENBQUQsR0FBK0JaLFVBQVUsQ0FBQ1ksVUFBRCxDQUF6QyxHQUF3REEsVUFBckU7QUFDQSxXQUFRQyxNQUFNLENBQUNWLFFBQVAsS0FBb0JKLFNBQVMsQ0FBQ0ksUUFBOUIsSUFDSlUsTUFBTSxDQUFDVCxJQUFQLEtBQWdCTCxTQUFTLENBQUNLLElBRDlCO0FBRUQsR0FKRDtBQUtELENBbERELEVBSkYsR0F3REE7QUFDRyxTQUFTYixxQkFBVCxHQUFpQztBQUNoQyxTQUFPLFNBQVNoUSxlQUFULEdBQTJCO0FBQ2hDLFdBQU8sSUFBUDtBQUNELEdBRkQ7QUFHRCxDQUpELEVBMURKOzs7Ozs7Ozs7O0FDSmE7O0FBRWIsSUFBSU4sS0FBSyxHQUFHMUIsbUJBQU8sQ0FBQyxtREFBRCxDQUFuQjs7QUFFQXlCLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBUzBPLG1CQUFULENBQTZCNUwsT0FBN0IsRUFBc0M0USxjQUF0QyxFQUFzRDtBQUNyRTdSLEVBQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBY25ELE9BQWQsRUFBdUIsU0FBUzZRLGFBQVQsQ0FBdUIxVCxLQUF2QixFQUE4QjRNLElBQTlCLEVBQW9DO0FBQ3pELFFBQUlBLElBQUksS0FBSzZHLGNBQVQsSUFBMkI3RyxJQUFJLENBQUM5SSxXQUFMLE9BQXVCMlAsY0FBYyxDQUFDM1AsV0FBZixFQUF0RCxFQUFvRjtBQUNsRmpCLE1BQUFBLE9BQU8sQ0FBQzRRLGNBQUQsQ0FBUCxHQUEwQnpULEtBQTFCO0FBQ0EsYUFBTzZDLE9BQU8sQ0FBQytKLElBQUQsQ0FBZDtBQUNEO0FBQ0YsR0FMRDtBQU1ELENBUEQ7Ozs7Ozs7Ozs7QUNKYTs7QUFFYixJQUFJaEwsS0FBSyxHQUFHMUIsbUJBQU8sQ0FBQyxxREFBRCxDQUFuQixFQUVBO0FBQ0E7OztBQUNBLElBQUl5VCxpQkFBaUIsR0FBRyxDQUN0QixLQURzQixFQUNmLGVBRGUsRUFDRSxnQkFERixFQUNvQixjQURwQixFQUNvQyxNQURwQyxFQUV0QixTQUZzQixFQUVYLE1BRlcsRUFFSCxNQUZHLEVBRUssbUJBRkwsRUFFMEIscUJBRjFCLEVBR3RCLGVBSHNCLEVBR0wsVUFISyxFQUdPLGNBSFAsRUFHdUIscUJBSHZCLEVBSXRCLFNBSnNCLEVBSVgsYUFKVyxFQUlJLFlBSkosQ0FBeEI7QUFPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQWhTLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBU2tDLFlBQVQsQ0FBc0JZLE9BQXRCLEVBQStCO0FBQzlDLE1BQUkyUSxNQUFNLEdBQUcsRUFBYjtBQUNBLE1BQUlyTixHQUFKO0FBQ0EsTUFBSUQsR0FBSjtBQUNBLE1BQUlxSyxDQUFKOztBQUVBLE1BQUksQ0FBQzFOLE9BQUwsRUFBYztBQUFFLFdBQU8yUSxNQUFQO0FBQWdCOztBQUVoQzVSLEVBQUFBLEtBQUssQ0FBQ29FLE9BQU4sQ0FBY25ELE9BQU8sQ0FBQytRLEtBQVIsQ0FBYyxJQUFkLENBQWQsRUFBbUMsU0FBUzVFLE1BQVQsQ0FBZ0I2RSxJQUFoQixFQUFzQjtBQUN2RHRELElBQUFBLENBQUMsR0FBR3NELElBQUksQ0FBQy9PLE9BQUwsQ0FBYSxHQUFiLENBQUo7QUFDQXFCLElBQUFBLEdBQUcsR0FBR3ZFLEtBQUssQ0FBQ3lOLElBQU4sQ0FBV3dFLElBQUksQ0FBQ0MsTUFBTCxDQUFZLENBQVosRUFBZXZELENBQWYsQ0FBWCxFQUE4Qm5LLFdBQTlCLEVBQU47QUFDQUYsSUFBQUEsR0FBRyxHQUFHdEUsS0FBSyxDQUFDeU4sSUFBTixDQUFXd0UsSUFBSSxDQUFDQyxNQUFMLENBQVl2RCxDQUFDLEdBQUcsQ0FBaEIsQ0FBWCxDQUFOOztBQUVBLFFBQUlwSyxHQUFKLEVBQVM7QUFDUCxVQUFJcU4sTUFBTSxDQUFDck4sR0FBRCxDQUFOLElBQWV3TixpQkFBaUIsQ0FBQzdPLE9BQWxCLENBQTBCcUIsR0FBMUIsS0FBa0MsQ0FBckQsRUFBd0Q7QUFDdEQ7QUFDRDs7QUFDRCxVQUFJQSxHQUFHLEtBQUssWUFBWixFQUEwQjtBQUN4QnFOLFFBQUFBLE1BQU0sQ0FBQ3JOLEdBQUQsQ0FBTixHQUFjLENBQUNxTixNQUFNLENBQUNyTixHQUFELENBQU4sR0FBY3FOLE1BQU0sQ0FBQ3JOLEdBQUQsQ0FBcEIsR0FBNEIsRUFBN0IsRUFBaUNxRSxNQUFqQyxDQUF3QyxDQUFDdEUsR0FBRCxDQUF4QyxDQUFkO0FBQ0QsT0FGRCxNQUVPO0FBQ0xzTixRQUFBQSxNQUFNLENBQUNyTixHQUFELENBQU4sR0FBY3FOLE1BQU0sQ0FBQ3JOLEdBQUQsQ0FBTixHQUFjcU4sTUFBTSxDQUFDck4sR0FBRCxDQUFOLEdBQWMsSUFBZCxHQUFxQkQsR0FBbkMsR0FBeUNBLEdBQXZEO0FBQ0Q7QUFDRjtBQUNGLEdBZkQ7QUFpQkEsU0FBT3NOLE1BQVA7QUFDRCxDQTFCRDs7Ozs7Ozs7OztBQzFCYTtBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E3UixNQUFNLENBQUM1QixPQUFQLEdBQWlCLFNBQVNvSSxNQUFULENBQWdCNEwsUUFBaEIsRUFBMEI7QUFDekMsU0FBTyxTQUFTMUQsSUFBVCxDQUFjMkQsR0FBZCxFQUFtQjtBQUN4QixXQUFPRCxRQUFRLENBQUN4SixLQUFULENBQWUsSUFBZixFQUFxQnlKLEdBQXJCLENBQVA7QUFDRCxHQUZEO0FBR0QsQ0FKRDs7Ozs7Ozs7OztBQ3RCYTs7OztBQUViLElBQUlDLEdBQUcsR0FBRy9ULG1CQUFPLENBQUMsK0RBQUQsQ0FBakI7O0FBRUEsSUFBSWlKLFVBQVUsR0FBRyxFQUFqQixFQUVBOztBQUNBLENBQUMsUUFBRCxFQUFXLFNBQVgsRUFBc0IsUUFBdEIsRUFBZ0MsVUFBaEMsRUFBNEMsUUFBNUMsRUFBc0QsUUFBdEQsRUFBZ0VuRCxPQUFoRSxDQUF3RSxVQUFTa08sSUFBVCxFQUFlM0QsQ0FBZixFQUFrQjtBQUN4RnBILEVBQUFBLFVBQVUsQ0FBQytLLElBQUQsQ0FBVixHQUFtQixTQUFTaEwsU0FBVCxDQUFtQmlMLEtBQW5CLEVBQTBCO0FBQzNDLFdBQU8sUUFBT0EsS0FBUCxNQUFpQkQsSUFBakIsSUFBeUIsT0FBTzNELENBQUMsR0FBRyxDQUFKLEdBQVEsSUFBUixHQUFlLEdBQXRCLElBQTZCMkQsSUFBN0Q7QUFDRCxHQUZEO0FBR0QsQ0FKRDtBQU1BLElBQUlFLGtCQUFrQixHQUFHLEVBQXpCO0FBQ0EsSUFBSUMsYUFBYSxHQUFHSixHQUFHLENBQUNLLE9BQUosQ0FBWVYsS0FBWixDQUFrQixHQUFsQixDQUFwQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxTQUFTVyxjQUFULENBQXdCRCxPQUF4QixFQUFpQ0UsV0FBakMsRUFBOEM7QUFDNUMsTUFBSUMsYUFBYSxHQUFHRCxXQUFXLEdBQUdBLFdBQVcsQ0FBQ1osS0FBWixDQUFrQixHQUFsQixDQUFILEdBQTRCUyxhQUEzRDtBQUNBLE1BQUlLLE9BQU8sR0FBR0osT0FBTyxDQUFDVixLQUFSLENBQWMsR0FBZCxDQUFkOztBQUNBLE9BQUssSUFBSXJELENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsQ0FBcEIsRUFBdUJBLENBQUMsRUFBeEIsRUFBNEI7QUFDMUIsUUFBSWtFLGFBQWEsQ0FBQ2xFLENBQUQsQ0FBYixHQUFtQm1FLE9BQU8sQ0FBQ25FLENBQUQsQ0FBOUIsRUFBbUM7QUFDakMsYUFBTyxJQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlrRSxhQUFhLENBQUNsRSxDQUFELENBQWIsR0FBbUJtRSxPQUFPLENBQUNuRSxDQUFELENBQTlCLEVBQW1DO0FBQ3hDLGFBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBQ0QsU0FBTyxLQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FwSCxVQUFVLENBQUM1RCxZQUFYLEdBQTBCLFNBQVNBLFlBQVQsQ0FBc0IyRCxTQUF0QixFQUFpQ29MLE9BQWpDLEVBQTBDak0sT0FBMUMsRUFBbUQ7QUFDM0UsTUFBSXNNLFlBQVksR0FBR0wsT0FBTyxJQUFJQyxjQUFjLENBQUNELE9BQUQsQ0FBNUM7O0FBRUEsV0FBU00sYUFBVCxDQUF1QkMsR0FBdkIsRUFBNEJDLElBQTVCLEVBQWtDO0FBQ2hDLFdBQU8sYUFBYWIsR0FBRyxDQUFDSyxPQUFqQixHQUEyQiwwQkFBM0IsR0FBd0RPLEdBQXhELEdBQThELElBQTlELEdBQXFFQyxJQUFyRSxJQUE2RXpNLE9BQU8sR0FBRyxPQUFPQSxPQUFWLEdBQW9CLEVBQXhHLENBQVA7QUFDRCxHQUwwRSxDQU8zRTs7O0FBQ0EsU0FBTyxVQUFTckksS0FBVCxFQUFnQjZVLEdBQWhCLEVBQXFCRSxJQUFyQixFQUEyQjtBQUNoQyxRQUFJN0wsU0FBUyxLQUFLLEtBQWxCLEVBQXlCO0FBQ3ZCLFlBQU0sSUFBSXpILEtBQUosQ0FBVW1ULGFBQWEsQ0FBQ0MsR0FBRCxFQUFNLDBCQUEwQlAsT0FBaEMsQ0FBdkIsQ0FBTjtBQUNEOztBQUVELFFBQUlLLFlBQVksSUFBSSxDQUFDUCxrQkFBa0IsQ0FBQ1MsR0FBRCxDQUF2QyxFQUE4QztBQUM1Q1QsTUFBQUEsa0JBQWtCLENBQUNTLEdBQUQsQ0FBbEIsR0FBMEIsSUFBMUIsQ0FENEMsQ0FFNUM7O0FBQ0FHLE1BQUFBLE9BQU8sQ0FBQ0MsSUFBUixDQUNFTCxhQUFhLENBQ1hDLEdBRFcsRUFFWCxpQ0FBaUNQLE9BQWpDLEdBQTJDLHlDQUZoQyxDQURmO0FBTUQ7O0FBRUQsV0FBT3BMLFNBQVMsR0FBR0EsU0FBUyxDQUFDbEosS0FBRCxFQUFRNlUsR0FBUixFQUFhRSxJQUFiLENBQVosR0FBaUMsSUFBakQ7QUFDRCxHQWpCRDtBQWtCRCxDQTFCRDtBQTRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFNBQVN6TCxhQUFULENBQXVCK0IsT0FBdkIsRUFBZ0M2SixNQUFoQyxFQUF3Q0MsWUFBeEMsRUFBc0Q7QUFDcEQsTUFBSSxRQUFPOUosT0FBUCxNQUFtQixRQUF2QixFQUFpQztBQUMvQixVQUFNLElBQUk3QyxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUNELE1BQUkyRixJQUFJLEdBQUd0TyxNQUFNLENBQUNzTyxJQUFQLENBQVk5QyxPQUFaLENBQVg7QUFDQSxNQUFJa0YsQ0FBQyxHQUFHcEMsSUFBSSxDQUFDMUQsTUFBYjs7QUFDQSxTQUFPOEYsQ0FBQyxLQUFLLENBQWIsRUFBZ0I7QUFDZCxRQUFJc0UsR0FBRyxHQUFHMUcsSUFBSSxDQUFDb0MsQ0FBRCxDQUFkO0FBQ0EsUUFBSXJILFNBQVMsR0FBR2dNLE1BQU0sQ0FBQ0wsR0FBRCxDQUF0Qjs7QUFDQSxRQUFJM0wsU0FBSixFQUFlO0FBQ2IsVUFBSWxKLEtBQUssR0FBR3FMLE9BQU8sQ0FBQ3dKLEdBQUQsQ0FBbkI7QUFDQSxVQUFJTyxNQUFNLEdBQUdwVixLQUFLLEtBQUs4RixTQUFWLElBQXVCb0QsU0FBUyxDQUFDbEosS0FBRCxFQUFRNlUsR0FBUixFQUFheEosT0FBYixDQUE3Qzs7QUFDQSxVQUFJK0osTUFBTSxLQUFLLElBQWYsRUFBcUI7QUFDbkIsY0FBTSxJQUFJNU0sU0FBSixDQUFjLFlBQVlxTSxHQUFaLEdBQWtCLFdBQWxCLEdBQWdDTyxNQUE5QyxDQUFOO0FBQ0Q7O0FBQ0Q7QUFDRDs7QUFDRCxRQUFJRCxZQUFZLEtBQUssSUFBckIsRUFBMkI7QUFDekIsWUFBTTFULEtBQUssQ0FBQyxvQkFBb0JvVCxHQUFyQixDQUFYO0FBQ0Q7QUFDRjtBQUNGOztBQUVEbFQsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQjtBQUNmd1UsRUFBQUEsY0FBYyxFQUFFQSxjQUREO0FBRWZqTCxFQUFBQSxhQUFhLEVBQUVBLGFBRkE7QUFHZkgsRUFBQUEsVUFBVSxFQUFFQTtBQUhHLENBQWpCOzs7Ozs7Ozs7O0FDcEdhOzs7O0FBRWIsSUFBSWxDLElBQUksR0FBRy9HLG1CQUFPLENBQUMsZ0VBQUQsQ0FBbEIsRUFFQTs7O0FBRUEsSUFBSVcsUUFBUSxHQUFHaEIsTUFBTSxDQUFDNEgsU0FBUCxDQUFpQjVHLFFBQWhDO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBLFNBQVMrTSxPQUFULENBQWlCMUgsR0FBakIsRUFBc0I7QUFDcEIsU0FBT3JGLFFBQVEsQ0FBQ3FMLElBQVQsQ0FBY2hHLEdBQWQsTUFBdUIsZ0JBQTlCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNHLFdBQVQsQ0FBcUJILEdBQXJCLEVBQTBCO0FBQ3hCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFdBQXRCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN1SixRQUFULENBQWtCdkosR0FBbEIsRUFBdUI7QUFDckIsU0FBT0EsR0FBRyxLQUFLLElBQVIsSUFBZ0IsQ0FBQ0csV0FBVyxDQUFDSCxHQUFELENBQTVCLElBQXFDQSxHQUFHLENBQUNtUCxXQUFKLEtBQW9CLElBQXpELElBQWlFLENBQUNoUCxXQUFXLENBQUNILEdBQUcsQ0FBQ21QLFdBQUwsQ0FBN0UsSUFDRixPQUFPblAsR0FBRyxDQUFDbVAsV0FBSixDQUFnQjVGLFFBQXZCLEtBQW9DLFVBRGxDLElBQ2dEdkosR0FBRyxDQUFDbVAsV0FBSixDQUFnQjVGLFFBQWhCLENBQXlCdkosR0FBekIsQ0FEdkQ7QUFFRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3NKLGFBQVQsQ0FBdUJ0SixHQUF2QixFQUE0QjtBQUMxQixTQUFPckYsUUFBUSxDQUFDcUwsSUFBVCxDQUFjaEcsR0FBZCxNQUF1QixzQkFBOUI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU25ELFVBQVQsQ0FBb0JtRCxHQUFwQixFQUF5QjtBQUN2QixTQUFRLE9BQU9vUCxRQUFQLEtBQW9CLFdBQXJCLElBQXNDcFAsR0FBRyxZQUFZb1AsUUFBNUQ7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3pGLGlCQUFULENBQTJCM0osR0FBM0IsRUFBZ0M7QUFDOUIsTUFBSWtQLE1BQUo7O0FBQ0EsTUFBSyxPQUFPRyxXQUFQLEtBQXVCLFdBQXhCLElBQXlDQSxXQUFXLENBQUNDLE1BQXpELEVBQWtFO0FBQ2hFSixJQUFBQSxNQUFNLEdBQUdHLFdBQVcsQ0FBQ0MsTUFBWixDQUFtQnRQLEdBQW5CLENBQVQ7QUFDRCxHQUZELE1BRU87QUFDTGtQLElBQUFBLE1BQU0sR0FBSWxQLEdBQUQsSUFBVUEsR0FBRyxDQUFDNEosTUFBZCxJQUEwQjVKLEdBQUcsQ0FBQzRKLE1BQUosWUFBc0J5RixXQUF6RDtBQUNEOztBQUNELFNBQU9ILE1BQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU2xHLFFBQVQsQ0FBa0JoSixHQUFsQixFQUF1QjtBQUNyQixTQUFPLE9BQU9BLEdBQVAsS0FBZSxRQUF0QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTdUwsUUFBVCxDQUFrQnZMLEdBQWxCLEVBQXVCO0FBQ3JCLFNBQU8sT0FBT0EsR0FBUCxLQUFlLFFBQXRCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM4SixRQUFULENBQWtCOUosR0FBbEIsRUFBdUI7QUFDckIsU0FBT0EsR0FBRyxLQUFLLElBQVIsSUFBZ0IsUUFBT0EsR0FBUCxNQUFlLFFBQXRDO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN5SCxhQUFULENBQXVCekgsR0FBdkIsRUFBNEI7QUFDMUIsTUFBSXJGLFFBQVEsQ0FBQ3FMLElBQVQsQ0FBY2hHLEdBQWQsTUFBdUIsaUJBQTNCLEVBQThDO0FBQzVDLFdBQU8sS0FBUDtBQUNEOztBQUVELE1BQUl1QixTQUFTLEdBQUc1SCxNQUFNLENBQUM0VixjQUFQLENBQXNCdlAsR0FBdEIsQ0FBaEI7QUFDQSxTQUFPdUIsU0FBUyxLQUFLLElBQWQsSUFBc0JBLFNBQVMsS0FBSzVILE1BQU0sQ0FBQzRILFNBQWxEO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNvSixNQUFULENBQWdCM0ssR0FBaEIsRUFBcUI7QUFDbkIsU0FBT3JGLFFBQVEsQ0FBQ3FMLElBQVQsQ0FBY2hHLEdBQWQsTUFBdUIsZUFBOUI7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU3lKLE1BQVQsQ0FBZ0J6SixHQUFoQixFQUFxQjtBQUNuQixTQUFPckYsUUFBUSxDQUFDcUwsSUFBVCxDQUFjaEcsR0FBZCxNQUF1QixlQUE5QjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTMEosTUFBVCxDQUFnQjFKLEdBQWhCLEVBQXFCO0FBQ25CLFNBQU9yRixRQUFRLENBQUNxTCxJQUFULENBQWNoRyxHQUFkLE1BQXVCLGVBQTlCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN3UCxVQUFULENBQW9CeFAsR0FBcEIsRUFBeUI7QUFDdkIsU0FBT3JGLFFBQVEsQ0FBQ3FMLElBQVQsQ0FBY2hHLEdBQWQsTUFBdUIsbUJBQTlCO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN3SixRQUFULENBQWtCeEosR0FBbEIsRUFBdUI7QUFDckIsU0FBTzhKLFFBQVEsQ0FBQzlKLEdBQUQsQ0FBUixJQUFpQndQLFVBQVUsQ0FBQ3hQLEdBQUcsQ0FBQ3lQLElBQUwsQ0FBbEM7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBUzVGLGlCQUFULENBQTJCN0osR0FBM0IsRUFBZ0M7QUFDOUIsU0FBTyxPQUFPMFAsZUFBUCxLQUEyQixXQUEzQixJQUEwQzFQLEdBQUcsWUFBWTBQLGVBQWhFO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN2RyxJQUFULENBQWN3RyxHQUFkLEVBQW1CO0FBQ2pCLFNBQU9BLEdBQUcsQ0FBQ3hHLElBQUosR0FBV3dHLEdBQUcsQ0FBQ3hHLElBQUosRUFBWCxHQUF3QndHLEdBQUcsQ0FBQzdLLE9BQUosQ0FBWSxZQUFaLEVBQTBCLEVBQTFCLENBQS9CO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVN2RixvQkFBVCxHQUFnQztBQUM5QixNQUFJLE9BQU82TSxTQUFQLEtBQXFCLFdBQXJCLEtBQXFDQSxTQUFTLENBQUN3RCxPQUFWLEtBQXNCLGFBQXRCLElBQ0F4RCxTQUFTLENBQUN3RCxPQUFWLEtBQXNCLGNBRHRCLElBRUF4RCxTQUFTLENBQUN3RCxPQUFWLEtBQXNCLElBRjNELENBQUosRUFFc0U7QUFDcEUsV0FBTyxLQUFQO0FBQ0Q7O0FBQ0QsU0FDRSxPQUFPekMsTUFBUCxLQUFrQixXQUFsQixJQUNBLE9BQU96QixRQUFQLEtBQW9CLFdBRnRCO0FBSUQ7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVM1TCxPQUFULENBQWlCK1AsR0FBakIsRUFBc0J2SyxFQUF0QixFQUEwQjtBQUN4QjtBQUNBLE1BQUl1SyxHQUFHLEtBQUssSUFBUixJQUFnQixPQUFPQSxHQUFQLEtBQWUsV0FBbkMsRUFBZ0Q7QUFDOUM7QUFDRCxHQUp1QixDQU14Qjs7O0FBQ0EsTUFBSSxRQUFPQSxHQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDM0I7QUFDQUEsSUFBQUEsR0FBRyxHQUFHLENBQUNBLEdBQUQsQ0FBTjtBQUNEOztBQUVELE1BQUluSSxPQUFPLENBQUNtSSxHQUFELENBQVgsRUFBa0I7QUFDaEI7QUFDQSxTQUFLLElBQUl4RixDQUFDLEdBQUcsQ0FBUixFQUFXeUYsQ0FBQyxHQUFHRCxHQUFHLENBQUN0TCxNQUF4QixFQUFnQzhGLENBQUMsR0FBR3lGLENBQXBDLEVBQXVDekYsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQy9FLE1BQUFBLEVBQUUsQ0FBQ1UsSUFBSCxDQUFRLElBQVIsRUFBYzZKLEdBQUcsQ0FBQ3hGLENBQUQsQ0FBakIsRUFBc0JBLENBQXRCLEVBQXlCd0YsR0FBekI7QUFDRDtBQUNGLEdBTEQsTUFLTztBQUNMO0FBQ0EsU0FBSyxJQUFJNVAsR0FBVCxJQUFnQjRQLEdBQWhCLEVBQXFCO0FBQ25CLFVBQUlsVyxNQUFNLENBQUM0SCxTQUFQLENBQWlCd08sY0FBakIsQ0FBZ0MvSixJQUFoQyxDQUFxQzZKLEdBQXJDLEVBQTBDNVAsR0FBMUMsQ0FBSixFQUFvRDtBQUNsRHFGLFFBQUFBLEVBQUUsQ0FBQ1UsSUFBSCxDQUFRLElBQVIsRUFBYzZKLEdBQUcsQ0FBQzVQLEdBQUQsQ0FBakIsRUFBd0JBLEdBQXhCLEVBQTZCNFAsR0FBN0I7QUFDRDtBQUNGO0FBQ0Y7QUFDRjtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBO0FBQWU7QUFBTjNKLEtBQVQsR0FBNEM7QUFDMUMsTUFBSWdKLE1BQU0sR0FBRyxFQUFiOztBQUNBLFdBQVNjLFdBQVQsQ0FBcUJoUSxHQUFyQixFQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsUUFBSXdILGFBQWEsQ0FBQ3lILE1BQU0sQ0FBQ2pQLEdBQUQsQ0FBUCxDQUFiLElBQThCd0gsYUFBYSxDQUFDekgsR0FBRCxDQUEvQyxFQUFzRDtBQUNwRGtQLE1BQUFBLE1BQU0sQ0FBQ2pQLEdBQUQsQ0FBTixHQUFjaUcsS0FBSyxDQUFDZ0osTUFBTSxDQUFDalAsR0FBRCxDQUFQLEVBQWNELEdBQWQsQ0FBbkI7QUFDRCxLQUZELE1BRU8sSUFBSXlILGFBQWEsQ0FBQ3pILEdBQUQsQ0FBakIsRUFBd0I7QUFDN0JrUCxNQUFBQSxNQUFNLENBQUNqUCxHQUFELENBQU4sR0FBY2lHLEtBQUssQ0FBQyxFQUFELEVBQUtsRyxHQUFMLENBQW5CO0FBQ0QsS0FGTSxNQUVBLElBQUkwSCxPQUFPLENBQUMxSCxHQUFELENBQVgsRUFBa0I7QUFDdkJrUCxNQUFBQSxNQUFNLENBQUNqUCxHQUFELENBQU4sR0FBY0QsR0FBRyxDQUFDbkYsS0FBSixFQUFkO0FBQ0QsS0FGTSxNQUVBO0FBQ0xxVSxNQUFBQSxNQUFNLENBQUNqUCxHQUFELENBQU4sR0FBY0QsR0FBZDtBQUNEO0FBQ0Y7O0FBRUQsT0FBSyxJQUFJcUssQ0FBQyxHQUFHLENBQVIsRUFBV3lGLENBQUMsR0FBRzNNLFNBQVMsQ0FBQ29CLE1BQTlCLEVBQXNDOEYsQ0FBQyxHQUFHeUYsQ0FBMUMsRUFBNkN6RixDQUFDLEVBQTlDLEVBQWtEO0FBQ2hEdkssSUFBQUEsT0FBTyxDQUFDcUQsU0FBUyxDQUFDa0gsQ0FBRCxDQUFWLEVBQWUyRixXQUFmLENBQVA7QUFDRDs7QUFDRCxTQUFPZCxNQUFQO0FBQ0Q7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTMU4sTUFBVCxDQUFnQnlPLENBQWhCLEVBQW1CQyxDQUFuQixFQUFzQmhHLE9BQXRCLEVBQStCO0FBQzdCcEssRUFBQUEsT0FBTyxDQUFDb1EsQ0FBRCxFQUFJLFNBQVNGLFdBQVQsQ0FBcUJoUSxHQUFyQixFQUEwQkMsR0FBMUIsRUFBK0I7QUFDeEMsUUFBSWlLLE9BQU8sSUFBSSxPQUFPbEssR0FBUCxLQUFlLFVBQTlCLEVBQTBDO0FBQ3hDaVEsTUFBQUEsQ0FBQyxDQUFDaFEsR0FBRCxDQUFELEdBQVNjLElBQUksQ0FBQ2YsR0FBRCxFQUFNa0ssT0FBTixDQUFiO0FBQ0QsS0FGRCxNQUVPO0FBQ0wrRixNQUFBQSxDQUFDLENBQUNoUSxHQUFELENBQUQsR0FBU0QsR0FBVDtBQUNEO0FBQ0YsR0FOTSxDQUFQO0FBT0EsU0FBT2lRLENBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0UsUUFBVCxDQUFrQkMsT0FBbEIsRUFBMkI7QUFDekIsTUFBSUEsT0FBTyxDQUFDQyxVQUFSLENBQW1CLENBQW5CLE1BQTBCLE1BQTlCLEVBQXNDO0FBQ3BDRCxJQUFBQSxPQUFPLEdBQUdBLE9BQU8sQ0FBQ3ZWLEtBQVIsQ0FBYyxDQUFkLENBQVY7QUFDRDs7QUFDRCxTQUFPdVYsT0FBUDtBQUNEOztBQUVEM1UsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQjtBQUNmNk4sRUFBQUEsT0FBTyxFQUFFQSxPQURNO0FBRWY0QixFQUFBQSxhQUFhLEVBQUVBLGFBRkE7QUFHZkMsRUFBQUEsUUFBUSxFQUFFQSxRQUhLO0FBSWYxTSxFQUFBQSxVQUFVLEVBQUVBLFVBSkc7QUFLZjhNLEVBQUFBLGlCQUFpQixFQUFFQSxpQkFMSjtBQU1mWCxFQUFBQSxRQUFRLEVBQUVBLFFBTks7QUFPZnVDLEVBQUFBLFFBQVEsRUFBRUEsUUFQSztBQVFmekIsRUFBQUEsUUFBUSxFQUFFQSxRQVJLO0FBU2ZyQyxFQUFBQSxhQUFhLEVBQUVBLGFBVEE7QUFVZnRILEVBQUFBLFdBQVcsRUFBRUEsV0FWRTtBQVdmd0ssRUFBQUEsTUFBTSxFQUFFQSxNQVhPO0FBWWZsQixFQUFBQSxNQUFNLEVBQUVBLE1BWk87QUFhZkMsRUFBQUEsTUFBTSxFQUFFQSxNQWJPO0FBY2Y4RixFQUFBQSxVQUFVLEVBQUVBLFVBZEc7QUFlZmhHLEVBQUFBLFFBQVEsRUFBRUEsUUFmSztBQWdCZkssRUFBQUEsaUJBQWlCLEVBQUVBLGlCQWhCSjtBQWlCZnRLLEVBQUFBLG9CQUFvQixFQUFFQSxvQkFqQlA7QUFrQmZPLEVBQUFBLE9BQU8sRUFBRUEsT0FsQk07QUFtQmZvRyxFQUFBQSxLQUFLLEVBQUVBLEtBbkJRO0FBb0JmMUUsRUFBQUEsTUFBTSxFQUFFQSxNQXBCTztBQXFCZjJILEVBQUFBLElBQUksRUFBRUEsSUFyQlM7QUFzQmZnSCxFQUFBQSxRQUFRLEVBQUVBO0FBdEJLLENBQWpCOzs7Ozs7Ozs7O0FDclVBOztBQUVBdFcsa0JBQUEsR0FBcUJ5VyxVQUFyQjtBQUNBelcsbUJBQUEsR0FBc0IwVyxXQUF0QjtBQUNBMVcscUJBQUEsR0FBd0IyVyxhQUF4QjtBQUVBLElBQUlDLE1BQU0sR0FBRyxFQUFiO0FBQ0EsSUFBSUMsU0FBUyxHQUFHLEVBQWhCO0FBQ0EsSUFBSUMsR0FBRyxHQUFHLE9BQU96VixVQUFQLEtBQXNCLFdBQXRCLEdBQW9DQSxVQUFwQyxHQUFpRGtKLEtBQTNEO0FBRUEsSUFBSXlCLElBQUksR0FBRyxrRUFBWDs7QUFDQSxLQUFLLElBQUl3RSxDQUFDLEdBQUcsQ0FBUixFQUFXdUcsR0FBRyxHQUFHL0ssSUFBSSxDQUFDdEIsTUFBM0IsRUFBbUM4RixDQUFDLEdBQUd1RyxHQUF2QyxFQUE0QyxFQUFFdkcsQ0FBOUMsRUFBaUQ7QUFDL0NvRyxFQUFBQSxNQUFNLENBQUNwRyxDQUFELENBQU4sR0FBWXhFLElBQUksQ0FBQ3dFLENBQUQsQ0FBaEI7QUFDQXFHLEVBQUFBLFNBQVMsQ0FBQzdLLElBQUksQ0FBQ3dLLFVBQUwsQ0FBZ0JoRyxDQUFoQixDQUFELENBQVQsR0FBZ0NBLENBQWhDO0FBQ0QsRUFFRDtBQUNBOzs7QUFDQXFHLFNBQVMsQ0FBQyxJQUFJTCxVQUFKLENBQWUsQ0FBZixDQUFELENBQVQsR0FBK0IsRUFBL0I7QUFDQUssU0FBUyxDQUFDLElBQUlMLFVBQUosQ0FBZSxDQUFmLENBQUQsQ0FBVCxHQUErQixFQUEvQjs7QUFFQSxTQUFTUSxPQUFULENBQWtCQyxHQUFsQixFQUF1QjtBQUNyQixNQUFJRixHQUFHLEdBQUdFLEdBQUcsQ0FBQ3ZNLE1BQWQ7O0FBRUEsTUFBSXFNLEdBQUcsR0FBRyxDQUFOLEdBQVUsQ0FBZCxFQUFpQjtBQUNmLFVBQU0sSUFBSXJWLEtBQUosQ0FBVSxnREFBVixDQUFOO0FBQ0QsR0FMb0IsQ0FPckI7QUFDQTs7O0FBQ0EsTUFBSXdWLFFBQVEsR0FBR0QsR0FBRyxDQUFDbFMsT0FBSixDQUFZLEdBQVosQ0FBZjtBQUNBLE1BQUltUyxRQUFRLEtBQUssQ0FBQyxDQUFsQixFQUFxQkEsUUFBUSxHQUFHSCxHQUFYO0FBRXJCLE1BQUlJLGVBQWUsR0FBR0QsUUFBUSxLQUFLSCxHQUFiLEdBQ2xCLENBRGtCLEdBRWxCLElBQUtHLFFBQVEsR0FBRyxDQUZwQjtBQUlBLFNBQU8sQ0FBQ0EsUUFBRCxFQUFXQyxlQUFYLENBQVA7QUFDRCxFQUVEOzs7QUFDQSxTQUFTVixVQUFULENBQXFCUSxHQUFyQixFQUEwQjtBQUN4QixNQUFJRyxJQUFJLEdBQUdKLE9BQU8sQ0FBQ0MsR0FBRCxDQUFsQjtBQUNBLE1BQUlDLFFBQVEsR0FBR0UsSUFBSSxDQUFDLENBQUQsQ0FBbkI7QUFDQSxNQUFJRCxlQUFlLEdBQUdDLElBQUksQ0FBQyxDQUFELENBQTFCO0FBQ0EsU0FBUSxDQUFDRixRQUFRLEdBQUdDLGVBQVosSUFBK0IsQ0FBL0IsR0FBbUMsQ0FBcEMsR0FBeUNBLGVBQWhEO0FBQ0Q7O0FBRUQsU0FBU0UsV0FBVCxDQUFzQkosR0FBdEIsRUFBMkJDLFFBQTNCLEVBQXFDQyxlQUFyQyxFQUFzRDtBQUNwRCxTQUFRLENBQUNELFFBQVEsR0FBR0MsZUFBWixJQUErQixDQUEvQixHQUFtQyxDQUFwQyxHQUF5Q0EsZUFBaEQ7QUFDRDs7QUFFRCxTQUFTVCxXQUFULENBQXNCTyxHQUF0QixFQUEyQjtBQUN6QixNQUFJSyxHQUFKO0FBQ0EsTUFBSUYsSUFBSSxHQUFHSixPQUFPLENBQUNDLEdBQUQsQ0FBbEI7QUFDQSxNQUFJQyxRQUFRLEdBQUdFLElBQUksQ0FBQyxDQUFELENBQW5CO0FBQ0EsTUFBSUQsZUFBZSxHQUFHQyxJQUFJLENBQUMsQ0FBRCxDQUExQjtBQUVBLE1BQUluRCxHQUFHLEdBQUcsSUFBSTZDLEdBQUosQ0FBUU8sV0FBVyxDQUFDSixHQUFELEVBQU1DLFFBQU4sRUFBZ0JDLGVBQWhCLENBQW5CLENBQVY7QUFFQSxNQUFJSSxPQUFPLEdBQUcsQ0FBZCxDQVJ5QixDQVV6Qjs7QUFDQSxNQUFJUixHQUFHLEdBQUdJLGVBQWUsR0FBRyxDQUFsQixHQUNORCxRQUFRLEdBQUcsQ0FETCxHQUVOQSxRQUZKO0FBSUEsTUFBSTFHLENBQUo7O0FBQ0EsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdUcsR0FBaEIsRUFBcUJ2RyxDQUFDLElBQUksQ0FBMUIsRUFBNkI7QUFDM0I4RyxJQUFBQSxHQUFHLEdBQ0FULFNBQVMsQ0FBQ0ksR0FBRyxDQUFDVCxVQUFKLENBQWVoRyxDQUFmLENBQUQsQ0FBVCxJQUFnQyxFQUFqQyxHQUNDcUcsU0FBUyxDQUFDSSxHQUFHLENBQUNULFVBQUosQ0FBZWhHLENBQUMsR0FBRyxDQUFuQixDQUFELENBQVQsSUFBb0MsRUFEckMsR0FFQ3FHLFNBQVMsQ0FBQ0ksR0FBRyxDQUFDVCxVQUFKLENBQWVoRyxDQUFDLEdBQUcsQ0FBbkIsQ0FBRCxDQUFULElBQW9DLENBRnJDLEdBR0FxRyxTQUFTLENBQUNJLEdBQUcsQ0FBQ1QsVUFBSixDQUFlaEcsQ0FBQyxHQUFHLENBQW5CLENBQUQsQ0FKWDtBQUtBeUQsSUFBQUEsR0FBRyxDQUFDc0QsT0FBTyxFQUFSLENBQUgsR0FBa0JELEdBQUcsSUFBSSxFQUFSLEdBQWMsSUFBL0I7QUFDQXJELElBQUFBLEdBQUcsQ0FBQ3NELE9BQU8sRUFBUixDQUFILEdBQWtCRCxHQUFHLElBQUksQ0FBUixHQUFhLElBQTlCO0FBQ0FyRCxJQUFBQSxHQUFHLENBQUNzRCxPQUFPLEVBQVIsQ0FBSCxHQUFpQkQsR0FBRyxHQUFHLElBQXZCO0FBQ0Q7O0FBRUQsTUFBSUgsZUFBZSxLQUFLLENBQXhCLEVBQTJCO0FBQ3pCRyxJQUFBQSxHQUFHLEdBQ0FULFNBQVMsQ0FBQ0ksR0FBRyxDQUFDVCxVQUFKLENBQWVoRyxDQUFmLENBQUQsQ0FBVCxJQUFnQyxDQUFqQyxHQUNDcUcsU0FBUyxDQUFDSSxHQUFHLENBQUNULFVBQUosQ0FBZWhHLENBQUMsR0FBRyxDQUFuQixDQUFELENBQVQsSUFBb0MsQ0FGdkM7QUFHQXlELElBQUFBLEdBQUcsQ0FBQ3NELE9BQU8sRUFBUixDQUFILEdBQWlCRCxHQUFHLEdBQUcsSUFBdkI7QUFDRDs7QUFFRCxNQUFJSCxlQUFlLEtBQUssQ0FBeEIsRUFBMkI7QUFDekJHLElBQUFBLEdBQUcsR0FDQVQsU0FBUyxDQUFDSSxHQUFHLENBQUNULFVBQUosQ0FBZWhHLENBQWYsQ0FBRCxDQUFULElBQWdDLEVBQWpDLEdBQ0NxRyxTQUFTLENBQUNJLEdBQUcsQ0FBQ1QsVUFBSixDQUFlaEcsQ0FBQyxHQUFHLENBQW5CLENBQUQsQ0FBVCxJQUFvQyxDQURyQyxHQUVDcUcsU0FBUyxDQUFDSSxHQUFHLENBQUNULFVBQUosQ0FBZWhHLENBQUMsR0FBRyxDQUFuQixDQUFELENBQVQsSUFBb0MsQ0FIdkM7QUFJQXlELElBQUFBLEdBQUcsQ0FBQ3NELE9BQU8sRUFBUixDQUFILEdBQWtCRCxHQUFHLElBQUksQ0FBUixHQUFhLElBQTlCO0FBQ0FyRCxJQUFBQSxHQUFHLENBQUNzRCxPQUFPLEVBQVIsQ0FBSCxHQUFpQkQsR0FBRyxHQUFHLElBQXZCO0FBQ0Q7O0FBRUQsU0FBT3JELEdBQVA7QUFDRDs7QUFFRCxTQUFTdUQsZUFBVCxDQUEwQkMsR0FBMUIsRUFBK0I7QUFDN0IsU0FBT2IsTUFBTSxDQUFDYSxHQUFHLElBQUksRUFBUCxHQUFZLElBQWIsQ0FBTixHQUNMYixNQUFNLENBQUNhLEdBQUcsSUFBSSxFQUFQLEdBQVksSUFBYixDQURELEdBRUxiLE1BQU0sQ0FBQ2EsR0FBRyxJQUFJLENBQVAsR0FBVyxJQUFaLENBRkQsR0FHTGIsTUFBTSxDQUFDYSxHQUFHLEdBQUcsSUFBUCxDQUhSO0FBSUQ7O0FBRUQsU0FBU0MsV0FBVCxDQUFzQkMsS0FBdEIsRUFBNkJDLEtBQTdCLEVBQW9DQyxHQUFwQyxFQUF5QztBQUN2QyxNQUFJUCxHQUFKO0FBQ0EsTUFBSVEsTUFBTSxHQUFHLEVBQWI7O0FBQ0EsT0FBSyxJQUFJdEgsQ0FBQyxHQUFHb0gsS0FBYixFQUFvQnBILENBQUMsR0FBR3FILEdBQXhCLEVBQTZCckgsQ0FBQyxJQUFJLENBQWxDLEVBQXFDO0FBQ25DOEcsSUFBQUEsR0FBRyxHQUNELENBQUVLLEtBQUssQ0FBQ25ILENBQUQsQ0FBTCxJQUFZLEVBQWIsR0FBbUIsUUFBcEIsS0FDRW1ILEtBQUssQ0FBQ25ILENBQUMsR0FBRyxDQUFMLENBQUwsSUFBZ0IsQ0FBakIsR0FBc0IsTUFEdkIsS0FFQ21ILEtBQUssQ0FBQ25ILENBQUMsR0FBRyxDQUFMLENBQUwsR0FBZSxJQUZoQixDQURGO0FBSUFzSCxJQUFBQSxNQUFNLENBQUN6TixJQUFQLENBQVltTixlQUFlLENBQUNGLEdBQUQsQ0FBM0I7QUFDRDs7QUFDRCxTQUFPUSxNQUFNLENBQUM5RyxJQUFQLENBQVksRUFBWixDQUFQO0FBQ0Q7O0FBRUQsU0FBUzJGLGFBQVQsQ0FBd0JnQixLQUF4QixFQUErQjtBQUM3QixNQUFJTCxHQUFKO0FBQ0EsTUFBSVAsR0FBRyxHQUFHWSxLQUFLLENBQUNqTixNQUFoQjtBQUNBLE1BQUlxTixVQUFVLEdBQUdoQixHQUFHLEdBQUcsQ0FBdkIsQ0FINkIsQ0FHSjs7QUFDekIsTUFBSXJHLEtBQUssR0FBRyxFQUFaO0FBQ0EsTUFBSXNILGNBQWMsR0FBRyxLQUFyQixDQUw2QixDQUtGO0FBRTNCOztBQUNBLE9BQUssSUFBSXhILENBQUMsR0FBRyxDQUFSLEVBQVd5SCxJQUFJLEdBQUdsQixHQUFHLEdBQUdnQixVQUE3QixFQUF5Q3ZILENBQUMsR0FBR3lILElBQTdDLEVBQW1EekgsQ0FBQyxJQUFJd0gsY0FBeEQsRUFBd0U7QUFDdEV0SCxJQUFBQSxLQUFLLENBQUNyRyxJQUFOLENBQVdxTixXQUFXLENBQUNDLEtBQUQsRUFBUW5ILENBQVIsRUFBWUEsQ0FBQyxHQUFHd0gsY0FBTCxHQUF1QkMsSUFBdkIsR0FBOEJBLElBQTlCLEdBQXNDekgsQ0FBQyxHQUFHd0gsY0FBckQsQ0FBdEI7QUFDRCxHQVY0QixDQVk3Qjs7O0FBQ0EsTUFBSUQsVUFBVSxLQUFLLENBQW5CLEVBQXNCO0FBQ3BCVCxJQUFBQSxHQUFHLEdBQUdLLEtBQUssQ0FBQ1osR0FBRyxHQUFHLENBQVAsQ0FBWDtBQUNBckcsSUFBQUEsS0FBSyxDQUFDckcsSUFBTixDQUNFdU0sTUFBTSxDQUFDVSxHQUFHLElBQUksQ0FBUixDQUFOLEdBQ0FWLE1BQU0sQ0FBRVUsR0FBRyxJQUFJLENBQVIsR0FBYSxJQUFkLENBRE4sR0FFQSxJQUhGO0FBS0QsR0FQRCxNQU9PLElBQUlTLFVBQVUsS0FBSyxDQUFuQixFQUFzQjtBQUMzQlQsSUFBQUEsR0FBRyxHQUFHLENBQUNLLEtBQUssQ0FBQ1osR0FBRyxHQUFHLENBQVAsQ0FBTCxJQUFrQixDQUFuQixJQUF3QlksS0FBSyxDQUFDWixHQUFHLEdBQUcsQ0FBUCxDQUFuQztBQUNBckcsSUFBQUEsS0FBSyxDQUFDckcsSUFBTixDQUNFdU0sTUFBTSxDQUFDVSxHQUFHLElBQUksRUFBUixDQUFOLEdBQ0FWLE1BQU0sQ0FBRVUsR0FBRyxJQUFJLENBQVIsR0FBYSxJQUFkLENBRE4sR0FFQVYsTUFBTSxDQUFFVSxHQUFHLElBQUksQ0FBUixHQUFhLElBQWQsQ0FGTixHQUdBLEdBSkY7QUFNRDs7QUFFRCxTQUFPNUcsS0FBSyxDQUFDTSxJQUFOLENBQVcsRUFBWCxDQUFQO0FBQ0Q7Ozs7Ozs7Ozs7QUNySlk7Ozs7QUFDYmxSLDhDQUE2QztBQUFFRyxFQUFBQSxLQUFLLEVBQUU7QUFBVCxDQUE3QztBQUNBRCxlQUFBLEdBQWtCQSxjQUFBLEdBQWlCLEtBQUssQ0FBeEM7QUFDQSxJQUFNbVksUUFBUSxHQUFHLGtDQUFqQjtBQUNBLElBQU1DLFlBQVksR0FBRyxFQUFyQjs7QUFDQSxLQUFLLElBQUlDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdGLFFBQVEsQ0FBQ3pOLE1BQTdCLEVBQXFDMk4sQ0FBQyxFQUF0QyxFQUEwQztBQUN0QyxNQUFNQyxDQUFDLEdBQUdILFFBQVEsQ0FBQzlFLE1BQVQsQ0FBZ0JnRixDQUFoQixDQUFWO0FBQ0FELEVBQUFBLFlBQVksQ0FBQ0UsQ0FBRCxDQUFaLEdBQWtCRCxDQUFsQjtBQUNIOztBQUNELFNBQVNFLFdBQVQsQ0FBcUJDLEdBQXJCLEVBQTBCO0FBQ3RCLE1BQU1uQyxDQUFDLEdBQUdtQyxHQUFHLElBQUksRUFBakI7QUFDQSxTQUFTLENBQUNBLEdBQUcsR0FBRyxTQUFQLEtBQXFCLENBQXRCLEdBQ0gsRUFBR25DLENBQUMsSUFBSSxDQUFOLEdBQVcsQ0FBYixJQUFrQixVQURmLEdBRUgsRUFBR0EsQ0FBQyxJQUFJLENBQU4sR0FBVyxDQUFiLElBQWtCLFVBRmYsR0FHSCxFQUFHQSxDQUFDLElBQUksQ0FBTixHQUFXLENBQWIsSUFBa0IsVUFIZixHQUlILEVBQUdBLENBQUMsSUFBSSxDQUFOLEdBQVcsQ0FBYixJQUFrQixVQUpmLEdBS0gsRUFBR0EsQ0FBQyxJQUFJLENBQU4sR0FBVyxDQUFiLElBQWtCLFVBTHZCO0FBTUg7O0FBQ0QsU0FBU29DLFNBQVQsQ0FBbUJoWCxNQUFuQixFQUEyQjtBQUN2QixNQUFJaVgsR0FBRyxHQUFHLENBQVY7O0FBQ0EsT0FBSyxJQUFJbEksQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRy9PLE1BQU0sQ0FBQ2lKLE1BQTNCLEVBQW1DLEVBQUU4RixDQUFyQyxFQUF3QztBQUNwQyxRQUFNeEgsQ0FBQyxHQUFHdkgsTUFBTSxDQUFDK1UsVUFBUCxDQUFrQmhHLENBQWxCLENBQVY7QUFDQSxRQUFJeEgsQ0FBQyxHQUFHLEVBQUosSUFBVUEsQ0FBQyxHQUFHLEdBQWxCLEVBQ0ksT0FBTyxxQkFBcUJ2SCxNQUFyQixHQUE4QixHQUFyQztBQUNKaVgsSUFBQUEsR0FBRyxHQUFHSCxXQUFXLENBQUNHLEdBQUQsQ0FBWCxHQUFvQjFQLENBQUMsSUFBSSxDQUEvQjtBQUNIOztBQUNEMFAsRUFBQUEsR0FBRyxHQUFHSCxXQUFXLENBQUNHLEdBQUQsQ0FBakI7O0FBQ0EsT0FBSyxJQUFJbEksRUFBQyxHQUFHLENBQWIsRUFBZ0JBLEVBQUMsR0FBRy9PLE1BQU0sQ0FBQ2lKLE1BQTNCLEVBQW1DLEVBQUU4RixFQUFyQyxFQUF3QztBQUNwQyxRQUFNSyxDQUFDLEdBQUdwUCxNQUFNLENBQUMrVSxVQUFQLENBQWtCaEcsRUFBbEIsQ0FBVjtBQUNBa0ksSUFBQUEsR0FBRyxHQUFHSCxXQUFXLENBQUNHLEdBQUQsQ0FBWCxHQUFvQjdILENBQUMsR0FBRyxJQUE5QjtBQUNIOztBQUNELFNBQU82SCxHQUFQO0FBQ0g7O0FBQ0QsU0FBU0MsT0FBVCxDQUFpQi9WLElBQWpCLEVBQXVCZ1csTUFBdkIsRUFBK0JDLE9BQS9CLEVBQXdDQyxHQUF4QyxFQUE2QztBQUN6QyxNQUFJN1ksS0FBSyxHQUFHLENBQVo7QUFDQSxNQUFJOFksSUFBSSxHQUFHLENBQVg7QUFDQSxNQUFNQyxJQUFJLEdBQUcsQ0FBQyxLQUFLSCxPQUFOLElBQWlCLENBQTlCO0FBQ0EsTUFBTXhELE1BQU0sR0FBRyxFQUFmOztBQUNBLE9BQUssSUFBSTdFLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUc1TixJQUFJLENBQUM4SCxNQUF6QixFQUFpQyxFQUFFOEYsQ0FBbkMsRUFBc0M7QUFDbEN2USxJQUFBQSxLQUFLLEdBQUlBLEtBQUssSUFBSTJZLE1BQVYsR0FBb0JoVyxJQUFJLENBQUM0TixDQUFELENBQWhDO0FBQ0F1SSxJQUFBQSxJQUFJLElBQUlILE1BQVI7O0FBQ0EsV0FBT0csSUFBSSxJQUFJRixPQUFmLEVBQXdCO0FBQ3BCRSxNQUFBQSxJQUFJLElBQUlGLE9BQVI7QUFDQXhELE1BQUFBLE1BQU0sQ0FBQ2hMLElBQVAsQ0FBYXBLLEtBQUssSUFBSThZLElBQVYsR0FBa0JDLElBQTlCO0FBQ0g7QUFDSjs7QUFDRCxNQUFJRixHQUFKLEVBQVM7QUFDTCxRQUFJQyxJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ1YxRCxNQUFBQSxNQUFNLENBQUNoTCxJQUFQLENBQWFwSyxLQUFLLElBQUs0WSxPQUFPLEdBQUdFLElBQXJCLEdBQThCQyxJQUExQztBQUNIO0FBQ0osR0FKRCxNQUtLO0FBQ0QsUUFBSUQsSUFBSSxJQUFJSCxNQUFaLEVBQ0ksT0FBTyxnQkFBUDtBQUNKLFFBQUszWSxLQUFLLElBQUs0WSxPQUFPLEdBQUdFLElBQXJCLEdBQThCQyxJQUFsQyxFQUNJLE9BQU8sa0JBQVA7QUFDUDs7QUFDRCxTQUFPM0QsTUFBUDtBQUNIOztBQUNELFNBQVMzVSxPQUFULENBQWlCdVksS0FBakIsRUFBd0I7QUFDcEIsU0FBT04sT0FBTyxDQUFDTSxLQUFELEVBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxJQUFkLENBQWQ7QUFDSDs7QUFDRCxTQUFTQyxlQUFULENBQXlCMVksS0FBekIsRUFBZ0M7QUFDNUIsTUFBTTJZLEdBQUcsR0FBR1IsT0FBTyxDQUFDblksS0FBRCxFQUFRLENBQVIsRUFBVyxDQUFYLEVBQWMsS0FBZCxDQUFuQjtBQUNBLE1BQUkrSixLQUFLLENBQUNzRCxPQUFOLENBQWNzTCxHQUFkLENBQUosRUFDSSxPQUFPQSxHQUFQO0FBQ1A7O0FBQ0QsU0FBU3hYLFNBQVQsQ0FBbUJuQixLQUFuQixFQUEwQjtBQUN0QixNQUFNMlksR0FBRyxHQUFHUixPQUFPLENBQUNuWSxLQUFELEVBQVEsQ0FBUixFQUFXLENBQVgsRUFBYyxLQUFkLENBQW5CO0FBQ0EsTUFBSStKLEtBQUssQ0FBQ3NELE9BQU4sQ0FBY3NMLEdBQWQsQ0FBSixFQUNJLE9BQU9BLEdBQVA7QUFDSixRQUFNLElBQUl6WCxLQUFKLENBQVV5WCxHQUFWLENBQU47QUFDSDs7QUFDRCxTQUFTQyxzQkFBVCxDQUFnQ0MsUUFBaEMsRUFBMEM7QUFDdEMsTUFBSUMsY0FBSjs7QUFDQSxNQUFJRCxRQUFRLEtBQUssUUFBakIsRUFBMkI7QUFDdkJDLElBQUFBLGNBQWMsR0FBRyxDQUFqQjtBQUNILEdBRkQsTUFHSztBQUNEQSxJQUFBQSxjQUFjLEdBQUcsVUFBakI7QUFDSDs7QUFDRCxXQUFTM1ksTUFBVCxDQUFnQmMsTUFBaEIsRUFBd0JqQixLQUF4QixFQUErQitZLEtBQS9CLEVBQXNDO0FBQ2xDQSxJQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxFQUFqQjtBQUNBLFFBQUk5WCxNQUFNLENBQUNpSixNQUFQLEdBQWdCLENBQWhCLEdBQW9CbEssS0FBSyxDQUFDa0ssTUFBMUIsR0FBbUM2TyxLQUF2QyxFQUNJLE1BQU0sSUFBSTlRLFNBQUosQ0FBYyxzQkFBZCxDQUFOO0FBQ0poSCxJQUFBQSxNQUFNLEdBQUdBLE1BQU0sQ0FBQzRFLFdBQVAsRUFBVCxDQUprQyxDQUtsQzs7QUFDQSxRQUFJcVMsR0FBRyxHQUFHRCxTQUFTLENBQUNoWCxNQUFELENBQW5CO0FBQ0EsUUFBSSxPQUFPaVgsR0FBUCxLQUFlLFFBQW5CLEVBQ0ksTUFBTSxJQUFJaFgsS0FBSixDQUFVZ1gsR0FBVixDQUFOO0FBQ0osUUFBSXJELE1BQU0sR0FBRzVULE1BQU0sR0FBRyxHQUF0Qjs7QUFDQSxTQUFLLElBQUkrTyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHaFEsS0FBSyxDQUFDa0ssTUFBMUIsRUFBa0MsRUFBRThGLENBQXBDLEVBQXVDO0FBQ25DLFVBQU04SCxFQUFDLEdBQUc5WCxLQUFLLENBQUNnUSxDQUFELENBQWY7QUFDQSxVQUFJOEgsRUFBQyxJQUFJLENBQUwsS0FBVyxDQUFmLEVBQ0ksTUFBTSxJQUFJNVcsS0FBSixDQUFVLGdCQUFWLENBQU47QUFDSmdYLE1BQUFBLEdBQUcsR0FBR0gsV0FBVyxDQUFDRyxHQUFELENBQVgsR0FBbUJKLEVBQXpCO0FBQ0FqRCxNQUFBQSxNQUFNLElBQUk4QyxRQUFRLENBQUM5RSxNQUFULENBQWdCaUYsRUFBaEIsQ0FBVjtBQUNIOztBQUNELFNBQUssSUFBSTlILEdBQUMsR0FBRyxDQUFiLEVBQWdCQSxHQUFDLEdBQUcsQ0FBcEIsRUFBdUIsRUFBRUEsR0FBekIsRUFBNEI7QUFDeEJrSSxNQUFBQSxHQUFHLEdBQUdILFdBQVcsQ0FBQ0csR0FBRCxDQUFqQjtBQUNIOztBQUNEQSxJQUFBQSxHQUFHLElBQUlZLGNBQVA7O0FBQ0EsU0FBSyxJQUFJOUksR0FBQyxHQUFHLENBQWIsRUFBZ0JBLEdBQUMsR0FBRyxDQUFwQixFQUF1QixFQUFFQSxHQUF6QixFQUE0QjtBQUN4QixVQUFNSyxDQUFDLEdBQUk2SCxHQUFHLElBQUssQ0FBQyxJQUFJbEksR0FBTCxJQUFVLENBQW5CLEdBQXlCLElBQW5DO0FBQ0E2RSxNQUFBQSxNQUFNLElBQUk4QyxRQUFRLENBQUM5RSxNQUFULENBQWdCeEMsQ0FBaEIsQ0FBVjtBQUNIOztBQUNELFdBQU93RSxNQUFQO0FBQ0g7O0FBQ0QsV0FBU21FLFFBQVQsQ0FBa0IxRCxHQUFsQixFQUF1QnlELEtBQXZCLEVBQThCO0FBQzFCQSxJQUFBQSxLQUFLLEdBQUdBLEtBQUssSUFBSSxFQUFqQjtBQUNBLFFBQUl6RCxHQUFHLENBQUNwTCxNQUFKLEdBQWEsQ0FBakIsRUFDSSxPQUFPb0wsR0FBRyxHQUFHLFlBQWI7QUFDSixRQUFJQSxHQUFHLENBQUNwTCxNQUFKLEdBQWE2TyxLQUFqQixFQUNJLE9BQU8sc0JBQVAsQ0FMc0IsQ0FNMUI7O0FBQ0EsUUFBTUUsT0FBTyxHQUFHM0QsR0FBRyxDQUFDelAsV0FBSixFQUFoQjtBQUNBLFFBQU1xVCxPQUFPLEdBQUc1RCxHQUFHLENBQUMvUixXQUFKLEVBQWhCO0FBQ0EsUUFBSStSLEdBQUcsS0FBSzJELE9BQVIsSUFBbUIzRCxHQUFHLEtBQUs0RCxPQUEvQixFQUNJLE9BQU8sdUJBQXVCNUQsR0FBOUI7QUFDSkEsSUFBQUEsR0FBRyxHQUFHMkQsT0FBTjtBQUNBLFFBQU01RixLQUFLLEdBQUdpQyxHQUFHLENBQUM2RCxXQUFKLENBQWdCLEdBQWhCLENBQWQ7QUFDQSxRQUFJOUYsS0FBSyxLQUFLLENBQUMsQ0FBZixFQUNJLE9BQU8sZ0NBQWdDaUMsR0FBdkM7QUFDSixRQUFJakMsS0FBSyxLQUFLLENBQWQsRUFDSSxPQUFPLHdCQUF3QmlDLEdBQS9CO0FBQ0osUUFBTXJVLE1BQU0sR0FBR3FVLEdBQUcsQ0FBQzlVLEtBQUosQ0FBVSxDQUFWLEVBQWE2UyxLQUFiLENBQWY7QUFDQSxRQUFNK0YsU0FBUyxHQUFHOUQsR0FBRyxDQUFDOVUsS0FBSixDQUFVNlMsS0FBSyxHQUFHLENBQWxCLENBQWxCO0FBQ0EsUUFBSStGLFNBQVMsQ0FBQ2xQLE1BQVYsR0FBbUIsQ0FBdkIsRUFDSSxPQUFPLGdCQUFQO0FBQ0osUUFBSWdPLEdBQUcsR0FBR0QsU0FBUyxDQUFDaFgsTUFBRCxDQUFuQjtBQUNBLFFBQUksT0FBT2lYLEdBQVAsS0FBZSxRQUFuQixFQUNJLE9BQU9BLEdBQVA7QUFDSixRQUFNbFksS0FBSyxHQUFHLEVBQWQ7O0FBQ0EsU0FBSyxJQUFJZ1EsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR29KLFNBQVMsQ0FBQ2xQLE1BQTlCLEVBQXNDLEVBQUU4RixDQUF4QyxFQUEyQztBQUN2QyxVQUFNeEgsQ0FBQyxHQUFHNFEsU0FBUyxDQUFDdkcsTUFBVixDQUFpQjdDLENBQWpCLENBQVY7QUFDQSxVQUFNSyxDQUFDLEdBQUd1SCxZQUFZLENBQUNwUCxDQUFELENBQXRCO0FBQ0EsVUFBSTZILENBQUMsS0FBSzlLLFNBQVYsRUFDSSxPQUFPLHVCQUF1QmlELENBQTlCO0FBQ0owUCxNQUFBQSxHQUFHLEdBQUdILFdBQVcsQ0FBQ0csR0FBRCxDQUFYLEdBQW1CN0gsQ0FBekIsQ0FMdUMsQ0FNdkM7O0FBQ0EsVUFBSUwsQ0FBQyxHQUFHLENBQUosSUFBU29KLFNBQVMsQ0FBQ2xQLE1BQXZCLEVBQ0k7QUFDSmxLLE1BQUFBLEtBQUssQ0FBQzZKLElBQU4sQ0FBV3dHLENBQVg7QUFDSDs7QUFDRCxRQUFJNkgsR0FBRyxLQUFLWSxjQUFaLEVBQ0ksT0FBTywwQkFBMEJ4RCxHQUFqQztBQUNKLFdBQU87QUFBRXJVLE1BQUFBLE1BQU0sRUFBTkEsTUFBRjtBQUFVakIsTUFBQUEsS0FBSyxFQUFMQTtBQUFWLEtBQVA7QUFDSDs7QUFDRCxXQUFTcVosWUFBVCxDQUFzQi9ELEdBQXRCLEVBQTJCeUQsS0FBM0IsRUFBa0M7QUFDOUIsUUFBTUosR0FBRyxHQUFHSyxRQUFRLENBQUMxRCxHQUFELEVBQU15RCxLQUFOLENBQXBCOztBQUNBLFFBQUksUUFBT0osR0FBUCxNQUFlLFFBQW5CLEVBQ0ksT0FBT0EsR0FBUDtBQUNQOztBQUNELFdBQVMzWCxNQUFULENBQWdCc1UsR0FBaEIsRUFBcUJ5RCxLQUFyQixFQUE0QjtBQUN4QixRQUFNSixHQUFHLEdBQUdLLFFBQVEsQ0FBQzFELEdBQUQsRUFBTXlELEtBQU4sQ0FBcEI7O0FBQ0EsUUFBSSxRQUFPSixHQUFQLE1BQWUsUUFBbkIsRUFDSSxPQUFPQSxHQUFQO0FBQ0osVUFBTSxJQUFJelgsS0FBSixDQUFVeVgsR0FBVixDQUFOO0FBQ0g7O0FBQ0QsU0FBTztBQUNIVSxJQUFBQSxZQUFZLEVBQVpBLFlBREc7QUFFSHJZLElBQUFBLE1BQU0sRUFBTkEsTUFGRztBQUdIYixJQUFBQSxNQUFNLEVBQU5BLE1BSEc7QUFJSEQsSUFBQUEsT0FBTyxFQUFQQSxPQUpHO0FBS0h3WSxJQUFBQSxlQUFlLEVBQWZBLGVBTEc7QUFNSHZYLElBQUFBLFNBQVMsRUFBVEE7QUFORyxHQUFQO0FBUUg7O0FBQ0QzQixjQUFBLEdBQWlCb1osc0JBQXNCLENBQUMsUUFBRCxDQUF2QztBQUNBcFosZUFBQSxHQUFrQm9aLHNCQUFzQixDQUFDLFNBQUQsQ0FBeEM7Ozs7Ozs7Ozs7QUN4S0F4WCxNQUFNLENBQUM1QixPQUFQLEdBQWlCOFosZUFBakI7QUFFQUEsZUFBZSxDQUFDQyxTQUFoQixHQUE0QixPQUFPQyxXQUFQLEtBQXVCLFdBQW5EOztBQUVBLFNBQVNGLGVBQVQsQ0FBMEI5RSxJQUExQixFQUFnQztBQUM5QixNQUFJLENBQUM4RSxlQUFlLENBQUNDLFNBQXJCLEVBQWdDLE9BQU8sSUFBUDtBQUVoQyxNQUFJRSxHQUFHLEdBQUdqRixJQUFJLElBQUlBLElBQUksQ0FBQ2tGLE9BQXZCO0FBQ0EsTUFBSUMsSUFBSSxHQUFHQyxZQUFZLENBQUMsODdWQUFELENBQXZCO0FBQ0EsTUFBSUMsS0FBSyxHQUFHLElBQVo7QUFFQSxNQUFJemEsR0FBRyxHQUFHO0FBQ1JtUSxJQUFBQSxNQUFNLEVBQUVvSyxJQURBO0FBRVJHLElBQUFBLE1BQU0sRUFBRSxJQUZBO0FBR1J0YSxJQUFBQSxPQUFPLEVBQUUsSUFIRDtBQUlSdWEsSUFBQUEsT0FBTyxFQUFFQSxPQUpEO0FBS1JDLElBQUFBLE1BQU0sRUFBRUE7QUFMQSxHQUFWO0FBUUFBLEVBQUFBLE1BQU0sQ0FBQyxZQUFZLENBQUUsQ0FBZixDQUFOO0FBRUEsU0FBTzVhLEdBQVA7O0FBRUEsV0FBUzJhLE9BQVQsQ0FBa0JFLElBQWxCLEVBQXdCO0FBQ3RCN2EsSUFBQUEsR0FBRyxDQUFDSSxPQUFKLENBQVlzYSxNQUFaLENBQW1CSSxJQUFuQixDQUF3QkMsSUFBSSxDQUFDQyxJQUFMLENBQVVELElBQUksQ0FBQ0UsR0FBTCxDQUFTSixJQUFJLEdBQUc3YSxHQUFHLENBQUMwYSxNQUFKLENBQVc1UCxNQUEzQixJQUFxQyxLQUEvQyxDQUF4QjtBQUNBOUssSUFBQUEsR0FBRyxDQUFDMGEsTUFBSixHQUFhLElBQUlqWixVQUFKLENBQWV6QixHQUFHLENBQUNJLE9BQUosQ0FBWXNhLE1BQVosQ0FBbUJ2SyxNQUFsQyxDQUFiO0FBQ0Q7O0FBRUQsV0FBU3lLLE1BQVQsQ0FBaUJNLEVBQWpCLEVBQXFCO0FBQ25CLFFBQUlsYixHQUFHLENBQUNJLE9BQVIsRUFBaUIsT0FBTzhhLEVBQUUsRUFBVDs7QUFFakIsUUFBSVQsS0FBSixFQUFXO0FBQ1RBLE1BQUFBLEtBQUssQ0FBQ3hULElBQU4sQ0FBV2lVLEVBQUUsQ0FBQzVULElBQUgsQ0FBUSxJQUFSLEVBQWMsSUFBZCxDQUFYLFdBQXNDNFQsRUFBdEM7QUFDQTtBQUNEOztBQUVELFFBQUk7QUFDRixVQUFJOUYsSUFBSSxJQUFJQSxJQUFJLENBQUMrRixLQUFqQixFQUF3QixNQUFNLElBQUlyWixLQUFKLENBQVUsT0FBVixDQUFOO0FBQ3hCc1osTUFBQUEsS0FBSyxDQUFDO0FBQUN2VCxRQUFBQSxRQUFRLEVBQUUsSUFBSXVTLFdBQVcsQ0FBQ2lCLFFBQWhCLENBQXlCLElBQUlqQixXQUFXLENBQUNrQixNQUFoQixDQUF1QmYsSUFBdkIsQ0FBekIsRUFBdURGLEdBQXZEO0FBQVgsT0FBRCxDQUFMO0FBQ0QsS0FIRCxDQUdFLE9BQU9rQixHQUFQLEVBQVk7QUFDWmQsTUFBQUEsS0FBSyxHQUFHTCxXQUFXLENBQUNvQixXQUFaLENBQXdCakIsSUFBeEIsRUFBOEJGLEdBQTlCLEVBQW1DcFQsSUFBbkMsQ0FBd0NtVSxLQUF4QyxDQUFSO0FBQ0Q7O0FBRURSLElBQUFBLE1BQU0sQ0FBQ00sRUFBRCxDQUFOO0FBQ0Q7O0FBRUQsV0FBU0UsS0FBVCxDQUFnQkssQ0FBaEIsRUFBbUI7QUFDakJ6YixJQUFBQSxHQUFHLENBQUNJLE9BQUosR0FBY3FiLENBQUMsQ0FBQzVULFFBQUYsQ0FBV3pILE9BQXpCO0FBQ0FKLElBQUFBLEdBQUcsQ0FBQzBhLE1BQUosR0FBYTFhLEdBQUcsQ0FBQ0ksT0FBSixDQUFZc2EsTUFBWixJQUFzQjFhLEdBQUcsQ0FBQ0ksT0FBSixDQUFZc2EsTUFBWixDQUFtQnZLLE1BQXpDLElBQW1ELElBQUkxTyxVQUFKLENBQWV6QixHQUFHLENBQUNJLE9BQUosQ0FBWXNhLE1BQVosQ0FBbUJ2SyxNQUFsQyxDQUFoRTtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3FLLFlBQVQsQ0FBdUJrQixDQUF2QixFQUEwQjtBQUN4QixNQUFJLE9BQU9DLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0MsT0FBTyxJQUFJbGEsVUFBSixDQUFla2EsSUFBSSxDQUFDRCxDQUFELENBQUosQ0FBUXpILEtBQVIsQ0FBYyxFQUFkLEVBQWtCMkgsR0FBbEIsQ0FBc0JoRixVQUF0QixDQUFmLENBQVA7QUFDaEMsU0FBTyxLQUFLclcsNEVBQUwsRUFBb0NtYixDQUFwQyxFQUF1QyxRQUF2QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBUzlFLFVBQVQsQ0FBcUJ4TixDQUFyQixFQUF3QjtBQUN0QixTQUFPQSxDQUFDLENBQUN3TixVQUFGLENBQWEsQ0FBYixDQUFQO0FBQ0Q7Ozs7Ozs7Ozs7QUM1REQsSUFBSWlGLE1BQU0sR0FBR3RiLG1CQUFPLENBQUMsc0RBQUQsQ0FBcEI7O0FBQ0EsSUFBSWdhLElBQUksR0FBR2hhLG1CQUFPLENBQUMseURBQUQsQ0FBUCxFQUFYOztBQUVBLElBQUl1YixJQUFJLEdBQUcsRUFBWDtBQUNBLElBQUlDLFFBQVEsR0FBRyxFQUFmO0FBRUEvWixNQUFNLENBQUM1QixPQUFQLEdBQWlCNGIsT0FBakI7QUFDQSxJQUFJQyxTQUFTLEdBQUdqYSx3QkFBQSxHQUEyQixFQUEzQztBQUNBLElBQUlrYSxTQUFTLEdBQUdsYSx3QkFBQSxHQUEyQixFQUEzQztBQUNBLElBQUltYSxLQUFLLEdBQUduYSxvQkFBQSxHQUF1QixFQUFuQztBQUNBLElBQUlvYSxZQUFZLEdBQUdwYSwyQkFBQSxHQUE4QixFQUFqRDtBQUNBLElBQUlxYSxZQUFZLEdBQUdyYSwyQkFBQSxHQUE4QixFQUFqRDtBQUNBLElBQUlzYSxRQUFRLEdBQUd0YSx1QkFBQSxHQUEwQixFQUF6QztBQUNBLElBQUl1YSxTQUFTLEdBQUd2YSx3QkFBQSxHQUEyQixFQUEzQztBQUNBLElBQUl3YSxhQUFhLEdBQUd4YSw0QkFBQSxHQUErQixFQUFuRDs7QUFFQSxTQUFTZ2EsT0FBVCxDQUFrQlMsWUFBbEIsRUFBZ0NqVyxHQUFoQyxFQUFxQ2tXLElBQXJDLEVBQTJDQyxRQUEzQyxFQUFxREMsUUFBckQsRUFBK0Q7QUFDN0QsTUFBSSxFQUFFLGdCQUFnQlosT0FBbEIsQ0FBSixFQUFnQyxPQUFPLElBQUlBLE9BQUosQ0FBWVMsWUFBWixFQUEwQmpXLEdBQTFCLEVBQStCa1csSUFBL0IsRUFBcUNDLFFBQXJDLEVBQStDQyxRQUEvQyxDQUFQO0FBQ2hDLE1BQUksRUFBRXJDLElBQUksSUFBSUEsSUFBSSxDQUFDbmEsT0FBZixDQUFKLEVBQTZCLE1BQU0sSUFBSTBCLEtBQUosQ0FBVSw2Q0FBVixDQUFOO0FBQzdCLE1BQUksQ0FBQzJhLFlBQUwsRUFBbUJBLFlBQVksR0FBRyxFQUFmOztBQUVuQixNQUFJRyxRQUFRLEtBQUssSUFBakIsRUFBdUI7QUFDckJmLElBQUFBLE1BQU0sQ0FBQ1ksWUFBWSxJQUFJUixTQUFqQixFQUE0QixtQ0FBbUNBLFNBQW5DLEdBQStDLGNBQS9DLEdBQWdFUSxZQUE1RixDQUFOO0FBQ0FaLElBQUFBLE1BQU0sQ0FBQ1ksWUFBWSxJQUFJUCxTQUFqQixFQUE0QixrQ0FBa0NBLFNBQWxDLEdBQThDLGNBQTlDLEdBQStETyxZQUEzRixDQUFOO0FBQ0EsUUFBSWpXLEdBQUcsSUFBSSxJQUFYLEVBQWlCcVYsTUFBTSxDQUFDclYsR0FBRyxDQUFDc0UsTUFBSixJQUFjc1IsWUFBZixFQUE2QiwwQkFBMEJBLFlBQTFCLEdBQXlDLGNBQXpDLEdBQTBENVYsR0FBRyxDQUFDc0UsTUFBM0YsQ0FBTjtBQUNqQixRQUFJdEUsR0FBRyxJQUFJLElBQVgsRUFBaUJxVixNQUFNLENBQUNyVixHQUFHLENBQUNzRSxNQUFKLElBQWN1UixZQUFmLEVBQTZCLDBCQUEwQkEsWUFBMUIsR0FBeUMsY0FBekMsR0FBMEQ3VixHQUFHLENBQUNzRSxNQUEzRixDQUFOO0FBQ2pCLFFBQUk0UixJQUFJLElBQUksSUFBWixFQUFrQmIsTUFBTSxDQUFDYSxJQUFJLENBQUM1UixNQUFMLEtBQWdCeVIsU0FBakIsRUFBNEIsMEJBQTBCQSxTQUExQixHQUFzQyxjQUF0QyxHQUF1REcsSUFBSSxDQUFDNVIsTUFBeEYsQ0FBTjtBQUNsQixRQUFJNlIsUUFBUSxJQUFJLElBQWhCLEVBQXNCZCxNQUFNLENBQUNjLFFBQVEsQ0FBQzdSLE1BQVQsS0FBb0IwUixhQUFyQixFQUFvQyw4QkFBOEJBLGFBQTlCLEdBQThDLGNBQTlDLEdBQStERyxRQUFRLENBQUM3UixNQUE1RyxDQUFOO0FBQ3ZCOztBQUVELE1BQUksQ0FBQ2lSLFFBQVEsQ0FBQ2pSLE1BQWQsRUFBc0I7QUFDcEJpUixJQUFBQSxRQUFRLENBQUN0UixJQUFULENBQWNxUixJQUFkO0FBQ0FBLElBQUFBLElBQUksSUFBSSxHQUFSO0FBQ0Q7O0FBRUQsT0FBS1csWUFBTCxHQUFvQkEsWUFBcEI7QUFDQSxPQUFLSSxTQUFMLEdBQWlCLEtBQWpCO0FBQ0EsT0FBS0MsT0FBTCxHQUFlZixRQUFRLENBQUNnQixHQUFULEVBQWY7QUFFQXhDLEVBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZc0MsSUFBWixDQUFpQixDQUFqQixFQUFvQixDQUFwQixFQUF1QixFQUF2QjtBQUNBekMsRUFBQUEsSUFBSSxDQUFDRyxNQUFMLENBQVksQ0FBWixJQUFpQixLQUFLK0IsWUFBdEI7QUFDQWxDLEVBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZLENBQVosSUFBaUJsVSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3NFLE1BQVAsR0FBZ0IsQ0FBcEM7QUFDQXlQLEVBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZLENBQVosSUFBaUIsQ0FBakIsQ0ExQjZELENBMEIxQzs7QUFDbkJILEVBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZLENBQVosSUFBaUIsQ0FBakIsQ0EzQjZELENBMkIxQzs7QUFFbkIsTUFBSWdDLElBQUosRUFBVW5DLElBQUksQ0FBQ0csTUFBTCxDQUFZdUMsR0FBWixDQUFnQlAsSUFBaEIsRUFBc0IsRUFBdEI7QUFDVixNQUFJQyxRQUFKLEVBQWNwQyxJQUFJLENBQUNHLE1BQUwsQ0FBWXVDLEdBQVosQ0FBZ0JOLFFBQWhCLEVBQTBCLEVBQTFCO0FBRWQsTUFBSSxLQUFLRyxPQUFMLEdBQWUsR0FBZixHQUFxQnZDLElBQUksQ0FBQ0csTUFBTCxDQUFZNVAsTUFBckMsRUFBNkN5UCxJQUFJLENBQUNJLE9BQUwsQ0FBYSxLQUFLbUMsT0FBTCxHQUFlLEdBQTVCLEVBaENnQixDQWdDaUI7O0FBQzlFdkMsRUFBQUEsSUFBSSxDQUFDbmEsT0FBTCxDQUFhOGMsWUFBYixDQUEwQixLQUFLSixPQUEvQixFQUF3QyxLQUFLTCxZQUE3Qzs7QUFFQSxNQUFJalcsR0FBSixFQUFTO0FBQ1AsU0FBS2hGLE1BQUwsQ0FBWWdGLEdBQVo7QUFDQStULElBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZc0MsSUFBWixDQUFpQixDQUFqQixFQUFvQmxCLElBQXBCLEVBQTBCQSxJQUFJLEdBQUd0VixHQUFHLENBQUNzRSxNQUFyQyxFQUZPLENBRXNDOztBQUM3Q3lQLElBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZLEtBQUtvQyxPQUFMLEdBQWUsR0FBM0IsSUFBa0MsR0FBbEM7QUFDRDtBQUNGOztBQUdEZCxPQUFPLENBQUNsVSxTQUFSLENBQWtCdEcsTUFBbEIsR0FBMkIsVUFBVTJiLEtBQVYsRUFBaUI7QUFDMUN0QixFQUFBQSxNQUFNLENBQUMsS0FBS2dCLFNBQUwsS0FBbUIsS0FBcEIsRUFBMkIseUJBQTNCLENBQU47QUFDQWhCLEVBQUFBLE1BQU0sQ0FBQ3NCLEtBQUQsRUFBUSxvQ0FBUixDQUFOO0FBRUEsTUFBSXJCLElBQUksR0FBR3FCLEtBQUssQ0FBQ3JTLE1BQWIsR0FBc0J5UCxJQUFJLENBQUNHLE1BQUwsQ0FBWTVQLE1BQXRDLEVBQThDeVAsSUFBSSxDQUFDSSxPQUFMLENBQWFtQixJQUFJLEdBQUdxQixLQUFLLENBQUNyUyxNQUExQjtBQUM5Q3lQLEVBQUFBLElBQUksQ0FBQ0csTUFBTCxDQUFZdUMsR0FBWixDQUFnQkUsS0FBaEIsRUFBdUJyQixJQUF2QjtBQUNBdkIsRUFBQUEsSUFBSSxDQUFDbmEsT0FBTCxDQUFhZ2QsY0FBYixDQUE0QixLQUFLTixPQUFqQyxFQUEwQ2hCLElBQTFDLEVBQWdEQSxJQUFJLEdBQUdxQixLQUFLLENBQUNyUyxNQUE3RDtBQUNBLFNBQU8sSUFBUDtBQUNELENBUkQ7O0FBVUFrUixPQUFPLENBQUNsVSxTQUFSLENBQWtCcEcsTUFBbEIsR0FBMkIsVUFBVTJiLEdBQVYsRUFBZTtBQUN4Q3hCLEVBQUFBLE1BQU0sQ0FBQyxLQUFLZ0IsU0FBTCxLQUFtQixLQUFwQixFQUEyQix5QkFBM0IsQ0FBTjtBQUNBLE9BQUtBLFNBQUwsR0FBaUIsSUFBakI7QUFFQWQsRUFBQUEsUUFBUSxDQUFDdFIsSUFBVCxDQUFjLEtBQUtxUyxPQUFuQjtBQUNBdkMsRUFBQUEsSUFBSSxDQUFDbmEsT0FBTCxDQUFha2QsYUFBYixDQUEyQixLQUFLUixPQUFoQzs7QUFFQSxNQUFJLENBQUNPLEdBQUQsSUFBUUEsR0FBRyxLQUFLLFFBQXBCLEVBQThCO0FBQzVCLFdBQU85QyxJQUFJLENBQUNHLE1BQUwsQ0FBWXRaLEtBQVosQ0FBa0IsS0FBSzBiLE9BQUwsR0FBZSxHQUFqQyxFQUFzQyxLQUFLQSxPQUFMLEdBQWUsR0FBZixHQUFxQixLQUFLTCxZQUFoRSxDQUFQO0FBQ0Q7O0FBRUQsTUFBSVksR0FBRyxLQUFLLEtBQVosRUFBbUI7QUFDakIsV0FBT0UsUUFBUSxDQUFDaEQsSUFBSSxDQUFDRyxNQUFOLEVBQWMsS0FBS29DLE9BQUwsR0FBZSxHQUE3QixFQUFrQyxLQUFLTCxZQUF2QyxDQUFmO0FBQ0Q7O0FBRURaLEVBQUFBLE1BQU0sQ0FBQ3dCLEdBQUcsQ0FBQ3ZTLE1BQUosSUFBYyxLQUFLMlIsWUFBcEIsRUFBa0Msb0NBQWxDLENBQU47O0FBQ0EsT0FBSyxJQUFJN0wsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxLQUFLNkwsWUFBekIsRUFBdUM3TCxDQUFDLEVBQXhDLEVBQTRDO0FBQzFDeU0sSUFBQUEsR0FBRyxDQUFDek0sQ0FBRCxDQUFILEdBQVMySixJQUFJLENBQUNHLE1BQUwsQ0FBWSxLQUFLb0MsT0FBTCxHQUFlLEdBQWYsR0FBcUJsTSxDQUFqQyxDQUFUO0FBQ0Q7O0FBRUQsU0FBT3lNLEdBQVA7QUFDRCxDQXJCRCxFQXVCQTs7O0FBQ0FyQixPQUFPLENBQUNsVSxTQUFSLFlBQTBCa1UsT0FBTyxDQUFDbFUsU0FBUixDQUFrQnBHLE1BQTVDO0FBRUFzYSxPQUFPLENBQUN3QixJQUFSLEdBQWVqRCxJQUFJLElBQUlBLElBQUksQ0FBQ3BLLE1BQTVCO0FBQ0E2TCxPQUFPLENBQUN5QixTQUFSLEdBQW9CLE9BQU9yRCxXQUFQLEtBQXVCLFdBQTNDOztBQUVBNEIsT0FBTyxDQUFDdkIsS0FBUixHQUFnQixVQUFVUyxFQUFWLEVBQWM7QUFDNUIsTUFBSSxDQUFDQSxFQUFMLEVBQVNBLEVBQUUsR0FBR3dDLElBQUw7QUFDVCxNQUFJLENBQUNuRCxJQUFMLEVBQVcsT0FBT1csRUFBRSxDQUFDLElBQUlwWixLQUFKLENBQVUsMkJBQVYsQ0FBRCxDQUFULENBRmlCLENBSTVCOztBQUNBLE1BQUk2YixDQUFDLEdBQUcsSUFBSWhiLE9BQUosQ0FBWSxVQUFVRyxNQUFWLEVBQWtCRCxPQUFsQixFQUEyQjtBQUM3QzBYLElBQUFBLElBQUksQ0FBQ0ssTUFBTCxDQUFZLFVBQVVXLEdBQVYsRUFBZTtBQUN6QixVQUFJQSxHQUFKLEVBQVMxWSxPQUFPLEdBQWhCLEtBQ0tDLE1BQU07QUFDWG9ZLE1BQUFBLEVBQUUsQ0FBQ0ssR0FBRCxDQUFGO0FBQ0QsS0FKRDtBQUtELEdBTk8sQ0FBUjtBQVFBLFNBQU9vQyxDQUFQO0FBQ0QsQ0FkRDs7QUFnQkEzQixPQUFPLENBQUNsVSxTQUFSLENBQWtCMlMsS0FBbEIsR0FBMEJ1QixPQUFPLENBQUN2QixLQUFsQzs7QUFFQSxTQUFTaUQsSUFBVCxHQUFpQixDQUFFOztBQUVuQixTQUFTSCxRQUFULENBQW1CSyxHQUFuQixFQUF3QjVGLEtBQXhCLEVBQStCYixHQUEvQixFQUFvQztBQUNsQyxNQUFJakIsR0FBRyxHQUFHLEVBQVY7O0FBQ0EsT0FBSyxJQUFJdEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLEdBQXBCLEVBQXlCdkcsQ0FBQyxFQUExQjtBQUE4QnNGLElBQUFBLEdBQUcsSUFBSTJILEtBQUssQ0FBQ0QsR0FBRyxDQUFDNUYsS0FBSyxHQUFHcEgsQ0FBVCxDQUFKLENBQVo7QUFBOUI7O0FBQ0EsU0FBT3NGLEdBQVA7QUFDRDs7QUFFRCxTQUFTMkgsS0FBVCxDQUFnQkMsQ0FBaEIsRUFBbUI7QUFDakIsTUFBSUEsQ0FBQyxHQUFHLEVBQVIsRUFBWSxPQUFPLE1BQU1BLENBQUMsQ0FBQzVjLFFBQUYsQ0FBVyxFQUFYLENBQWI7QUFDWixTQUFPNGMsQ0FBQyxDQUFDNWMsUUFBRixDQUFXLEVBQVgsQ0FBUDtBQUNEOzs7Ozs7Ozs7O0FDL0hELElBQUkyYSxNQUFNLEdBQUd0YixtQkFBTyxDQUFDLHNEQUFELENBQXBCOztBQUNBLElBQUl3ZCxNQUFNLEdBQUd4ZCxtQkFBTyxDQUFDLDBEQUFELENBQXBCLEVBRUE7QUFDQTtBQUNBOzs7QUFDQSxTQUFTeWQsT0FBVCxDQUFrQi9NLENBQWxCLEVBQXFCdUYsQ0FBckIsRUFBd0JDLENBQXhCLEVBQTJCO0FBQ3pCLE1BQUl3SCxFQUFFLEdBQUdoTixDQUFDLENBQUN1RixDQUFELENBQUQsR0FBT3ZGLENBQUMsQ0FBQ3dGLENBQUQsQ0FBakI7QUFDQSxNQUFJeUgsRUFBRSxHQUFHak4sQ0FBQyxDQUFDdUYsQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXdkYsQ0FBQyxDQUFDd0YsQ0FBQyxHQUFHLENBQUwsQ0FBckI7O0FBQ0EsTUFBSXdILEVBQUUsSUFBSSxXQUFWLEVBQXVCO0FBQ3JCQyxJQUFBQSxFQUFFO0FBQ0g7O0FBQ0RqTixFQUFBQSxDQUFDLENBQUN1RixDQUFELENBQUQsR0FBT3lILEVBQVA7QUFDQWhOLEVBQUFBLENBQUMsQ0FBQ3VGLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBVzBILEVBQVg7QUFDRCxFQUVEO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0MsT0FBVCxDQUFrQmxOLENBQWxCLEVBQXFCdUYsQ0FBckIsRUFBd0I0SCxFQUF4QixFQUE0QkMsRUFBNUIsRUFBZ0M7QUFDOUIsTUFBSUosRUFBRSxHQUFHaE4sQ0FBQyxDQUFDdUYsQ0FBRCxDQUFELEdBQU80SCxFQUFoQjs7QUFDQSxNQUFJQSxFQUFFLEdBQUcsQ0FBVCxFQUFZO0FBQ1ZILElBQUFBLEVBQUUsSUFBSSxXQUFOO0FBQ0Q7O0FBQ0QsTUFBSUMsRUFBRSxHQUFHak4sQ0FBQyxDQUFDdUYsQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXNkgsRUFBcEI7O0FBQ0EsTUFBSUosRUFBRSxJQUFJLFdBQVYsRUFBdUI7QUFDckJDLElBQUFBLEVBQUU7QUFDSDs7QUFDRGpOLEVBQUFBLENBQUMsQ0FBQ3VGLENBQUQsQ0FBRCxHQUFPeUgsRUFBUDtBQUNBaE4sRUFBQUEsQ0FBQyxDQUFDdUYsQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXMEgsRUFBWDtBQUNELEVBRUQ7OztBQUNBLFNBQVNJLFNBQVQsQ0FBb0JqSyxHQUFwQixFQUF5QnpELENBQXpCLEVBQTRCO0FBQzFCLFNBQVF5RCxHQUFHLENBQUN6RCxDQUFELENBQUgsR0FDUHlELEdBQUcsQ0FBQ3pELENBQUMsR0FBRyxDQUFMLENBQUgsSUFBYyxDQURQLEdBRVB5RCxHQUFHLENBQUN6RCxDQUFDLEdBQUcsQ0FBTCxDQUFILElBQWMsRUFGUCxHQUdQeUQsR0FBRyxDQUFDekQsQ0FBQyxHQUFHLENBQUwsQ0FBSCxJQUFjLEVBSGY7QUFJRCxFQUVEO0FBQ0E7OztBQUNBLFNBQVMyTixLQUFULENBQWdCL0gsQ0FBaEIsRUFBbUJDLENBQW5CLEVBQXNCck4sQ0FBdEIsRUFBeUJvVixDQUF6QixFQUE0QkMsRUFBNUIsRUFBZ0NDLEVBQWhDLEVBQW9DO0FBQ2xDLE1BQUlDLEVBQUUsR0FBR0MsQ0FBQyxDQUFDSCxFQUFELENBQVY7QUFDQSxNQUFJSSxFQUFFLEdBQUdELENBQUMsQ0FBQ0gsRUFBRSxHQUFHLENBQU4sQ0FBVjtBQUNBLE1BQUlLLEVBQUUsR0FBR0YsQ0FBQyxDQUFDRixFQUFELENBQVY7QUFDQSxNQUFJSyxFQUFFLEdBQUdILENBQUMsQ0FBQ0YsRUFBRSxHQUFHLENBQU4sQ0FBVjtBQUVBVixFQUFBQSxPQUFPLENBQUMvTSxDQUFELEVBQUl1RixDQUFKLEVBQU9DLENBQVAsQ0FBUCxDQU5rQyxDQU1qQjs7QUFDakIwSCxFQUFBQSxPQUFPLENBQUNsTixDQUFELEVBQUl1RixDQUFKLEVBQU9tSSxFQUFQLEVBQVdFLEVBQVgsQ0FBUCxDQVBrQyxDQU9aO0FBRXRCOztBQUNBLE1BQUlHLElBQUksR0FBRy9OLENBQUMsQ0FBQ3VOLENBQUQsQ0FBRCxHQUFPdk4sQ0FBQyxDQUFDdUYsQ0FBRCxDQUFuQjtBQUNBLE1BQUl5SSxJQUFJLEdBQUdoTyxDQUFDLENBQUN1TixDQUFDLEdBQUcsQ0FBTCxDQUFELEdBQVd2TixDQUFDLENBQUN1RixDQUFDLEdBQUcsQ0FBTCxDQUF2QjtBQUNBdkYsRUFBQUEsQ0FBQyxDQUFDdU4sQ0FBRCxDQUFELEdBQU9TLElBQVA7QUFDQWhPLEVBQUFBLENBQUMsQ0FBQ3VOLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBV1EsSUFBWDtBQUVBaEIsRUFBQUEsT0FBTyxDQUFDL00sQ0FBRCxFQUFJN0gsQ0FBSixFQUFPb1YsQ0FBUCxDQUFQLENBZmtDLENBaUJsQzs7QUFDQVEsRUFBQUEsSUFBSSxHQUFHL04sQ0FBQyxDQUFDd0YsQ0FBRCxDQUFELEdBQU94RixDQUFDLENBQUM3SCxDQUFELENBQWY7QUFDQTZWLEVBQUFBLElBQUksR0FBR2hPLENBQUMsQ0FBQ3dGLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBV3hGLENBQUMsQ0FBQzdILENBQUMsR0FBRyxDQUFMLENBQW5CO0FBQ0E2SCxFQUFBQSxDQUFDLENBQUN3RixDQUFELENBQUQsR0FBUXVJLElBQUksS0FBSyxFQUFWLEdBQWlCQyxJQUFJLElBQUksQ0FBaEM7QUFDQWhPLEVBQUFBLENBQUMsQ0FBQ3dGLENBQUMsR0FBRyxDQUFMLENBQUQsR0FBWXdJLElBQUksS0FBSyxFQUFWLEdBQWlCRCxJQUFJLElBQUksQ0FBcEM7QUFFQWhCLEVBQUFBLE9BQU8sQ0FBQy9NLENBQUQsRUFBSXVGLENBQUosRUFBT0MsQ0FBUCxDQUFQO0FBQ0EwSCxFQUFBQSxPQUFPLENBQUNsTixDQUFELEVBQUl1RixDQUFKLEVBQU9zSSxFQUFQLEVBQVdDLEVBQVgsQ0FBUCxDQXhCa0MsQ0EwQmxDOztBQUNBQyxFQUFBQSxJQUFJLEdBQUcvTixDQUFDLENBQUN1TixDQUFELENBQUQsR0FBT3ZOLENBQUMsQ0FBQ3VGLENBQUQsQ0FBZjtBQUNBeUksRUFBQUEsSUFBSSxHQUFHaE8sQ0FBQyxDQUFDdU4sQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXdk4sQ0FBQyxDQUFDdUYsQ0FBQyxHQUFHLENBQUwsQ0FBbkI7QUFDQXZGLEVBQUFBLENBQUMsQ0FBQ3VOLENBQUQsQ0FBRCxHQUFRUSxJQUFJLEtBQUssRUFBVixHQUFpQkMsSUFBSSxJQUFJLEVBQWhDO0FBQ0FoTyxFQUFBQSxDQUFDLENBQUN1TixDQUFDLEdBQUcsQ0FBTCxDQUFELEdBQVlTLElBQUksS0FBSyxFQUFWLEdBQWlCRCxJQUFJLElBQUksRUFBcEM7QUFFQWhCLEVBQUFBLE9BQU8sQ0FBQy9NLENBQUQsRUFBSTdILENBQUosRUFBT29WLENBQVAsQ0FBUCxDQWhDa0MsQ0FrQ2xDOztBQUNBUSxFQUFBQSxJQUFJLEdBQUcvTixDQUFDLENBQUN3RixDQUFELENBQUQsR0FBT3hGLENBQUMsQ0FBQzdILENBQUQsQ0FBZjtBQUNBNlYsRUFBQUEsSUFBSSxHQUFHaE8sQ0FBQyxDQUFDd0YsQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFXeEYsQ0FBQyxDQUFDN0gsQ0FBQyxHQUFHLENBQUwsQ0FBbkI7QUFDQTZILEVBQUFBLENBQUMsQ0FBQ3dGLENBQUQsQ0FBRCxHQUFRd0ksSUFBSSxLQUFLLEVBQVYsR0FBaUJELElBQUksSUFBSSxDQUFoQztBQUNBL04sRUFBQUEsQ0FBQyxDQUFDd0YsQ0FBQyxHQUFHLENBQUwsQ0FBRCxHQUFZdUksSUFBSSxLQUFLLEVBQVYsR0FBaUJDLElBQUksSUFBSSxDQUFwQztBQUNELEVBRUQ7OztBQUNBLElBQUlDLFlBQVksR0FBRyxJQUFJQyxXQUFKLENBQWdCLENBQ2pDLFVBRGlDLEVBQ3JCLFVBRHFCLEVBQ1QsVUFEUyxFQUNHLFVBREgsRUFFakMsVUFGaUMsRUFFckIsVUFGcUIsRUFFVCxVQUZTLEVBRUcsVUFGSCxFQUdqQyxVQUhpQyxFQUdyQixVQUhxQixFQUdULFVBSFMsRUFHRyxVQUhILEVBSWpDLFVBSmlDLEVBSXJCLFVBSnFCLEVBSVQsVUFKUyxFQUlHLFVBSkgsQ0FBaEIsQ0FBbkI7QUFPQSxJQUFJQyxNQUFNLEdBQUcsQ0FDWCxDQURXLEVBQ1IsQ0FEUSxFQUNMLENBREssRUFDRixDQURFLEVBQ0MsQ0FERCxFQUNJLENBREosRUFDTyxDQURQLEVBQ1UsQ0FEVixFQUNhLENBRGIsRUFDZ0IsQ0FEaEIsRUFDbUIsRUFEbkIsRUFDdUIsRUFEdkIsRUFDMkIsRUFEM0IsRUFDK0IsRUFEL0IsRUFDbUMsRUFEbkMsRUFDdUMsRUFEdkMsRUFFWCxFQUZXLEVBRVAsRUFGTyxFQUVILENBRkcsRUFFQSxDQUZBLEVBRUcsQ0FGSCxFQUVNLEVBRk4sRUFFVSxFQUZWLEVBRWMsQ0FGZCxFQUVpQixDQUZqQixFQUVvQixFQUZwQixFQUV3QixDQUZ4QixFQUUyQixDQUYzQixFQUU4QixFQUY5QixFQUVrQyxDQUZsQyxFQUVxQyxDQUZyQyxFQUV3QyxDQUZ4QyxFQUdYLEVBSFcsRUFHUCxDQUhPLEVBR0osRUFISSxFQUdBLENBSEEsRUFHRyxDQUhILEVBR00sQ0FITixFQUdTLEVBSFQsRUFHYSxFQUhiLEVBR2lCLEVBSGpCLEVBR3FCLEVBSHJCLEVBR3lCLENBSHpCLEVBRzRCLENBSDVCLEVBRytCLENBSC9CLEVBR2tDLENBSGxDLEVBR3FDLENBSHJDLEVBR3dDLENBSHhDLEVBSVgsQ0FKVyxFQUlSLENBSlEsRUFJTCxDQUpLLEVBSUYsQ0FKRSxFQUlDLEVBSkQsRUFJSyxFQUpMLEVBSVMsRUFKVCxFQUlhLEVBSmIsRUFJaUIsQ0FKakIsRUFJb0IsQ0FKcEIsRUFJdUIsQ0FKdkIsRUFJMEIsRUFKMUIsRUFJOEIsQ0FKOUIsRUFJaUMsQ0FKakMsRUFJb0MsRUFKcEMsRUFJd0MsQ0FKeEMsRUFLWCxDQUxXLEVBS1IsQ0FMUSxFQUtMLENBTEssRUFLRixDQUxFLEVBS0MsQ0FMRCxFQUtJLENBTEosRUFLTyxFQUxQLEVBS1csRUFMWCxFQUtlLEVBTGYsRUFLbUIsQ0FMbkIsRUFLc0IsRUFMdEIsRUFLMEIsRUFMMUIsRUFLOEIsQ0FMOUIsRUFLaUMsQ0FMakMsRUFLb0MsQ0FMcEMsRUFLdUMsRUFMdkMsRUFNWCxDQU5XLEVBTVIsRUFOUSxFQU1KLENBTkksRUFNRCxFQU5DLEVBTUcsQ0FOSCxFQU1NLEVBTk4sRUFNVSxDQU5WLEVBTWEsQ0FOYixFQU1nQixDQU5oQixFQU1tQixFQU5uQixFQU11QixDQU52QixFQU0wQixDQU4xQixFQU02QixFQU43QixFQU1pQyxFQU5qQyxFQU1xQyxDQU5yQyxFQU13QyxDQU54QyxFQU9YLEVBUFcsRUFPUCxDQVBPLEVBT0osQ0FQSSxFQU9ELEVBUEMsRUFPRyxFQVBILEVBT08sRUFQUCxFQU9XLENBUFgsRUFPYyxFQVBkLEVBT2tCLENBUGxCLEVBT3FCLENBUHJCLEVBT3dCLENBUHhCLEVBTzJCLENBUDNCLEVBTzhCLENBUDlCLEVBT2lDLENBUGpDLEVBT29DLENBUHBDLEVBT3VDLEVBUHZDLEVBUVgsRUFSVyxFQVFQLEVBUk8sRUFRSCxDQVJHLEVBUUEsRUFSQSxFQVFJLEVBUkosRUFRUSxDQVJSLEVBUVcsQ0FSWCxFQVFjLENBUmQsRUFRaUIsQ0FSakIsRUFRb0IsQ0FScEIsRUFRdUIsRUFSdkIsRUFRMkIsQ0FSM0IsRUFROEIsQ0FSOUIsRUFRaUMsQ0FSakMsRUFRb0MsQ0FScEMsRUFRdUMsRUFSdkMsRUFTWCxDQVRXLEVBU1IsRUFUUSxFQVNKLEVBVEksRUFTQSxDQVRBLEVBU0csRUFUSCxFQVNPLENBVFAsRUFTVSxDQVRWLEVBU2EsQ0FUYixFQVNnQixFQVRoQixFQVNvQixDQVRwQixFQVN1QixFQVR2QixFQVMyQixDQVQzQixFQVM4QixDQVQ5QixFQVNpQyxDQVRqQyxFQVNvQyxFQVRwQyxFQVN3QyxDQVR4QyxFQVVYLEVBVlcsRUFVUCxDQVZPLEVBVUosQ0FWSSxFQVVELENBVkMsRUFVRSxDQVZGLEVBVUssQ0FWTCxFQVVRLENBVlIsRUFVVyxDQVZYLEVBVWMsRUFWZCxFQVVrQixFQVZsQixFQVVzQixDQVZ0QixFQVV5QixFQVZ6QixFQVU2QixDQVY3QixFQVVnQyxFQVZoQyxFQVVvQyxFQVZwQyxFQVV3QyxDQVZ4QyxFQVdYLENBWFcsRUFXUixDQVhRLEVBV0wsQ0FYSyxFQVdGLENBWEUsRUFXQyxDQVhELEVBV0ksQ0FYSixFQVdPLENBWFAsRUFXVSxDQVhWLEVBV2EsQ0FYYixFQVdnQixDQVhoQixFQVdtQixFQVhuQixFQVd1QixFQVh2QixFQVcyQixFQVgzQixFQVcrQixFQVgvQixFQVdtQyxFQVhuQyxFQVd1QyxFQVh2QyxFQVlYLEVBWlcsRUFZUCxFQVpPLEVBWUgsQ0FaRyxFQVlBLENBWkEsRUFZRyxDQVpILEVBWU0sRUFaTixFQVlVLEVBWlYsRUFZYyxDQVpkLEVBWWlCLENBWmpCLEVBWW9CLEVBWnBCLEVBWXdCLENBWnhCLEVBWTJCLENBWjNCLEVBWThCLEVBWjlCLEVBWWtDLENBWmxDLEVBWXFDLENBWnJDLEVBWXdDLENBWnhDLENBQWIsRUFlQTtBQUNBO0FBQ0E7O0FBQ0EsSUFBSUMsT0FBTyxHQUFHLElBQUk1ZCxVQUFKLENBQWUyZCxNQUFNLENBQUN4RCxHQUFQLENBQVcsVUFBVWxELENBQVYsRUFBYTtBQUFFLFNBQU9BLENBQUMsR0FBRyxDQUFYO0FBQWMsQ0FBeEMsQ0FBZixDQUFkLEVBRUE7QUFDQTs7QUFDQSxJQUFJekgsQ0FBQyxHQUFHLElBQUlrTyxXQUFKLENBQWdCLEVBQWhCLENBQVI7QUFDQSxJQUFJUCxDQUFDLEdBQUcsSUFBSU8sV0FBSixDQUFnQixFQUFoQixDQUFSOztBQUNBLFNBQVNHLGVBQVQsQ0FBMEJDLEdBQTFCLEVBQStCQyxJQUEvQixFQUFxQztBQUNuQyxNQUFJNU8sQ0FBQyxHQUFHLENBQVIsQ0FEbUMsQ0FHbkM7O0FBQ0EsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHLEVBQWhCLEVBQW9CQSxDQUFDLEVBQXJCLEVBQXlCO0FBQ3ZCSyxJQUFBQSxDQUFDLENBQUNMLENBQUQsQ0FBRCxHQUFPMk8sR0FBRyxDQUFDeFQsQ0FBSixDQUFNNkUsQ0FBTixDQUFQO0FBQ0FLLElBQUFBLENBQUMsQ0FBQ0wsQ0FBQyxHQUFHLEVBQUwsQ0FBRCxHQUFZc08sWUFBWSxDQUFDdE8sQ0FBRCxDQUF4QjtBQUNELEdBUGtDLENBU25DOzs7QUFDQUssRUFBQUEsQ0FBQyxDQUFDLEVBQUQsQ0FBRCxHQUFRQSxDQUFDLENBQUMsRUFBRCxDQUFELEdBQVFzTyxHQUFHLENBQUNFLENBQXBCO0FBQ0F4TyxFQUFBQSxDQUFDLENBQUMsRUFBRCxDQUFELEdBQVFBLENBQUMsQ0FBQyxFQUFELENBQUQsR0FBU3NPLEdBQUcsQ0FBQ0UsQ0FBSixHQUFRLFdBQXpCLENBWG1DLENBWW5DO0FBRUE7O0FBQ0EsTUFBSUQsSUFBSixFQUFVO0FBQ1J2TyxJQUFBQSxDQUFDLENBQUMsRUFBRCxDQUFELEdBQVEsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUQsQ0FBVjtBQUNBQSxJQUFBQSxDQUFDLENBQUMsRUFBRCxDQUFELEdBQVEsQ0FBQ0EsQ0FBQyxDQUFDLEVBQUQsQ0FBVjtBQUNELEdBbEJrQyxDQW9CbkM7OztBQUNBLE9BQUtMLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRyxFQUFoQixFQUFvQkEsQ0FBQyxFQUFyQixFQUF5QjtBQUN2QmdPLElBQUFBLENBQUMsQ0FBQ2hPLENBQUQsQ0FBRCxHQUFPME4sU0FBUyxDQUFDaUIsR0FBRyxDQUFDOUksQ0FBTCxFQUFRLElBQUk3RixDQUFaLENBQWhCO0FBQ0QsR0F2QmtDLENBeUJuQzs7O0FBQ0EsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHLEVBQWhCLEVBQW9CQSxDQUFDLEVBQXJCLEVBQXlCO0FBQ3ZCMk4sSUFBQUEsS0FBSyxDQUFDLENBQUQsRUFBSSxDQUFKLEVBQU8sRUFBUCxFQUFXLEVBQVgsRUFBZWMsT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxDQUFWLENBQXRCLEVBQW9DeU8sT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxDQUFWLENBQTNDLENBQUw7QUFDQTJOLElBQUFBLEtBQUssQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLEVBQWdCYyxPQUFPLENBQUN6TyxDQUFDLEdBQUcsRUFBSixHQUFTLENBQVYsQ0FBdkIsRUFBcUN5TyxPQUFPLENBQUN6TyxDQUFDLEdBQUcsRUFBSixHQUFTLENBQVYsQ0FBNUMsQ0FBTDtBQUNBMk4sSUFBQUEsS0FBSyxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLEVBQVosRUFBZ0JjLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsQ0FBVixDQUF2QixFQUFxQ3lPLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsQ0FBVixDQUE1QyxDQUFMO0FBQ0EyTixJQUFBQSxLQUFLLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxFQUFSLEVBQVksRUFBWixFQUFnQmMsT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxDQUFWLENBQXZCLEVBQXFDeU8sT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxDQUFWLENBQTVDLENBQUw7QUFDQTJOLElBQUFBLEtBQUssQ0FBQyxDQUFELEVBQUksRUFBSixFQUFRLEVBQVIsRUFBWSxFQUFaLEVBQWdCYyxPQUFPLENBQUN6TyxDQUFDLEdBQUcsRUFBSixHQUFTLENBQVYsQ0FBdkIsRUFBcUN5TyxPQUFPLENBQUN6TyxDQUFDLEdBQUcsRUFBSixHQUFTLENBQVYsQ0FBNUMsQ0FBTDtBQUNBMk4sSUFBQUEsS0FBSyxDQUFDLENBQUQsRUFBSSxFQUFKLEVBQVEsRUFBUixFQUFZLEVBQVosRUFBZ0JjLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsRUFBVixDQUF2QixFQUFzQ3lPLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsRUFBVixDQUE3QyxDQUFMO0FBQ0EyTixJQUFBQSxLQUFLLENBQUMsQ0FBRCxFQUFJLEVBQUosRUFBUSxFQUFSLEVBQVksRUFBWixFQUFnQmMsT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxFQUFWLENBQXZCLEVBQXNDeU8sT0FBTyxDQUFDek8sQ0FBQyxHQUFHLEVBQUosR0FBUyxFQUFWLENBQTdDLENBQUw7QUFDQTJOLElBQUFBLEtBQUssQ0FBQyxDQUFELEVBQUksQ0FBSixFQUFPLEVBQVAsRUFBVyxFQUFYLEVBQWVjLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsRUFBVixDQUF0QixFQUFxQ3lPLE9BQU8sQ0FBQ3pPLENBQUMsR0FBRyxFQUFKLEdBQVMsRUFBVixDQUE1QyxDQUFMO0FBQ0Q7O0FBRUQsT0FBS0EsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHLEVBQWhCLEVBQW9CQSxDQUFDLEVBQXJCLEVBQXlCO0FBQ3ZCMk8sSUFBQUEsR0FBRyxDQUFDeFQsQ0FBSixDQUFNNkUsQ0FBTixJQUFXMk8sR0FBRyxDQUFDeFQsQ0FBSixDQUFNNkUsQ0FBTixJQUFXSyxDQUFDLENBQUNMLENBQUQsQ0FBWixHQUFrQkssQ0FBQyxDQUFDTCxDQUFDLEdBQUcsRUFBTCxDQUE5QjtBQUNEO0FBQ0YsRUFFRDs7O0FBQ0EsSUFBSThPLGVBQWUsR0FBRyxJQUFJamUsVUFBSixDQUFlLENBQ25DLENBRG1DLEVBQ2hDLENBRGdDLEVBQzdCLENBRDZCLEVBQzFCLENBRDBCLEVBQ2xCO0FBQ2pCLENBRm1DLEVBRWhDLENBRmdDLEVBRTdCLENBRjZCLEVBRTFCLENBRjBCLEVBRWxCO0FBQ2pCLENBSG1DLEVBR2hDLENBSGdDLEVBRzdCLENBSDZCLEVBRzFCLENBSDBCLEVBR2xCO0FBQ2pCLENBSm1DLEVBSWhDLENBSmdDLEVBSTdCLENBSjZCLEVBSTFCLENBSjBCLEVBSWxCO0FBQ2pCLENBTG1DLEVBS2hDLENBTGdDLEVBSzdCLENBTDZCLEVBSzFCLENBTDBCLEVBS2xCO0FBQ2pCLENBTm1DLEVBTWhDLENBTmdDLEVBTTdCLENBTjZCLEVBTTFCLENBTjBCLEVBTWxCO0FBQ2pCLENBUG1DLEVBT2hDLENBUGdDLEVBTzdCLENBUDZCLEVBTzFCLENBUDBCLEVBT2xCO0FBQ2pCLENBUm1DLEVBUWhDLENBUmdDLEVBUTdCLENBUjZCLEVBUTFCLENBUjBCLEVBUWxCO0FBQ2pCLENBVG1DLEVBU2hDLENBVGdDLEVBUzdCLENBVDZCLEVBUzFCLENBVDBCLEVBU2xCO0FBQ2pCLENBVm1DLEVBVWhDLENBVmdDLEVBVTdCLENBVjZCLEVBVTFCLENBVjBCLEVBVWxCO0FBQ2pCLENBWG1DLEVBV2hDLENBWGdDLEVBVzdCLENBWDZCLEVBVzFCLENBWDBCLEVBV2xCO0FBQ2pCLENBWm1DLEVBWWhDLENBWmdDLEVBWTdCLENBWjZCLEVBWTFCLENBWjBCLEVBWWxCO0FBQ2pCLENBYm1DLEVBYWhDLENBYmdDLEVBYTdCLENBYjZCLEVBYTFCLENBYjBCLEVBYWxCO0FBQ2pCLENBZG1DLEVBY2hDLENBZGdDLEVBYzdCLENBZDZCLEVBYzFCLENBZDBCLEVBY2xCO0FBQ2pCLENBZm1DLEVBZWhDLENBZmdDLEVBZTdCLENBZjZCLEVBZTFCLENBZjBCLEVBZWxCO0FBQ2pCLENBaEJtQyxFQWdCaEMsQ0FoQmdDLEVBZ0I3QixDQWhCNkIsRUFnQjFCLENBaEIwQixDQWdCbEI7QUFoQmtCLENBQWYsQ0FBdEIsRUFtQkE7QUFDQTtBQUNBOztBQUNBLFNBQVN1YSxPQUFULENBQWtCMkQsTUFBbEIsRUFBMEJuWixHQUExQixFQUErQmtXLElBQS9CLEVBQXFDQyxRQUFyQyxFQUErQztBQUM3QztBQUNBK0MsRUFBQUEsZUFBZSxDQUFDMUMsSUFBaEIsQ0FBcUIsQ0FBckIsRUFGNkMsQ0FHN0M7O0FBRUEsT0FBS3ZHLENBQUwsR0FBUyxJQUFJaFYsVUFBSixDQUFlLEdBQWYsQ0FBVDtBQUNBLE9BQUtzSyxDQUFMLEdBQVMsSUFBSW9ULFdBQUosQ0FBZ0IsRUFBaEIsQ0FBVDtBQUNBLE9BQUtNLENBQUwsR0FBUyxDQUFULENBUDZDLENBT2xDOztBQUNYLE9BQUtyVyxDQUFMLEdBQVMsQ0FBVCxDQVI2QyxDQVFsQzs7QUFDWCxPQUFLdVcsTUFBTCxHQUFjQSxNQUFkLENBVDZDLENBU3hCOztBQUVyQkQsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQkMsTUFBckI7QUFDQSxNQUFJblosR0FBSixFQUFTa1osZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQmxaLEdBQUcsQ0FBQ3NFLE1BQXpCO0FBQ1Q0VSxFQUFBQSxlQUFlLENBQUMsQ0FBRCxDQUFmLEdBQXFCLENBQXJCLENBYjZDLENBYXRCOztBQUN2QkEsRUFBQUEsZUFBZSxDQUFDLENBQUQsQ0FBZixHQUFxQixDQUFyQixDQWQ2QyxDQWN0Qjs7QUFFdkIsTUFBSWhELElBQUosRUFBVWdELGVBQWUsQ0FBQ3pDLEdBQWhCLENBQW9CUCxJQUFwQixFQUEwQixFQUExQjtBQUNWLE1BQUlDLFFBQUosRUFBYytDLGVBQWUsQ0FBQ3pDLEdBQWhCLENBQW9CTixRQUFwQixFQUE4QixFQUE5QixFQWpCK0IsQ0FtQjdDOztBQUNBLE9BQUssSUFBSS9MLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcsRUFBcEIsRUFBd0JBLENBQUMsRUFBekIsRUFBNkI7QUFDM0IsU0FBSzdFLENBQUwsQ0FBTzZFLENBQVAsSUFBWXNPLFlBQVksQ0FBQ3RPLENBQUQsQ0FBWixHQUFrQjBOLFNBQVMsQ0FBQ29CLGVBQUQsRUFBa0I5TyxDQUFDLEdBQUcsQ0FBdEIsQ0FBdkM7QUFDRCxHQXRCNEMsQ0F3QjdDOzs7QUFDQSxNQUFJcEssR0FBSixFQUFTO0FBQ1BvWixJQUFBQSxhQUFhLENBQUMsSUFBRCxFQUFPcFosR0FBUCxDQUFiLENBRE8sQ0FFUDs7QUFDQSxTQUFLNEMsQ0FBTCxHQUFTLEdBQVQ7QUFDRDtBQUNGOztBQUVENFMsT0FBTyxDQUFDbFUsU0FBUixDQUFrQnRHLE1BQWxCLEdBQTJCLFVBQVUyYixLQUFWLEVBQWlCO0FBQzFDdEIsRUFBQUEsTUFBTSxDQUFDc0IsS0FBSyxJQUFJLElBQVYsRUFBZ0Isb0NBQWhCLENBQU47QUFDQXlDLEVBQUFBLGFBQWEsQ0FBQyxJQUFELEVBQU96QyxLQUFQLENBQWI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQUpEOztBQU1BbkIsT0FBTyxDQUFDbFUsU0FBUixDQUFrQnBHLE1BQWxCLEdBQTJCLFVBQVVtZSxHQUFWLEVBQWU7QUFDeEMsTUFBSWpDLEdBQUcsR0FBSSxDQUFDaUMsR0FBRCxJQUFRQSxHQUFHLEtBQUssUUFBaEIsSUFBNEJBLEdBQUcsS0FBSyxLQUFyQyxHQUE4QyxJQUFJcGUsVUFBSixDQUFlLEtBQUtrZSxNQUFwQixDQUE5QyxHQUE0RUUsR0FBdEY7QUFDQWhFLEVBQUFBLE1BQU0sQ0FBQytCLEdBQUcsQ0FBQzlTLE1BQUosSUFBYyxLQUFLNlUsTUFBcEIsRUFBNEIsOENBQTVCLENBQU47QUFDQUcsRUFBQUEsWUFBWSxDQUFDLElBQUQsRUFBT2xDLEdBQVAsQ0FBWjtBQUNBLE1BQUlpQyxHQUFHLEtBQUssS0FBWixFQUFtQixPQUFPdEMsUUFBUSxDQUFDSyxHQUFELENBQWY7QUFDbkIsU0FBT0EsR0FBUDtBQUNELENBTkQ7O0FBUUE1QixPQUFPLENBQUNsVSxTQUFSLFlBQTBCa1UsT0FBTyxDQUFDbFUsU0FBUixDQUFrQnBHLE1BQTVDOztBQUVBc2EsT0FBTyxDQUFDdkIsS0FBUixHQUFnQixVQUFVUyxFQUFWLEVBQWM7QUFDNUI2QyxFQUFBQSxNQUFNLENBQUN0RCxLQUFQLENBQWEsWUFBWTtBQUN2QlMsSUFBQUEsRUFBRSxHQURxQixDQUNsQjtBQUNOLEdBRkQ7QUFHRCxDQUpELEVBTUE7QUFDQTs7O0FBQ0EsU0FBUzBFLGFBQVQsQ0FBd0JMLEdBQXhCLEVBQTZCcEMsS0FBN0IsRUFBb0M7QUFDbEMsT0FBSyxJQUFJdk0sQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VNLEtBQUssQ0FBQ3JTLE1BQTFCLEVBQWtDOEYsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxRQUFJMk8sR0FBRyxDQUFDblcsQ0FBSixLQUFVLEdBQWQsRUFBbUI7QUFBRTtBQUNuQm1XLE1BQUFBLEdBQUcsQ0FBQ0UsQ0FBSixJQUFTRixHQUFHLENBQUNuVyxDQUFiLENBRGlCLENBQ0Y7O0FBQ2ZrVyxNQUFBQSxlQUFlLENBQUNDLEdBQUQsRUFBTSxLQUFOLENBQWYsQ0FGaUIsQ0FFVzs7QUFDNUJBLE1BQUFBLEdBQUcsQ0FBQ25XLENBQUosR0FBUSxDQUFSLENBSGlCLENBR1A7QUFDWDs7QUFDRG1XLElBQUFBLEdBQUcsQ0FBQzlJLENBQUosQ0FBTThJLEdBQUcsQ0FBQ25XLENBQUosRUFBTixJQUFpQitULEtBQUssQ0FBQ3ZNLENBQUQsQ0FBdEI7QUFDRDtBQUNGLEVBRUQ7QUFDQTs7O0FBQ0EsU0FBU2tQLFlBQVQsQ0FBdUJQLEdBQXZCLEVBQTRCTSxHQUE1QixFQUFpQztBQUMvQk4sRUFBQUEsR0FBRyxDQUFDRSxDQUFKLElBQVNGLEdBQUcsQ0FBQ25XLENBQWIsQ0FEK0IsQ0FDaEI7O0FBRWYsU0FBT21XLEdBQUcsQ0FBQ25XLENBQUosR0FBUSxHQUFmLEVBQW9CO0FBQUU7QUFDcEJtVyxJQUFBQSxHQUFHLENBQUM5SSxDQUFKLENBQU04SSxHQUFHLENBQUNuVyxDQUFKLEVBQU4sSUFBaUIsQ0FBakI7QUFDRDs7QUFDRGtXLEVBQUFBLGVBQWUsQ0FBQ0MsR0FBRCxFQUFNLElBQU4sQ0FBZixDQU4rQixDQU1KOztBQUUzQixPQUFLLElBQUkzTyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHMk8sR0FBRyxDQUFDSSxNQUF4QixFQUFnQy9PLENBQUMsRUFBakMsRUFBcUM7QUFDbkNpUCxJQUFBQSxHQUFHLENBQUNqUCxDQUFELENBQUgsR0FBUzJPLEdBQUcsQ0FBQ3hULENBQUosQ0FBTTZFLENBQUMsSUFBSSxDQUFYLEtBQWtCLEtBQUtBLENBQUMsR0FBRyxDQUFULENBQTNCO0FBQ0Q7O0FBQ0QsU0FBT2lQLEdBQVA7QUFDRDs7QUFFRCxTQUFTdEMsUUFBVCxDQUFtQkssR0FBbkIsRUFBd0I7QUFDdEIsTUFBSTFILEdBQUcsR0FBRyxFQUFWOztBQUNBLE9BQUssSUFBSXRGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdnTixHQUFHLENBQUM5UyxNQUF4QixFQUFnQzhGLENBQUMsRUFBakM7QUFBcUNzRixJQUFBQSxHQUFHLElBQUkySCxLQUFLLENBQUNELEdBQUcsQ0FBQ2hOLENBQUQsQ0FBSixDQUFaO0FBQXJDOztBQUNBLFNBQU9zRixHQUFQO0FBQ0Q7O0FBRUQsU0FBUzJILEtBQVQsQ0FBZ0JDLENBQWhCLEVBQW1CO0FBQ2pCLE1BQUlBLENBQUMsR0FBRyxFQUFSLEVBQVksT0FBTyxNQUFNQSxDQUFDLENBQUM1YyxRQUFGLENBQVcsRUFBWCxDQUFiO0FBQ1osU0FBTzRjLENBQUMsQ0FBQzVjLFFBQUYsQ0FBVyxFQUFYLENBQVA7QUFDRDs7QUFFRCxJQUFJNmUsS0FBSyxHQUFHL0QsT0FBWjs7QUFFQWhhLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBUzRmLFVBQVQsQ0FBcUJMLE1BQXJCLEVBQTZCblosR0FBN0IsRUFBa0NrVyxJQUFsQyxFQUF3Q0MsUUFBeEMsRUFBa0RDLFFBQWxELEVBQTREO0FBQzNFLE1BQUlBLFFBQVEsS0FBSyxJQUFqQixFQUF1QjtBQUNyQmYsSUFBQUEsTUFBTSxDQUFDOEQsTUFBTSxJQUFJMUQsU0FBWCxFQUFzQiw2QkFBNkJBLFNBQTdCLEdBQXlDLGNBQXpDLEdBQTBEMEQsTUFBaEYsQ0FBTjtBQUNBOUQsSUFBQUEsTUFBTSxDQUFDOEQsTUFBTSxJQUFJekQsU0FBWCxFQUFzQiw0QkFBNEJBLFNBQTVCLEdBQXdDLGNBQXhDLEdBQXlEeUQsTUFBL0UsQ0FBTjtBQUNBLFFBQUluWixHQUFHLElBQUksSUFBWCxFQUFpQnFWLE1BQU0sQ0FBQ3JWLEdBQUcsQ0FBQ3NFLE1BQUosSUFBY3NSLFlBQWYsRUFBNkIsMEJBQTBCQSxZQUExQixHQUF5QyxjQUF6QyxHQUEwRDVWLEdBQUcsQ0FBQ3NFLE1BQTNGLENBQU47QUFDakIsUUFBSXRFLEdBQUcsSUFBSSxJQUFYLEVBQWlCcVYsTUFBTSxDQUFDclYsR0FBRyxDQUFDc0UsTUFBSixJQUFjdVIsWUFBZixFQUE2Qix5QkFBeUJBLFlBQXpCLEdBQXdDLGNBQXhDLEdBQXlEN1YsR0FBRyxDQUFDc0UsTUFBMUYsQ0FBTjtBQUNqQixRQUFJNFIsSUFBSSxJQUFJLElBQVosRUFBa0JiLE1BQU0sQ0FBQ2EsSUFBSSxDQUFDNVIsTUFBTCxLQUFnQnlSLFNBQWpCLEVBQTRCLDBCQUEwQkEsU0FBMUIsR0FBc0MsY0FBdEMsR0FBdURHLElBQUksQ0FBQzVSLE1BQXhGLENBQU47QUFDbEIsUUFBSTZSLFFBQVEsSUFBSSxJQUFoQixFQUFzQmQsTUFBTSxDQUFDYyxRQUFRLENBQUM3UixNQUFULEtBQW9CMFIsYUFBckIsRUFBb0MsOEJBQThCQSxhQUE5QixHQUE4QyxjQUE5QyxHQUErREcsUUFBUSxDQUFDN1IsTUFBNUcsQ0FBTjtBQUN2Qjs7QUFFRCxTQUFPLElBQUlpVixLQUFKLENBQVVKLE1BQVYsRUFBa0JuWixHQUFsQixFQUF1QmtXLElBQXZCLEVBQTZCQyxRQUE3QixDQUFQO0FBQ0QsQ0FYRDs7QUFhQTNhLG9CQUFBLEdBQXVCLFVBQVVrWixFQUFWLEVBQWM7QUFDbkM2QyxFQUFBQSxNQUFNLENBQUN0RCxLQUFQLENBQWEsWUFBWTtBQUFFO0FBQ3pCUyxJQUFBQSxFQUFFO0FBQ0gsR0FGRDtBQUdELENBSkQ7O0FBTUFsWiw2QkFBQSxHQUFnQytiLE1BQU0sQ0FBQ04sU0FBdkM7QUFDQXpiLDBCQUFBLEdBQTZCLEtBQTdCO0FBRUEsSUFBSWlhLFNBQVMsR0FBR2phLHdCQUFBLEdBQTJCLEVBQTNDO0FBQ0EsSUFBSWthLFNBQVMsR0FBR2xhLHdCQUFBLEdBQTJCLEVBQTNDO0FBQ0EsSUFBSW1hLEtBQUssR0FBR25hLG9CQUFBLEdBQXVCLEVBQW5DO0FBQ0EsSUFBSW9hLFlBQVksR0FBR3BhLDJCQUFBLEdBQThCLEVBQWpEO0FBQ0EsSUFBSXFhLFlBQVksR0FBR3JhLDJCQUFBLEdBQThCLEVBQWpEO0FBQ0EsSUFBSXNhLFFBQVEsR0FBR3RhLHVCQUFBLEdBQTBCLEVBQXpDO0FBQ0EsSUFBSXVhLFNBQVMsR0FBR3ZhLHdCQUFBLEdBQTJCLEVBQTNDO0FBQ0EsSUFBSXdhLGFBQWEsR0FBR3hhLDRCQUFBLEdBQStCLEVBQW5EO0FBRUErYixNQUFNLENBQUN0RCxLQUFQLENBQWEsVUFBVWMsR0FBVixFQUFlO0FBQzFCLE1BQUksQ0FBQ0EsR0FBTCxFQUFVO0FBQ1J2WixJQUFBQSwwQkFBQSxHQUE2QixJQUE3QjtBQUNBK2QsSUFBQUEsS0FBSyxHQUFHaEMsTUFBUjtBQUNEO0FBQ0YsQ0FMRDs7Ozs7Ozs7OztBQ25UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsSUFBTW9DLE1BQU0sR0FBRzVmLG1CQUFPLENBQUMsb0RBQUQsQ0FBdEI7O0FBQ0EsSUFBTTZmLE9BQU8sR0FBRzdmLG1CQUFPLENBQUMsZ0RBQUQsQ0FBdkI7O0FBQ0EsSUFBTThmLG1CQUFtQixHQUN0QixPQUFPQyxNQUFQLEtBQWtCLFVBQWxCLElBQWdDLE9BQU9BLE1BQU0sQ0FBQyxLQUFELENBQWIsS0FBeUIsVUFBMUQsQ0FBc0U7QUFBdEUsRUFDSUEsTUFBTSxDQUFDLEtBQUQsQ0FBTixDQUFjLDRCQUFkLENBREosQ0FDZ0Q7QUFEaEQsRUFFSSxJQUhOO0FBS0FsZ0IsY0FBQSxHQUFpQlksTUFBakI7QUFDQVosa0JBQUEsR0FBcUJtZ0IsVUFBckI7QUFDQW5nQix5QkFBQSxHQUE0QixFQUE1QjtBQUVBLElBQU1xZ0IsWUFBWSxHQUFHLFVBQXJCO0FBQ0FyZ0Isa0JBQUEsR0FBcUJxZ0IsWUFBckI7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUNBemYsTUFBTSxDQUFDMmYsbUJBQVAsR0FBNkJDLGlCQUFpQixFQUE5Qzs7QUFFQSxJQUFJLENBQUM1ZixNQUFNLENBQUMyZixtQkFBUixJQUErQixPQUFPdEwsT0FBUCxLQUFtQixXQUFsRCxJQUNBLE9BQU9BLE9BQU8sQ0FBQ2xLLEtBQWYsS0FBeUIsVUFEN0IsRUFDeUM7QUFDdkNrSyxFQUFBQSxPQUFPLENBQUNsSyxLQUFSLENBQ0UsOEVBQ0Esc0VBRkY7QUFJRDs7QUFFRCxTQUFTeVYsaUJBQVQsR0FBOEI7QUFDNUI7QUFDQSxNQUFJO0FBQ0YsUUFBTXZNLEdBQUcsR0FBRyxJQUFJNVMsVUFBSixDQUFlLENBQWYsQ0FBWjtBQUNBLFFBQU1vZixLQUFLLEdBQUc7QUFBRUMsTUFBQUEsR0FBRyxFQUFFLGVBQVk7QUFBRSxlQUFPLEVBQVA7QUFBVztBQUFoQyxLQUFkO0FBQ0E1Z0IsSUFBQUEsTUFBTSxDQUFDNmdCLGNBQVAsQ0FBc0JGLEtBQXRCLEVBQTZCcGYsVUFBVSxDQUFDcUcsU0FBeEM7QUFDQTVILElBQUFBLE1BQU0sQ0FBQzZnQixjQUFQLENBQXNCMU0sR0FBdEIsRUFBMkJ3TSxLQUEzQjtBQUNBLFdBQU94TSxHQUFHLENBQUN5TSxHQUFKLE9BQWMsRUFBckI7QUFDRCxHQU5ELENBTUUsT0FBT25SLENBQVAsRUFBVTtBQUNWLFdBQU8sS0FBUDtBQUNEO0FBQ0Y7O0FBRUR6UCxNQUFNLENBQUNDLGNBQVAsQ0FBc0JhLE1BQU0sQ0FBQzhHLFNBQTdCLEVBQXdDLFFBQXhDLEVBQWtEO0FBQ2hEa1osRUFBQUEsVUFBVSxFQUFFLElBRG9DO0FBRWhEQyxFQUFBQSxHQUFHLEVBQUUsZUFBWTtBQUNmLFFBQUksQ0FBQ2pnQixNQUFNLENBQUM4TyxRQUFQLENBQWdCLElBQWhCLENBQUwsRUFBNEIsT0FBTzNKLFNBQVA7QUFDNUIsV0FBTyxLQUFLZ0ssTUFBWjtBQUNEO0FBTCtDLENBQWxEO0FBUUFqUSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JhLE1BQU0sQ0FBQzhHLFNBQTdCLEVBQXdDLFFBQXhDLEVBQWtEO0FBQ2hEa1osRUFBQUEsVUFBVSxFQUFFLElBRG9DO0FBRWhEQyxFQUFBQSxHQUFHLEVBQUUsZUFBWTtBQUNmLFFBQUksQ0FBQ2pnQixNQUFNLENBQUM4TyxRQUFQLENBQWdCLElBQWhCLENBQUwsRUFBNEIsT0FBTzNKLFNBQVA7QUFDNUIsV0FBTyxLQUFLK2EsVUFBWjtBQUNEO0FBTCtDLENBQWxEOztBQVFBLFNBQVNDLFlBQVQsQ0FBdUJyVyxNQUF2QixFQUErQjtBQUM3QixNQUFJQSxNQUFNLEdBQUcyVixZQUFiLEVBQTJCO0FBQ3pCLFVBQU0sSUFBSVcsVUFBSixDQUFlLGdCQUFnQnRXLE1BQWhCLEdBQXlCLGdDQUF4QyxDQUFOO0FBQ0QsR0FINEIsQ0FJN0I7OztBQUNBLE1BQU04UyxHQUFHLEdBQUcsSUFBSW5jLFVBQUosQ0FBZXFKLE1BQWYsQ0FBWjtBQUNBNUssRUFBQUEsTUFBTSxDQUFDNmdCLGNBQVAsQ0FBc0JuRCxHQUF0QixFQUEyQjVjLE1BQU0sQ0FBQzhHLFNBQWxDO0FBQ0EsU0FBTzhWLEdBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsU0FBUzVjLE1BQVQsQ0FBaUJxZ0IsR0FBakIsRUFBc0JDLGdCQUF0QixFQUF3Q3hXLE1BQXhDLEVBQWdEO0FBQzlDO0FBQ0EsTUFBSSxPQUFPdVcsR0FBUCxLQUFlLFFBQW5CLEVBQTZCO0FBQzNCLFFBQUksT0FBT0MsZ0JBQVAsS0FBNEIsUUFBaEMsRUFBMEM7QUFDeEMsWUFBTSxJQUFJelksU0FBSixDQUNKLG9FQURJLENBQU47QUFHRDs7QUFDRCxXQUFPMFksV0FBVyxDQUFDRixHQUFELENBQWxCO0FBQ0Q7O0FBQ0QsU0FBT3BnQixJQUFJLENBQUNvZ0IsR0FBRCxFQUFNQyxnQkFBTixFQUF3QnhXLE1BQXhCLENBQVg7QUFDRDs7QUFFRDlKLE1BQU0sQ0FBQ3dnQixRQUFQLEdBQWtCLElBQWxCLEVBQXVCOztBQUV2QixTQUFTdmdCLElBQVQsQ0FBZVosS0FBZixFQUFzQmloQixnQkFBdEIsRUFBd0N4VyxNQUF4QyxFQUFnRDtBQUM5QyxNQUFJLE9BQU96SyxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQzdCLFdBQU9vaEIsVUFBVSxDQUFDcGhCLEtBQUQsRUFBUWloQixnQkFBUixDQUFqQjtBQUNEOztBQUVELE1BQUkxTCxXQUFXLENBQUNDLE1BQVosQ0FBbUJ4VixLQUFuQixDQUFKLEVBQStCO0FBQzdCLFdBQU9xaEIsYUFBYSxDQUFDcmhCLEtBQUQsQ0FBcEI7QUFDRDs7QUFFRCxNQUFJQSxLQUFLLElBQUksSUFBYixFQUFtQjtBQUNqQixVQUFNLElBQUl3SSxTQUFKLENBQ0osZ0ZBQ0Esc0NBREEsV0FDaUR4SSxLQURqRCxDQURJLENBQU47QUFJRDs7QUFFRCxNQUFJc2hCLFVBQVUsQ0FBQ3RoQixLQUFELEVBQVF1VixXQUFSLENBQVYsSUFDQ3ZWLEtBQUssSUFBSXNoQixVQUFVLENBQUN0aEIsS0FBSyxDQUFDOFAsTUFBUCxFQUFleUYsV0FBZixDQUR4QixFQUNzRDtBQUNwRCxXQUFPZ00sZUFBZSxDQUFDdmhCLEtBQUQsRUFBUWloQixnQkFBUixFQUEwQnhXLE1BQTFCLENBQXRCO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPK1csaUJBQVAsS0FBNkIsV0FBN0IsS0FDQ0YsVUFBVSxDQUFDdGhCLEtBQUQsRUFBUXdoQixpQkFBUixDQUFWLElBQ0F4aEIsS0FBSyxJQUFJc2hCLFVBQVUsQ0FBQ3RoQixLQUFLLENBQUM4UCxNQUFQLEVBQWUwUixpQkFBZixDQUZwQixDQUFKLEVBRTZEO0FBQzNELFdBQU9ELGVBQWUsQ0FBQ3ZoQixLQUFELEVBQVFpaEIsZ0JBQVIsRUFBMEJ4VyxNQUExQixDQUF0QjtBQUNEOztBQUVELE1BQUksT0FBT3pLLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJd0ksU0FBSixDQUNKLHVFQURJLENBQU47QUFHRDs7QUFFRCxNQUFNaVosT0FBTyxHQUFHemhCLEtBQUssQ0FBQ3loQixPQUFOLElBQWlCemhCLEtBQUssQ0FBQ3loQixPQUFOLEVBQWpDOztBQUNBLE1BQUlBLE9BQU8sSUFBSSxJQUFYLElBQW1CQSxPQUFPLEtBQUt6aEIsS0FBbkMsRUFBMEM7QUFDeEMsV0FBT1csTUFBTSxDQUFDQyxJQUFQLENBQVk2Z0IsT0FBWixFQUFxQlIsZ0JBQXJCLEVBQXVDeFcsTUFBdkMsQ0FBUDtBQUNEOztBQUVELE1BQU0yTCxDQUFDLEdBQUdzTCxVQUFVLENBQUMxaEIsS0FBRCxDQUFwQjtBQUNBLE1BQUlvVyxDQUFKLEVBQU8sT0FBT0EsQ0FBUDs7QUFFUCxNQUFJLE9BQU82SixNQUFQLEtBQWtCLFdBQWxCLElBQWlDQSxNQUFNLENBQUMwQixXQUFQLElBQXNCLElBQXZELElBQ0EsT0FBTzNoQixLQUFLLENBQUNpZ0IsTUFBTSxDQUFDMEIsV0FBUixDQUFaLEtBQXFDLFVBRHpDLEVBQ3FEO0FBQ25ELFdBQU9oaEIsTUFBTSxDQUFDQyxJQUFQLENBQVlaLEtBQUssQ0FBQ2lnQixNQUFNLENBQUMwQixXQUFSLENBQUwsQ0FBMEIsUUFBMUIsQ0FBWixFQUFpRFYsZ0JBQWpELEVBQW1FeFcsTUFBbkUsQ0FBUDtBQUNEOztBQUVELFFBQU0sSUFBSWpDLFNBQUosQ0FDSixnRkFDQSxzQ0FEQSxXQUNpRHhJLEtBRGpELENBREksQ0FBTjtBQUlEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0FXLE1BQU0sQ0FBQ0MsSUFBUCxHQUFjLFVBQVVaLEtBQVYsRUFBaUJpaEIsZ0JBQWpCLEVBQW1DeFcsTUFBbkMsRUFBMkM7QUFDdkQsU0FBTzdKLElBQUksQ0FBQ1osS0FBRCxFQUFRaWhCLGdCQUFSLEVBQTBCeFcsTUFBMUIsQ0FBWDtBQUNELENBRkQsRUFJQTtBQUNBOzs7QUFDQTVLLE1BQU0sQ0FBQzZnQixjQUFQLENBQXNCL2YsTUFBTSxDQUFDOEcsU0FBN0IsRUFBd0NyRyxVQUFVLENBQUNxRyxTQUFuRDtBQUNBNUgsTUFBTSxDQUFDNmdCLGNBQVAsQ0FBc0IvZixNQUF0QixFQUE4QlMsVUFBOUI7O0FBRUEsU0FBU3dnQixVQUFULENBQXFCcEgsSUFBckIsRUFBMkI7QUFDekIsTUFBSSxPQUFPQSxJQUFQLEtBQWdCLFFBQXBCLEVBQThCO0FBQzVCLFVBQU0sSUFBSWhTLFNBQUosQ0FBYyx3Q0FBZCxDQUFOO0FBQ0QsR0FGRCxNQUVPLElBQUlnUyxJQUFJLEdBQUcsQ0FBWCxFQUFjO0FBQ25CLFVBQU0sSUFBSXVHLFVBQUosQ0FBZSxnQkFBZ0J2RyxJQUFoQixHQUF1QixnQ0FBdEMsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU3FILEtBQVQsQ0FBZ0JySCxJQUFoQixFQUFzQm1DLElBQXRCLEVBQTRCdkQsUUFBNUIsRUFBc0M7QUFDcEN3SSxFQUFBQSxVQUFVLENBQUNwSCxJQUFELENBQVY7O0FBQ0EsTUFBSUEsSUFBSSxJQUFJLENBQVosRUFBZTtBQUNiLFdBQU9zRyxZQUFZLENBQUN0RyxJQUFELENBQW5CO0FBQ0Q7O0FBQ0QsTUFBSW1DLElBQUksS0FBSzdXLFNBQWIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0EsV0FBTyxPQUFPc1QsUUFBUCxLQUFvQixRQUFwQixHQUNIMEgsWUFBWSxDQUFDdEcsSUFBRCxDQUFaLENBQW1CbUMsSUFBbkIsQ0FBd0JBLElBQXhCLEVBQThCdkQsUUFBOUIsQ0FERyxHQUVIMEgsWUFBWSxDQUFDdEcsSUFBRCxDQUFaLENBQW1CbUMsSUFBbkIsQ0FBd0JBLElBQXhCLENBRko7QUFHRDs7QUFDRCxTQUFPbUUsWUFBWSxDQUFDdEcsSUFBRCxDQUFuQjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7OztBQUNBN1osTUFBTSxDQUFDa2hCLEtBQVAsR0FBZSxVQUFVckgsSUFBVixFQUFnQm1DLElBQWhCLEVBQXNCdkQsUUFBdEIsRUFBZ0M7QUFDN0MsU0FBT3lJLEtBQUssQ0FBQ3JILElBQUQsRUFBT21DLElBQVAsRUFBYXZELFFBQWIsQ0FBWjtBQUNELENBRkQ7O0FBSUEsU0FBUzhILFdBQVQsQ0FBc0IxRyxJQUF0QixFQUE0QjtBQUMxQm9ILEVBQUFBLFVBQVUsQ0FBQ3BILElBQUQsQ0FBVjtBQUNBLFNBQU9zRyxZQUFZLENBQUN0RyxJQUFJLEdBQUcsQ0FBUCxHQUFXLENBQVgsR0FBZXNILE9BQU8sQ0FBQ3RILElBQUQsQ0FBUCxHQUFnQixDQUFoQyxDQUFuQjtBQUNEO0FBRUQ7QUFDQTtBQUNBOzs7QUFDQTdaLE1BQU0sQ0FBQ3VnQixXQUFQLEdBQXFCLFVBQVUxRyxJQUFWLEVBQWdCO0FBQ25DLFNBQU8wRyxXQUFXLENBQUMxRyxJQUFELENBQWxCO0FBQ0QsQ0FGRDtBQUdBO0FBQ0E7QUFDQTs7O0FBQ0E3WixNQUFNLENBQUNvaEIsZUFBUCxHQUF5QixVQUFVdkgsSUFBVixFQUFnQjtBQUN2QyxTQUFPMEcsV0FBVyxDQUFDMUcsSUFBRCxDQUFsQjtBQUNELENBRkQ7O0FBSUEsU0FBUzRHLFVBQVQsQ0FBcUJZLE1BQXJCLEVBQTZCNUksUUFBN0IsRUFBdUM7QUFDckMsTUFBSSxPQUFPQSxRQUFQLEtBQW9CLFFBQXBCLElBQWdDQSxRQUFRLEtBQUssRUFBakQsRUFBcUQ7QUFDbkRBLElBQUFBLFFBQVEsR0FBRyxNQUFYO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDelksTUFBTSxDQUFDc2hCLFVBQVAsQ0FBa0I3SSxRQUFsQixDQUFMLEVBQWtDO0FBQ2hDLFVBQU0sSUFBSTVRLFNBQUosQ0FBYyx1QkFBdUI0USxRQUFyQyxDQUFOO0FBQ0Q7O0FBRUQsTUFBTTNPLE1BQU0sR0FBRytMLFVBQVUsQ0FBQ3dMLE1BQUQsRUFBUzVJLFFBQVQsQ0FBVixHQUErQixDQUE5QztBQUNBLE1BQUltRSxHQUFHLEdBQUd1RCxZQUFZLENBQUNyVyxNQUFELENBQXRCO0FBRUEsTUFBTXlYLE1BQU0sR0FBRzNFLEdBQUcsQ0FBQ3BNLEtBQUosQ0FBVTZRLE1BQVYsRUFBa0I1SSxRQUFsQixDQUFmOztBQUVBLE1BQUk4SSxNQUFNLEtBQUt6WCxNQUFmLEVBQXVCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOFMsSUFBQUEsR0FBRyxHQUFHQSxHQUFHLENBQUN4YyxLQUFKLENBQVUsQ0FBVixFQUFhbWhCLE1BQWIsQ0FBTjtBQUNEOztBQUVELFNBQU8zRSxHQUFQO0FBQ0Q7O0FBRUQsU0FBUzRFLGFBQVQsQ0FBd0JDLEtBQXhCLEVBQStCO0FBQzdCLE1BQU0zWCxNQUFNLEdBQUcyWCxLQUFLLENBQUMzWCxNQUFOLEdBQWUsQ0FBZixHQUFtQixDQUFuQixHQUF1QnFYLE9BQU8sQ0FBQ00sS0FBSyxDQUFDM1gsTUFBUCxDQUFQLEdBQXdCLENBQTlEO0FBQ0EsTUFBTThTLEdBQUcsR0FBR3VELFlBQVksQ0FBQ3JXLE1BQUQsQ0FBeEI7O0FBQ0EsT0FBSyxJQUFJOEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRzlGLE1BQXBCLEVBQTRCOEYsQ0FBQyxJQUFJLENBQWpDLEVBQW9DO0FBQ2xDZ04sSUFBQUEsR0FBRyxDQUFDaE4sQ0FBRCxDQUFILEdBQVM2UixLQUFLLENBQUM3UixDQUFELENBQUwsR0FBVyxHQUFwQjtBQUNEOztBQUNELFNBQU9nTixHQUFQO0FBQ0Q7O0FBRUQsU0FBUzhELGFBQVQsQ0FBd0JnQixTQUF4QixFQUFtQztBQUNqQyxNQUFJZixVQUFVLENBQUNlLFNBQUQsRUFBWWpoQixVQUFaLENBQWQsRUFBdUM7QUFDckMsUUFBTWtoQixJQUFJLEdBQUcsSUFBSWxoQixVQUFKLENBQWVpaEIsU0FBZixDQUFiO0FBQ0EsV0FBT2QsZUFBZSxDQUFDZSxJQUFJLENBQUN4UyxNQUFOLEVBQWN3UyxJQUFJLENBQUN6QixVQUFuQixFQUErQnlCLElBQUksQ0FBQzlMLFVBQXBDLENBQXRCO0FBQ0Q7O0FBQ0QsU0FBTzJMLGFBQWEsQ0FBQ0UsU0FBRCxDQUFwQjtBQUNEOztBQUVELFNBQVNkLGVBQVQsQ0FBMEJhLEtBQTFCLEVBQWlDdkIsVUFBakMsRUFBNkNwVyxNQUE3QyxFQUFxRDtBQUNuRCxNQUFJb1csVUFBVSxHQUFHLENBQWIsSUFBa0J1QixLQUFLLENBQUM1TCxVQUFOLEdBQW1CcUssVUFBekMsRUFBcUQ7QUFDbkQsVUFBTSxJQUFJRSxVQUFKLENBQWUsc0NBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUlxQixLQUFLLENBQUM1TCxVQUFOLEdBQW1CcUssVUFBVSxJQUFJcFcsTUFBTSxJQUFJLENBQWQsQ0FBakMsRUFBbUQ7QUFDakQsVUFBTSxJQUFJc1csVUFBSixDQUFlLHNDQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJeEQsR0FBSjs7QUFDQSxNQUFJc0QsVUFBVSxLQUFLL2EsU0FBZixJQUE0QjJFLE1BQU0sS0FBSzNFLFNBQTNDLEVBQXNEO0FBQ3BEeVgsSUFBQUEsR0FBRyxHQUFHLElBQUluYyxVQUFKLENBQWVnaEIsS0FBZixDQUFOO0FBQ0QsR0FGRCxNQUVPLElBQUkzWCxNQUFNLEtBQUszRSxTQUFmLEVBQTBCO0FBQy9CeVgsSUFBQUEsR0FBRyxHQUFHLElBQUluYyxVQUFKLENBQWVnaEIsS0FBZixFQUFzQnZCLFVBQXRCLENBQU47QUFDRCxHQUZNLE1BRUE7QUFDTHRELElBQUFBLEdBQUcsR0FBRyxJQUFJbmMsVUFBSixDQUFlZ2hCLEtBQWYsRUFBc0J2QixVQUF0QixFQUFrQ3BXLE1BQWxDLENBQU47QUFDRCxHQWhCa0QsQ0FrQm5EOzs7QUFDQTVLLEVBQUFBLE1BQU0sQ0FBQzZnQixjQUFQLENBQXNCbkQsR0FBdEIsRUFBMkI1YyxNQUFNLENBQUM4RyxTQUFsQztBQUVBLFNBQU84VixHQUFQO0FBQ0Q7O0FBRUQsU0FBU21FLFVBQVQsQ0FBcUIzTCxHQUFyQixFQUEwQjtBQUN4QixNQUFJcFYsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQnNHLEdBQWhCLENBQUosRUFBMEI7QUFDeEIsUUFBTWUsR0FBRyxHQUFHZ0wsT0FBTyxDQUFDL0wsR0FBRyxDQUFDdEwsTUFBTCxDQUFQLEdBQXNCLENBQWxDO0FBQ0EsUUFBTThTLEdBQUcsR0FBR3VELFlBQVksQ0FBQ2hLLEdBQUQsQ0FBeEI7O0FBRUEsUUFBSXlHLEdBQUcsQ0FBQzlTLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFPOFMsR0FBUDtBQUNEOztBQUVEeEgsSUFBQUEsR0FBRyxDQUFDdU0sSUFBSixDQUFTL0UsR0FBVCxFQUFjLENBQWQsRUFBaUIsQ0FBakIsRUFBb0J6RyxHQUFwQjtBQUNBLFdBQU95RyxHQUFQO0FBQ0Q7O0FBRUQsTUFBSXhILEdBQUcsQ0FBQ3RMLE1BQUosS0FBZTNFLFNBQW5CLEVBQThCO0FBQzVCLFFBQUksT0FBT2lRLEdBQUcsQ0FBQ3RMLE1BQVgsS0FBc0IsUUFBdEIsSUFBa0M4WCxXQUFXLENBQUN4TSxHQUFHLENBQUN0TCxNQUFMLENBQWpELEVBQStEO0FBQzdELGFBQU9xVyxZQUFZLENBQUMsQ0FBRCxDQUFuQjtBQUNEOztBQUNELFdBQU9xQixhQUFhLENBQUNwTSxHQUFELENBQXBCO0FBQ0Q7O0FBRUQsTUFBSUEsR0FBRyxDQUFDN0IsSUFBSixLQUFhLFFBQWIsSUFBeUI1SixLQUFLLENBQUNzRCxPQUFOLENBQWNtSSxHQUFHLENBQUNwVCxJQUFsQixDQUE3QixFQUFzRDtBQUNwRCxXQUFPd2YsYUFBYSxDQUFDcE0sR0FBRyxDQUFDcFQsSUFBTCxDQUFwQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBU21mLE9BQVQsQ0FBa0JyWCxNQUFsQixFQUEwQjtBQUN4QjtBQUNBO0FBQ0EsTUFBSUEsTUFBTSxJQUFJMlYsWUFBZCxFQUE0QjtBQUMxQixVQUFNLElBQUlXLFVBQUosQ0FBZSxvREFDQSxVQURBLEdBQ2FYLFlBQVksQ0FBQ3ZmLFFBQWIsQ0FBc0IsRUFBdEIsQ0FEYixHQUN5QyxRQUR4RCxDQUFOO0FBRUQ7O0FBQ0QsU0FBTzRKLE1BQU0sR0FBRyxDQUFoQjtBQUNEOztBQUVELFNBQVN5VixVQUFULENBQXFCelYsTUFBckIsRUFBNkI7QUFDM0IsTUFBSSxDQUFDQSxNQUFELElBQVdBLE1BQWYsRUFBdUI7QUFBRTtBQUN2QkEsSUFBQUEsTUFBTSxHQUFHLENBQVQ7QUFDRDs7QUFDRCxTQUFPOUosTUFBTSxDQUFDa2hCLEtBQVAsQ0FBYSxDQUFDcFgsTUFBZCxDQUFQO0FBQ0Q7O0FBRUQ5SixNQUFNLENBQUM4TyxRQUFQLEdBQWtCLFNBQVNBLFFBQVQsQ0FBbUIyRyxDQUFuQixFQUFzQjtBQUN0QyxTQUFPQSxDQUFDLElBQUksSUFBTCxJQUFhQSxDQUFDLENBQUNvTSxTQUFGLEtBQWdCLElBQTdCLElBQ0xwTSxDQUFDLEtBQUt6VixNQUFNLENBQUM4RyxTQURmLENBRHNDLENBRWI7QUFDMUIsQ0FIRDs7QUFLQTlHLE1BQU0sQ0FBQzhoQixPQUFQLEdBQWlCLFNBQVNBLE9BQVQsQ0FBa0J0TSxDQUFsQixFQUFxQkMsQ0FBckIsRUFBd0I7QUFDdkMsTUFBSWtMLFVBQVUsQ0FBQ25MLENBQUQsRUFBSS9VLFVBQUosQ0FBZCxFQUErQitVLENBQUMsR0FBR3hWLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZdVYsQ0FBWixFQUFlQSxDQUFDLENBQUN1TSxNQUFqQixFQUF5QnZNLENBQUMsQ0FBQ0ssVUFBM0IsQ0FBSjtBQUMvQixNQUFJOEssVUFBVSxDQUFDbEwsQ0FBRCxFQUFJaFYsVUFBSixDQUFkLEVBQStCZ1YsQ0FBQyxHQUFHelYsTUFBTSxDQUFDQyxJQUFQLENBQVl3VixDQUFaLEVBQWVBLENBQUMsQ0FBQ3NNLE1BQWpCLEVBQXlCdE0sQ0FBQyxDQUFDSSxVQUEzQixDQUFKOztBQUMvQixNQUFJLENBQUM3VixNQUFNLENBQUM4TyxRQUFQLENBQWdCMEcsQ0FBaEIsQ0FBRCxJQUF1QixDQUFDeFYsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQjJHLENBQWhCLENBQTVCLEVBQWdEO0FBQzlDLFVBQU0sSUFBSTVOLFNBQUosQ0FDSix1RUFESSxDQUFOO0FBR0Q7O0FBRUQsTUFBSTJOLENBQUMsS0FBS0MsQ0FBVixFQUFhLE9BQU8sQ0FBUDtBQUViLE1BQUlpQyxDQUFDLEdBQUdsQyxDQUFDLENBQUMxTCxNQUFWO0FBQ0EsTUFBSWtZLENBQUMsR0FBR3ZNLENBQUMsQ0FBQzNMLE1BQVY7O0FBRUEsT0FBSyxJQUFJOEYsQ0FBQyxHQUFHLENBQVIsRUFBV3VHLEdBQUcsR0FBRzRELElBQUksQ0FBQ2tJLEdBQUwsQ0FBU3ZLLENBQVQsRUFBWXNLLENBQVosQ0FBdEIsRUFBc0NwUyxDQUFDLEdBQUd1RyxHQUExQyxFQUErQyxFQUFFdkcsQ0FBakQsRUFBb0Q7QUFDbEQsUUFBSTRGLENBQUMsQ0FBQzVGLENBQUQsQ0FBRCxLQUFTNkYsQ0FBQyxDQUFDN0YsQ0FBRCxDQUFkLEVBQW1CO0FBQ2pCOEgsTUFBQUEsQ0FBQyxHQUFHbEMsQ0FBQyxDQUFDNUYsQ0FBRCxDQUFMO0FBQ0FvUyxNQUFBQSxDQUFDLEdBQUd2TSxDQUFDLENBQUM3RixDQUFELENBQUw7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsTUFBSThILENBQUMsR0FBR3NLLENBQVIsRUFBVyxPQUFPLENBQUMsQ0FBUjtBQUNYLE1BQUlBLENBQUMsR0FBR3RLLENBQVIsRUFBVyxPQUFPLENBQVA7QUFDWCxTQUFPLENBQVA7QUFDRCxDQXpCRDs7QUEyQkExWCxNQUFNLENBQUNzaEIsVUFBUCxHQUFvQixTQUFTQSxVQUFULENBQXFCN0ksUUFBckIsRUFBK0I7QUFDakQsVUFBUXlKLE1BQU0sQ0FBQ3pKLFFBQUQsQ0FBTixDQUFpQmhULFdBQWpCLEVBQVI7QUFDRSxTQUFLLEtBQUw7QUFDQSxTQUFLLE1BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLFFBQUw7QUFDQSxTQUFLLE1BQUw7QUFDQSxTQUFLLE9BQUw7QUFDQSxTQUFLLFNBQUw7QUFDQSxTQUFLLFVBQUw7QUFDRSxhQUFPLElBQVA7O0FBQ0Y7QUFDRSxhQUFPLEtBQVA7QUFkSjtBQWdCRCxDQWpCRDs7QUFtQkF6RixNQUFNLENBQUM2SixNQUFQLEdBQWdCLFNBQVNBLE1BQVQsQ0FBaUJzWSxJQUFqQixFQUF1QnJZLE1BQXZCLEVBQStCO0FBQzdDLE1BQUksQ0FBQ0gsS0FBSyxDQUFDc0QsT0FBTixDQUFja1YsSUFBZCxDQUFMLEVBQTBCO0FBQ3hCLFVBQU0sSUFBSXRhLFNBQUosQ0FBYyw2Q0FBZCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSXNhLElBQUksQ0FBQ3JZLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDckIsV0FBTzlKLE1BQU0sQ0FBQ2toQixLQUFQLENBQWEsQ0FBYixDQUFQO0FBQ0Q7O0FBRUQsTUFBSXRSLENBQUo7O0FBQ0EsTUFBSTlGLE1BQU0sS0FBSzNFLFNBQWYsRUFBMEI7QUFDeEIyRSxJQUFBQSxNQUFNLEdBQUcsQ0FBVDs7QUFDQSxTQUFLOEYsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdVMsSUFBSSxDQUFDclksTUFBckIsRUFBNkIsRUFBRThGLENBQS9CLEVBQWtDO0FBQ2hDOUYsTUFBQUEsTUFBTSxJQUFJcVksSUFBSSxDQUFDdlMsQ0FBRCxDQUFKLENBQVE5RixNQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsTUFBTXFGLE1BQU0sR0FBR25QLE1BQU0sQ0FBQ3VnQixXQUFQLENBQW1CelcsTUFBbkIsQ0FBZjtBQUNBLE1BQUlzWSxHQUFHLEdBQUcsQ0FBVjs7QUFDQSxPQUFLeFMsQ0FBQyxHQUFHLENBQVQsRUFBWUEsQ0FBQyxHQUFHdVMsSUFBSSxDQUFDclksTUFBckIsRUFBNkIsRUFBRThGLENBQS9CLEVBQWtDO0FBQ2hDLFFBQUlnTixHQUFHLEdBQUd1RixJQUFJLENBQUN2UyxDQUFELENBQWQ7O0FBQ0EsUUFBSStRLFVBQVUsQ0FBQy9ELEdBQUQsRUFBTW5jLFVBQU4sQ0FBZCxFQUFpQztBQUMvQixVQUFJMmhCLEdBQUcsR0FBR3hGLEdBQUcsQ0FBQzlTLE1BQVYsR0FBbUJxRixNQUFNLENBQUNyRixNQUE5QixFQUFzQztBQUNwQyxZQUFJLENBQUM5SixNQUFNLENBQUM4TyxRQUFQLENBQWdCOE4sR0FBaEIsQ0FBTCxFQUEyQkEsR0FBRyxHQUFHNWMsTUFBTSxDQUFDQyxJQUFQLENBQVkyYyxHQUFaLENBQU47QUFDM0JBLFFBQUFBLEdBQUcsQ0FBQytFLElBQUosQ0FBU3hTLE1BQVQsRUFBaUJpVCxHQUFqQjtBQUNELE9BSEQsTUFHTztBQUNMM2hCLFFBQUFBLFVBQVUsQ0FBQ3FHLFNBQVgsQ0FBcUJtVixHQUFyQixDQUF5QjFRLElBQXpCLENBQ0U0RCxNQURGLEVBRUV5TixHQUZGLEVBR0V3RixHQUhGO0FBS0Q7QUFDRixLQVhELE1BV08sSUFBSSxDQUFDcGlCLE1BQU0sQ0FBQzhPLFFBQVAsQ0FBZ0I4TixHQUFoQixDQUFMLEVBQTJCO0FBQ2hDLFlBQU0sSUFBSS9VLFNBQUosQ0FBYyw2Q0FBZCxDQUFOO0FBQ0QsS0FGTSxNQUVBO0FBQ0wrVSxNQUFBQSxHQUFHLENBQUMrRSxJQUFKLENBQVN4UyxNQUFULEVBQWlCaVQsR0FBakI7QUFDRDs7QUFDREEsSUFBQUEsR0FBRyxJQUFJeEYsR0FBRyxDQUFDOVMsTUFBWDtBQUNEOztBQUNELFNBQU9xRixNQUFQO0FBQ0QsQ0F4Q0Q7O0FBMENBLFNBQVMwRyxVQUFULENBQXFCd0wsTUFBckIsRUFBNkI1SSxRQUE3QixFQUF1QztBQUNyQyxNQUFJelksTUFBTSxDQUFDOE8sUUFBUCxDQUFnQnVTLE1BQWhCLENBQUosRUFBNkI7QUFDM0IsV0FBT0EsTUFBTSxDQUFDdlgsTUFBZDtBQUNEOztBQUNELE1BQUk4SyxXQUFXLENBQUNDLE1BQVosQ0FBbUJ3TSxNQUFuQixLQUE4QlYsVUFBVSxDQUFDVSxNQUFELEVBQVN6TSxXQUFULENBQTVDLEVBQW1FO0FBQ2pFLFdBQU95TSxNQUFNLENBQUN4TCxVQUFkO0FBQ0Q7O0FBQ0QsTUFBSSxPQUFPd0wsTUFBUCxLQUFrQixRQUF0QixFQUFnQztBQUM5QixVQUFNLElBQUl4WixTQUFKLENBQ0osK0VBQ0EsZ0JBREEsV0FDMEJ3WixNQUQxQixDQURJLENBQU47QUFJRDs7QUFFRCxNQUFNbEwsR0FBRyxHQUFHa0wsTUFBTSxDQUFDdlgsTUFBbkI7QUFDQSxNQUFNdVksU0FBUyxHQUFJM1osU0FBUyxDQUFDb0IsTUFBVixHQUFtQixDQUFuQixJQUF3QnBCLFNBQVMsQ0FBQyxDQUFELENBQVQsS0FBaUIsSUFBNUQ7QUFDQSxNQUFJLENBQUMyWixTQUFELElBQWNsTSxHQUFHLEtBQUssQ0FBMUIsRUFBNkIsT0FBTyxDQUFQLENBaEJRLENBa0JyQzs7QUFDQSxNQUFJbU0sV0FBVyxHQUFHLEtBQWxCOztBQUNBLFdBQVM7QUFDUCxZQUFRN0osUUFBUjtBQUNFLFdBQUssT0FBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU90QyxHQUFQOztBQUNGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNFLGVBQU9vTSxXQUFXLENBQUNsQixNQUFELENBQVgsQ0FBb0J2WCxNQUEzQjs7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPcU0sR0FBRyxHQUFHLENBQWI7O0FBQ0YsV0FBSyxLQUFMO0FBQ0UsZUFBT0EsR0FBRyxLQUFLLENBQWY7O0FBQ0YsV0FBSyxRQUFMO0FBQ0UsZUFBT3FNLGFBQWEsQ0FBQ25CLE1BQUQsQ0FBYixDQUFzQnZYLE1BQTdCOztBQUNGO0FBQ0UsWUFBSXdZLFdBQUosRUFBaUI7QUFDZixpQkFBT0QsU0FBUyxHQUFHLENBQUMsQ0FBSixHQUFRRSxXQUFXLENBQUNsQixNQUFELENBQVgsQ0FBb0J2WCxNQUE1QyxDQURlLENBQ29DO0FBQ3BEOztBQUNEMk8sUUFBQUEsUUFBUSxHQUFHLENBQUMsS0FBS0EsUUFBTixFQUFnQmhULFdBQWhCLEVBQVg7QUFDQTZjLFFBQUFBLFdBQVcsR0FBRyxJQUFkO0FBdEJKO0FBd0JEO0FBQ0Y7O0FBQ0R0aUIsTUFBTSxDQUFDNlYsVUFBUCxHQUFvQkEsVUFBcEI7O0FBRUEsU0FBUzRNLFlBQVQsQ0FBdUJoSyxRQUF2QixFQUFpQ3pCLEtBQWpDLEVBQXdDQyxHQUF4QyxFQUE2QztBQUMzQyxNQUFJcUwsV0FBVyxHQUFHLEtBQWxCLENBRDJDLENBRzNDO0FBQ0E7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFJdEwsS0FBSyxLQUFLN1IsU0FBVixJQUF1QjZSLEtBQUssR0FBRyxDQUFuQyxFQUFzQztBQUNwQ0EsSUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDRCxHQVowQyxDQWEzQztBQUNBOzs7QUFDQSxNQUFJQSxLQUFLLEdBQUcsS0FBS2xOLE1BQWpCLEVBQXlCO0FBQ3ZCLFdBQU8sRUFBUDtBQUNEOztBQUVELE1BQUltTixHQUFHLEtBQUs5UixTQUFSLElBQXFCOFIsR0FBRyxHQUFHLEtBQUtuTixNQUFwQyxFQUE0QztBQUMxQ21OLElBQUFBLEdBQUcsR0FBRyxLQUFLbk4sTUFBWDtBQUNEOztBQUVELE1BQUltTixHQUFHLElBQUksQ0FBWCxFQUFjO0FBQ1osV0FBTyxFQUFQO0FBQ0QsR0F6QjBDLENBMkIzQzs7O0FBQ0FBLEVBQUFBLEdBQUcsTUFBTSxDQUFUO0FBQ0FELEVBQUFBLEtBQUssTUFBTSxDQUFYOztBQUVBLE1BQUlDLEdBQUcsSUFBSUQsS0FBWCxFQUFrQjtBQUNoQixXQUFPLEVBQVA7QUFDRDs7QUFFRCxNQUFJLENBQUN5QixRQUFMLEVBQWVBLFFBQVEsR0FBRyxNQUFYOztBQUVmLFNBQU8sSUFBUCxFQUFhO0FBQ1gsWUFBUUEsUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU84RCxRQUFRLENBQUMsSUFBRCxFQUFPdkYsS0FBUCxFQUFjQyxHQUFkLENBQWY7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0UsZUFBT3lMLFNBQVMsQ0FBQyxJQUFELEVBQU8xTCxLQUFQLEVBQWNDLEdBQWQsQ0FBaEI7O0FBRUYsV0FBSyxPQUFMO0FBQ0UsZUFBTzBMLFVBQVUsQ0FBQyxJQUFELEVBQU8zTCxLQUFQLEVBQWNDLEdBQWQsQ0FBakI7O0FBRUYsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTzJMLFdBQVcsQ0FBQyxJQUFELEVBQU81TCxLQUFQLEVBQWNDLEdBQWQsQ0FBbEI7O0FBRUYsV0FBSyxRQUFMO0FBQ0UsZUFBTzRMLFdBQVcsQ0FBQyxJQUFELEVBQU83TCxLQUFQLEVBQWNDLEdBQWQsQ0FBbEI7O0FBRUYsV0FBSyxNQUFMO0FBQ0EsV0FBSyxPQUFMO0FBQ0EsV0FBSyxTQUFMO0FBQ0EsV0FBSyxVQUFMO0FBQ0UsZUFBTzZMLFlBQVksQ0FBQyxJQUFELEVBQU85TCxLQUFQLEVBQWNDLEdBQWQsQ0FBbkI7O0FBRUY7QUFDRSxZQUFJcUwsV0FBSixFQUFpQixNQUFNLElBQUl6YSxTQUFKLENBQWMsdUJBQXVCNFEsUUFBckMsQ0FBTjtBQUNqQkEsUUFBQUEsUUFBUSxHQUFHLENBQUNBLFFBQVEsR0FBRyxFQUFaLEVBQWdCaFQsV0FBaEIsRUFBWDtBQUNBNmMsUUFBQUEsV0FBVyxHQUFHLElBQWQ7QUEzQko7QUE2QkQ7QUFDRixFQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0F0aUIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQithLFNBQWpCLEdBQTZCLElBQTdCOztBQUVBLFNBQVNrQixJQUFULENBQWV0TixDQUFmLEVBQWtCcUgsQ0FBbEIsRUFBcUJjLENBQXJCLEVBQXdCO0FBQ3RCLE1BQU1oTyxDQUFDLEdBQUc2RixDQUFDLENBQUNxSCxDQUFELENBQVg7QUFDQXJILEVBQUFBLENBQUMsQ0FBQ3FILENBQUQsQ0FBRCxHQUFPckgsQ0FBQyxDQUFDbUksQ0FBRCxDQUFSO0FBQ0FuSSxFQUFBQSxDQUFDLENBQUNtSSxDQUFELENBQUQsR0FBT2hPLENBQVA7QUFDRDs7QUFFRDVQLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJrYyxNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLE1BQU03TSxHQUFHLEdBQUcsS0FBS3JNLE1BQWpCOztBQUNBLE1BQUlxTSxHQUFHLEdBQUcsQ0FBTixLQUFZLENBQWhCLEVBQW1CO0FBQ2pCLFVBQU0sSUFBSWlLLFVBQUosQ0FBZSwyQ0FBZixDQUFOO0FBQ0Q7O0FBQ0QsT0FBSyxJQUFJeFEsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLEdBQXBCLEVBQXlCdkcsQ0FBQyxJQUFJLENBQTlCLEVBQWlDO0FBQy9CbVQsSUFBQUEsSUFBSSxDQUFDLElBQUQsRUFBT25ULENBQVAsRUFBVUEsQ0FBQyxHQUFHLENBQWQsQ0FBSjtBQUNEOztBQUNELFNBQU8sSUFBUDtBQUNELENBVEQ7O0FBV0E1UCxNQUFNLENBQUM4RyxTQUFQLENBQWlCbWMsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxHQUFtQjtBQUMzQyxNQUFNOU0sR0FBRyxHQUFHLEtBQUtyTSxNQUFqQjs7QUFDQSxNQUFJcU0sR0FBRyxHQUFHLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUlpSyxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEOztBQUNELE9BQUssSUFBSXhRLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RyxHQUFwQixFQUF5QnZHLENBQUMsSUFBSSxDQUE5QixFQUFpQztBQUMvQm1ULElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU9uVCxDQUFQLEVBQVVBLENBQUMsR0FBRyxDQUFkLENBQUo7QUFDQW1ULElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU9uVCxDQUFDLEdBQUcsQ0FBWCxFQUFjQSxDQUFDLEdBQUcsQ0FBbEIsQ0FBSjtBQUNEOztBQUNELFNBQU8sSUFBUDtBQUNELENBVkQ7O0FBWUE1UCxNQUFNLENBQUM4RyxTQUFQLENBQWlCb2MsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxHQUFtQjtBQUMzQyxNQUFNL00sR0FBRyxHQUFHLEtBQUtyTSxNQUFqQjs7QUFDQSxNQUFJcU0sR0FBRyxHQUFHLENBQU4sS0FBWSxDQUFoQixFQUFtQjtBQUNqQixVQUFNLElBQUlpSyxVQUFKLENBQWUsMkNBQWYsQ0FBTjtBQUNEOztBQUNELE9BQUssSUFBSXhRLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RyxHQUFwQixFQUF5QnZHLENBQUMsSUFBSSxDQUE5QixFQUFpQztBQUMvQm1ULElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU9uVCxDQUFQLEVBQVVBLENBQUMsR0FBRyxDQUFkLENBQUo7QUFDQW1ULElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU9uVCxDQUFDLEdBQUcsQ0FBWCxFQUFjQSxDQUFDLEdBQUcsQ0FBbEIsQ0FBSjtBQUNBbVQsSUFBQUEsSUFBSSxDQUFDLElBQUQsRUFBT25ULENBQUMsR0FBRyxDQUFYLEVBQWNBLENBQUMsR0FBRyxDQUFsQixDQUFKO0FBQ0FtVCxJQUFBQSxJQUFJLENBQUMsSUFBRCxFQUFPblQsQ0FBQyxHQUFHLENBQVgsRUFBY0EsQ0FBQyxHQUFHLENBQWxCLENBQUo7QUFDRDs7QUFDRCxTQUFPLElBQVA7QUFDRCxDQVpEOztBQWNBNVAsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjVHLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsR0FBcUI7QUFDL0MsTUFBTTRKLE1BQU0sR0FBRyxLQUFLQSxNQUFwQjtBQUNBLE1BQUlBLE1BQU0sS0FBSyxDQUFmLEVBQWtCLE9BQU8sRUFBUDtBQUNsQixNQUFJcEIsU0FBUyxDQUFDb0IsTUFBVixLQUFxQixDQUF6QixFQUE0QixPQUFPNFksU0FBUyxDQUFDLElBQUQsRUFBTyxDQUFQLEVBQVU1WSxNQUFWLENBQWhCO0FBQzVCLFNBQU8yWSxZQUFZLENBQUM3WSxLQUFiLENBQW1CLElBQW5CLEVBQXlCbEIsU0FBekIsQ0FBUDtBQUNELENBTEQ7O0FBT0ExSSxNQUFNLENBQUM4RyxTQUFQLENBQWlCcWMsY0FBakIsR0FBa0NuakIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjVHLFFBQW5EOztBQUVBRixNQUFNLENBQUM4RyxTQUFQLENBQWlCc2MsTUFBakIsR0FBMEIsU0FBU0EsTUFBVCxDQUFpQjNOLENBQWpCLEVBQW9CO0FBQzVDLE1BQUksQ0FBQ3pWLE1BQU0sQ0FBQzhPLFFBQVAsQ0FBZ0IyRyxDQUFoQixDQUFMLEVBQXlCLE1BQU0sSUFBSTVOLFNBQUosQ0FBYywyQkFBZCxDQUFOO0FBQ3pCLE1BQUksU0FBUzROLENBQWIsRUFBZ0IsT0FBTyxJQUFQO0FBQ2hCLFNBQU96VixNQUFNLENBQUM4aEIsT0FBUCxDQUFlLElBQWYsRUFBcUJyTSxDQUFyQixNQUE0QixDQUFuQztBQUNELENBSkQ7O0FBTUF6VixNQUFNLENBQUM4RyxTQUFQLENBQWlCdWMsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxHQUFvQjtBQUM3QyxNQUFJbk8sR0FBRyxHQUFHLEVBQVY7QUFDQSxNQUFNb08sR0FBRyxHQUFHbGtCLE9BQU8sQ0FBQ29nQixpQkFBcEI7QUFDQXRLLEVBQUFBLEdBQUcsR0FBRyxLQUFLaFYsUUFBTCxDQUFjLEtBQWQsRUFBcUIsQ0FBckIsRUFBd0JvakIsR0FBeEIsRUFBNkJqWixPQUE3QixDQUFxQyxTQUFyQyxFQUFnRCxLQUFoRCxFQUF1RHFFLElBQXZELEVBQU47QUFDQSxNQUFJLEtBQUs1RSxNQUFMLEdBQWN3WixHQUFsQixFQUF1QnBPLEdBQUcsSUFBSSxPQUFQO0FBQ3ZCLFNBQU8sYUFBYUEsR0FBYixHQUFtQixHQUExQjtBQUNELENBTkQ7O0FBT0EsSUFBSW1LLG1CQUFKLEVBQXlCO0FBQ3ZCcmYsRUFBQUEsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnVZLG1CQUFqQixJQUF3Q3JmLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJ1YyxPQUF6RDtBQUNEOztBQUVEcmpCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJnYixPQUFqQixHQUEyQixTQUFTQSxPQUFULENBQWtCL1UsTUFBbEIsRUFBMEJpSyxLQUExQixFQUFpQ0MsR0FBakMsRUFBc0NzTSxTQUF0QyxFQUFpREMsT0FBakQsRUFBMEQ7QUFDbkYsTUFBSTdDLFVBQVUsQ0FBQzVULE1BQUQsRUFBU3RNLFVBQVQsQ0FBZCxFQUFvQztBQUNsQ3NNLElBQUFBLE1BQU0sR0FBRy9NLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZOE0sTUFBWixFQUFvQkEsTUFBTSxDQUFDZ1YsTUFBM0IsRUFBbUNoVixNQUFNLENBQUM4SSxVQUExQyxDQUFUO0FBQ0Q7O0FBQ0QsTUFBSSxDQUFDN1YsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQi9CLE1BQWhCLENBQUwsRUFBOEI7QUFDNUIsVUFBTSxJQUFJbEYsU0FBSixDQUNKLHFFQUNBLGdCQURBLFdBQzJCa0YsTUFEM0IsQ0FESSxDQUFOO0FBSUQ7O0FBRUQsTUFBSWlLLEtBQUssS0FBSzdSLFNBQWQsRUFBeUI7QUFDdkI2UixJQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNEOztBQUNELE1BQUlDLEdBQUcsS0FBSzlSLFNBQVosRUFBdUI7QUFDckI4UixJQUFBQSxHQUFHLEdBQUdsSyxNQUFNLEdBQUdBLE1BQU0sQ0FBQ2pELE1BQVYsR0FBbUIsQ0FBL0I7QUFDRDs7QUFDRCxNQUFJeVosU0FBUyxLQUFLcGUsU0FBbEIsRUFBNkI7QUFDM0JvZSxJQUFBQSxTQUFTLEdBQUcsQ0FBWjtBQUNEOztBQUNELE1BQUlDLE9BQU8sS0FBS3JlLFNBQWhCLEVBQTJCO0FBQ3pCcWUsSUFBQUEsT0FBTyxHQUFHLEtBQUsxWixNQUFmO0FBQ0Q7O0FBRUQsTUFBSWtOLEtBQUssR0FBRyxDQUFSLElBQWFDLEdBQUcsR0FBR2xLLE1BQU0sQ0FBQ2pELE1BQTFCLElBQW9DeVosU0FBUyxHQUFHLENBQWhELElBQXFEQyxPQUFPLEdBQUcsS0FBSzFaLE1BQXhFLEVBQWdGO0FBQzlFLFVBQU0sSUFBSXNXLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQ0Q7O0FBRUQsTUFBSW1ELFNBQVMsSUFBSUMsT0FBYixJQUF3QnhNLEtBQUssSUFBSUMsR0FBckMsRUFBMEM7QUFDeEMsV0FBTyxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSXNNLFNBQVMsSUFBSUMsT0FBakIsRUFBMEI7QUFDeEIsV0FBTyxDQUFDLENBQVI7QUFDRDs7QUFDRCxNQUFJeE0sS0FBSyxJQUFJQyxHQUFiLEVBQWtCO0FBQ2hCLFdBQU8sQ0FBUDtBQUNEOztBQUVERCxFQUFBQSxLQUFLLE1BQU0sQ0FBWDtBQUNBQyxFQUFBQSxHQUFHLE1BQU0sQ0FBVDtBQUNBc00sRUFBQUEsU0FBUyxNQUFNLENBQWY7QUFDQUMsRUFBQUEsT0FBTyxNQUFNLENBQWI7QUFFQSxNQUFJLFNBQVN6VyxNQUFiLEVBQXFCLE9BQU8sQ0FBUDtBQUVyQixNQUFJMkssQ0FBQyxHQUFHOEwsT0FBTyxHQUFHRCxTQUFsQjtBQUNBLE1BQUl2QixDQUFDLEdBQUcvSyxHQUFHLEdBQUdELEtBQWQ7QUFDQSxNQUFNYixHQUFHLEdBQUc0RCxJQUFJLENBQUNrSSxHQUFMLENBQVN2SyxDQUFULEVBQVlzSyxDQUFaLENBQVo7QUFFQSxNQUFNeUIsUUFBUSxHQUFHLEtBQUtyakIsS0FBTCxDQUFXbWpCLFNBQVgsRUFBc0JDLE9BQXRCLENBQWpCO0FBQ0EsTUFBTUUsVUFBVSxHQUFHM1csTUFBTSxDQUFDM00sS0FBUCxDQUFhNFcsS0FBYixFQUFvQkMsR0FBcEIsQ0FBbkI7O0FBRUEsT0FBSyxJQUFJckgsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLEdBQXBCLEVBQXlCLEVBQUV2RyxDQUEzQixFQUE4QjtBQUM1QixRQUFJNlQsUUFBUSxDQUFDN1QsQ0FBRCxDQUFSLEtBQWdCOFQsVUFBVSxDQUFDOVQsQ0FBRCxDQUE5QixFQUFtQztBQUNqQzhILE1BQUFBLENBQUMsR0FBRytMLFFBQVEsQ0FBQzdULENBQUQsQ0FBWjtBQUNBb1MsTUFBQUEsQ0FBQyxHQUFHMEIsVUFBVSxDQUFDOVQsQ0FBRCxDQUFkO0FBQ0E7QUFDRDtBQUNGOztBQUVELE1BQUk4SCxDQUFDLEdBQUdzSyxDQUFSLEVBQVcsT0FBTyxDQUFDLENBQVI7QUFDWCxNQUFJQSxDQUFDLEdBQUd0SyxDQUFSLEVBQVcsT0FBTyxDQUFQO0FBQ1gsU0FBTyxDQUFQO0FBQ0QsQ0EvREQsRUFpRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSxTQUFTaU0sb0JBQVQsQ0FBK0J4VSxNQUEvQixFQUF1QzVKLEdBQXZDLEVBQTRDMmEsVUFBNUMsRUFBd0R6SCxRQUF4RCxFQUFrRW1MLEdBQWxFLEVBQXVFO0FBQ3JFO0FBQ0EsTUFBSXpVLE1BQU0sQ0FBQ3JGLE1BQVAsS0FBa0IsQ0FBdEIsRUFBeUIsT0FBTyxDQUFDLENBQVIsQ0FGNEMsQ0FJckU7O0FBQ0EsTUFBSSxPQUFPb1csVUFBUCxLQUFzQixRQUExQixFQUFvQztBQUNsQ3pILElBQUFBLFFBQVEsR0FBR3lILFVBQVg7QUFDQUEsSUFBQUEsVUFBVSxHQUFHLENBQWI7QUFDRCxHQUhELE1BR08sSUFBSUEsVUFBVSxHQUFHLFVBQWpCLEVBQTZCO0FBQ2xDQSxJQUFBQSxVQUFVLEdBQUcsVUFBYjtBQUNELEdBRk0sTUFFQSxJQUFJQSxVQUFVLEdBQUcsQ0FBQyxVQUFsQixFQUE4QjtBQUNuQ0EsSUFBQUEsVUFBVSxHQUFHLENBQUMsVUFBZDtBQUNEOztBQUNEQSxFQUFBQSxVQUFVLEdBQUcsQ0FBQ0EsVUFBZCxDQWJxRSxDQWE1Qzs7QUFDekIsTUFBSTBCLFdBQVcsQ0FBQzFCLFVBQUQsQ0FBZixFQUE2QjtBQUMzQjtBQUNBQSxJQUFBQSxVQUFVLEdBQUcwRCxHQUFHLEdBQUcsQ0FBSCxHQUFRelUsTUFBTSxDQUFDckYsTUFBUCxHQUFnQixDQUF4QztBQUNELEdBakJvRSxDQW1CckU7OztBQUNBLE1BQUlvVyxVQUFVLEdBQUcsQ0FBakIsRUFBb0JBLFVBQVUsR0FBRy9RLE1BQU0sQ0FBQ3JGLE1BQVAsR0FBZ0JvVyxVQUE3Qjs7QUFDcEIsTUFBSUEsVUFBVSxJQUFJL1EsTUFBTSxDQUFDckYsTUFBekIsRUFBaUM7QUFDL0IsUUFBSThaLEdBQUosRUFBUyxPQUFPLENBQUMsQ0FBUixDQUFULEtBQ0sxRCxVQUFVLEdBQUcvUSxNQUFNLENBQUNyRixNQUFQLEdBQWdCLENBQTdCO0FBQ04sR0FIRCxNQUdPLElBQUlvVyxVQUFVLEdBQUcsQ0FBakIsRUFBb0I7QUFDekIsUUFBSTBELEdBQUosRUFBUzFELFVBQVUsR0FBRyxDQUFiLENBQVQsS0FDSyxPQUFPLENBQUMsQ0FBUjtBQUNOLEdBM0JvRSxDQTZCckU7OztBQUNBLE1BQUksT0FBTzNhLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQkEsSUFBQUEsR0FBRyxHQUFHdkYsTUFBTSxDQUFDQyxJQUFQLENBQVlzRixHQUFaLEVBQWlCa1QsUUFBakIsQ0FBTjtBQUNELEdBaENvRSxDQWtDckU7OztBQUNBLE1BQUl6WSxNQUFNLENBQUM4TyxRQUFQLENBQWdCdkosR0FBaEIsQ0FBSixFQUEwQjtBQUN4QjtBQUNBLFFBQUlBLEdBQUcsQ0FBQ3VFLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixhQUFPLENBQUMsQ0FBUjtBQUNEOztBQUNELFdBQU8rWixZQUFZLENBQUMxVSxNQUFELEVBQVM1SixHQUFULEVBQWMyYSxVQUFkLEVBQTBCekgsUUFBMUIsRUFBb0NtTCxHQUFwQyxDQUFuQjtBQUNELEdBTkQsTUFNTyxJQUFJLE9BQU9yZSxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENBLElBQUFBLEdBQUcsR0FBR0EsR0FBRyxHQUFHLElBQVosQ0FEa0MsQ0FDakI7O0FBQ2pCLFFBQUksT0FBTzlFLFVBQVUsQ0FBQ3FHLFNBQVgsQ0FBcUIzQyxPQUE1QixLQUF3QyxVQUE1QyxFQUF3RDtBQUN0RCxVQUFJeWYsR0FBSixFQUFTO0FBQ1AsZUFBT25qQixVQUFVLENBQUNxRyxTQUFYLENBQXFCM0MsT0FBckIsQ0FBNkJvSCxJQUE3QixDQUFrQzRELE1BQWxDLEVBQTBDNUosR0FBMUMsRUFBK0MyYSxVQUEvQyxDQUFQO0FBQ0QsT0FGRCxNQUVPO0FBQ0wsZUFBT3pmLFVBQVUsQ0FBQ3FHLFNBQVgsQ0FBcUJpUyxXQUFyQixDQUFpQ3hOLElBQWpDLENBQXNDNEQsTUFBdEMsRUFBOEM1SixHQUE5QyxFQUFtRDJhLFVBQW5ELENBQVA7QUFDRDtBQUNGOztBQUNELFdBQU8yRCxZQUFZLENBQUMxVSxNQUFELEVBQVMsQ0FBQzVKLEdBQUQsQ0FBVCxFQUFnQjJhLFVBQWhCLEVBQTRCekgsUUFBNUIsRUFBc0NtTCxHQUF0QyxDQUFuQjtBQUNEOztBQUVELFFBQU0sSUFBSS9iLFNBQUosQ0FBYyxzQ0FBZCxDQUFOO0FBQ0Q7O0FBRUQsU0FBU2djLFlBQVQsQ0FBdUJ4USxHQUF2QixFQUE0QjlOLEdBQTVCLEVBQWlDMmEsVUFBakMsRUFBNkN6SCxRQUE3QyxFQUF1RG1MLEdBQXZELEVBQTREO0FBQzFELE1BQUlFLFNBQVMsR0FBRyxDQUFoQjtBQUNBLE1BQUlDLFNBQVMsR0FBRzFRLEdBQUcsQ0FBQ3ZKLE1BQXBCO0FBQ0EsTUFBSWthLFNBQVMsR0FBR3plLEdBQUcsQ0FBQ3VFLE1BQXBCOztBQUVBLE1BQUkyTyxRQUFRLEtBQUt0VCxTQUFqQixFQUE0QjtBQUMxQnNULElBQUFBLFFBQVEsR0FBR3lKLE1BQU0sQ0FBQ3pKLFFBQUQsQ0FBTixDQUFpQmhULFdBQWpCLEVBQVg7O0FBQ0EsUUFBSWdULFFBQVEsS0FBSyxNQUFiLElBQXVCQSxRQUFRLEtBQUssT0FBcEMsSUFDQUEsUUFBUSxLQUFLLFNBRGIsSUFDMEJBLFFBQVEsS0FBSyxVQUQzQyxFQUN1RDtBQUNyRCxVQUFJcEYsR0FBRyxDQUFDdkosTUFBSixHQUFhLENBQWIsSUFBa0J2RSxHQUFHLENBQUN1RSxNQUFKLEdBQWEsQ0FBbkMsRUFBc0M7QUFDcEMsZUFBTyxDQUFDLENBQVI7QUFDRDs7QUFDRGdhLE1BQUFBLFNBQVMsR0FBRyxDQUFaO0FBQ0FDLE1BQUFBLFNBQVMsSUFBSSxDQUFiO0FBQ0FDLE1BQUFBLFNBQVMsSUFBSSxDQUFiO0FBQ0E5RCxNQUFBQSxVQUFVLElBQUksQ0FBZDtBQUNEO0FBQ0Y7O0FBRUQsV0FBU2hiLElBQVQsQ0FBZTBYLEdBQWYsRUFBb0JoTixDQUFwQixFQUF1QjtBQUNyQixRQUFJa1UsU0FBUyxLQUFLLENBQWxCLEVBQXFCO0FBQ25CLGFBQU9sSCxHQUFHLENBQUNoTixDQUFELENBQVY7QUFDRCxLQUZELE1BRU87QUFDTCxhQUFPZ04sR0FBRyxDQUFDcUgsWUFBSixDQUFpQnJVLENBQUMsR0FBR2tVLFNBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELE1BQUlsVSxDQUFKOztBQUNBLE1BQUlnVSxHQUFKLEVBQVM7QUFDUCxRQUFJTSxVQUFVLEdBQUcsQ0FBQyxDQUFsQjs7QUFDQSxTQUFLdFUsQ0FBQyxHQUFHc1EsVUFBVCxFQUFxQnRRLENBQUMsR0FBR21VLFNBQXpCLEVBQW9DblUsQ0FBQyxFQUFyQyxFQUF5QztBQUN2QyxVQUFJMUssSUFBSSxDQUFDbU8sR0FBRCxFQUFNekQsQ0FBTixDQUFKLEtBQWlCMUssSUFBSSxDQUFDSyxHQUFELEVBQU0yZSxVQUFVLEtBQUssQ0FBQyxDQUFoQixHQUFvQixDQUFwQixHQUF3QnRVLENBQUMsR0FBR3NVLFVBQWxDLENBQXpCLEVBQXdFO0FBQ3RFLFlBQUlBLFVBQVUsS0FBSyxDQUFDLENBQXBCLEVBQXVCQSxVQUFVLEdBQUd0VSxDQUFiO0FBQ3ZCLFlBQUlBLENBQUMsR0FBR3NVLFVBQUosR0FBaUIsQ0FBakIsS0FBdUJGLFNBQTNCLEVBQXNDLE9BQU9FLFVBQVUsR0FBR0osU0FBcEI7QUFDdkMsT0FIRCxNQUdPO0FBQ0wsWUFBSUksVUFBVSxLQUFLLENBQUMsQ0FBcEIsRUFBdUJ0VSxDQUFDLElBQUlBLENBQUMsR0FBR3NVLFVBQVQ7QUFDdkJBLFFBQUFBLFVBQVUsR0FBRyxDQUFDLENBQWQ7QUFDRDtBQUNGO0FBQ0YsR0FYRCxNQVdPO0FBQ0wsUUFBSWhFLFVBQVUsR0FBRzhELFNBQWIsR0FBeUJELFNBQTdCLEVBQXdDN0QsVUFBVSxHQUFHNkQsU0FBUyxHQUFHQyxTQUF6Qjs7QUFDeEMsU0FBS3BVLENBQUMsR0FBR3NRLFVBQVQsRUFBcUJ0USxDQUFDLElBQUksQ0FBMUIsRUFBNkJBLENBQUMsRUFBOUIsRUFBa0M7QUFDaEMsVUFBSXVVLEtBQUssR0FBRyxJQUFaOztBQUNBLFdBQUssSUFBSUMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR0osU0FBcEIsRUFBK0JJLENBQUMsRUFBaEMsRUFBb0M7QUFDbEMsWUFBSWxmLElBQUksQ0FBQ21PLEdBQUQsRUFBTXpELENBQUMsR0FBR3dVLENBQVYsQ0FBSixLQUFxQmxmLElBQUksQ0FBQ0ssR0FBRCxFQUFNNmUsQ0FBTixDQUE3QixFQUF1QztBQUNyQ0QsVUFBQUEsS0FBSyxHQUFHLEtBQVI7QUFDQTtBQUNEO0FBQ0Y7O0FBQ0QsVUFBSUEsS0FBSixFQUFXLE9BQU92VSxDQUFQO0FBQ1o7QUFDRjs7QUFFRCxTQUFPLENBQUMsQ0FBUjtBQUNEOztBQUVENVAsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnVkLFFBQWpCLEdBQTRCLFNBQVNBLFFBQVQsQ0FBbUI5ZSxHQUFuQixFQUF3QjJhLFVBQXhCLEVBQW9DekgsUUFBcEMsRUFBOEM7QUFDeEUsU0FBTyxLQUFLdFUsT0FBTCxDQUFhb0IsR0FBYixFQUFrQjJhLFVBQWxCLEVBQThCekgsUUFBOUIsTUFBNEMsQ0FBQyxDQUFwRDtBQUNELENBRkQ7O0FBSUF6WSxNQUFNLENBQUM4RyxTQUFQLENBQWlCM0MsT0FBakIsR0FBMkIsU0FBU0EsT0FBVCxDQUFrQm9CLEdBQWxCLEVBQXVCMmEsVUFBdkIsRUFBbUN6SCxRQUFuQyxFQUE2QztBQUN0RSxTQUFPa0wsb0JBQW9CLENBQUMsSUFBRCxFQUFPcGUsR0FBUCxFQUFZMmEsVUFBWixFQUF3QnpILFFBQXhCLEVBQWtDLElBQWxDLENBQTNCO0FBQ0QsQ0FGRDs7QUFJQXpZLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJpUyxXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCeFQsR0FBdEIsRUFBMkIyYSxVQUEzQixFQUF1Q3pILFFBQXZDLEVBQWlEO0FBQzlFLFNBQU9rTCxvQkFBb0IsQ0FBQyxJQUFELEVBQU9wZSxHQUFQLEVBQVkyYSxVQUFaLEVBQXdCekgsUUFBeEIsRUFBa0MsS0FBbEMsQ0FBM0I7QUFDRCxDQUZEOztBQUlBLFNBQVM2TCxRQUFULENBQW1CMUgsR0FBbkIsRUFBd0J5RSxNQUF4QixFQUFnQ1UsTUFBaEMsRUFBd0NqWSxNQUF4QyxFQUFnRDtBQUM5Q2lZLEVBQUFBLE1BQU0sR0FBR3dDLE1BQU0sQ0FBQ3hDLE1BQUQsQ0FBTixJQUFrQixDQUEzQjtBQUNBLE1BQU15QyxTQUFTLEdBQUc1SCxHQUFHLENBQUM5UyxNQUFKLEdBQWFpWSxNQUEvQjs7QUFDQSxNQUFJLENBQUNqWSxNQUFMLEVBQWE7QUFDWEEsSUFBQUEsTUFBTSxHQUFHMGEsU0FBVDtBQUNELEdBRkQsTUFFTztBQUNMMWEsSUFBQUEsTUFBTSxHQUFHeWEsTUFBTSxDQUFDemEsTUFBRCxDQUFmOztBQUNBLFFBQUlBLE1BQU0sR0FBRzBhLFNBQWIsRUFBd0I7QUFDdEIxYSxNQUFBQSxNQUFNLEdBQUcwYSxTQUFUO0FBQ0Q7QUFDRjs7QUFFRCxNQUFNQyxNQUFNLEdBQUdwRCxNQUFNLENBQUN2WCxNQUF0Qjs7QUFFQSxNQUFJQSxNQUFNLEdBQUcyYSxNQUFNLEdBQUcsQ0FBdEIsRUFBeUI7QUFDdkIzYSxJQUFBQSxNQUFNLEdBQUcyYSxNQUFNLEdBQUcsQ0FBbEI7QUFDRDs7QUFDRCxNQUFJN1UsQ0FBSjs7QUFDQSxPQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc5RixNQUFoQixFQUF3QixFQUFFOEYsQ0FBMUIsRUFBNkI7QUFDM0IsUUFBTWlELE1BQU0sR0FBRzZSLFFBQVEsQ0FBQ3JELE1BQU0sQ0FBQ2xPLE1BQVAsQ0FBY3ZELENBQUMsR0FBRyxDQUFsQixFQUFxQixDQUFyQixDQUFELEVBQTBCLEVBQTFCLENBQXZCO0FBQ0EsUUFBSWdTLFdBQVcsQ0FBQy9PLE1BQUQsQ0FBZixFQUF5QixPQUFPakQsQ0FBUDtBQUN6QmdOLElBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sR0FBR25TLENBQVYsQ0FBSCxHQUFrQmlELE1BQWxCO0FBQ0Q7O0FBQ0QsU0FBT2pELENBQVA7QUFDRDs7QUFFRCxTQUFTK1UsU0FBVCxDQUFvQi9ILEdBQXBCLEVBQXlCeUUsTUFBekIsRUFBaUNVLE1BQWpDLEVBQXlDalksTUFBekMsRUFBaUQ7QUFDL0MsU0FBTzhhLFVBQVUsQ0FBQ3JDLFdBQVcsQ0FBQ2xCLE1BQUQsRUFBU3pFLEdBQUcsQ0FBQzlTLE1BQUosR0FBYWlZLE1BQXRCLENBQVosRUFBMkNuRixHQUEzQyxFQUFnRG1GLE1BQWhELEVBQXdEalksTUFBeEQsQ0FBakI7QUFDRDs7QUFFRCxTQUFTK2EsVUFBVCxDQUFxQmpJLEdBQXJCLEVBQTBCeUUsTUFBMUIsRUFBa0NVLE1BQWxDLEVBQTBDalksTUFBMUMsRUFBa0Q7QUFDaEQsU0FBTzhhLFVBQVUsQ0FBQ0UsWUFBWSxDQUFDekQsTUFBRCxDQUFiLEVBQXVCekUsR0FBdkIsRUFBNEJtRixNQUE1QixFQUFvQ2pZLE1BQXBDLENBQWpCO0FBQ0Q7O0FBRUQsU0FBU2liLFdBQVQsQ0FBc0JuSSxHQUF0QixFQUEyQnlFLE1BQTNCLEVBQW1DVSxNQUFuQyxFQUEyQ2pZLE1BQTNDLEVBQW1EO0FBQ2pELFNBQU84YSxVQUFVLENBQUNwQyxhQUFhLENBQUNuQixNQUFELENBQWQsRUFBd0J6RSxHQUF4QixFQUE2Qm1GLE1BQTdCLEVBQXFDalksTUFBckMsQ0FBakI7QUFDRDs7QUFFRCxTQUFTa2IsU0FBVCxDQUFvQnBJLEdBQXBCLEVBQXlCeUUsTUFBekIsRUFBaUNVLE1BQWpDLEVBQXlDalksTUFBekMsRUFBaUQ7QUFDL0MsU0FBTzhhLFVBQVUsQ0FBQ0ssY0FBYyxDQUFDNUQsTUFBRCxFQUFTekUsR0FBRyxDQUFDOVMsTUFBSixHQUFhaVksTUFBdEIsQ0FBZixFQUE4Q25GLEdBQTlDLEVBQW1EbUYsTUFBbkQsRUFBMkRqWSxNQUEzRCxDQUFqQjtBQUNEOztBQUVEOUosTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjBKLEtBQWpCLEdBQXlCLFNBQVNBLEtBQVQsQ0FBZ0I2USxNQUFoQixFQUF3QlUsTUFBeEIsRUFBZ0NqWSxNQUFoQyxFQUF3QzJPLFFBQXhDLEVBQWtEO0FBQ3pFO0FBQ0EsTUFBSXNKLE1BQU0sS0FBSzVjLFNBQWYsRUFBMEI7QUFDeEJzVCxJQUFBQSxRQUFRLEdBQUcsTUFBWDtBQUNBM08sSUFBQUEsTUFBTSxHQUFHLEtBQUtBLE1BQWQ7QUFDQWlZLElBQUFBLE1BQU0sR0FBRyxDQUFULENBSHdCLENBSTFCO0FBQ0MsR0FMRCxNQUtPLElBQUlqWSxNQUFNLEtBQUszRSxTQUFYLElBQXdCLE9BQU80YyxNQUFQLEtBQWtCLFFBQTlDLEVBQXdEO0FBQzdEdEosSUFBQUEsUUFBUSxHQUFHc0osTUFBWDtBQUNBalksSUFBQUEsTUFBTSxHQUFHLEtBQUtBLE1BQWQ7QUFDQWlZLElBQUFBLE1BQU0sR0FBRyxDQUFULENBSDZELENBSS9EO0FBQ0MsR0FMTSxNQUtBLElBQUltRCxRQUFRLENBQUNuRCxNQUFELENBQVosRUFBc0I7QUFDM0JBLElBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCOztBQUNBLFFBQUltRCxRQUFRLENBQUNwYixNQUFELENBQVosRUFBc0I7QUFDcEJBLE1BQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsVUFBSTJPLFFBQVEsS0FBS3RULFNBQWpCLEVBQTRCc1QsUUFBUSxHQUFHLE1BQVg7QUFDN0IsS0FIRCxNQUdPO0FBQ0xBLE1BQUFBLFFBQVEsR0FBRzNPLE1BQVg7QUFDQUEsTUFBQUEsTUFBTSxHQUFHM0UsU0FBVDtBQUNEO0FBQ0YsR0FUTSxNQVNBO0FBQ0wsVUFBTSxJQUFJckUsS0FBSixDQUNKLHlFQURJLENBQU47QUFHRDs7QUFFRCxNQUFNMGpCLFNBQVMsR0FBRyxLQUFLMWEsTUFBTCxHQUFjaVksTUFBaEM7QUFDQSxNQUFJalksTUFBTSxLQUFLM0UsU0FBWCxJQUF3QjJFLE1BQU0sR0FBRzBhLFNBQXJDLEVBQWdEMWEsTUFBTSxHQUFHMGEsU0FBVDs7QUFFaEQsTUFBS25ELE1BQU0sQ0FBQ3ZYLE1BQVAsR0FBZ0IsQ0FBaEIsS0FBc0JBLE1BQU0sR0FBRyxDQUFULElBQWNpWSxNQUFNLEdBQUcsQ0FBN0MsQ0FBRCxJQUFxREEsTUFBTSxHQUFHLEtBQUtqWSxNQUF2RSxFQUErRTtBQUM3RSxVQUFNLElBQUlzVyxVQUFKLENBQWUsd0NBQWYsQ0FBTjtBQUNEOztBQUVELE1BQUksQ0FBQzNILFFBQUwsRUFBZUEsUUFBUSxHQUFHLE1BQVg7QUFFZixNQUFJNkosV0FBVyxHQUFHLEtBQWxCOztBQUNBLFdBQVM7QUFDUCxZQUFRN0osUUFBUjtBQUNFLFdBQUssS0FBTDtBQUNFLGVBQU82TCxRQUFRLENBQUMsSUFBRCxFQUFPakQsTUFBUCxFQUFlVSxNQUFmLEVBQXVCalksTUFBdkIsQ0FBZjs7QUFFRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDRSxlQUFPNmEsU0FBUyxDQUFDLElBQUQsRUFBT3RELE1BQVAsRUFBZVUsTUFBZixFQUF1QmpZLE1BQXZCLENBQWhCOztBQUVGLFdBQUssT0FBTDtBQUNBLFdBQUssUUFBTDtBQUNBLFdBQUssUUFBTDtBQUNFLGVBQU8rYSxVQUFVLENBQUMsSUFBRCxFQUFPeEQsTUFBUCxFQUFlVSxNQUFmLEVBQXVCalksTUFBdkIsQ0FBakI7O0FBRUYsV0FBSyxRQUFMO0FBQ0U7QUFDQSxlQUFPaWIsV0FBVyxDQUFDLElBQUQsRUFBTzFELE1BQVAsRUFBZVUsTUFBZixFQUF1QmpZLE1BQXZCLENBQWxCOztBQUVGLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssU0FBTDtBQUNBLFdBQUssVUFBTDtBQUNFLGVBQU9rYixTQUFTLENBQUMsSUFBRCxFQUFPM0QsTUFBUCxFQUFlVSxNQUFmLEVBQXVCalksTUFBdkIsQ0FBaEI7O0FBRUY7QUFDRSxZQUFJd1ksV0FBSixFQUFpQixNQUFNLElBQUl6YSxTQUFKLENBQWMsdUJBQXVCNFEsUUFBckMsQ0FBTjtBQUNqQkEsUUFBQUEsUUFBUSxHQUFHLENBQUMsS0FBS0EsUUFBTixFQUFnQmhULFdBQWhCLEVBQVg7QUFDQTZjLFFBQUFBLFdBQVcsR0FBRyxJQUFkO0FBMUJKO0FBNEJEO0FBQ0YsQ0FuRUQ7O0FBcUVBdGlCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJrRixNQUFqQixHQUEwQixTQUFTQSxNQUFULEdBQW1CO0FBQzNDLFNBQU87QUFDTHVILElBQUFBLElBQUksRUFBRSxRQUREO0FBRUx2UixJQUFBQSxJQUFJLEVBQUUySCxLQUFLLENBQUM3QyxTQUFOLENBQWdCMUcsS0FBaEIsQ0FBc0JtTCxJQUF0QixDQUEyQixLQUFLNFosSUFBTCxJQUFhLElBQXhDLEVBQThDLENBQTlDO0FBRkQsR0FBUDtBQUlELENBTEQ7O0FBT0EsU0FBU3RDLFdBQVQsQ0FBc0JqRyxHQUF0QixFQUEyQjVGLEtBQTNCLEVBQWtDQyxHQUFsQyxFQUF1QztBQUNyQyxNQUFJRCxLQUFLLEtBQUssQ0FBVixJQUFlQyxHQUFHLEtBQUsyRixHQUFHLENBQUM5UyxNQUEvQixFQUF1QztBQUNyQyxXQUFPcVYsTUFBTSxDQUFDcEosYUFBUCxDQUFxQjZHLEdBQXJCLENBQVA7QUFDRCxHQUZELE1BRU87QUFDTCxXQUFPdUMsTUFBTSxDQUFDcEosYUFBUCxDQUFxQjZHLEdBQUcsQ0FBQ3hjLEtBQUosQ0FBVTRXLEtBQVYsRUFBaUJDLEdBQWpCLENBQXJCLENBQVA7QUFDRDtBQUNGOztBQUVELFNBQVN5TCxTQUFULENBQW9COUYsR0FBcEIsRUFBeUI1RixLQUF6QixFQUFnQ0MsR0FBaEMsRUFBcUM7QUFDbkNBLEVBQUFBLEdBQUcsR0FBRzhDLElBQUksQ0FBQ2tJLEdBQUwsQ0FBU3JGLEdBQUcsQ0FBQzlTLE1BQWIsRUFBcUJtTixHQUFyQixDQUFOO0FBQ0EsTUFBTXNCLEdBQUcsR0FBRyxFQUFaO0FBRUEsTUFBSTNJLENBQUMsR0FBR29ILEtBQVI7O0FBQ0EsU0FBT3BILENBQUMsR0FBR3FILEdBQVgsRUFBZ0I7QUFDZCxRQUFNbU8sU0FBUyxHQUFHeEksR0FBRyxDQUFDaE4sQ0FBRCxDQUFyQjtBQUNBLFFBQUl5VixTQUFTLEdBQUcsSUFBaEI7QUFDQSxRQUFJQyxnQkFBZ0IsR0FBSUYsU0FBUyxHQUFHLElBQWIsR0FDbkIsQ0FEbUIsR0FFbEJBLFNBQVMsR0FBRyxJQUFiLEdBQ0ksQ0FESixHQUVLQSxTQUFTLEdBQUcsSUFBYixHQUNJLENBREosR0FFSSxDQU5aOztBQVFBLFFBQUl4VixDQUFDLEdBQUcwVixnQkFBSixJQUF3QnJPLEdBQTVCLEVBQWlDO0FBQy9CLFVBQUlzTyxVQUFVLFNBQWQ7QUFBQSxVQUFnQkMsU0FBUyxTQUF6QjtBQUFBLFVBQTJCQyxVQUFVLFNBQXJDO0FBQUEsVUFBdUNDLGFBQWEsU0FBcEQ7O0FBRUEsY0FBUUosZ0JBQVI7QUFDRSxhQUFLLENBQUw7QUFDRSxjQUFJRixTQUFTLEdBQUcsSUFBaEIsRUFBc0I7QUFDcEJDLFlBQUFBLFNBQVMsR0FBR0QsU0FBWjtBQUNEOztBQUNEOztBQUNGLGFBQUssQ0FBTDtBQUNFRyxVQUFBQSxVQUFVLEdBQUczSSxHQUFHLENBQUNoTixDQUFDLEdBQUcsQ0FBTCxDQUFoQjs7QUFDQSxjQUFJLENBQUMyVixVQUFVLEdBQUcsSUFBZCxNQUF3QixJQUE1QixFQUFrQztBQUNoQ0csWUFBQUEsYUFBYSxHQUFHLENBQUNOLFNBQVMsR0FBRyxJQUFiLEtBQXNCLEdBQXRCLEdBQTZCRyxVQUFVLEdBQUcsSUFBMUQ7O0FBQ0EsZ0JBQUlHLGFBQWEsR0FBRyxJQUFwQixFQUEwQjtBQUN4QkwsY0FBQUEsU0FBUyxHQUFHSyxhQUFaO0FBQ0Q7QUFDRjs7QUFDRDs7QUFDRixhQUFLLENBQUw7QUFDRUgsVUFBQUEsVUFBVSxHQUFHM0ksR0FBRyxDQUFDaE4sQ0FBQyxHQUFHLENBQUwsQ0FBaEI7QUFDQTRWLFVBQUFBLFNBQVMsR0FBRzVJLEdBQUcsQ0FBQ2hOLENBQUMsR0FBRyxDQUFMLENBQWY7O0FBQ0EsY0FBSSxDQUFDMlYsVUFBVSxHQUFHLElBQWQsTUFBd0IsSUFBeEIsSUFBZ0MsQ0FBQ0MsU0FBUyxHQUFHLElBQWIsTUFBdUIsSUFBM0QsRUFBaUU7QUFDL0RFLFlBQUFBLGFBQWEsR0FBRyxDQUFDTixTQUFTLEdBQUcsR0FBYixLQUFxQixHQUFyQixHQUEyQixDQUFDRyxVQUFVLEdBQUcsSUFBZCxLQUF1QixHQUFsRCxHQUF5REMsU0FBUyxHQUFHLElBQXJGOztBQUNBLGdCQUFJRSxhQUFhLEdBQUcsS0FBaEIsS0FBMEJBLGFBQWEsR0FBRyxNQUFoQixJQUEwQkEsYUFBYSxHQUFHLE1BQXBFLENBQUosRUFBaUY7QUFDL0VMLGNBQUFBLFNBQVMsR0FBR0ssYUFBWjtBQUNEO0FBQ0Y7O0FBQ0Q7O0FBQ0YsYUFBSyxDQUFMO0FBQ0VILFVBQUFBLFVBQVUsR0FBRzNJLEdBQUcsQ0FBQ2hOLENBQUMsR0FBRyxDQUFMLENBQWhCO0FBQ0E0VixVQUFBQSxTQUFTLEdBQUc1SSxHQUFHLENBQUNoTixDQUFDLEdBQUcsQ0FBTCxDQUFmO0FBQ0E2VixVQUFBQSxVQUFVLEdBQUc3SSxHQUFHLENBQUNoTixDQUFDLEdBQUcsQ0FBTCxDQUFoQjs7QUFDQSxjQUFJLENBQUMyVixVQUFVLEdBQUcsSUFBZCxNQUF3QixJQUF4QixJQUFnQyxDQUFDQyxTQUFTLEdBQUcsSUFBYixNQUF1QixJQUF2RCxJQUErRCxDQUFDQyxVQUFVLEdBQUcsSUFBZCxNQUF3QixJQUEzRixFQUFpRztBQUMvRkMsWUFBQUEsYUFBYSxHQUFHLENBQUNOLFNBQVMsR0FBRyxHQUFiLEtBQXFCLElBQXJCLEdBQTRCLENBQUNHLFVBQVUsR0FBRyxJQUFkLEtBQXVCLEdBQW5ELEdBQXlELENBQUNDLFNBQVMsR0FBRyxJQUFiLEtBQXNCLEdBQS9FLEdBQXNGQyxVQUFVLEdBQUcsSUFBbkg7O0FBQ0EsZ0JBQUlDLGFBQWEsR0FBRyxNQUFoQixJQUEwQkEsYUFBYSxHQUFHLFFBQTlDLEVBQXdEO0FBQ3RETCxjQUFBQSxTQUFTLEdBQUdLLGFBQVo7QUFDRDtBQUNGOztBQWxDTDtBQW9DRDs7QUFFRCxRQUFJTCxTQUFTLEtBQUssSUFBbEIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBQSxNQUFBQSxTQUFTLEdBQUcsTUFBWjtBQUNBQyxNQUFBQSxnQkFBZ0IsR0FBRyxDQUFuQjtBQUNELEtBTEQsTUFLTyxJQUFJRCxTQUFTLEdBQUcsTUFBaEIsRUFBd0I7QUFDN0I7QUFDQUEsTUFBQUEsU0FBUyxJQUFJLE9BQWI7QUFDQTlNLE1BQUFBLEdBQUcsQ0FBQzlPLElBQUosQ0FBUzRiLFNBQVMsS0FBSyxFQUFkLEdBQW1CLEtBQW5CLEdBQTJCLE1BQXBDO0FBQ0FBLE1BQUFBLFNBQVMsR0FBRyxTQUFTQSxTQUFTLEdBQUcsS0FBakM7QUFDRDs7QUFFRDlNLElBQUFBLEdBQUcsQ0FBQzlPLElBQUosQ0FBUzRiLFNBQVQ7QUFDQXpWLElBQUFBLENBQUMsSUFBSTBWLGdCQUFMO0FBQ0Q7O0FBRUQsU0FBT0sscUJBQXFCLENBQUNwTixHQUFELENBQTVCO0FBQ0QsRUFFRDtBQUNBO0FBQ0E7OztBQUNBLElBQU1xTixvQkFBb0IsR0FBRyxNQUE3Qjs7QUFFQSxTQUFTRCxxQkFBVCxDQUFnQ0UsVUFBaEMsRUFBNEM7QUFDMUMsTUFBTTFQLEdBQUcsR0FBRzBQLFVBQVUsQ0FBQy9iLE1BQXZCOztBQUNBLE1BQUlxTSxHQUFHLElBQUl5UCxvQkFBWCxFQUFpQztBQUMvQixXQUFPMUQsTUFBTSxDQUFDNEQsWUFBUCxDQUFvQmxjLEtBQXBCLENBQTBCc1ksTUFBMUIsRUFBa0MyRCxVQUFsQyxDQUFQLENBRCtCLENBQ3NCO0FBQ3RELEdBSnlDLENBTTFDOzs7QUFDQSxNQUFJdE4sR0FBRyxHQUFHLEVBQVY7QUFDQSxNQUFJM0ksQ0FBQyxHQUFHLENBQVI7O0FBQ0EsU0FBT0EsQ0FBQyxHQUFHdUcsR0FBWCxFQUFnQjtBQUNkb0MsSUFBQUEsR0FBRyxJQUFJMkosTUFBTSxDQUFDNEQsWUFBUCxDQUFvQmxjLEtBQXBCLENBQ0xzWSxNQURLLEVBRUwyRCxVQUFVLENBQUN6bEIsS0FBWCxDQUFpQndQLENBQWpCLEVBQW9CQSxDQUFDLElBQUlnVyxvQkFBekIsQ0FGSyxDQUFQO0FBSUQ7O0FBQ0QsU0FBT3JOLEdBQVA7QUFDRDs7QUFFRCxTQUFTb0ssVUFBVCxDQUFxQi9GLEdBQXJCLEVBQTBCNUYsS0FBMUIsRUFBaUNDLEdBQWpDLEVBQXNDO0FBQ3BDLE1BQUk4TyxHQUFHLEdBQUcsRUFBVjtBQUNBOU8sRUFBQUEsR0FBRyxHQUFHOEMsSUFBSSxDQUFDa0ksR0FBTCxDQUFTckYsR0FBRyxDQUFDOVMsTUFBYixFQUFxQm1OLEdBQXJCLENBQU47O0FBRUEsT0FBSyxJQUFJckgsQ0FBQyxHQUFHb0gsS0FBYixFQUFvQnBILENBQUMsR0FBR3FILEdBQXhCLEVBQTZCLEVBQUVySCxDQUEvQixFQUFrQztBQUNoQ21XLElBQUFBLEdBQUcsSUFBSTdELE1BQU0sQ0FBQzRELFlBQVAsQ0FBb0JsSixHQUFHLENBQUNoTixDQUFELENBQUgsR0FBUyxJQUE3QixDQUFQO0FBQ0Q7O0FBQ0QsU0FBT21XLEdBQVA7QUFDRDs7QUFFRCxTQUFTbkQsV0FBVCxDQUFzQmhHLEdBQXRCLEVBQTJCNUYsS0FBM0IsRUFBa0NDLEdBQWxDLEVBQXVDO0FBQ3JDLE1BQUk4TyxHQUFHLEdBQUcsRUFBVjtBQUNBOU8sRUFBQUEsR0FBRyxHQUFHOEMsSUFBSSxDQUFDa0ksR0FBTCxDQUFTckYsR0FBRyxDQUFDOVMsTUFBYixFQUFxQm1OLEdBQXJCLENBQU47O0FBRUEsT0FBSyxJQUFJckgsQ0FBQyxHQUFHb0gsS0FBYixFQUFvQnBILENBQUMsR0FBR3FILEdBQXhCLEVBQTZCLEVBQUVySCxDQUEvQixFQUFrQztBQUNoQ21XLElBQUFBLEdBQUcsSUFBSTdELE1BQU0sQ0FBQzRELFlBQVAsQ0FBb0JsSixHQUFHLENBQUNoTixDQUFELENBQXZCLENBQVA7QUFDRDs7QUFDRCxTQUFPbVcsR0FBUDtBQUNEOztBQUVELFNBQVN4SixRQUFULENBQW1CSyxHQUFuQixFQUF3QjVGLEtBQXhCLEVBQStCQyxHQUEvQixFQUFvQztBQUNsQyxNQUFNZCxHQUFHLEdBQUd5RyxHQUFHLENBQUM5UyxNQUFoQjtBQUVBLE1BQUksQ0FBQ2tOLEtBQUQsSUFBVUEsS0FBSyxHQUFHLENBQXRCLEVBQXlCQSxLQUFLLEdBQUcsQ0FBUjtBQUN6QixNQUFJLENBQUNDLEdBQUQsSUFBUUEsR0FBRyxHQUFHLENBQWQsSUFBbUJBLEdBQUcsR0FBR2QsR0FBN0IsRUFBa0NjLEdBQUcsR0FBR2QsR0FBTjtBQUVsQyxNQUFJMEksR0FBRyxHQUFHLEVBQVY7O0FBQ0EsT0FBSyxJQUFJalAsQ0FBQyxHQUFHb0gsS0FBYixFQUFvQnBILENBQUMsR0FBR3FILEdBQXhCLEVBQTZCLEVBQUVySCxDQUEvQixFQUFrQztBQUNoQ2lQLElBQUFBLEdBQUcsSUFBSW1ILG1CQUFtQixDQUFDcEosR0FBRyxDQUFDaE4sQ0FBRCxDQUFKLENBQTFCO0FBQ0Q7O0FBQ0QsU0FBT2lQLEdBQVA7QUFDRDs7QUFFRCxTQUFTaUUsWUFBVCxDQUF1QmxHLEdBQXZCLEVBQTRCNUYsS0FBNUIsRUFBbUNDLEdBQW5DLEVBQXdDO0FBQ3RDLE1BQU1vQixLQUFLLEdBQUd1RSxHQUFHLENBQUN4YyxLQUFKLENBQVU0VyxLQUFWLEVBQWlCQyxHQUFqQixDQUFkO0FBQ0EsTUFBSXNCLEdBQUcsR0FBRyxFQUFWLENBRnNDLENBR3RDOztBQUNBLE9BQUssSUFBSTNJLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd5SSxLQUFLLENBQUN2TyxNQUFOLEdBQWUsQ0FBbkMsRUFBc0M4RixDQUFDLElBQUksQ0FBM0MsRUFBOEM7QUFDNUMySSxJQUFBQSxHQUFHLElBQUkySixNQUFNLENBQUM0RCxZQUFQLENBQW9Cek4sS0FBSyxDQUFDekksQ0FBRCxDQUFMLEdBQVl5SSxLQUFLLENBQUN6SSxDQUFDLEdBQUcsQ0FBTCxDQUFMLEdBQWUsR0FBL0MsQ0FBUDtBQUNEOztBQUNELFNBQU8ySSxHQUFQO0FBQ0Q7O0FBRUR2WSxNQUFNLENBQUM4RyxTQUFQLENBQWlCMUcsS0FBakIsR0FBeUIsU0FBU0EsS0FBVCxDQUFnQjRXLEtBQWhCLEVBQXVCQyxHQUF2QixFQUE0QjtBQUNuRCxNQUFNZCxHQUFHLEdBQUcsS0FBS3JNLE1BQWpCO0FBQ0FrTixFQUFBQSxLQUFLLEdBQUcsQ0FBQyxDQUFDQSxLQUFWO0FBQ0FDLEVBQUFBLEdBQUcsR0FBR0EsR0FBRyxLQUFLOVIsU0FBUixHQUFvQmdSLEdBQXBCLEdBQTBCLENBQUMsQ0FBQ2MsR0FBbEM7O0FBRUEsTUFBSUQsS0FBSyxHQUFHLENBQVosRUFBZTtBQUNiQSxJQUFBQSxLQUFLLElBQUliLEdBQVQ7QUFDQSxRQUFJYSxLQUFLLEdBQUcsQ0FBWixFQUFlQSxLQUFLLEdBQUcsQ0FBUjtBQUNoQixHQUhELE1BR08sSUFBSUEsS0FBSyxHQUFHYixHQUFaLEVBQWlCO0FBQ3RCYSxJQUFBQSxLQUFLLEdBQUdiLEdBQVI7QUFDRDs7QUFFRCxNQUFJYyxHQUFHLEdBQUcsQ0FBVixFQUFhO0FBQ1hBLElBQUFBLEdBQUcsSUFBSWQsR0FBUDtBQUNBLFFBQUljLEdBQUcsR0FBRyxDQUFWLEVBQWFBLEdBQUcsR0FBRyxDQUFOO0FBQ2QsR0FIRCxNQUdPLElBQUlBLEdBQUcsR0FBR2QsR0FBVixFQUFlO0FBQ3BCYyxJQUFBQSxHQUFHLEdBQUdkLEdBQU47QUFDRDs7QUFFRCxNQUFJYyxHQUFHLEdBQUdELEtBQVYsRUFBaUJDLEdBQUcsR0FBR0QsS0FBTjtBQUVqQixNQUFNaVAsTUFBTSxHQUFHLEtBQUtDLFFBQUwsQ0FBY2xQLEtBQWQsRUFBcUJDLEdBQXJCLENBQWYsQ0FyQm1ELENBc0JuRDs7QUFDQS9YLEVBQUFBLE1BQU0sQ0FBQzZnQixjQUFQLENBQXNCa0csTUFBdEIsRUFBOEJqbUIsTUFBTSxDQUFDOEcsU0FBckM7QUFFQSxTQUFPbWYsTUFBUDtBQUNELENBMUJEO0FBNEJBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU0UsV0FBVCxDQUFzQnBFLE1BQXRCLEVBQThCcUUsR0FBOUIsRUFBbUN0YyxNQUFuQyxFQUEyQztBQUN6QyxNQUFLaVksTUFBTSxHQUFHLENBQVYsS0FBaUIsQ0FBakIsSUFBc0JBLE1BQU0sR0FBRyxDQUFuQyxFQUFzQyxNQUFNLElBQUkzQixVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUN0QyxNQUFJMkIsTUFBTSxHQUFHcUUsR0FBVCxHQUFldGMsTUFBbkIsRUFBMkIsTUFBTSxJQUFJc1csVUFBSixDQUFlLHVDQUFmLENBQU47QUFDNUI7O0FBRURwZ0IsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnVmLFVBQWpCLEdBQ0FybUIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQndmLFVBQWpCLEdBQThCLFNBQVNBLFVBQVQsQ0FBcUJ2RSxNQUFyQixFQUE2QmxNLFVBQTdCLEVBQXlDK0YsUUFBekMsRUFBbUQ7QUFDL0VtRyxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBbE0sRUFBQUEsVUFBVSxHQUFHQSxVQUFVLEtBQUssQ0FBNUI7QUFDQSxNQUFJLENBQUMrRixRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVNsTSxVQUFULEVBQXFCLEtBQUsvTCxNQUExQixDQUFYO0FBRWYsTUFBSXZFLEdBQUcsR0FBRyxLQUFLd2MsTUFBTCxDQUFWO0FBQ0EsTUFBSXdFLEdBQUcsR0FBRyxDQUFWO0FBQ0EsTUFBSTNXLENBQUMsR0FBRyxDQUFSOztBQUNBLFNBQU8sRUFBRUEsQ0FBRixHQUFNaUcsVUFBTixLQUFxQjBRLEdBQUcsSUFBSSxLQUE1QixDQUFQLEVBQTJDO0FBQ3pDaGhCLElBQUFBLEdBQUcsSUFBSSxLQUFLd2MsTUFBTSxHQUFHblMsQ0FBZCxJQUFtQjJXLEdBQTFCO0FBQ0Q7O0FBRUQsU0FBT2hoQixHQUFQO0FBQ0QsQ0FkRDs7QUFnQkF2RixNQUFNLENBQUM4RyxTQUFQLENBQWlCMGYsVUFBakIsR0FDQXhtQixNQUFNLENBQUM4RyxTQUFQLENBQWlCMmYsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQjFFLE1BQXJCLEVBQTZCbE0sVUFBN0IsRUFBeUMrRixRQUF6QyxFQUFtRDtBQUMvRW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0FsTSxFQUFBQSxVQUFVLEdBQUdBLFVBQVUsS0FBSyxDQUE1Qjs7QUFDQSxNQUFJLENBQUMrRixRQUFMLEVBQWU7QUFDYnVLLElBQUFBLFdBQVcsQ0FBQ3BFLE1BQUQsRUFBU2xNLFVBQVQsRUFBcUIsS0FBSy9MLE1BQTFCLENBQVg7QUFDRDs7QUFFRCxNQUFJdkUsR0FBRyxHQUFHLEtBQUt3YyxNQUFNLEdBQUcsRUFBRWxNLFVBQWhCLENBQVY7QUFDQSxNQUFJMFEsR0FBRyxHQUFHLENBQVY7O0FBQ0EsU0FBTzFRLFVBQVUsR0FBRyxDQUFiLEtBQW1CMFEsR0FBRyxJQUFJLEtBQTFCLENBQVAsRUFBeUM7QUFDdkNoaEIsSUFBQUEsR0FBRyxJQUFJLEtBQUt3YyxNQUFNLEdBQUcsRUFBRWxNLFVBQWhCLElBQThCMFEsR0FBckM7QUFDRDs7QUFFRCxTQUFPaGhCLEdBQVA7QUFDRCxDQWZEOztBQWlCQXZGLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUI0ZixTQUFqQixHQUNBMW1CLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUI2ZixTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9CNUUsTUFBcEIsRUFBNEJuRyxRQUE1QixFQUFzQztBQUNqRW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFldUssV0FBVyxDQUFDcEUsTUFBRCxFQUFTLENBQVQsRUFBWSxLQUFLalksTUFBakIsQ0FBWDtBQUNmLFNBQU8sS0FBS2lZLE1BQUwsQ0FBUDtBQUNELENBTEQ7O0FBT0EvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjhmLFlBQWpCLEdBQ0E1bUIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQitmLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUI5RSxNQUF2QixFQUErQm5HLFFBQS9CLEVBQXlDO0FBQ3ZFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBQ2YsU0FBTyxLQUFLaVksTUFBTCxJQUFnQixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQUEzQztBQUNELENBTEQ7O0FBT0EvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQmdnQixZQUFqQixHQUNBOW1CLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJtZCxZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCbEMsTUFBdkIsRUFBK0JuRyxRQUEvQixFQUF5QztBQUN2RW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFldUssV0FBVyxDQUFDcEUsTUFBRCxFQUFTLENBQVQsRUFBWSxLQUFLalksTUFBakIsQ0FBWDtBQUNmLFNBQVEsS0FBS2lZLE1BQUwsS0FBZ0IsQ0FBakIsR0FBc0IsS0FBS0EsTUFBTSxHQUFHLENBQWQsQ0FBN0I7QUFDRCxDQUxEOztBQU9BL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJpZ0IsWUFBakIsR0FDQS9tQixNQUFNLENBQUM4RyxTQUFQLENBQWlCa2dCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJqRixNQUF2QixFQUErQm5HLFFBQS9CLEVBQXlDO0FBQ3ZFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBRWYsU0FBTyxDQUFFLEtBQUtpWSxNQUFMLENBQUQsR0FDSCxLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQURqQixHQUVILEtBQUtBLE1BQU0sR0FBRyxDQUFkLEtBQW9CLEVBRmxCLElBR0YsS0FBS0EsTUFBTSxHQUFHLENBQWQsSUFBbUIsU0FIeEI7QUFJRCxDQVREOztBQVdBL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJtZ0IsWUFBakIsR0FDQWpuQixNQUFNLENBQUM4RyxTQUFQLENBQWlCb2dCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJuRixNQUF2QixFQUErQm5HLFFBQS9CLEVBQXlDO0FBQ3ZFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBRWYsU0FBUSxLQUFLaVksTUFBTCxJQUFlLFNBQWhCLElBQ0gsS0FBS0EsTUFBTSxHQUFHLENBQWQsS0FBb0IsRUFBckIsR0FDQSxLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQURwQixHQUVELEtBQUtBLE1BQU0sR0FBRyxDQUFkLENBSEssQ0FBUDtBQUlELENBVEQ7O0FBV0EvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnFnQixlQUFqQixHQUFtQ0Msa0JBQWtCLENBQUMsU0FBU0QsZUFBVCxDQUEwQnBGLE1BQTFCLEVBQWtDO0FBQ3RGQSxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBc0YsRUFBQUEsY0FBYyxDQUFDdEYsTUFBRCxFQUFTLFFBQVQsQ0FBZDtBQUNBLE1BQU11RixLQUFLLEdBQUcsS0FBS3ZGLE1BQUwsQ0FBZDtBQUNBLE1BQU12RCxJQUFJLEdBQUcsS0FBS3VELE1BQU0sR0FBRyxDQUFkLENBQWI7O0FBQ0EsTUFBSXVGLEtBQUssS0FBS25pQixTQUFWLElBQXVCcVosSUFBSSxLQUFLclosU0FBcEMsRUFBK0M7QUFDN0NvaUIsSUFBQUEsV0FBVyxDQUFDeEYsTUFBRCxFQUFTLEtBQUtqWSxNQUFMLEdBQWMsQ0FBdkIsQ0FBWDtBQUNEOztBQUVELE1BQU0wZCxFQUFFLEdBQUdGLEtBQUssR0FDZCxLQUFLLEVBQUV2RixNQUFQLGFBQWlCLENBQWpCLEVBQXNCLENBQXRCLENBRFMsR0FFVCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsQ0FGUyxHQUdULEtBQUssRUFBRUEsTUFBUCxhQUFpQixDQUFqQixFQUFzQixFQUF0QixDQUhGO0FBS0EsTUFBTTBGLEVBQUUsR0FBRyxLQUFLLEVBQUUxRixNQUFQLElBQ1QsS0FBSyxFQUFFQSxNQUFQLGFBQWlCLENBQWpCLEVBQXNCLENBQXRCLENBRFMsR0FFVCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsQ0FGUyxHQUdUdkQsSUFBSSxZQUFHLENBQUgsRUFBUSxFQUFSLENBSE47QUFLQSxTQUFPa0osTUFBTSxDQUFDRixFQUFELENBQU4sSUFBY0UsTUFBTSxDQUFDRCxFQUFELENBQU4sSUFBY0MsTUFBTSxDQUFDLEVBQUQsQ0FBbEMsQ0FBUDtBQUNELENBcEJvRCxDQUFyRDtBQXNCQTFuQixNQUFNLENBQUM4RyxTQUFQLENBQWlCNmdCLGVBQWpCLEdBQW1DUCxrQkFBa0IsQ0FBQyxTQUFTTyxlQUFULENBQTBCNUYsTUFBMUIsRUFBa0M7QUFDdEZBLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0FzRixFQUFBQSxjQUFjLENBQUN0RixNQUFELEVBQVMsUUFBVCxDQUFkO0FBQ0EsTUFBTXVGLEtBQUssR0FBRyxLQUFLdkYsTUFBTCxDQUFkO0FBQ0EsTUFBTXZELElBQUksR0FBRyxLQUFLdUQsTUFBTSxHQUFHLENBQWQsQ0FBYjs7QUFDQSxNQUFJdUYsS0FBSyxLQUFLbmlCLFNBQVYsSUFBdUJxWixJQUFJLEtBQUtyWixTQUFwQyxFQUErQztBQUM3Q29pQixJQUFBQSxXQUFXLENBQUN4RixNQUFELEVBQVMsS0FBS2pZLE1BQUwsR0FBYyxDQUF2QixDQUFYO0FBQ0Q7O0FBRUQsTUFBTTJkLEVBQUUsR0FBR0gsS0FBSyxZQUFHLENBQUgsRUFBUSxFQUFSLENBQUwsR0FDVCxLQUFLLEVBQUV2RixNQUFQLGFBQWlCLENBQWpCLEVBQXNCLEVBQXRCLENBRFMsR0FFVCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsQ0FBdEIsQ0FGUyxHQUdULEtBQUssRUFBRUEsTUFBUCxDQUhGO0FBS0EsTUFBTXlGLEVBQUUsR0FBRyxLQUFLLEVBQUV6RixNQUFQLGFBQWlCLENBQWpCLEVBQXNCLEVBQXRCLElBQ1QsS0FBSyxFQUFFQSxNQUFQLGFBQWlCLENBQWpCLEVBQXNCLEVBQXRCLENBRFMsR0FFVCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsQ0FBdEIsQ0FGUyxHQUdUdkQsSUFIRjtBQUtBLFNBQU8sQ0FBQ2tKLE1BQU0sQ0FBQ0QsRUFBRCxDQUFOLElBQWNDLE1BQU0sQ0FBQyxFQUFELENBQXJCLElBQTZCQSxNQUFNLENBQUNGLEVBQUQsQ0FBMUM7QUFDRCxDQXBCb0QsQ0FBckQ7O0FBc0JBeG5CLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUI4Z0IsU0FBakIsR0FBNkIsU0FBU0EsU0FBVCxDQUFvQjdGLE1BQXBCLEVBQTRCbE0sVUFBNUIsRUFBd0MrRixRQUF4QyxFQUFrRDtBQUM3RW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0FsTSxFQUFBQSxVQUFVLEdBQUdBLFVBQVUsS0FBSyxDQUE1QjtBQUNBLE1BQUksQ0FBQytGLFFBQUwsRUFBZXVLLFdBQVcsQ0FBQ3BFLE1BQUQsRUFBU2xNLFVBQVQsRUFBcUIsS0FBSy9MLE1BQTFCLENBQVg7QUFFZixNQUFJdkUsR0FBRyxHQUFHLEtBQUt3YyxNQUFMLENBQVY7QUFDQSxNQUFJd0UsR0FBRyxHQUFHLENBQVY7QUFDQSxNQUFJM1csQ0FBQyxHQUFHLENBQVI7O0FBQ0EsU0FBTyxFQUFFQSxDQUFGLEdBQU1pRyxVQUFOLEtBQXFCMFEsR0FBRyxJQUFJLEtBQTVCLENBQVAsRUFBMkM7QUFDekNoaEIsSUFBQUEsR0FBRyxJQUFJLEtBQUt3YyxNQUFNLEdBQUduUyxDQUFkLElBQW1CMlcsR0FBMUI7QUFDRDs7QUFDREEsRUFBQUEsR0FBRyxJQUFJLElBQVA7QUFFQSxNQUFJaGhCLEdBQUcsSUFBSWdoQixHQUFYLEVBQWdCaGhCLEdBQUcsSUFBSXdVLElBQUksQ0FBQzhOLEdBQUwsQ0FBUyxDQUFULEVBQVksSUFBSWhTLFVBQWhCLENBQVA7QUFFaEIsU0FBT3RRLEdBQVA7QUFDRCxDQWhCRDs7QUFrQkF2RixNQUFNLENBQUM4RyxTQUFQLENBQWlCZ2hCLFNBQWpCLEdBQTZCLFNBQVNBLFNBQVQsQ0FBb0IvRixNQUFwQixFQUE0QmxNLFVBQTVCLEVBQXdDK0YsUUFBeEMsRUFBa0Q7QUFDN0VtRyxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBbE0sRUFBQUEsVUFBVSxHQUFHQSxVQUFVLEtBQUssQ0FBNUI7QUFDQSxNQUFJLENBQUMrRixRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVNsTSxVQUFULEVBQXFCLEtBQUsvTCxNQUExQixDQUFYO0FBRWYsTUFBSThGLENBQUMsR0FBR2lHLFVBQVI7QUFDQSxNQUFJMFEsR0FBRyxHQUFHLENBQVY7QUFDQSxNQUFJaGhCLEdBQUcsR0FBRyxLQUFLd2MsTUFBTSxHQUFHLEVBQUVuUyxDQUFoQixDQUFWOztBQUNBLFNBQU9BLENBQUMsR0FBRyxDQUFKLEtBQVUyVyxHQUFHLElBQUksS0FBakIsQ0FBUCxFQUFnQztBQUM5QmhoQixJQUFBQSxHQUFHLElBQUksS0FBS3djLE1BQU0sR0FBRyxFQUFFblMsQ0FBaEIsSUFBcUIyVyxHQUE1QjtBQUNEOztBQUNEQSxFQUFBQSxHQUFHLElBQUksSUFBUDtBQUVBLE1BQUloaEIsR0FBRyxJQUFJZ2hCLEdBQVgsRUFBZ0JoaEIsR0FBRyxJQUFJd1UsSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJaFMsVUFBaEIsQ0FBUDtBQUVoQixTQUFPdFEsR0FBUDtBQUNELENBaEJEOztBQWtCQXZGLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJpaEIsUUFBakIsR0FBNEIsU0FBU0EsUUFBVCxDQUFtQmhHLE1BQW5CLEVBQTJCbkcsUUFBM0IsRUFBcUM7QUFDL0RtRyxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZXVLLFdBQVcsQ0FBQ3BFLE1BQUQsRUFBUyxDQUFULEVBQVksS0FBS2pZLE1BQWpCLENBQVg7QUFDZixNQUFJLEVBQUUsS0FBS2lZLE1BQUwsSUFBZSxJQUFqQixDQUFKLEVBQTRCLE9BQVEsS0FBS0EsTUFBTCxDQUFSO0FBQzVCLFNBQVEsQ0FBQyxPQUFPLEtBQUtBLE1BQUwsQ0FBUCxHQUFzQixDQUF2QixJQUE0QixDQUFDLENBQXJDO0FBQ0QsQ0FMRDs7QUFPQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCa2hCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JqRyxNQUF0QixFQUE4Qm5HLFFBQTlCLEVBQXdDO0FBQ3JFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBQ2YsTUFBTXZFLEdBQUcsR0FBRyxLQUFLd2MsTUFBTCxJQUFnQixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixDQUFoRDtBQUNBLFNBQVF4YyxHQUFHLEdBQUcsTUFBUCxHQUFpQkEsR0FBRyxHQUFHLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBTEQ7O0FBT0F2RixNQUFNLENBQUM4RyxTQUFQLENBQWlCbWhCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JsRyxNQUF0QixFQUE4Qm5HLFFBQTlCLEVBQXdDO0FBQ3JFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBQ2YsTUFBTXZFLEdBQUcsR0FBRyxLQUFLd2MsTUFBTSxHQUFHLENBQWQsSUFBb0IsS0FBS0EsTUFBTCxLQUFnQixDQUFoRDtBQUNBLFNBQVF4YyxHQUFHLEdBQUcsTUFBUCxHQUFpQkEsR0FBRyxHQUFHLFVBQXZCLEdBQW9DQSxHQUEzQztBQUNELENBTEQ7O0FBT0F2RixNQUFNLENBQUM4RyxTQUFQLENBQWlCb2hCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JuRyxNQUF0QixFQUE4Qm5HLFFBQTlCLEVBQXdDO0FBQ3JFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBRWYsU0FBUSxLQUFLaVksTUFBTCxDQUFELEdBQ0osS0FBS0EsTUFBTSxHQUFHLENBQWQsS0FBb0IsQ0FEaEIsR0FFSixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxLQUFvQixFQUZoQixHQUdKLEtBQUtBLE1BQU0sR0FBRyxDQUFkLEtBQW9CLEVBSHZCO0FBSUQsQ0FSRDs7QUFVQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCcWhCLFdBQWpCLEdBQStCLFNBQVNBLFdBQVQsQ0FBc0JwRyxNQUF0QixFQUE4Qm5HLFFBQTlCLEVBQXdDO0FBQ3JFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBRWYsU0FBUSxLQUFLaVksTUFBTCxLQUFnQixFQUFqQixHQUNKLEtBQUtBLE1BQU0sR0FBRyxDQUFkLEtBQW9CLEVBRGhCLEdBRUosS0FBS0EsTUFBTSxHQUFHLENBQWQsS0FBb0IsQ0FGaEIsR0FHSixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxDQUhIO0FBSUQsQ0FSRDs7QUFVQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCc2hCLGNBQWpCLEdBQWtDaEIsa0JBQWtCLENBQUMsU0FBU2dCLGNBQVQsQ0FBeUJyRyxNQUF6QixFQUFpQztBQUNwRkEsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQXNGLEVBQUFBLGNBQWMsQ0FBQ3RGLE1BQUQsRUFBUyxRQUFULENBQWQ7QUFDQSxNQUFNdUYsS0FBSyxHQUFHLEtBQUt2RixNQUFMLENBQWQ7QUFDQSxNQUFNdkQsSUFBSSxHQUFHLEtBQUt1RCxNQUFNLEdBQUcsQ0FBZCxDQUFiOztBQUNBLE1BQUl1RixLQUFLLEtBQUtuaUIsU0FBVixJQUF1QnFaLElBQUksS0FBS3JaLFNBQXBDLEVBQStDO0FBQzdDb2lCLElBQUFBLFdBQVcsQ0FBQ3hGLE1BQUQsRUFBUyxLQUFLalksTUFBTCxHQUFjLENBQXZCLENBQVg7QUFDRDs7QUFFRCxNQUFNdkUsR0FBRyxHQUFHLEtBQUt3YyxNQUFNLEdBQUcsQ0FBZCxJQUNWLEtBQUtBLE1BQU0sR0FBRyxDQUFkLGFBQW1CLENBQW5CLEVBQXdCLENBQXhCLENBRFUsR0FFVixLQUFLQSxNQUFNLEdBQUcsQ0FBZCxhQUFtQixDQUFuQixFQUF3QixFQUF4QixDQUZVLElBR1R2RCxJQUFJLElBQUksRUFIQyxDQUFaLENBVG9GLENBWXJFOztBQUVmLFNBQU8sQ0FBQ2tKLE1BQU0sQ0FBQ25pQixHQUFELENBQU4sSUFBZW1pQixNQUFNLENBQUMsRUFBRCxDQUF0QixJQUNMQSxNQUFNLENBQUNKLEtBQUssR0FDWixLQUFLLEVBQUV2RixNQUFQLGFBQWlCLENBQWpCLEVBQXNCLENBQXRCLENBRE8sR0FFUCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsQ0FGTyxHQUdQLEtBQUssRUFBRUEsTUFBUCxhQUFpQixDQUFqQixFQUFzQixFQUF0QixDQUhNLENBRFI7QUFLRCxDQW5CbUQsQ0FBcEQ7QUFxQkEvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnVoQixjQUFqQixHQUFrQ2pCLGtCQUFrQixDQUFDLFNBQVNpQixjQUFULENBQXlCdEcsTUFBekIsRUFBaUM7QUFDcEZBLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0FzRixFQUFBQSxjQUFjLENBQUN0RixNQUFELEVBQVMsUUFBVCxDQUFkO0FBQ0EsTUFBTXVGLEtBQUssR0FBRyxLQUFLdkYsTUFBTCxDQUFkO0FBQ0EsTUFBTXZELElBQUksR0FBRyxLQUFLdUQsTUFBTSxHQUFHLENBQWQsQ0FBYjs7QUFDQSxNQUFJdUYsS0FBSyxLQUFLbmlCLFNBQVYsSUFBdUJxWixJQUFJLEtBQUtyWixTQUFwQyxFQUErQztBQUM3Q29pQixJQUFBQSxXQUFXLENBQUN4RixNQUFELEVBQVMsS0FBS2pZLE1BQUwsR0FBYyxDQUF2QixDQUFYO0FBQ0Q7O0FBRUQsTUFBTXZFLEdBQUcsR0FBRyxDQUFDK2hCLEtBQUssSUFBSSxFQUFWLElBQWdCO0FBQzFCLE9BQUssRUFBRXZGLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsQ0FEVSxHQUVWLEtBQUssRUFBRUEsTUFBUCxhQUFpQixDQUFqQixFQUFzQixDQUF0QixDQUZVLEdBR1YsS0FBSyxFQUFFQSxNQUFQLENBSEY7QUFLQSxTQUFPLENBQUMyRixNQUFNLENBQUNuaUIsR0FBRCxDQUFOLElBQWVtaUIsTUFBTSxDQUFDLEVBQUQsQ0FBdEIsSUFDTEEsTUFBTSxDQUFDLEtBQUssRUFBRTNGLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsSUFDUCxLQUFLLEVBQUVBLE1BQVAsYUFBaUIsQ0FBakIsRUFBc0IsRUFBdEIsQ0FETyxHQUVQLEtBQUssRUFBRUEsTUFBUCxhQUFpQixDQUFqQixFQUFzQixDQUF0QixDQUZPLEdBR1B2RCxJQUhNLENBRFI7QUFLRCxDQW5CbUQsQ0FBcEQ7O0FBcUJBeGUsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQndoQixXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCdkcsTUFBdEIsRUFBOEJuRyxRQUE5QixFQUF3QztBQUNyRW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFldUssV0FBVyxDQUFDcEUsTUFBRCxFQUFTLENBQVQsRUFBWSxLQUFLalksTUFBakIsQ0FBWDtBQUNmLFNBQU9zVixPQUFPLENBQUNsYSxJQUFSLENBQWEsSUFBYixFQUFtQjZjLE1BQW5CLEVBQTJCLElBQTNCLEVBQWlDLEVBQWpDLEVBQXFDLENBQXJDLENBQVA7QUFDRCxDQUpEOztBQU1BL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJ5aEIsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQnhHLE1BQXRCLEVBQThCbkcsUUFBOUIsRUFBd0M7QUFDckVtRyxFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZXVLLFdBQVcsQ0FBQ3BFLE1BQUQsRUFBUyxDQUFULEVBQVksS0FBS2pZLE1BQWpCLENBQVg7QUFDZixTQUFPc1YsT0FBTyxDQUFDbGEsSUFBUixDQUFhLElBQWIsRUFBbUI2YyxNQUFuQixFQUEyQixLQUEzQixFQUFrQyxFQUFsQyxFQUFzQyxDQUF0QyxDQUFQO0FBQ0QsQ0FKRDs7QUFNQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCMGhCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ6RyxNQUF2QixFQUErQm5HLFFBQS9CLEVBQXlDO0FBQ3ZFbUcsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWV1SyxXQUFXLENBQUNwRSxNQUFELEVBQVMsQ0FBVCxFQUFZLEtBQUtqWSxNQUFqQixDQUFYO0FBQ2YsU0FBT3NWLE9BQU8sQ0FBQ2xhLElBQVIsQ0FBYSxJQUFiLEVBQW1CNmMsTUFBbkIsRUFBMkIsSUFBM0IsRUFBaUMsRUFBakMsRUFBcUMsQ0FBckMsQ0FBUDtBQUNELENBSkQ7O0FBTUEvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjJoQixZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCMUcsTUFBdkIsRUFBK0JuRyxRQUEvQixFQUF5QztBQUN2RW1HLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFldUssV0FBVyxDQUFDcEUsTUFBRCxFQUFTLENBQVQsRUFBWSxLQUFLalksTUFBakIsQ0FBWDtBQUNmLFNBQU9zVixPQUFPLENBQUNsYSxJQUFSLENBQWEsSUFBYixFQUFtQjZjLE1BQW5CLEVBQTJCLEtBQTNCLEVBQWtDLEVBQWxDLEVBQXNDLENBQXRDLENBQVA7QUFDRCxDQUpEOztBQU1BLFNBQVMyRyxRQUFULENBQW1COUwsR0FBbkIsRUFBd0J2ZCxLQUF4QixFQUErQjBpQixNQUEvQixFQUF1Q3FFLEdBQXZDLEVBQTRDOUMsR0FBNUMsRUFBaURyQixHQUFqRCxFQUFzRDtBQUNwRCxNQUFJLENBQUNqaUIsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQjhOLEdBQWhCLENBQUwsRUFBMkIsTUFBTSxJQUFJL1UsU0FBSixDQUFjLDZDQUFkLENBQU47QUFDM0IsTUFBSXhJLEtBQUssR0FBR2lrQixHQUFSLElBQWVqa0IsS0FBSyxHQUFHNGlCLEdBQTNCLEVBQWdDLE1BQU0sSUFBSTdCLFVBQUosQ0FBZSxtQ0FBZixDQUFOO0FBQ2hDLE1BQUkyQixNQUFNLEdBQUdxRSxHQUFULEdBQWV4SixHQUFHLENBQUM5UyxNQUF2QixFQUErQixNQUFNLElBQUlzVyxVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNoQzs7QUFFRHBnQixNQUFNLENBQUM4RyxTQUFQLENBQWlCNmhCLFdBQWpCLEdBQ0Ezb0IsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjhoQixXQUFqQixHQUErQixTQUFTQSxXQUFULENBQXNCdnBCLEtBQXRCLEVBQTZCMGlCLE1BQTdCLEVBQXFDbE0sVUFBckMsRUFBaUQrRixRQUFqRCxFQUEyRDtBQUN4RnZjLEVBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0EwaUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQWxNLEVBQUFBLFVBQVUsR0FBR0EsVUFBVSxLQUFLLENBQTVCOztBQUNBLE1BQUksQ0FBQytGLFFBQUwsRUFBZTtBQUNiLFFBQU1pTixRQUFRLEdBQUc5TyxJQUFJLENBQUM4TixHQUFMLENBQVMsQ0FBVCxFQUFZLElBQUloUyxVQUFoQixJQUE4QixDQUEvQztBQUNBNlMsSUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBT3JwQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQmxNLFVBQXRCLEVBQWtDZ1QsUUFBbEMsRUFBNEMsQ0FBNUMsQ0FBUjtBQUNEOztBQUVELE1BQUl0QyxHQUFHLEdBQUcsQ0FBVjtBQUNBLE1BQUkzVyxDQUFDLEdBQUcsQ0FBUjtBQUNBLE9BQUttUyxNQUFMLElBQWUxaUIsS0FBSyxHQUFHLElBQXZCOztBQUNBLFNBQU8sRUFBRXVRLENBQUYsR0FBTWlHLFVBQU4sS0FBcUIwUSxHQUFHLElBQUksS0FBNUIsQ0FBUCxFQUEyQztBQUN6QyxTQUFLeEUsTUFBTSxHQUFHblMsQ0FBZCxJQUFvQnZRLEtBQUssR0FBR2tuQixHQUFULEdBQWdCLElBQW5DO0FBQ0Q7O0FBRUQsU0FBT3hFLE1BQU0sR0FBR2xNLFVBQWhCO0FBQ0QsQ0FsQkQ7O0FBb0JBN1YsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQmdpQixXQUFqQixHQUNBOW9CLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJpaUIsV0FBakIsR0FBK0IsU0FBU0EsV0FBVCxDQUFzQjFwQixLQUF0QixFQUE2QjBpQixNQUE3QixFQUFxQ2xNLFVBQXJDLEVBQWlEK0YsUUFBakQsRUFBMkQ7QUFDeEZ2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0FsTSxFQUFBQSxVQUFVLEdBQUdBLFVBQVUsS0FBSyxDQUE1Qjs7QUFDQSxNQUFJLENBQUMrRixRQUFMLEVBQWU7QUFDYixRQUFNaU4sUUFBUSxHQUFHOU8sSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJaFMsVUFBaEIsSUFBOEIsQ0FBL0M7QUFDQTZTLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0JsTSxVQUF0QixFQUFrQ2dULFFBQWxDLEVBQTRDLENBQTVDLENBQVI7QUFDRDs7QUFFRCxNQUFJalosQ0FBQyxHQUFHaUcsVUFBVSxHQUFHLENBQXJCO0FBQ0EsTUFBSTBRLEdBQUcsR0FBRyxDQUFWO0FBQ0EsT0FBS3hFLE1BQU0sR0FBR25TLENBQWQsSUFBbUJ2USxLQUFLLEdBQUcsSUFBM0I7O0FBQ0EsU0FBTyxFQUFFdVEsQ0FBRixJQUFPLENBQVAsS0FBYTJXLEdBQUcsSUFBSSxLQUFwQixDQUFQLEVBQW1DO0FBQ2pDLFNBQUt4RSxNQUFNLEdBQUduUyxDQUFkLElBQW9CdlEsS0FBSyxHQUFHa25CLEdBQVQsR0FBZ0IsSUFBbkM7QUFDRDs7QUFFRCxTQUFPeEUsTUFBTSxHQUFHbE0sVUFBaEI7QUFDRCxDQWxCRDs7QUFvQkE3VixNQUFNLENBQUM4RyxTQUFQLENBQWlCa2lCLFVBQWpCLEdBQ0FocEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQm1pQixVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCNXBCLEtBQXJCLEVBQTRCMGlCLE1BQTVCLEVBQW9DbkcsUUFBcEMsRUFBOEM7QUFDMUV2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFlOE0sUUFBUSxDQUFDLElBQUQsRUFBT3JwQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQixDQUF0QixFQUF5QixJQUF6QixFQUErQixDQUEvQixDQUFSO0FBQ2YsT0FBS0EsTUFBTCxJQUFnQjFpQixLQUFLLEdBQUcsSUFBeEI7QUFDQSxTQUFPMGlCLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUEQ7O0FBU0EvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQm9pQixhQUFqQixHQUNBbHBCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJxaUIsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QjlwQixLQUF4QixFQUErQjBpQixNQUEvQixFQUF1Q25HLFFBQXZDLEVBQWlEO0FBQ2hGdmMsRUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQ7QUFDQTBpQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZThNLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsRUFBaUMsQ0FBakMsQ0FBUjtBQUNmLE9BQUtBLE1BQUwsSUFBZ0IxaUIsS0FBSyxHQUFHLElBQXhCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEtBQUssQ0FBOUI7QUFDQSxTQUFPMGlCLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUkQ7O0FBVUEvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnNpQixhQUFqQixHQUNBcHBCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJ1aUIsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QmhxQixLQUF4QixFQUErQjBpQixNQUEvQixFQUF1Q25HLFFBQXZDLEVBQWlEO0FBQ2hGdmMsRUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQ7QUFDQTBpQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZThNLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsRUFBaUMsQ0FBakMsQ0FBUjtBQUNmLE9BQUtBLE1BQUwsSUFBZ0IxaUIsS0FBSyxLQUFLLENBQTFCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEdBQUcsSUFBNUI7QUFDQSxTQUFPMGlCLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUkQ7O0FBVUEvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQndpQixhQUFqQixHQUNBdHBCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJ5aUIsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QmxxQixLQUF4QixFQUErQjBpQixNQUEvQixFQUF1Q25HLFFBQXZDLEVBQWlEO0FBQ2hGdmMsRUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQ7QUFDQTBpQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZThNLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsQ0FBdEIsRUFBeUIsVUFBekIsRUFBcUMsQ0FBckMsQ0FBUjtBQUNmLE9BQUtBLE1BQU0sR0FBRyxDQUFkLElBQW9CMWlCLEtBQUssS0FBSyxFQUE5QjtBQUNBLE9BQUswaUIsTUFBTSxHQUFHLENBQWQsSUFBb0IxaUIsS0FBSyxLQUFLLEVBQTlCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEtBQUssQ0FBOUI7QUFDQSxPQUFLMGlCLE1BQUwsSUFBZ0IxaUIsS0FBSyxHQUFHLElBQXhCO0FBQ0EsU0FBTzBpQixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQVZEOztBQVlBL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUIwaUIsYUFBakIsR0FDQXhwQixNQUFNLENBQUM4RyxTQUFQLENBQWlCMmlCLGFBQWpCLEdBQWlDLFNBQVNBLGFBQVQsQ0FBd0JwcUIsS0FBeEIsRUFBK0IwaUIsTUFBL0IsRUFBdUNuRyxRQUF2QyxFQUFpRDtBQUNoRnZjLEVBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0EwaUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWU4TSxRQUFRLENBQUMsSUFBRCxFQUFPcnBCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLENBQXRCLEVBQXlCLFVBQXpCLEVBQXFDLENBQXJDLENBQVI7QUFDZixPQUFLQSxNQUFMLElBQWdCMWlCLEtBQUssS0FBSyxFQUExQjtBQUNBLE9BQUswaUIsTUFBTSxHQUFHLENBQWQsSUFBb0IxaUIsS0FBSyxLQUFLLEVBQTlCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEtBQUssQ0FBOUI7QUFDQSxPQUFLMGlCLE1BQU0sR0FBRyxDQUFkLElBQW9CMWlCLEtBQUssR0FBRyxJQUE1QjtBQUNBLFNBQU8waUIsTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FWRDs7QUFZQSxTQUFTMkgsY0FBVCxDQUF5QjlNLEdBQXpCLEVBQThCdmQsS0FBOUIsRUFBcUMwaUIsTUFBckMsRUFBNkNFLEdBQTdDLEVBQWtEcUIsR0FBbEQsRUFBdUQ7QUFDckRxRyxFQUFBQSxVQUFVLENBQUN0cUIsS0FBRCxFQUFRNGlCLEdBQVIsRUFBYXFCLEdBQWIsRUFBa0IxRyxHQUFsQixFQUF1Qm1GLE1BQXZCLEVBQStCLENBQS9CLENBQVY7QUFFQSxNQUFJeUYsRUFBRSxHQUFHakQsTUFBTSxDQUFDbGxCLEtBQUssR0FBR3FvQixNQUFNLENBQUMsVUFBRCxDQUFmLENBQWY7QUFDQTlLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sRUFBUCxDQUFILEdBQWdCeUYsRUFBaEI7QUFDQUEsRUFBQUEsRUFBRSxHQUFHQSxFQUFFLElBQUksQ0FBWDtBQUNBNUssRUFBQUEsR0FBRyxDQUFDbUYsTUFBTSxFQUFQLENBQUgsR0FBZ0J5RixFQUFoQjtBQUNBQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxDQUFYO0FBQ0E1SyxFQUFBQSxHQUFHLENBQUNtRixNQUFNLEVBQVAsQ0FBSCxHQUFnQnlGLEVBQWhCO0FBQ0FBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLENBQVg7QUFDQTVLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sRUFBUCxDQUFILEdBQWdCeUYsRUFBaEI7QUFDQSxNQUFJQyxFQUFFLEdBQUdsRCxNQUFNLENBQUNsbEIsS0FBSyxJQUFJcW9CLE1BQU0sQ0FBQyxFQUFELENBQWYsR0FBc0JBLE1BQU0sQ0FBQyxVQUFELENBQTdCLENBQWY7QUFDQTlLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sRUFBUCxDQUFILEdBQWdCMEYsRUFBaEI7QUFDQUEsRUFBQUEsRUFBRSxHQUFHQSxFQUFFLElBQUksQ0FBWDtBQUNBN0ssRUFBQUEsR0FBRyxDQUFDbUYsTUFBTSxFQUFQLENBQUgsR0FBZ0IwRixFQUFoQjtBQUNBQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxDQUFYO0FBQ0E3SyxFQUFBQSxHQUFHLENBQUNtRixNQUFNLEVBQVAsQ0FBSCxHQUFnQjBGLEVBQWhCO0FBQ0FBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLENBQVg7QUFDQTdLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sRUFBUCxDQUFILEdBQWdCMEYsRUFBaEI7QUFDQSxTQUFPMUYsTUFBUDtBQUNEOztBQUVELFNBQVM2SCxjQUFULENBQXlCaE4sR0FBekIsRUFBOEJ2ZCxLQUE5QixFQUFxQzBpQixNQUFyQyxFQUE2Q0UsR0FBN0MsRUFBa0RxQixHQUFsRCxFQUF1RDtBQUNyRHFHLEVBQUFBLFVBQVUsQ0FBQ3RxQixLQUFELEVBQVE0aUIsR0FBUixFQUFhcUIsR0FBYixFQUFrQjFHLEdBQWxCLEVBQXVCbUYsTUFBdkIsRUFBK0IsQ0FBL0IsQ0FBVjtBQUVBLE1BQUl5RixFQUFFLEdBQUdqRCxNQUFNLENBQUNsbEIsS0FBSyxHQUFHcW9CLE1BQU0sQ0FBQyxVQUFELENBQWYsQ0FBZjtBQUNBOUssRUFBQUEsR0FBRyxDQUFDbUYsTUFBTSxHQUFHLENBQVYsQ0FBSCxHQUFrQnlGLEVBQWxCO0FBQ0FBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLENBQVg7QUFDQTVLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sR0FBRyxDQUFWLENBQUgsR0FBa0J5RixFQUFsQjtBQUNBQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxDQUFYO0FBQ0E1SyxFQUFBQSxHQUFHLENBQUNtRixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCeUYsRUFBbEI7QUFDQUEsRUFBQUEsRUFBRSxHQUFHQSxFQUFFLElBQUksQ0FBWDtBQUNBNUssRUFBQUEsR0FBRyxDQUFDbUYsTUFBTSxHQUFHLENBQVYsQ0FBSCxHQUFrQnlGLEVBQWxCO0FBQ0EsTUFBSUMsRUFBRSxHQUFHbEQsTUFBTSxDQUFDbGxCLEtBQUssSUFBSXFvQixNQUFNLENBQUMsRUFBRCxDQUFmLEdBQXNCQSxNQUFNLENBQUMsVUFBRCxDQUE3QixDQUFmO0FBQ0E5SyxFQUFBQSxHQUFHLENBQUNtRixNQUFNLEdBQUcsQ0FBVixDQUFILEdBQWtCMEYsRUFBbEI7QUFDQUEsRUFBQUEsRUFBRSxHQUFHQSxFQUFFLElBQUksQ0FBWDtBQUNBN0ssRUFBQUEsR0FBRyxDQUFDbUYsTUFBTSxHQUFHLENBQVYsQ0FBSCxHQUFrQjBGLEVBQWxCO0FBQ0FBLEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxJQUFJLENBQVg7QUFDQTdLLEVBQUFBLEdBQUcsQ0FBQ21GLE1BQU0sR0FBRyxDQUFWLENBQUgsR0FBa0IwRixFQUFsQjtBQUNBQSxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxDQUFYO0FBQ0E3SyxFQUFBQSxHQUFHLENBQUNtRixNQUFELENBQUgsR0FBYzBGLEVBQWQ7QUFDQSxTQUFPMUYsTUFBTSxHQUFHLENBQWhCO0FBQ0Q7O0FBRUQvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQitpQixnQkFBakIsR0FBb0N6QyxrQkFBa0IsQ0FBQyxTQUFTeUMsZ0JBQVQsQ0FBMkJ4cUIsS0FBM0IsRUFBOEM7QUFBQSxNQUFaMGlCLE1BQVksdUVBQUgsQ0FBRztBQUNuRyxTQUFPMkgsY0FBYyxDQUFDLElBQUQsRUFBT3JxQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQjJGLE1BQU0sQ0FBQyxDQUFELENBQTVCLEVBQWlDQSxNQUFNLENBQUMsb0JBQUQsQ0FBdkMsQ0FBckI7QUFDRCxDQUZxRCxDQUF0RDtBQUlBMW5CLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJnakIsZ0JBQWpCLEdBQW9DMUMsa0JBQWtCLENBQUMsU0FBUzBDLGdCQUFULENBQTJCenFCLEtBQTNCLEVBQThDO0FBQUEsTUFBWjBpQixNQUFZLHVFQUFILENBQUc7QUFDbkcsU0FBTzZILGNBQWMsQ0FBQyxJQUFELEVBQU92cUIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IyRixNQUFNLENBQUMsQ0FBRCxDQUE1QixFQUFpQ0EsTUFBTSxDQUFDLG9CQUFELENBQXZDLENBQXJCO0FBQ0QsQ0FGcUQsQ0FBdEQ7O0FBSUExbkIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQmlqQixVQUFqQixHQUE4QixTQUFTQSxVQUFULENBQXFCMXFCLEtBQXJCLEVBQTRCMGlCLE1BQTVCLEVBQW9DbE0sVUFBcEMsRUFBZ0QrRixRQUFoRCxFQUEwRDtBQUN0RnZjLEVBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0EwaUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7O0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFlO0FBQ2IsUUFBTW9PLEtBQUssR0FBR2pRLElBQUksQ0FBQzhOLEdBQUwsQ0FBUyxDQUFULEVBQWEsSUFBSWhTLFVBQUwsR0FBbUIsQ0FBL0IsQ0FBZDtBQUVBNlMsSUFBQUEsUUFBUSxDQUFDLElBQUQsRUFBT3JwQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQmxNLFVBQXRCLEVBQWtDbVUsS0FBSyxHQUFHLENBQTFDLEVBQTZDLENBQUNBLEtBQTlDLENBQVI7QUFDRDs7QUFFRCxNQUFJcGEsQ0FBQyxHQUFHLENBQVI7QUFDQSxNQUFJMlcsR0FBRyxHQUFHLENBQVY7QUFDQSxNQUFJMEQsR0FBRyxHQUFHLENBQVY7QUFDQSxPQUFLbEksTUFBTCxJQUFlMWlCLEtBQUssR0FBRyxJQUF2Qjs7QUFDQSxTQUFPLEVBQUV1USxDQUFGLEdBQU1pRyxVQUFOLEtBQXFCMFEsR0FBRyxJQUFJLEtBQTVCLENBQVAsRUFBMkM7QUFDekMsUUFBSWxuQixLQUFLLEdBQUcsQ0FBUixJQUFhNHFCLEdBQUcsS0FBSyxDQUFyQixJQUEwQixLQUFLbEksTUFBTSxHQUFHblMsQ0FBVCxHQUFhLENBQWxCLE1BQXlCLENBQXZELEVBQTBEO0FBQ3hEcWEsTUFBQUEsR0FBRyxHQUFHLENBQU47QUFDRDs7QUFDRCxTQUFLbEksTUFBTSxHQUFHblMsQ0FBZCxJQUFtQixDQUFFdlEsS0FBSyxHQUFHa25CLEdBQVQsSUFBaUIsQ0FBbEIsSUFBdUIwRCxHQUF2QixHQUE2QixJQUFoRDtBQUNEOztBQUVELFNBQU9sSSxNQUFNLEdBQUdsTSxVQUFoQjtBQUNELENBckJEOztBQXVCQTdWLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJvakIsVUFBakIsR0FBOEIsU0FBU0EsVUFBVCxDQUFxQjdxQixLQUFyQixFQUE0QjBpQixNQUE1QixFQUFvQ2xNLFVBQXBDLEVBQWdEK0YsUUFBaEQsRUFBMEQ7QUFDdEZ2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCOztBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZTtBQUNiLFFBQU1vTyxLQUFLLEdBQUdqUSxJQUFJLENBQUM4TixHQUFMLENBQVMsQ0FBVCxFQUFhLElBQUloUyxVQUFMLEdBQW1CLENBQS9CLENBQWQ7QUFFQTZTLElBQUFBLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0JsTSxVQUF0QixFQUFrQ21VLEtBQUssR0FBRyxDQUExQyxFQUE2QyxDQUFDQSxLQUE5QyxDQUFSO0FBQ0Q7O0FBRUQsTUFBSXBhLENBQUMsR0FBR2lHLFVBQVUsR0FBRyxDQUFyQjtBQUNBLE1BQUkwUSxHQUFHLEdBQUcsQ0FBVjtBQUNBLE1BQUkwRCxHQUFHLEdBQUcsQ0FBVjtBQUNBLE9BQUtsSSxNQUFNLEdBQUduUyxDQUFkLElBQW1CdlEsS0FBSyxHQUFHLElBQTNCOztBQUNBLFNBQU8sRUFBRXVRLENBQUYsSUFBTyxDQUFQLEtBQWEyVyxHQUFHLElBQUksS0FBcEIsQ0FBUCxFQUFtQztBQUNqQyxRQUFJbG5CLEtBQUssR0FBRyxDQUFSLElBQWE0cUIsR0FBRyxLQUFLLENBQXJCLElBQTBCLEtBQUtsSSxNQUFNLEdBQUduUyxDQUFULEdBQWEsQ0FBbEIsTUFBeUIsQ0FBdkQsRUFBMEQ7QUFDeERxYSxNQUFBQSxHQUFHLEdBQUcsQ0FBTjtBQUNEOztBQUNELFNBQUtsSSxNQUFNLEdBQUduUyxDQUFkLElBQW1CLENBQUV2USxLQUFLLEdBQUdrbkIsR0FBVCxJQUFpQixDQUFsQixJQUF1QjBELEdBQXZCLEdBQTZCLElBQWhEO0FBQ0Q7O0FBRUQsU0FBT2xJLE1BQU0sR0FBR2xNLFVBQWhCO0FBQ0QsQ0FyQkQ7O0FBdUJBN1YsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQnFqQixTQUFqQixHQUE2QixTQUFTQSxTQUFULENBQW9COXFCLEtBQXBCLEVBQTJCMGlCLE1BQTNCLEVBQW1DbkcsUUFBbkMsRUFBNkM7QUFDeEV2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFlOE0sUUFBUSxDQUFDLElBQUQsRUFBT3JwQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQixDQUF0QixFQUF5QixJQUF6QixFQUErQixDQUFDLElBQWhDLENBQVI7QUFDZixNQUFJMWlCLEtBQUssR0FBRyxDQUFaLEVBQWVBLEtBQUssR0FBRyxPQUFPQSxLQUFQLEdBQWUsQ0FBdkI7QUFDZixPQUFLMGlCLE1BQUwsSUFBZ0IxaUIsS0FBSyxHQUFHLElBQXhCO0FBQ0EsU0FBTzBpQixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQVBEOztBQVNBL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJzakIsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1Qi9xQixLQUF2QixFQUE4QjBpQixNQUE5QixFQUFzQ25HLFFBQXRDLEVBQWdEO0FBQzlFdmMsRUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQ7QUFDQTBpQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjtBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZThNLFFBQVEsQ0FBQyxJQUFELEVBQU9ycEIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsQ0FBdEIsRUFBeUIsTUFBekIsRUFBaUMsQ0FBQyxNQUFsQyxDQUFSO0FBQ2YsT0FBS0EsTUFBTCxJQUFnQjFpQixLQUFLLEdBQUcsSUFBeEI7QUFDQSxPQUFLMGlCLE1BQU0sR0FBRyxDQUFkLElBQW9CMWlCLEtBQUssS0FBSyxDQUE5QjtBQUNBLFNBQU8waUIsTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FQRDs7QUFTQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCdWpCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJockIsS0FBdkIsRUFBOEIwaUIsTUFBOUIsRUFBc0NuRyxRQUF0QyxFQUFnRDtBQUM5RXZjLEVBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0EwaUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWU4TSxRQUFRLENBQUMsSUFBRCxFQUFPcnBCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLENBQXRCLEVBQXlCLE1BQXpCLEVBQWlDLENBQUMsTUFBbEMsQ0FBUjtBQUNmLE9BQUtBLE1BQUwsSUFBZ0IxaUIsS0FBSyxLQUFLLENBQTFCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEdBQUcsSUFBNUI7QUFDQSxTQUFPMGlCLE1BQU0sR0FBRyxDQUFoQjtBQUNELENBUEQ7O0FBU0EvaEIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQndqQixZQUFqQixHQUFnQyxTQUFTQSxZQUFULENBQXVCanJCLEtBQXZCLEVBQThCMGlCLE1BQTlCLEVBQXNDbkcsUUFBdEMsRUFBZ0Q7QUFDOUV2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCO0FBQ0EsTUFBSSxDQUFDbkcsUUFBTCxFQUFlOE0sUUFBUSxDQUFDLElBQUQsRUFBT3JwQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQixDQUF0QixFQUF5QixVQUF6QixFQUFxQyxDQUFDLFVBQXRDLENBQVI7QUFDZixPQUFLQSxNQUFMLElBQWdCMWlCLEtBQUssR0FBRyxJQUF4QjtBQUNBLE9BQUswaUIsTUFBTSxHQUFHLENBQWQsSUFBb0IxaUIsS0FBSyxLQUFLLENBQTlCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEtBQUssRUFBOUI7QUFDQSxPQUFLMGlCLE1BQU0sR0FBRyxDQUFkLElBQW9CMWlCLEtBQUssS0FBSyxFQUE5QjtBQUNBLFNBQU8waUIsTUFBTSxHQUFHLENBQWhCO0FBQ0QsQ0FURDs7QUFXQS9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCeWpCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJsckIsS0FBdkIsRUFBOEIwaUIsTUFBOUIsRUFBc0NuRyxRQUF0QyxFQUFnRDtBQUM5RXZjLEVBQUFBLEtBQUssR0FBRyxDQUFDQSxLQUFUO0FBQ0EwaUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLEtBQUssQ0FBcEI7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWU4TSxRQUFRLENBQUMsSUFBRCxFQUFPcnBCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLENBQXRCLEVBQXlCLFVBQXpCLEVBQXFDLENBQUMsVUFBdEMsQ0FBUjtBQUNmLE1BQUkxaUIsS0FBSyxHQUFHLENBQVosRUFBZUEsS0FBSyxHQUFHLGFBQWFBLEtBQWIsR0FBcUIsQ0FBN0I7QUFDZixPQUFLMGlCLE1BQUwsSUFBZ0IxaUIsS0FBSyxLQUFLLEVBQTFCO0FBQ0EsT0FBSzBpQixNQUFNLEdBQUcsQ0FBZCxJQUFvQjFpQixLQUFLLEtBQUssRUFBOUI7QUFDQSxPQUFLMGlCLE1BQU0sR0FBRyxDQUFkLElBQW9CMWlCLEtBQUssS0FBSyxDQUE5QjtBQUNBLE9BQUswaUIsTUFBTSxHQUFHLENBQWQsSUFBb0IxaUIsS0FBSyxHQUFHLElBQTVCO0FBQ0EsU0FBTzBpQixNQUFNLEdBQUcsQ0FBaEI7QUFDRCxDQVZEOztBQVlBL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUIwakIsZUFBakIsR0FBbUNwRCxrQkFBa0IsQ0FBQyxTQUFTb0QsZUFBVCxDQUEwQm5yQixLQUExQixFQUE2QztBQUFBLE1BQVowaUIsTUFBWSx1RUFBSCxDQUFHO0FBQ2pHLFNBQU8ySCxjQUFjLENBQUMsSUFBRCxFQUFPcnFCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLENBQUMyRixNQUFNLENBQUMsb0JBQUQsQ0FBN0IsRUFBcURBLE1BQU0sQ0FBQyxvQkFBRCxDQUEzRCxDQUFyQjtBQUNELENBRm9ELENBQXJEO0FBSUExbkIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQjJqQixlQUFqQixHQUFtQ3JELGtCQUFrQixDQUFDLFNBQVNxRCxlQUFULENBQTBCcHJCLEtBQTFCLEVBQTZDO0FBQUEsTUFBWjBpQixNQUFZLHVFQUFILENBQUc7QUFDakcsU0FBTzZILGNBQWMsQ0FBQyxJQUFELEVBQU92cUIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsQ0FBQzJGLE1BQU0sQ0FBQyxvQkFBRCxDQUE3QixFQUFxREEsTUFBTSxDQUFDLG9CQUFELENBQTNELENBQXJCO0FBQ0QsQ0FGb0QsQ0FBckQ7O0FBSUEsU0FBU2dELFlBQVQsQ0FBdUI5TixHQUF2QixFQUE0QnZkLEtBQTVCLEVBQW1DMGlCLE1BQW5DLEVBQTJDcUUsR0FBM0MsRUFBZ0Q5QyxHQUFoRCxFQUFxRHJCLEdBQXJELEVBQTBEO0FBQ3hELE1BQUlGLE1BQU0sR0FBR3FFLEdBQVQsR0FBZXhKLEdBQUcsQ0FBQzlTLE1BQXZCLEVBQStCLE1BQU0sSUFBSXNXLFVBQUosQ0FBZSxvQkFBZixDQUFOO0FBQy9CLE1BQUkyQixNQUFNLEdBQUcsQ0FBYixFQUFnQixNQUFNLElBQUkzQixVQUFKLENBQWUsb0JBQWYsQ0FBTjtBQUNqQjs7QUFFRCxTQUFTdUssVUFBVCxDQUFxQi9OLEdBQXJCLEVBQTBCdmQsS0FBMUIsRUFBaUMwaUIsTUFBakMsRUFBeUM2SSxZQUF6QyxFQUF1RGhQLFFBQXZELEVBQWlFO0FBQy9EdmMsRUFBQUEsS0FBSyxHQUFHLENBQUNBLEtBQVQ7QUFDQTBpQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sS0FBSyxDQUFwQjs7QUFDQSxNQUFJLENBQUNuRyxRQUFMLEVBQWU7QUFDYjhPLElBQUFBLFlBQVksQ0FBQzlOLEdBQUQsRUFBTXZkLEtBQU4sRUFBYTBpQixNQUFiLEVBQXFCLENBQXJCLEVBQXdCLHNCQUF4QixFQUFnRCxDQUFDLHNCQUFqRCxDQUFaO0FBQ0Q7O0FBQ0QzQyxFQUFBQSxPQUFPLENBQUM1TyxLQUFSLENBQWNvTSxHQUFkLEVBQW1CdmQsS0FBbkIsRUFBMEIwaUIsTUFBMUIsRUFBa0M2SSxZQUFsQyxFQUFnRCxFQUFoRCxFQUFvRCxDQUFwRDtBQUNBLFNBQU83SSxNQUFNLEdBQUcsQ0FBaEI7QUFDRDs7QUFFRC9oQixNQUFNLENBQUM4RyxTQUFQLENBQWlCK2pCLFlBQWpCLEdBQWdDLFNBQVNBLFlBQVQsQ0FBdUJ4ckIsS0FBdkIsRUFBOEIwaUIsTUFBOUIsRUFBc0NuRyxRQUF0QyxFQUFnRDtBQUM5RSxTQUFPK08sVUFBVSxDQUFDLElBQUQsRUFBT3RyQixLQUFQLEVBQWMwaUIsTUFBZCxFQUFzQixJQUF0QixFQUE0Qm5HLFFBQTVCLENBQWpCO0FBQ0QsQ0FGRDs7QUFJQTViLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJna0IsWUFBakIsR0FBZ0MsU0FBU0EsWUFBVCxDQUF1QnpyQixLQUF2QixFQUE4QjBpQixNQUE5QixFQUFzQ25HLFFBQXRDLEVBQWdEO0FBQzlFLFNBQU8rTyxVQUFVLENBQUMsSUFBRCxFQUFPdHJCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLEtBQXRCLEVBQTZCbkcsUUFBN0IsQ0FBakI7QUFDRCxDQUZEOztBQUlBLFNBQVNtUCxXQUFULENBQXNCbk8sR0FBdEIsRUFBMkJ2ZCxLQUEzQixFQUFrQzBpQixNQUFsQyxFQUEwQzZJLFlBQTFDLEVBQXdEaFAsUUFBeEQsRUFBa0U7QUFDaEV2YyxFQUFBQSxLQUFLLEdBQUcsQ0FBQ0EsS0FBVDtBQUNBMGlCLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxLQUFLLENBQXBCOztBQUNBLE1BQUksQ0FBQ25HLFFBQUwsRUFBZTtBQUNiOE8sSUFBQUEsWUFBWSxDQUFDOU4sR0FBRCxFQUFNdmQsS0FBTixFQUFhMGlCLE1BQWIsRUFBcUIsQ0FBckIsRUFBd0IsdUJBQXhCLEVBQWlELENBQUMsdUJBQWxELENBQVo7QUFDRDs7QUFDRDNDLEVBQUFBLE9BQU8sQ0FBQzVPLEtBQVIsQ0FBY29NLEdBQWQsRUFBbUJ2ZCxLQUFuQixFQUEwQjBpQixNQUExQixFQUFrQzZJLFlBQWxDLEVBQWdELEVBQWhELEVBQW9ELENBQXBEO0FBQ0EsU0FBTzdJLE1BQU0sR0FBRyxDQUFoQjtBQUNEOztBQUVEL2hCLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJra0IsYUFBakIsR0FBaUMsU0FBU0EsYUFBVCxDQUF3QjNyQixLQUF4QixFQUErQjBpQixNQUEvQixFQUF1Q25HLFFBQXZDLEVBQWlEO0FBQ2hGLFNBQU9tUCxXQUFXLENBQUMsSUFBRCxFQUFPMXJCLEtBQVAsRUFBYzBpQixNQUFkLEVBQXNCLElBQXRCLEVBQTRCbkcsUUFBNUIsQ0FBbEI7QUFDRCxDQUZEOztBQUlBNWIsTUFBTSxDQUFDOEcsU0FBUCxDQUFpQm1rQixhQUFqQixHQUFpQyxTQUFTQSxhQUFULENBQXdCNXJCLEtBQXhCLEVBQStCMGlCLE1BQS9CLEVBQXVDbkcsUUFBdkMsRUFBaUQ7QUFDaEYsU0FBT21QLFdBQVcsQ0FBQyxJQUFELEVBQU8xckIsS0FBUCxFQUFjMGlCLE1BQWQsRUFBc0IsS0FBdEIsRUFBNkJuRyxRQUE3QixDQUFsQjtBQUNELENBRkQsRUFJQTs7O0FBQ0E1YixNQUFNLENBQUM4RyxTQUFQLENBQWlCNmEsSUFBakIsR0FBd0IsU0FBU0EsSUFBVCxDQUFlNVUsTUFBZixFQUF1Qm1lLFdBQXZCLEVBQW9DbFUsS0FBcEMsRUFBMkNDLEdBQTNDLEVBQWdEO0FBQ3RFLE1BQUksQ0FBQ2pYLE1BQU0sQ0FBQzhPLFFBQVAsQ0FBZ0IvQixNQUFoQixDQUFMLEVBQThCLE1BQU0sSUFBSWxGLFNBQUosQ0FBYyw2QkFBZCxDQUFOO0FBQzlCLE1BQUksQ0FBQ21QLEtBQUwsRUFBWUEsS0FBSyxHQUFHLENBQVI7QUFDWixNQUFJLENBQUNDLEdBQUQsSUFBUUEsR0FBRyxLQUFLLENBQXBCLEVBQXVCQSxHQUFHLEdBQUcsS0FBS25OLE1BQVg7QUFDdkIsTUFBSW9oQixXQUFXLElBQUluZSxNQUFNLENBQUNqRCxNQUExQixFQUFrQ29oQixXQUFXLEdBQUduZSxNQUFNLENBQUNqRCxNQUFyQjtBQUNsQyxNQUFJLENBQUNvaEIsV0FBTCxFQUFrQkEsV0FBVyxHQUFHLENBQWQ7QUFDbEIsTUFBSWpVLEdBQUcsR0FBRyxDQUFOLElBQVdBLEdBQUcsR0FBR0QsS0FBckIsRUFBNEJDLEdBQUcsR0FBR0QsS0FBTixDQU4wQyxDQVF0RTs7QUFDQSxNQUFJQyxHQUFHLEtBQUtELEtBQVosRUFBbUIsT0FBTyxDQUFQO0FBQ25CLE1BQUlqSyxNQUFNLENBQUNqRCxNQUFQLEtBQWtCLENBQWxCLElBQXVCLEtBQUtBLE1BQUwsS0FBZ0IsQ0FBM0MsRUFBOEMsT0FBTyxDQUFQLENBVndCLENBWXRFOztBQUNBLE1BQUlvaEIsV0FBVyxHQUFHLENBQWxCLEVBQXFCO0FBQ25CLFVBQU0sSUFBSTlLLFVBQUosQ0FBZSwyQkFBZixDQUFOO0FBQ0Q7O0FBQ0QsTUFBSXBKLEtBQUssR0FBRyxDQUFSLElBQWFBLEtBQUssSUFBSSxLQUFLbE4sTUFBL0IsRUFBdUMsTUFBTSxJQUFJc1csVUFBSixDQUFlLG9CQUFmLENBQU47QUFDdkMsTUFBSW5KLEdBQUcsR0FBRyxDQUFWLEVBQWEsTUFBTSxJQUFJbUosVUFBSixDQUFlLHlCQUFmLENBQU4sQ0FqQnlELENBbUJ0RTs7QUFDQSxNQUFJbkosR0FBRyxHQUFHLEtBQUtuTixNQUFmLEVBQXVCbU4sR0FBRyxHQUFHLEtBQUtuTixNQUFYOztBQUN2QixNQUFJaUQsTUFBTSxDQUFDakQsTUFBUCxHQUFnQm9oQixXQUFoQixHQUE4QmpVLEdBQUcsR0FBR0QsS0FBeEMsRUFBK0M7QUFDN0NDLElBQUFBLEdBQUcsR0FBR2xLLE1BQU0sQ0FBQ2pELE1BQVAsR0FBZ0JvaEIsV0FBaEIsR0FBOEJsVSxLQUFwQztBQUNEOztBQUVELE1BQU1iLEdBQUcsR0FBR2MsR0FBRyxHQUFHRCxLQUFsQjs7QUFFQSxNQUFJLFNBQVNqSyxNQUFULElBQW1CLE9BQU90TSxVQUFVLENBQUNxRyxTQUFYLENBQXFCcWtCLFVBQTVCLEtBQTJDLFVBQWxFLEVBQThFO0FBQzVFO0FBQ0EsU0FBS0EsVUFBTCxDQUFnQkQsV0FBaEIsRUFBNkJsVSxLQUE3QixFQUFvQ0MsR0FBcEM7QUFDRCxHQUhELE1BR087QUFDTHhXLElBQUFBLFVBQVUsQ0FBQ3FHLFNBQVgsQ0FBcUJtVixHQUFyQixDQUF5QjFRLElBQXpCLENBQ0V3QixNQURGLEVBRUUsS0FBS21aLFFBQUwsQ0FBY2xQLEtBQWQsRUFBcUJDLEdBQXJCLENBRkYsRUFHRWlVLFdBSEY7QUFLRDs7QUFFRCxTQUFPL1UsR0FBUDtBQUNELENBdkNELEVBeUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQW5XLE1BQU0sQ0FBQzhHLFNBQVAsQ0FBaUJrVixJQUFqQixHQUF3QixTQUFTQSxJQUFULENBQWV6VyxHQUFmLEVBQW9CeVIsS0FBcEIsRUFBMkJDLEdBQTNCLEVBQWdDd0IsUUFBaEMsRUFBMEM7QUFDaEU7QUFDQSxNQUFJLE9BQU9sVCxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsUUFBSSxPQUFPeVIsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3QnlCLE1BQUFBLFFBQVEsR0FBR3pCLEtBQVg7QUFDQUEsTUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDQUMsTUFBQUEsR0FBRyxHQUFHLEtBQUtuTixNQUFYO0FBQ0QsS0FKRCxNQUlPLElBQUksT0FBT21OLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUNsQ3dCLE1BQUFBLFFBQVEsR0FBR3hCLEdBQVg7QUFDQUEsTUFBQUEsR0FBRyxHQUFHLEtBQUtuTixNQUFYO0FBQ0Q7O0FBQ0QsUUFBSTJPLFFBQVEsS0FBS3RULFNBQWIsSUFBMEIsT0FBT3NULFFBQVAsS0FBb0IsUUFBbEQsRUFBNEQ7QUFDMUQsWUFBTSxJQUFJNVEsU0FBSixDQUFjLDJCQUFkLENBQU47QUFDRDs7QUFDRCxRQUFJLE9BQU80USxRQUFQLEtBQW9CLFFBQXBCLElBQWdDLENBQUN6WSxNQUFNLENBQUNzaEIsVUFBUCxDQUFrQjdJLFFBQWxCLENBQXJDLEVBQWtFO0FBQ2hFLFlBQU0sSUFBSTVRLFNBQUosQ0FBYyx1QkFBdUI0USxRQUFyQyxDQUFOO0FBQ0Q7O0FBQ0QsUUFBSWxULEdBQUcsQ0FBQ3VFLE1BQUosS0FBZSxDQUFuQixFQUFzQjtBQUNwQixVQUFNc0IsSUFBSSxHQUFHN0YsR0FBRyxDQUFDcVEsVUFBSixDQUFlLENBQWYsQ0FBYjs7QUFDQSxVQUFLNkMsUUFBUSxLQUFLLE1BQWIsSUFBdUJyTixJQUFJLEdBQUcsR0FBL0IsSUFDQXFOLFFBQVEsS0FBSyxRQURqQixFQUMyQjtBQUN6QjtBQUNBbFQsUUFBQUEsR0FBRyxHQUFHNkYsSUFBTjtBQUNEO0FBQ0Y7QUFDRixHQXZCRCxNQXVCTyxJQUFJLE9BQU83RixHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDbENBLElBQUFBLEdBQUcsR0FBR0EsR0FBRyxHQUFHLEdBQVo7QUFDRCxHQUZNLE1BRUEsSUFBSSxPQUFPQSxHQUFQLEtBQWUsU0FBbkIsRUFBOEI7QUFDbkNBLElBQUFBLEdBQUcsR0FBR2dmLE1BQU0sQ0FBQ2hmLEdBQUQsQ0FBWjtBQUNELEdBN0IrRCxDQStCaEU7OztBQUNBLE1BQUl5UixLQUFLLEdBQUcsQ0FBUixJQUFhLEtBQUtsTixNQUFMLEdBQWNrTixLQUEzQixJQUFvQyxLQUFLbE4sTUFBTCxHQUFjbU4sR0FBdEQsRUFBMkQ7QUFDekQsVUFBTSxJQUFJbUosVUFBSixDQUFlLG9CQUFmLENBQU47QUFDRDs7QUFFRCxNQUFJbkosR0FBRyxJQUFJRCxLQUFYLEVBQWtCO0FBQ2hCLFdBQU8sSUFBUDtBQUNEOztBQUVEQSxFQUFBQSxLQUFLLEdBQUdBLEtBQUssS0FBSyxDQUFsQjtBQUNBQyxFQUFBQSxHQUFHLEdBQUdBLEdBQUcsS0FBSzlSLFNBQVIsR0FBb0IsS0FBSzJFLE1BQXpCLEdBQWtDbU4sR0FBRyxLQUFLLENBQWhEO0FBRUEsTUFBSSxDQUFDMVIsR0FBTCxFQUFVQSxHQUFHLEdBQUcsQ0FBTjtBQUVWLE1BQUlxSyxDQUFKOztBQUNBLE1BQUksT0FBT3JLLEdBQVAsS0FBZSxRQUFuQixFQUE2QjtBQUMzQixTQUFLcUssQ0FBQyxHQUFHb0gsS0FBVCxFQUFnQnBILENBQUMsR0FBR3FILEdBQXBCLEVBQXlCLEVBQUVySCxDQUEzQixFQUE4QjtBQUM1QixXQUFLQSxDQUFMLElBQVVySyxHQUFWO0FBQ0Q7QUFDRixHQUpELE1BSU87QUFDTCxRQUFNOFMsS0FBSyxHQUFHclksTUFBTSxDQUFDOE8sUUFBUCxDQUFnQnZKLEdBQWhCLElBQ1ZBLEdBRFUsR0FFVnZGLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZc0YsR0FBWixFQUFpQmtULFFBQWpCLENBRko7QUFHQSxRQUFNdEMsR0FBRyxHQUFHa0MsS0FBSyxDQUFDdk8sTUFBbEI7O0FBQ0EsUUFBSXFNLEdBQUcsS0FBSyxDQUFaLEVBQWU7QUFDYixZQUFNLElBQUl0TyxTQUFKLENBQWMsZ0JBQWdCdEMsR0FBaEIsR0FDbEIsbUNBREksQ0FBTjtBQUVEOztBQUNELFNBQUtxSyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUdxSCxHQUFHLEdBQUdELEtBQXRCLEVBQTZCLEVBQUVwSCxDQUEvQixFQUFrQztBQUNoQyxXQUFLQSxDQUFDLEdBQUdvSCxLQUFULElBQWtCcUIsS0FBSyxDQUFDekksQ0FBQyxHQUFHdUcsR0FBTCxDQUF2QjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxJQUFQO0FBQ0QsQ0FqRUQsRUFtRUE7QUFDQTtBQUVBOzs7QUFDQSxJQUFNaVYsTUFBTSxHQUFHLEVBQWY7O0FBQ0EsU0FBU0MsQ0FBVCxDQUFZQyxHQUFaLEVBQWlCQyxVQUFqQixFQUE2QkMsSUFBN0IsRUFBbUM7QUFDakNKLEVBQUFBLE1BQU0sQ0FBQ0UsR0FBRCxDQUFOO0FBQUE7O0FBQUE7O0FBQ0UseUJBQWU7QUFBQTs7QUFBQTs7QUFDYjtBQUVBcHNCLE1BQUFBLE1BQU0sQ0FBQ0MsY0FBUCxnQ0FBNEIsU0FBNUIsRUFBdUM7QUFDckNFLFFBQUFBLEtBQUssRUFBRWtzQixVQUFVLENBQUMzaEIsS0FBWCxnQ0FBdUJsQixTQUF2QixDQUQ4QjtBQUVyQytpQixRQUFBQSxRQUFRLEVBQUUsSUFGMkI7QUFHckNDLFFBQUFBLFlBQVksRUFBRTtBQUh1QixPQUF2QyxFQUhhLENBU2I7O0FBQ0EsWUFBS3pmLElBQUwsYUFBZSxNQUFLQSxJQUFwQixlQUE2QnFmLEdBQTdCLE9BVmEsQ0FXYjtBQUNBOztBQUNBLFlBQUsvZSxLQUFMLENBYmEsQ0FhRjtBQUNYOztBQUNBLGFBQU8sTUFBS04sSUFBWjtBQWZhO0FBZ0JkOztBQWpCSDtBQUFBO0FBQUEsV0FtQkUsZUFBWTtBQUNWLGVBQU9xZixHQUFQO0FBQ0QsT0FyQkg7QUFBQSxXQXVCRSxhQUFVanNCLEtBQVYsRUFBaUI7QUFDZkgsUUFBQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCLElBQXRCLEVBQTRCLE1BQTVCLEVBQW9DO0FBQ2xDdXNCLFVBQUFBLFlBQVksRUFBRSxJQURvQjtBQUVsQzFMLFVBQUFBLFVBQVUsRUFBRSxJQUZzQjtBQUdsQzNnQixVQUFBQSxLQUFLLEVBQUxBLEtBSGtDO0FBSWxDb3NCLFVBQUFBLFFBQVEsRUFBRTtBQUp3QixTQUFwQztBQU1EO0FBOUJIO0FBQUE7QUFBQSxhQWdDRSxvQkFBWTtBQUNWLHlCQUFVLEtBQUt4ZixJQUFmLGVBQXdCcWYsR0FBeEIsZ0JBQWlDLEtBQUs1akIsT0FBdEM7QUFDRDtBQWxDSDs7QUFBQTtBQUFBLElBQXNDOGpCLElBQXRDO0FBb0NEOztBQUVESCxDQUFDLENBQUMsMEJBQUQsRUFDQyxVQUFVcGYsSUFBVixFQUFnQjtBQUNkLE1BQUlBLElBQUosRUFBVTtBQUNSLHFCQUFVQSxJQUFWO0FBQ0Q7O0FBRUQsU0FBTyxnREFBUDtBQUNELENBUEYsRUFPSW1VLFVBUEosQ0FBRDtBQVFBaUwsQ0FBQyxDQUFDLHNCQUFELEVBQ0MsVUFBVXBmLElBQVYsRUFBZ0JzVixNQUFoQixFQUF3QjtBQUN0Qix5QkFBZXRWLElBQWYsdUVBQThFc1YsTUFBOUU7QUFDRCxDQUhGLEVBR0kxWixTQUhKLENBQUQ7QUFJQXdqQixDQUFDLENBQUMsa0JBQUQsRUFDQyxVQUFVblcsR0FBVixFQUFleVcsS0FBZixFQUFzQnhQLEtBQXRCLEVBQTZCO0FBQzNCLE1BQUl5UCxHQUFHLDRCQUFvQjFXLEdBQXBCLHdCQUFQO0FBQ0EsTUFBSTJXLFFBQVEsR0FBRzFQLEtBQWY7O0FBQ0EsTUFBSW9JLE1BQU0sQ0FBQ3VILFNBQVAsQ0FBaUIzUCxLQUFqQixLQUEyQnBDLElBQUksQ0FBQ0UsR0FBTCxDQUFTa0MsS0FBVCxhQUFrQixDQUFsQixFQUF1QixFQUF2QixDQUEvQixFQUEwRDtBQUN4RDBQLElBQUFBLFFBQVEsR0FBR0UscUJBQXFCLENBQUM3SixNQUFNLENBQUMvRixLQUFELENBQVAsQ0FBaEM7QUFDRCxHQUZELE1BRU8sSUFBSSxPQUFPQSxLQUFQLEtBQWlCLFFBQXJCLEVBQStCO0FBQ3BDMFAsSUFBQUEsUUFBUSxHQUFHM0osTUFBTSxDQUFDL0YsS0FBRCxDQUFqQjs7QUFDQSxRQUFJQSxLQUFLLFlBQUd1TCxNQUFNLENBQUMsQ0FBRCxDQUFULEVBQWdCQSxNQUFNLENBQUMsRUFBRCxDQUF0QixDQUFMLElBQW1DdkwsS0FBSyxHQUFHLFVBQUV1TCxNQUFNLENBQUMsQ0FBRCxDQUFSLEVBQWVBLE1BQU0sQ0FBQyxFQUFELENBQXJCLENBQS9DLEVBQTJFO0FBQ3pFbUUsTUFBQUEsUUFBUSxHQUFHRSxxQkFBcUIsQ0FBQ0YsUUFBRCxDQUFoQztBQUNEOztBQUNEQSxJQUFBQSxRQUFRLElBQUksR0FBWjtBQUNEOztBQUNERCxFQUFBQSxHQUFHLDBCQUFtQkQsS0FBbkIsd0JBQXNDRSxRQUF0QyxDQUFIO0FBQ0EsU0FBT0QsR0FBUDtBQUNELENBZkYsRUFlSXhMLFVBZkosQ0FBRDs7QUFpQkEsU0FBUzJMLHFCQUFULENBQWdDeG1CLEdBQWhDLEVBQXFDO0FBQ25DLE1BQUlnVCxHQUFHLEdBQUcsRUFBVjtBQUNBLE1BQUkzSSxDQUFDLEdBQUdySyxHQUFHLENBQUN1RSxNQUFaO0FBQ0EsTUFBTWtOLEtBQUssR0FBR3pSLEdBQUcsQ0FBQyxDQUFELENBQUgsS0FBVyxHQUFYLEdBQWlCLENBQWpCLEdBQXFCLENBQW5DOztBQUNBLFNBQU9xSyxDQUFDLElBQUlvSCxLQUFLLEdBQUcsQ0FBcEIsRUFBdUJwSCxDQUFDLElBQUksQ0FBNUIsRUFBK0I7QUFDN0IySSxJQUFBQSxHQUFHLGNBQU9oVCxHQUFHLENBQUNuRixLQUFKLENBQVV3UCxDQUFDLEdBQUcsQ0FBZCxFQUFpQkEsQ0FBakIsQ0FBUCxTQUE2QjJJLEdBQTdCLENBQUg7QUFDRDs7QUFDRCxtQkFBVWhULEdBQUcsQ0FBQ25GLEtBQUosQ0FBVSxDQUFWLEVBQWF3UCxDQUFiLENBQVYsU0FBNEIySSxHQUE1QjtBQUNELEVBRUQ7QUFDQTs7O0FBRUEsU0FBU3lULFdBQVQsQ0FBc0JwUCxHQUF0QixFQUEyQm1GLE1BQTNCLEVBQW1DbE0sVUFBbkMsRUFBK0M7QUFDN0N3UixFQUFBQSxjQUFjLENBQUN0RixNQUFELEVBQVMsUUFBVCxDQUFkOztBQUNBLE1BQUluRixHQUFHLENBQUNtRixNQUFELENBQUgsS0FBZ0I1YyxTQUFoQixJQUE2QnlYLEdBQUcsQ0FBQ21GLE1BQU0sR0FBR2xNLFVBQVYsQ0FBSCxLQUE2QjFRLFNBQTlELEVBQXlFO0FBQ3ZFb2lCLElBQUFBLFdBQVcsQ0FBQ3hGLE1BQUQsRUFBU25GLEdBQUcsQ0FBQzlTLE1BQUosSUFBYytMLFVBQVUsR0FBRyxDQUEzQixDQUFULENBQVg7QUFDRDtBQUNGOztBQUVELFNBQVM4VCxVQUFULENBQXFCdHFCLEtBQXJCLEVBQTRCNGlCLEdBQTVCLEVBQWlDcUIsR0FBakMsRUFBc0MxRyxHQUF0QyxFQUEyQ21GLE1BQTNDLEVBQW1EbE0sVUFBbkQsRUFBK0Q7QUFDN0QsTUFBSXhXLEtBQUssR0FBR2lrQixHQUFSLElBQWVqa0IsS0FBSyxHQUFHNGlCLEdBQTNCLEVBQWdDO0FBQzlCLFFBQU1uRixDQUFDLEdBQUcsT0FBT21GLEdBQVAsS0FBZSxRQUFmLEdBQTBCLEdBQTFCLEdBQWdDLEVBQTFDO0FBQ0EsUUFBSTBKLEtBQUo7O0FBQ0EsUUFBSTlWLFVBQVUsR0FBRyxDQUFqQixFQUFvQjtBQUNsQixVQUFJb00sR0FBRyxLQUFLLENBQVIsSUFBYUEsR0FBRyxLQUFLeUYsTUFBTSxDQUFDLENBQUQsQ0FBL0IsRUFBb0M7QUFDbENpRSxRQUFBQSxLQUFLLGlCQUFVN08sQ0FBVixxQkFBc0JBLENBQXRCLGlCQUE4QixDQUFDakgsVUFBVSxHQUFHLENBQWQsSUFBbUIsQ0FBakQsU0FBcURpSCxDQUFyRCxDQUFMO0FBQ0QsT0FGRCxNQUVPO0FBQ0w2TyxRQUFBQSxLQUFLLEdBQUcsZ0JBQVM3TyxDQUFULGlCQUFpQixDQUFDakgsVUFBVSxHQUFHLENBQWQsSUFBbUIsQ0FBbkIsR0FBdUIsQ0FBeEMsU0FBNENpSCxDQUE1QywrQkFDRyxDQUFDakgsVUFBVSxHQUFHLENBQWQsSUFBbUIsQ0FBbkIsR0FBdUIsQ0FEMUIsU0FDOEJpSCxDQUQ5QixDQUFSO0FBRUQ7QUFDRixLQVBELE1BT087QUFDTDZPLE1BQUFBLEtBQUssZ0JBQVMxSixHQUFULFNBQWVuRixDQUFmLHFCQUEyQndHLEdBQTNCLFNBQWlDeEcsQ0FBakMsQ0FBTDtBQUNEOztBQUNELFVBQU0sSUFBSXNPLE1BQU0sQ0FBQ2EsZ0JBQVgsQ0FBNEIsT0FBNUIsRUFBcUNOLEtBQXJDLEVBQTRDdHNCLEtBQTVDLENBQU47QUFDRDs7QUFDRDJzQixFQUFBQSxXQUFXLENBQUNwUCxHQUFELEVBQU1tRixNQUFOLEVBQWNsTSxVQUFkLENBQVg7QUFDRDs7QUFFRCxTQUFTd1IsY0FBVCxDQUF5QmhvQixLQUF6QixFQUFnQzRNLElBQWhDLEVBQXNDO0FBQ3BDLE1BQUksT0FBTzVNLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0IsVUFBTSxJQUFJK3JCLE1BQU0sQ0FBQ2Msb0JBQVgsQ0FBZ0NqZ0IsSUFBaEMsRUFBc0MsUUFBdEMsRUFBZ0Q1TSxLQUFoRCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTa29CLFdBQVQsQ0FBc0Jsb0IsS0FBdEIsRUFBNkJ5SyxNQUE3QixFQUFxQ3lKLElBQXJDLEVBQTJDO0FBQ3pDLE1BQUl3RyxJQUFJLENBQUNvUyxLQUFMLENBQVc5c0IsS0FBWCxNQUFzQkEsS0FBMUIsRUFBaUM7QUFDL0Jnb0IsSUFBQUEsY0FBYyxDQUFDaG9CLEtBQUQsRUFBUWtVLElBQVIsQ0FBZDtBQUNBLFVBQU0sSUFBSTZYLE1BQU0sQ0FBQ2EsZ0JBQVgsQ0FBNEIxWSxJQUFJLElBQUksUUFBcEMsRUFBOEMsWUFBOUMsRUFBNERsVSxLQUE1RCxDQUFOO0FBQ0Q7O0FBRUQsTUFBSXlLLE1BQU0sR0FBRyxDQUFiLEVBQWdCO0FBQ2QsVUFBTSxJQUFJc2hCLE1BQU0sQ0FBQ2dCLHdCQUFYLEVBQU47QUFDRDs7QUFFRCxRQUFNLElBQUloQixNQUFNLENBQUNhLGdCQUFYLENBQTRCMVksSUFBSSxJQUFJLFFBQXBDLGVBQ2tDQSxJQUFJLEdBQUcsQ0FBSCxHQUFPLENBRDdDLHFCQUN5RHpKLE1BRHpELEdBRTRCekssS0FGNUIsQ0FBTjtBQUdELEVBRUQ7QUFDQTs7O0FBRUEsSUFBTWd0QixpQkFBaUIsR0FBRyxtQkFBMUI7O0FBRUEsU0FBU0MsV0FBVCxDQUFzQnBYLEdBQXRCLEVBQTJCO0FBQ3pCO0FBQ0FBLEVBQUFBLEdBQUcsR0FBR0EsR0FBRyxDQUFDakMsS0FBSixDQUFVLEdBQVYsRUFBZSxDQUFmLENBQU4sQ0FGeUIsQ0FHekI7O0FBQ0FpQyxFQUFBQSxHQUFHLEdBQUdBLEdBQUcsQ0FBQ3hHLElBQUosR0FBV3JFLE9BQVgsQ0FBbUJnaUIsaUJBQW5CLEVBQXNDLEVBQXRDLENBQU4sQ0FKeUIsQ0FLekI7O0FBQ0EsTUFBSW5YLEdBQUcsQ0FBQ3BMLE1BQUosR0FBYSxDQUFqQixFQUFvQixPQUFPLEVBQVAsQ0FOSyxDQU96Qjs7QUFDQSxTQUFPb0wsR0FBRyxDQUFDcEwsTUFBSixHQUFhLENBQWIsS0FBbUIsQ0FBMUIsRUFBNkI7QUFDM0JvTCxJQUFBQSxHQUFHLEdBQUdBLEdBQUcsR0FBRyxHQUFaO0FBQ0Q7O0FBQ0QsU0FBT0EsR0FBUDtBQUNEOztBQUVELFNBQVNxTixXQUFULENBQXNCbEIsTUFBdEIsRUFBOEJrTCxLQUE5QixFQUFxQztBQUNuQ0EsRUFBQUEsS0FBSyxHQUFHQSxLQUFLLElBQUlDLFFBQWpCO0FBQ0EsTUFBSW5ILFNBQUo7QUFDQSxNQUFNdmIsTUFBTSxHQUFHdVgsTUFBTSxDQUFDdlgsTUFBdEI7QUFDQSxNQUFJMmlCLGFBQWEsR0FBRyxJQUFwQjtBQUNBLE1BQU1wVSxLQUFLLEdBQUcsRUFBZDs7QUFFQSxPQUFLLElBQUl6SSxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHOUYsTUFBcEIsRUFBNEIsRUFBRThGLENBQTlCLEVBQWlDO0FBQy9CeVYsSUFBQUEsU0FBUyxHQUFHaEUsTUFBTSxDQUFDekwsVUFBUCxDQUFrQmhHLENBQWxCLENBQVosQ0FEK0IsQ0FHL0I7O0FBQ0EsUUFBSXlWLFNBQVMsR0FBRyxNQUFaLElBQXNCQSxTQUFTLEdBQUcsTUFBdEMsRUFBOEM7QUFDNUM7QUFDQSxVQUFJLENBQUNvSCxhQUFMLEVBQW9CO0FBQ2xCO0FBQ0EsWUFBSXBILFNBQVMsR0FBRyxNQUFoQixFQUF3QjtBQUN0QjtBQUNBLGNBQUksQ0FBQ2tILEtBQUssSUFBSSxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1QmxVLEtBQUssQ0FBQzVPLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCO0FBQ0QsU0FKRCxNQUlPLElBQUltRyxDQUFDLEdBQUcsQ0FBSixLQUFVOUYsTUFBZCxFQUFzQjtBQUMzQjtBQUNBLGNBQUksQ0FBQ3lpQixLQUFLLElBQUksQ0FBVixJQUFlLENBQUMsQ0FBcEIsRUFBdUJsVSxLQUFLLENBQUM1TyxJQUFOLENBQVcsSUFBWCxFQUFpQixJQUFqQixFQUF1QixJQUF2QjtBQUN2QjtBQUNELFNBVmlCLENBWWxCOzs7QUFDQWdqQixRQUFBQSxhQUFhLEdBQUdwSCxTQUFoQjtBQUVBO0FBQ0QsT0FsQjJDLENBb0I1Qzs7O0FBQ0EsVUFBSUEsU0FBUyxHQUFHLE1BQWhCLEVBQXdCO0FBQ3RCLFlBQUksQ0FBQ2tILEtBQUssSUFBSSxDQUFWLElBQWUsQ0FBQyxDQUFwQixFQUF1QmxVLEtBQUssQ0FBQzVPLElBQU4sQ0FBVyxJQUFYLEVBQWlCLElBQWpCLEVBQXVCLElBQXZCO0FBQ3ZCZ2pCLFFBQUFBLGFBQWEsR0FBR3BILFNBQWhCO0FBQ0E7QUFDRCxPQXpCMkMsQ0EyQjVDOzs7QUFDQUEsTUFBQUEsU0FBUyxHQUFHLENBQUNvSCxhQUFhLEdBQUcsTUFBaEIsSUFBMEIsRUFBMUIsR0FBK0JwSCxTQUFTLEdBQUcsTUFBNUMsSUFBc0QsT0FBbEU7QUFDRCxLQTdCRCxNQTZCTyxJQUFJb0gsYUFBSixFQUFtQjtBQUN4QjtBQUNBLFVBQUksQ0FBQ0YsS0FBSyxJQUFJLENBQVYsSUFBZSxDQUFDLENBQXBCLEVBQXVCbFUsS0FBSyxDQUFDNU8sSUFBTixDQUFXLElBQVgsRUFBaUIsSUFBakIsRUFBdUIsSUFBdkI7QUFDeEI7O0FBRURnakIsSUFBQUEsYUFBYSxHQUFHLElBQWhCLENBdEMrQixDQXdDL0I7O0FBQ0EsUUFBSXBILFNBQVMsR0FBRyxJQUFoQixFQUFzQjtBQUNwQixVQUFJLENBQUNrSCxLQUFLLElBQUksQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCbFUsTUFBQUEsS0FBSyxDQUFDNU8sSUFBTixDQUFXNGIsU0FBWDtBQUNELEtBSEQsTUFHTyxJQUFJQSxTQUFTLEdBQUcsS0FBaEIsRUFBdUI7QUFDNUIsVUFBSSxDQUFDa0gsS0FBSyxJQUFJLENBQVYsSUFBZSxDQUFuQixFQUFzQjtBQUN0QmxVLE1BQUFBLEtBQUssQ0FBQzVPLElBQU4sQ0FDRTRiLFNBQVMsSUFBSSxHQUFiLEdBQW1CLElBRHJCLEVBRUVBLFNBQVMsR0FBRyxJQUFaLEdBQW1CLElBRnJCO0FBSUQsS0FOTSxNQU1BLElBQUlBLFNBQVMsR0FBRyxPQUFoQixFQUF5QjtBQUM5QixVQUFJLENBQUNrSCxLQUFLLElBQUksQ0FBVixJQUFlLENBQW5CLEVBQXNCO0FBQ3RCbFUsTUFBQUEsS0FBSyxDQUFDNU8sSUFBTixDQUNFNGIsU0FBUyxJQUFJLEdBQWIsR0FBbUIsSUFEckIsRUFFRUEsU0FBUyxJQUFJLEdBQWIsR0FBbUIsSUFBbkIsR0FBMEIsSUFGNUIsRUFHRUEsU0FBUyxHQUFHLElBQVosR0FBbUIsSUFIckI7QUFLRCxLQVBNLE1BT0EsSUFBSUEsU0FBUyxHQUFHLFFBQWhCLEVBQTBCO0FBQy9CLFVBQUksQ0FBQ2tILEtBQUssSUFBSSxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFDdEJsVSxNQUFBQSxLQUFLLENBQUM1TyxJQUFOLENBQ0U0YixTQUFTLElBQUksSUFBYixHQUFvQixJQUR0QixFQUVFQSxTQUFTLElBQUksR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUY1QixFQUdFQSxTQUFTLElBQUksR0FBYixHQUFtQixJQUFuQixHQUEwQixJQUg1QixFQUlFQSxTQUFTLEdBQUcsSUFBWixHQUFtQixJQUpyQjtBQU1ELEtBUk0sTUFRQTtBQUNMLFlBQU0sSUFBSXZrQixLQUFKLENBQVUsb0JBQVYsQ0FBTjtBQUNEO0FBQ0Y7O0FBRUQsU0FBT3VYLEtBQVA7QUFDRDs7QUFFRCxTQUFTeU0sWUFBVCxDQUF1QjVQLEdBQXZCLEVBQTRCO0FBQzFCLE1BQU13WCxTQUFTLEdBQUcsRUFBbEI7O0FBQ0EsT0FBSyxJQUFJOWMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3NGLEdBQUcsQ0FBQ3BMLE1BQXhCLEVBQWdDLEVBQUU4RixDQUFsQyxFQUFxQztBQUNuQztBQUNBOGMsSUFBQUEsU0FBUyxDQUFDampCLElBQVYsQ0FBZXlMLEdBQUcsQ0FBQ1UsVUFBSixDQUFlaEcsQ0FBZixJQUFvQixJQUFuQztBQUNEOztBQUNELFNBQU84YyxTQUFQO0FBQ0Q7O0FBRUQsU0FBU3pILGNBQVQsQ0FBeUIvUCxHQUF6QixFQUE4QnFYLEtBQTlCLEVBQXFDO0FBQ25DLE1BQUlua0IsQ0FBSixFQUFPcWYsRUFBUCxFQUFXRCxFQUFYO0FBQ0EsTUFBTWtGLFNBQVMsR0FBRyxFQUFsQjs7QUFDQSxPQUFLLElBQUk5YyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHc0YsR0FBRyxDQUFDcEwsTUFBeEIsRUFBZ0MsRUFBRThGLENBQWxDLEVBQXFDO0FBQ25DLFFBQUksQ0FBQzJjLEtBQUssSUFBSSxDQUFWLElBQWUsQ0FBbkIsRUFBc0I7QUFFdEJua0IsSUFBQUEsQ0FBQyxHQUFHOE0sR0FBRyxDQUFDVSxVQUFKLENBQWVoRyxDQUFmLENBQUo7QUFDQTZYLElBQUFBLEVBQUUsR0FBR3JmLENBQUMsSUFBSSxDQUFWO0FBQ0FvZixJQUFBQSxFQUFFLEdBQUdwZixDQUFDLEdBQUcsR0FBVDtBQUNBc2tCLElBQUFBLFNBQVMsQ0FBQ2pqQixJQUFWLENBQWUrZCxFQUFmO0FBQ0FrRixJQUFBQSxTQUFTLENBQUNqakIsSUFBVixDQUFlZ2UsRUFBZjtBQUNEOztBQUVELFNBQU9pRixTQUFQO0FBQ0Q7O0FBRUQsU0FBU2xLLGFBQVQsQ0FBd0J0TixHQUF4QixFQUE2QjtBQUMzQixTQUFPaUssTUFBTSxDQUFDckosV0FBUCxDQUFtQndXLFdBQVcsQ0FBQ3BYLEdBQUQsQ0FBOUIsQ0FBUDtBQUNEOztBQUVELFNBQVMwUCxVQUFULENBQXFCK0gsR0FBckIsRUFBMEJDLEdBQTFCLEVBQStCN0ssTUFBL0IsRUFBdUNqWSxNQUF2QyxFQUErQztBQUM3QyxNQUFJOEYsQ0FBSjs7QUFDQSxPQUFLQSxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc5RixNQUFoQixFQUF3QixFQUFFOEYsQ0FBMUIsRUFBNkI7QUFDM0IsUUFBS0EsQ0FBQyxHQUFHbVMsTUFBSixJQUFjNkssR0FBRyxDQUFDOWlCLE1BQW5CLElBQStCOEYsQ0FBQyxJQUFJK2MsR0FBRyxDQUFDN2lCLE1BQTVDLEVBQXFEO0FBQ3JEOGlCLElBQUFBLEdBQUcsQ0FBQ2hkLENBQUMsR0FBR21TLE1BQUwsQ0FBSCxHQUFrQjRLLEdBQUcsQ0FBQy9jLENBQUQsQ0FBckI7QUFDRDs7QUFDRCxTQUFPQSxDQUFQO0FBQ0QsRUFFRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVMrUSxVQUFULENBQXFCdkwsR0FBckIsRUFBMEI3QixJQUExQixFQUFnQztBQUM5QixTQUFPNkIsR0FBRyxZQUFZN0IsSUFBZixJQUNKNkIsR0FBRyxJQUFJLElBQVAsSUFBZUEsR0FBRyxDQUFDVixXQUFKLElBQW1CLElBQWxDLElBQTBDVSxHQUFHLENBQUNWLFdBQUosQ0FBZ0J6SSxJQUFoQixJQUF3QixJQUFsRSxJQUNDbUosR0FBRyxDQUFDVixXQUFKLENBQWdCekksSUFBaEIsS0FBeUJzSCxJQUFJLENBQUN0SCxJQUZsQztBQUdEOztBQUNELFNBQVMyVixXQUFULENBQXNCeE0sR0FBdEIsRUFBMkI7QUFDekI7QUFDQSxTQUFPQSxHQUFHLEtBQUtBLEdBQWYsQ0FGeUIsQ0FFTjtBQUNwQixFQUVEO0FBQ0E7OztBQUNBLElBQU00USxtQkFBbUIsR0FBSSxZQUFZO0FBQ3ZDLE1BQU02RyxRQUFRLEdBQUcsa0JBQWpCO0FBQ0EsTUFBTUMsS0FBSyxHQUFHLElBQUluakIsS0FBSixDQUFVLEdBQVYsQ0FBZDs7QUFDQSxPQUFLLElBQUlpRyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHLEVBQXBCLEVBQXdCLEVBQUVBLENBQTFCLEVBQTZCO0FBQzNCLFFBQU1tZCxHQUFHLEdBQUduZCxDQUFDLEdBQUcsRUFBaEI7O0FBQ0EsU0FBSyxJQUFJd1UsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBRyxFQUFwQixFQUF3QixFQUFFQSxDQUExQixFQUE2QjtBQUMzQjBJLE1BQUFBLEtBQUssQ0FBQ0MsR0FBRyxHQUFHM0ksQ0FBUCxDQUFMLEdBQWlCeUksUUFBUSxDQUFDamQsQ0FBRCxDQUFSLEdBQWNpZCxRQUFRLENBQUN6SSxDQUFELENBQXZDO0FBQ0Q7QUFDRjs7QUFDRCxTQUFPMEksS0FBUDtBQUNELENBVjJCLEVBQTVCLEVBWUE7OztBQUNBLFNBQVMxRixrQkFBVCxDQUE2QnZjLEVBQTdCLEVBQWlDO0FBQy9CLFNBQU8sT0FBTzZjLE1BQVAsS0FBa0IsV0FBbEIsR0FBZ0NzRixzQkFBaEMsR0FBeURuaUIsRUFBaEU7QUFDRDs7QUFFRCxTQUFTbWlCLHNCQUFULEdBQW1DO0FBQ2pDLFFBQU0sSUFBSWxzQixLQUFKLENBQVUsc0JBQVYsQ0FBTjtBQUNEOzs7Ozs7Ozs7O0FDempFREUsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQjtBQUNmLFNBQU8sVUFEUTtBQUVmLFNBQU8scUJBRlE7QUFHZixTQUFPLFlBSFE7QUFJZixTQUFPLElBSlE7QUFLZixTQUFPLFNBTFE7QUFNZixTQUFPLFVBTlE7QUFPZixTQUFPLCtCQVBRO0FBUWYsU0FBTyxZQVJRO0FBU2YsU0FBTyxlQVRRO0FBVWYsU0FBTyxpQkFWUTtBQVdmLFNBQU8sY0FYUTtBQVlmLFNBQU8sa0JBWlE7QUFhZixTQUFPLFNBYlE7QUFjZixTQUFPLGtCQWRRO0FBZWYsU0FBTyxtQkFmUTtBQWdCZixTQUFPLE9BaEJRO0FBaUJmLFNBQU8sV0FqQlE7QUFrQmYsU0FBTyxjQWxCUTtBQW1CZixTQUFPLFdBbkJRO0FBb0JmLFNBQU8sb0JBcEJRO0FBcUJmLFNBQU8sb0JBckJRO0FBc0JmLFNBQU8sYUF0QlE7QUF1QmYsU0FBTyxjQXZCUTtBQXdCZixTQUFPLGtCQXhCUTtBQXlCZixTQUFPLFdBekJRO0FBMEJmLFNBQU8sV0ExQlE7QUEyQmYsU0FBTyxvQkEzQlE7QUE0QmYsU0FBTyxnQkE1QlE7QUE2QmYsU0FBTywrQkE3QlE7QUE4QmYsU0FBTyxpQkE5QlE7QUErQmYsU0FBTyxVQS9CUTtBQWdDZixTQUFPLE1BaENRO0FBaUNmLFNBQU8saUJBakNRO0FBa0NmLFNBQU8scUJBbENRO0FBbUNmLFNBQU8sbUJBbkNRO0FBb0NmLFNBQU8sY0FwQ1E7QUFxQ2YsU0FBTyx3QkFyQ1E7QUFzQ2YsU0FBTyx1QkF0Q1E7QUF1Q2YsU0FBTyxvQkF2Q1E7QUF3Q2YsU0FBTyxjQXhDUTtBQXlDZixTQUFPLHFCQXpDUTtBQTBDZixTQUFPLHNCQTFDUTtBQTJDZixTQUFPLFFBM0NRO0FBNENmLFNBQU8sbUJBNUNRO0FBNkNmLFNBQU8sc0JBN0NRO0FBOENmLFNBQU8sa0JBOUNRO0FBK0NmLFNBQU8sdUJBL0NRO0FBZ0RmLFNBQU8sbUJBaERRO0FBaURmLFNBQU8saUNBakRRO0FBa0RmLFNBQU8sK0JBbERRO0FBbURmLFNBQU8sdUJBbkRRO0FBb0RmLFNBQU8saUJBcERRO0FBcURmLFNBQU8sYUFyRFE7QUFzRGYsU0FBTyxxQkF0RFE7QUF1RGYsU0FBTyxpQkF2RFE7QUF3RGYsU0FBTyw0QkF4RFE7QUF5RGYsU0FBTyx5QkF6RFE7QUEwRGYsU0FBTyxzQkExRFE7QUEyRGYsU0FBTyxlQTNEUTtBQTREZixTQUFPLDBCQTVEUTtBQTZEZixTQUFPLGNBN0RRO0FBOERmLFNBQU87QUE5RFEsQ0FBakI7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRWE7Ozs7QUFFYixJQUFJNnRCLENBQUMsR0FBRyxRQUFPQyxPQUFQLHlDQUFPQSxPQUFQLE9BQW1CLFFBQW5CLEdBQThCQSxPQUE5QixHQUF3QyxJQUFoRDtBQUNBLElBQUlDLFlBQVksR0FBR0YsQ0FBQyxJQUFJLE9BQU9BLENBQUMsQ0FBQ3JqQixLQUFULEtBQW1CLFVBQXhCLEdBQ2ZxakIsQ0FBQyxDQUFDcmpCLEtBRGEsR0FFZixTQUFTdWpCLFlBQVQsQ0FBc0JwZ0IsTUFBdEIsRUFBOEJxZ0IsUUFBOUIsRUFBd0N6ZCxJQUF4QyxFQUE4QztBQUM5QyxTQUFPMGQsUUFBUSxDQUFDdm1CLFNBQVQsQ0FBbUI4QyxLQUFuQixDQUF5QjJCLElBQXpCLENBQThCd0IsTUFBOUIsRUFBc0NxZ0IsUUFBdEMsRUFBZ0R6ZCxJQUFoRCxDQUFQO0FBQ0QsQ0FKSDtBQU1BLElBQUkyZCxjQUFKOztBQUNBLElBQUlMLENBQUMsSUFBSSxPQUFPQSxDQUFDLENBQUNNLE9BQVQsS0FBcUIsVUFBOUIsRUFBMEM7QUFDeENELEVBQUFBLGNBQWMsR0FBR0wsQ0FBQyxDQUFDTSxPQUFuQjtBQUNELENBRkQsTUFFTyxJQUFJcnVCLE1BQU0sQ0FBQ3N1QixxQkFBWCxFQUFrQztBQUN2Q0YsRUFBQUEsY0FBYyxHQUFHLFNBQVNBLGNBQVQsQ0FBd0J2Z0IsTUFBeEIsRUFBZ0M7QUFDL0MsV0FBTzdOLE1BQU0sQ0FBQ3V1QixtQkFBUCxDQUEyQjFnQixNQUEzQixFQUNKbEQsTUFESSxDQUNHM0ssTUFBTSxDQUFDc3VCLHFCQUFQLENBQTZCemdCLE1BQTdCLENBREgsQ0FBUDtBQUVELEdBSEQ7QUFJRCxDQUxNLE1BS0E7QUFDTHVnQixFQUFBQSxjQUFjLEdBQUcsU0FBU0EsY0FBVCxDQUF3QnZnQixNQUF4QixFQUFnQztBQUMvQyxXQUFPN04sTUFBTSxDQUFDdXVCLG1CQUFQLENBQTJCMWdCLE1BQTNCLENBQVA7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsU0FBUzJnQixrQkFBVCxDQUE0QkMsT0FBNUIsRUFBcUM7QUFDbkMsTUFBSXRaLE9BQU8sSUFBSUEsT0FBTyxDQUFDQyxJQUF2QixFQUE2QkQsT0FBTyxDQUFDQyxJQUFSLENBQWFxWixPQUFiO0FBQzlCOztBQUVELElBQUlDLFdBQVcsR0FBR3JKLE1BQU0sQ0FBQ3NKLEtBQVAsSUFBZ0IsU0FBU0QsV0FBVCxDQUFxQnZ1QixLQUFyQixFQUE0QjtBQUM1RCxTQUFPQSxLQUFLLEtBQUtBLEtBQWpCO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTeXVCLFlBQVQsR0FBd0I7QUFDdEJBLEVBQUFBLFlBQVksQ0FBQ0MsSUFBYixDQUFrQnhpQixJQUFsQixDQUF1QixJQUF2QjtBQUNEOztBQUNEdkssTUFBTSxDQUFDNUIsT0FBUCxHQUFpQjB1QixZQUFqQjtBQUNBOXNCLG1CQUFBLEdBQXNCZ3RCLElBQXRCLEVBRUE7O0FBQ0FGLFlBQVksQ0FBQ0EsWUFBYixHQUE0QkEsWUFBNUI7QUFFQUEsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUJtbkIsT0FBdkIsR0FBaUM5b0IsU0FBakM7QUFDQTJvQixZQUFZLENBQUNobkIsU0FBYixDQUF1Qm9uQixZQUF2QixHQUFzQyxDQUF0QztBQUNBSixZQUFZLENBQUNobkIsU0FBYixDQUF1QnFuQixhQUF2QixHQUF1Q2hwQixTQUF2QyxFQUVBO0FBQ0E7O0FBQ0EsSUFBSWlwQixtQkFBbUIsR0FBRyxFQUExQjs7QUFFQSxTQUFTQyxhQUFULENBQXVCQyxRQUF2QixFQUFpQztBQUMvQixNQUFJLE9BQU9BLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEMsVUFBTSxJQUFJem1CLFNBQUosQ0FBYyw2RUFBNEV5bUIsUUFBNUUsQ0FBZCxDQUFOO0FBQ0Q7QUFDRjs7QUFFRHB2QixNQUFNLENBQUNDLGNBQVAsQ0FBc0IydUIsWUFBdEIsRUFBb0MscUJBQXBDLEVBQTJEO0FBQ3pEOU4sRUFBQUEsVUFBVSxFQUFFLElBRDZDO0FBRXpEQyxFQUFBQSxHQUFHLEVBQUUsZUFBVztBQUNkLFdBQU9tTyxtQkFBUDtBQUNELEdBSndEO0FBS3pEblMsRUFBQUEsR0FBRyxFQUFFLGFBQVNvRSxHQUFULEVBQWM7QUFDakIsUUFBSSxPQUFPQSxHQUFQLEtBQWUsUUFBZixJQUEyQkEsR0FBRyxHQUFHLENBQWpDLElBQXNDdU4sV0FBVyxDQUFDdk4sR0FBRCxDQUFyRCxFQUE0RDtBQUMxRCxZQUFNLElBQUlELFVBQUosQ0FBZSxvR0FBb0dDLEdBQXBHLEdBQTBHLEdBQXpILENBQU47QUFDRDs7QUFDRCtOLElBQUFBLG1CQUFtQixHQUFHL04sR0FBdEI7QUFDRDtBQVZ3RCxDQUEzRDs7QUFhQXlOLFlBQVksQ0FBQ0MsSUFBYixHQUFvQixZQUFXO0FBRTdCLE1BQUksS0FBS0UsT0FBTCxLQUFpQjlvQixTQUFqQixJQUNBLEtBQUs4b0IsT0FBTCxLQUFpQi91QixNQUFNLENBQUM0VixjQUFQLENBQXNCLElBQXRCLEVBQTRCbVosT0FEakQsRUFDMEQ7QUFDeEQsU0FBS0EsT0FBTCxHQUFlL3VCLE1BQU0sQ0FBQytILE1BQVAsQ0FBYyxJQUFkLENBQWY7QUFDQSxTQUFLaW5CLFlBQUwsR0FBb0IsQ0FBcEI7QUFDRDs7QUFFRCxPQUFLQyxhQUFMLEdBQXFCLEtBQUtBLGFBQUwsSUFBc0JocEIsU0FBM0M7QUFDRCxDQVRELEVBV0E7QUFDQTs7O0FBQ0Eyb0IsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUJ5bkIsZUFBdkIsR0FBeUMsU0FBU0EsZUFBVCxDQUF5QnpSLENBQXpCLEVBQTRCO0FBQ25FLE1BQUksT0FBT0EsQ0FBUCxLQUFhLFFBQWIsSUFBeUJBLENBQUMsR0FBRyxDQUE3QixJQUFrQzhRLFdBQVcsQ0FBQzlRLENBQUQsQ0FBakQsRUFBc0Q7QUFDcEQsVUFBTSxJQUFJc0QsVUFBSixDQUFlLGtGQUFrRnRELENBQWxGLEdBQXNGLEdBQXJHLENBQU47QUFDRDs7QUFDRCxPQUFLcVIsYUFBTCxHQUFxQnJSLENBQXJCO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FORDs7QUFRQSxTQUFTMFIsZ0JBQVQsQ0FBMEJDLElBQTFCLEVBQWdDO0FBQzlCLE1BQUlBLElBQUksQ0FBQ04sYUFBTCxLQUF1QmhwQixTQUEzQixFQUNFLE9BQU8yb0IsWUFBWSxDQUFDTSxtQkFBcEI7QUFDRixTQUFPSyxJQUFJLENBQUNOLGFBQVo7QUFDRDs7QUFFREwsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUI0bkIsZUFBdkIsR0FBeUMsU0FBU0EsZUFBVCxHQUEyQjtBQUNsRSxTQUFPRixnQkFBZ0IsQ0FBQyxJQUFELENBQXZCO0FBQ0QsQ0FGRDs7QUFJQVYsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUI2bkIsSUFBdkIsR0FBOEIsU0FBU0EsSUFBVCxDQUFjcGIsSUFBZCxFQUFvQjtBQUNoRCxNQUFJNUQsSUFBSSxHQUFHLEVBQVg7O0FBQ0EsT0FBSyxJQUFJQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbEgsU0FBUyxDQUFDb0IsTUFBOUIsRUFBc0M4RixDQUFDLEVBQXZDO0FBQTJDRCxJQUFBQSxJQUFJLENBQUNsRyxJQUFMLENBQVVmLFNBQVMsQ0FBQ2tILENBQUQsQ0FBbkI7QUFBM0M7O0FBQ0EsTUFBSWdmLE9BQU8sR0FBSXJiLElBQUksS0FBSyxPQUF4QjtBQUVBLE1BQUlzYixNQUFNLEdBQUcsS0FBS1osT0FBbEI7QUFDQSxNQUFJWSxNQUFNLEtBQUsxcEIsU0FBZixFQUNFeXBCLE9BQU8sR0FBSUEsT0FBTyxJQUFJQyxNQUFNLENBQUMxa0IsS0FBUCxLQUFpQmhGLFNBQXZDLENBREYsS0FFSyxJQUFJLENBQUN5cEIsT0FBTCxFQUNILE9BQU8sS0FBUCxDQVQ4QyxDQVdoRDs7QUFDQSxNQUFJQSxPQUFKLEVBQWE7QUFDWCxRQUFJRSxFQUFKO0FBQ0EsUUFBSW5mLElBQUksQ0FBQzdGLE1BQUwsR0FBYyxDQUFsQixFQUNFZ2xCLEVBQUUsR0FBR25mLElBQUksQ0FBQyxDQUFELENBQVQ7O0FBQ0YsUUFBSW1mLEVBQUUsWUFBWWh1QixLQUFsQixFQUF5QjtBQUN2QjtBQUNBO0FBQ0EsWUFBTWd1QixFQUFOLENBSHVCLENBR2I7QUFDWCxLQVJVLENBU1g7OztBQUNBLFFBQUl2VSxHQUFHLEdBQUcsSUFBSXpaLEtBQUosQ0FBVSxzQkFBc0JndUIsRUFBRSxHQUFHLE9BQU9BLEVBQUUsQ0FBQ3BuQixPQUFWLEdBQW9CLEdBQXZCLEdBQTZCLEVBQXJELENBQVYsQ0FBVjtBQUNBNlMsSUFBQUEsR0FBRyxDQUFDM1QsT0FBSixHQUFja29CLEVBQWQ7QUFDQSxVQUFNdlUsR0FBTixDQVpXLENBWUE7QUFDWjs7QUFFRCxNQUFJd1UsT0FBTyxHQUFHRixNQUFNLENBQUN0YixJQUFELENBQXBCO0FBRUEsTUFBSXdiLE9BQU8sS0FBSzVwQixTQUFoQixFQUNFLE9BQU8sS0FBUDs7QUFFRixNQUFJLE9BQU80cEIsT0FBUCxLQUFtQixVQUF2QixFQUFtQztBQUNqQzVCLElBQUFBLFlBQVksQ0FBQzRCLE9BQUQsRUFBVSxJQUFWLEVBQWdCcGYsSUFBaEIsQ0FBWjtBQUNELEdBRkQsTUFFTztBQUNMLFFBQUl3RyxHQUFHLEdBQUc0WSxPQUFPLENBQUNqbEIsTUFBbEI7QUFDQSxRQUFJa2xCLFNBQVMsR0FBR0MsVUFBVSxDQUFDRixPQUFELEVBQVU1WSxHQUFWLENBQTFCOztBQUNBLFNBQUssSUFBSXZHLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RyxHQUFwQixFQUF5QixFQUFFdkcsQ0FBM0I7QUFDRXVkLE1BQUFBLFlBQVksQ0FBQzZCLFNBQVMsQ0FBQ3BmLENBQUQsQ0FBVixFQUFlLElBQWYsRUFBcUJELElBQXJCLENBQVo7QUFERjtBQUVEOztBQUVELFNBQU8sSUFBUDtBQUNELENBMUNEOztBQTRDQSxTQUFTdWYsWUFBVCxDQUFzQm5pQixNQUF0QixFQUE4QndHLElBQTlCLEVBQW9DK2EsUUFBcEMsRUFBOENhLE9BQTlDLEVBQXVEO0FBQ3JELE1BQUl2UixDQUFKO0FBQ0EsTUFBSWlSLE1BQUo7QUFDQSxNQUFJTyxRQUFKO0FBRUFmLEVBQUFBLGFBQWEsQ0FBQ0MsUUFBRCxDQUFiO0FBRUFPLEVBQUFBLE1BQU0sR0FBRzloQixNQUFNLENBQUNraEIsT0FBaEI7O0FBQ0EsTUFBSVksTUFBTSxLQUFLMXBCLFNBQWYsRUFBMEI7QUFDeEIwcEIsSUFBQUEsTUFBTSxHQUFHOWhCLE1BQU0sQ0FBQ2toQixPQUFQLEdBQWlCL3VCLE1BQU0sQ0FBQytILE1BQVAsQ0FBYyxJQUFkLENBQTFCO0FBQ0E4RixJQUFBQSxNQUFNLENBQUNtaEIsWUFBUCxHQUFzQixDQUF0QjtBQUNELEdBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQSxRQUFJVyxNQUFNLENBQUNRLFdBQVAsS0FBdUJscUIsU0FBM0IsRUFBc0M7QUFDcEM0SCxNQUFBQSxNQUFNLENBQUM0aEIsSUFBUCxDQUFZLGFBQVosRUFBMkJwYixJQUEzQixFQUNZK2EsUUFBUSxDQUFDQSxRQUFULEdBQW9CQSxRQUFRLENBQUNBLFFBQTdCLEdBQXdDQSxRQURwRCxFQURvQyxDQUlwQztBQUNBOztBQUNBTyxNQUFBQSxNQUFNLEdBQUc5aEIsTUFBTSxDQUFDa2hCLE9BQWhCO0FBQ0Q7O0FBQ0RtQixJQUFBQSxRQUFRLEdBQUdQLE1BQU0sQ0FBQ3RiLElBQUQsQ0FBakI7QUFDRDs7QUFFRCxNQUFJNmIsUUFBUSxLQUFLanFCLFNBQWpCLEVBQTRCO0FBQzFCO0FBQ0FpcUIsSUFBQUEsUUFBUSxHQUFHUCxNQUFNLENBQUN0YixJQUFELENBQU4sR0FBZSthLFFBQTFCO0FBQ0EsTUFBRXZoQixNQUFNLENBQUNtaEIsWUFBVDtBQUNELEdBSkQsTUFJTztBQUNMLFFBQUksT0FBT2tCLFFBQVAsS0FBb0IsVUFBeEIsRUFBb0M7QUFDbEM7QUFDQUEsTUFBQUEsUUFBUSxHQUFHUCxNQUFNLENBQUN0YixJQUFELENBQU4sR0FDVDRiLE9BQU8sR0FBRyxDQUFDYixRQUFELEVBQVdjLFFBQVgsQ0FBSCxHQUEwQixDQUFDQSxRQUFELEVBQVdkLFFBQVgsQ0FEbkMsQ0FGa0MsQ0FJbEM7QUFDRCxLQUxELE1BS08sSUFBSWEsT0FBSixFQUFhO0FBQ2xCQyxNQUFBQSxRQUFRLENBQUNobUIsT0FBVCxDQUFpQmtsQixRQUFqQjtBQUNELEtBRk0sTUFFQTtBQUNMYyxNQUFBQSxRQUFRLENBQUMzbEIsSUFBVCxDQUFjNmtCLFFBQWQ7QUFDRCxLQVZJLENBWUw7OztBQUNBMVEsSUFBQUEsQ0FBQyxHQUFHNFEsZ0JBQWdCLENBQUN6aEIsTUFBRCxDQUFwQjs7QUFDQSxRQUFJNlEsQ0FBQyxHQUFHLENBQUosSUFBU3dSLFFBQVEsQ0FBQ3RsQixNQUFULEdBQWtCOFQsQ0FBM0IsSUFBZ0MsQ0FBQ3dSLFFBQVEsQ0FBQ0UsTUFBOUMsRUFBc0Q7QUFDcERGLE1BQUFBLFFBQVEsQ0FBQ0UsTUFBVCxHQUFrQixJQUFsQixDQURvRCxDQUVwRDtBQUNBOztBQUNBLFVBQUk3VSxDQUFDLEdBQUcsSUFBSTNaLEtBQUosQ0FBVSxpREFDRXN1QixRQUFRLENBQUN0bEIsTUFEWCxHQUNvQixHQURwQixHQUMwQm9ZLE1BQU0sQ0FBQzNPLElBQUQsQ0FEaEMsR0FDeUMsYUFEekMsR0FFRSwwQ0FGRixHQUdFLGdCQUhaLENBQVI7QUFJQWtILE1BQUFBLENBQUMsQ0FBQ3hPLElBQUYsR0FBUyw2QkFBVDtBQUNBd08sTUFBQUEsQ0FBQyxDQUFDOFUsT0FBRixHQUFZeGlCLE1BQVo7QUFDQTBOLE1BQUFBLENBQUMsQ0FBQ2xILElBQUYsR0FBU0EsSUFBVDtBQUNBa0gsTUFBQUEsQ0FBQyxDQUFDK1UsS0FBRixHQUFVSixRQUFRLENBQUN0bEIsTUFBbkI7QUFDQTRqQixNQUFBQSxrQkFBa0IsQ0FBQ2pULENBQUQsQ0FBbEI7QUFDRDtBQUNGOztBQUVELFNBQU8xTixNQUFQO0FBQ0Q7O0FBRUQrZ0IsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUIyb0IsV0FBdkIsR0FBcUMsU0FBU0EsV0FBVCxDQUFxQmxjLElBQXJCLEVBQTJCK2EsUUFBM0IsRUFBcUM7QUFDeEUsU0FBT1ksWUFBWSxDQUFDLElBQUQsRUFBTzNiLElBQVAsRUFBYSthLFFBQWIsRUFBdUIsS0FBdkIsQ0FBbkI7QUFDRCxDQUZEOztBQUlBUixZQUFZLENBQUNobkIsU0FBYixDQUF1QjRvQixFQUF2QixHQUE0QjVCLFlBQVksQ0FBQ2huQixTQUFiLENBQXVCMm9CLFdBQW5EOztBQUVBM0IsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUI2b0IsZUFBdkIsR0FDSSxTQUFTQSxlQUFULENBQXlCcGMsSUFBekIsRUFBK0IrYSxRQUEvQixFQUF5QztBQUN2QyxTQUFPWSxZQUFZLENBQUMsSUFBRCxFQUFPM2IsSUFBUCxFQUFhK2EsUUFBYixFQUF1QixJQUF2QixDQUFuQjtBQUNELENBSEw7O0FBS0EsU0FBU3NCLFdBQVQsR0FBdUI7QUFDckIsTUFBSSxDQUFDLEtBQUtDLEtBQVYsRUFBaUI7QUFDZixTQUFLOWlCLE1BQUwsQ0FBWStpQixjQUFaLENBQTJCLEtBQUt2YyxJQUFoQyxFQUFzQyxLQUFLd2MsTUFBM0M7QUFDQSxTQUFLRixLQUFMLEdBQWEsSUFBYjtBQUNBLFFBQUlubkIsU0FBUyxDQUFDb0IsTUFBVixLQUFxQixDQUF6QixFQUNFLE9BQU8sS0FBS3drQixRQUFMLENBQWMvaUIsSUFBZCxDQUFtQixLQUFLd0IsTUFBeEIsQ0FBUDtBQUNGLFdBQU8sS0FBS3VoQixRQUFMLENBQWMxa0IsS0FBZCxDQUFvQixLQUFLbUQsTUFBekIsRUFBaUNyRSxTQUFqQyxDQUFQO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTc25CLFNBQVQsQ0FBbUJqakIsTUFBbkIsRUFBMkJ3RyxJQUEzQixFQUFpQythLFFBQWpDLEVBQTJDO0FBQ3pDLE1BQUkyQixLQUFLLEdBQUc7QUFBRUosSUFBQUEsS0FBSyxFQUFFLEtBQVQ7QUFBZ0JFLElBQUFBLE1BQU0sRUFBRTVxQixTQUF4QjtBQUFtQzRILElBQUFBLE1BQU0sRUFBRUEsTUFBM0M7QUFBbUR3RyxJQUFBQSxJQUFJLEVBQUVBLElBQXpEO0FBQStEK2EsSUFBQUEsUUFBUSxFQUFFQTtBQUF6RSxHQUFaO0FBQ0EsTUFBSTRCLE9BQU8sR0FBR04sV0FBVyxDQUFDdHBCLElBQVosQ0FBaUIycEIsS0FBakIsQ0FBZDtBQUNBQyxFQUFBQSxPQUFPLENBQUM1QixRQUFSLEdBQW1CQSxRQUFuQjtBQUNBMkIsRUFBQUEsS0FBSyxDQUFDRixNQUFOLEdBQWVHLE9BQWY7QUFDQSxTQUFPQSxPQUFQO0FBQ0Q7O0FBRURwQyxZQUFZLENBQUNobkIsU0FBYixDQUF1QmtuQixJQUF2QixHQUE4QixTQUFTQSxJQUFULENBQWN6YSxJQUFkLEVBQW9CK2EsUUFBcEIsRUFBOEI7QUFDMURELEVBQUFBLGFBQWEsQ0FBQ0MsUUFBRCxDQUFiO0FBQ0EsT0FBS29CLEVBQUwsQ0FBUW5jLElBQVIsRUFBY3ljLFNBQVMsQ0FBQyxJQUFELEVBQU96YyxJQUFQLEVBQWErYSxRQUFiLENBQXZCO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FKRDs7QUFNQVIsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUJxcEIsbUJBQXZCLEdBQ0ksU0FBU0EsbUJBQVQsQ0FBNkI1YyxJQUE3QixFQUFtQythLFFBQW5DLEVBQTZDO0FBQzNDRCxFQUFBQSxhQUFhLENBQUNDLFFBQUQsQ0FBYjtBQUNBLE9BQUtxQixlQUFMLENBQXFCcGMsSUFBckIsRUFBMkJ5YyxTQUFTLENBQUMsSUFBRCxFQUFPemMsSUFBUCxFQUFhK2EsUUFBYixDQUFwQztBQUNBLFNBQU8sSUFBUDtBQUNELENBTEwsRUFPQTs7O0FBQ0FSLFlBQVksQ0FBQ2huQixTQUFiLENBQXVCZ3BCLGNBQXZCLEdBQ0ksU0FBU0EsY0FBVCxDQUF3QnZjLElBQXhCLEVBQThCK2EsUUFBOUIsRUFBd0M7QUFDdEMsTUFBSW5NLElBQUosRUFBVTBNLE1BQVYsRUFBa0J1QixRQUFsQixFQUE0QnhnQixDQUE1QixFQUErQnlnQixnQkFBL0I7QUFFQWhDLEVBQUFBLGFBQWEsQ0FBQ0MsUUFBRCxDQUFiO0FBRUFPLEVBQUFBLE1BQU0sR0FBRyxLQUFLWixPQUFkO0FBQ0EsTUFBSVksTUFBTSxLQUFLMXBCLFNBQWYsRUFDRSxPQUFPLElBQVA7QUFFRmdkLEVBQUFBLElBQUksR0FBRzBNLE1BQU0sQ0FBQ3RiLElBQUQsQ0FBYjtBQUNBLE1BQUk0TyxJQUFJLEtBQUtoZCxTQUFiLEVBQ0UsT0FBTyxJQUFQOztBQUVGLE1BQUlnZCxJQUFJLEtBQUttTSxRQUFULElBQXFCbk0sSUFBSSxDQUFDbU0sUUFBTCxLQUFrQkEsUUFBM0MsRUFBcUQ7QUFDbkQsUUFBSSxFQUFFLEtBQUtKLFlBQVAsS0FBd0IsQ0FBNUIsRUFDRSxLQUFLRCxPQUFMLEdBQWUvdUIsTUFBTSxDQUFDK0gsTUFBUCxDQUFjLElBQWQsQ0FBZixDQURGLEtBRUs7QUFDSCxhQUFPNG5CLE1BQU0sQ0FBQ3RiLElBQUQsQ0FBYjtBQUNBLFVBQUlzYixNQUFNLENBQUNpQixjQUFYLEVBQ0UsS0FBS25CLElBQUwsQ0FBVSxnQkFBVixFQUE0QnBiLElBQTVCLEVBQWtDNE8sSUFBSSxDQUFDbU0sUUFBTCxJQUFpQkEsUUFBbkQ7QUFDSDtBQUNGLEdBUkQsTUFRTyxJQUFJLE9BQU9uTSxJQUFQLEtBQWdCLFVBQXBCLEVBQWdDO0FBQ3JDaU8sSUFBQUEsUUFBUSxHQUFHLENBQUMsQ0FBWjs7QUFFQSxTQUFLeGdCLENBQUMsR0FBR3VTLElBQUksQ0FBQ3JZLE1BQUwsR0FBYyxDQUF2QixFQUEwQjhGLENBQUMsSUFBSSxDQUEvQixFQUFrQ0EsQ0FBQyxFQUFuQyxFQUF1QztBQUNyQyxVQUFJdVMsSUFBSSxDQUFDdlMsQ0FBRCxDQUFKLEtBQVkwZSxRQUFaLElBQXdCbk0sSUFBSSxDQUFDdlMsQ0FBRCxDQUFKLENBQVEwZSxRQUFSLEtBQXFCQSxRQUFqRCxFQUEyRDtBQUN6RCtCLFFBQUFBLGdCQUFnQixHQUFHbE8sSUFBSSxDQUFDdlMsQ0FBRCxDQUFKLENBQVEwZSxRQUEzQjtBQUNBOEIsUUFBQUEsUUFBUSxHQUFHeGdCLENBQVg7QUFDQTtBQUNEO0FBQ0Y7O0FBRUQsUUFBSXdnQixRQUFRLEdBQUcsQ0FBZixFQUNFLE9BQU8sSUFBUDtBQUVGLFFBQUlBLFFBQVEsS0FBSyxDQUFqQixFQUNFak8sSUFBSSxDQUFDcFksS0FBTCxHQURGLEtBRUs7QUFDSHVtQixNQUFBQSxTQUFTLENBQUNuTyxJQUFELEVBQU9pTyxRQUFQLENBQVQ7QUFDRDtBQUVELFFBQUlqTyxJQUFJLENBQUNyWSxNQUFMLEtBQWdCLENBQXBCLEVBQ0Ura0IsTUFBTSxDQUFDdGIsSUFBRCxDQUFOLEdBQWU0TyxJQUFJLENBQUMsQ0FBRCxDQUFuQjtBQUVGLFFBQUkwTSxNQUFNLENBQUNpQixjQUFQLEtBQTBCM3FCLFNBQTlCLEVBQ0UsS0FBS3dwQixJQUFMLENBQVUsZ0JBQVYsRUFBNEJwYixJQUE1QixFQUFrQzhjLGdCQUFnQixJQUFJL0IsUUFBdEQ7QUFDSDs7QUFFRCxTQUFPLElBQVA7QUFDRCxDQWxETDs7QUFvREFSLFlBQVksQ0FBQ2huQixTQUFiLENBQXVCeXBCLEdBQXZCLEdBQTZCekMsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUJncEIsY0FBcEQ7O0FBRUFoQyxZQUFZLENBQUNobkIsU0FBYixDQUF1QjBwQixrQkFBdkIsR0FDSSxTQUFTQSxrQkFBVCxDQUE0QmpkLElBQTVCLEVBQWtDO0FBQ2hDLE1BQUl5YixTQUFKLEVBQWVILE1BQWYsRUFBdUJqZixDQUF2QjtBQUVBaWYsRUFBQUEsTUFBTSxHQUFHLEtBQUtaLE9BQWQ7QUFDQSxNQUFJWSxNQUFNLEtBQUsxcEIsU0FBZixFQUNFLE9BQU8sSUFBUCxDQUw4QixDQU9oQzs7QUFDQSxNQUFJMHBCLE1BQU0sQ0FBQ2lCLGNBQVAsS0FBMEIzcUIsU0FBOUIsRUFBeUM7QUFDdkMsUUFBSXVELFNBQVMsQ0FBQ29CLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsV0FBS21rQixPQUFMLEdBQWUvdUIsTUFBTSxDQUFDK0gsTUFBUCxDQUFjLElBQWQsQ0FBZjtBQUNBLFdBQUtpbkIsWUFBTCxHQUFvQixDQUFwQjtBQUNELEtBSEQsTUFHTyxJQUFJVyxNQUFNLENBQUN0YixJQUFELENBQU4sS0FBaUJwTyxTQUFyQixFQUFnQztBQUNyQyxVQUFJLEVBQUUsS0FBSytvQixZQUFQLEtBQXdCLENBQTVCLEVBQ0UsS0FBS0QsT0FBTCxHQUFlL3VCLE1BQU0sQ0FBQytILE1BQVAsQ0FBYyxJQUFkLENBQWYsQ0FERixLQUdFLE9BQU80bkIsTUFBTSxDQUFDdGIsSUFBRCxDQUFiO0FBQ0g7O0FBQ0QsV0FBTyxJQUFQO0FBQ0QsR0FuQitCLENBcUJoQzs7O0FBQ0EsTUFBSTdLLFNBQVMsQ0FBQ29CLE1BQVYsS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUIsUUFBSTBELElBQUksR0FBR3RPLE1BQU0sQ0FBQ3NPLElBQVAsQ0FBWXFoQixNQUFaLENBQVg7QUFDQSxRQUFJcnBCLEdBQUo7O0FBQ0EsU0FBS29LLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBR3BDLElBQUksQ0FBQzFELE1BQXJCLEVBQTZCLEVBQUU4RixDQUEvQixFQUFrQztBQUNoQ3BLLE1BQUFBLEdBQUcsR0FBR2dJLElBQUksQ0FBQ29DLENBQUQsQ0FBVjtBQUNBLFVBQUlwSyxHQUFHLEtBQUssZ0JBQVosRUFBOEI7QUFDOUIsV0FBS2dyQixrQkFBTCxDQUF3QmhyQixHQUF4QjtBQUNEOztBQUNELFNBQUtnckIsa0JBQUwsQ0FBd0IsZ0JBQXhCO0FBQ0EsU0FBS3ZDLE9BQUwsR0FBZS91QixNQUFNLENBQUMrSCxNQUFQLENBQWMsSUFBZCxDQUFmO0FBQ0EsU0FBS2luQixZQUFMLEdBQW9CLENBQXBCO0FBQ0EsV0FBTyxJQUFQO0FBQ0Q7O0FBRURjLEVBQUFBLFNBQVMsR0FBR0gsTUFBTSxDQUFDdGIsSUFBRCxDQUFsQjs7QUFFQSxNQUFJLE9BQU95YixTQUFQLEtBQXFCLFVBQXpCLEVBQXFDO0FBQ25DLFNBQUtjLGNBQUwsQ0FBb0J2YyxJQUFwQixFQUEwQnliLFNBQTFCO0FBQ0QsR0FGRCxNQUVPLElBQUlBLFNBQVMsS0FBSzdwQixTQUFsQixFQUE2QjtBQUNsQztBQUNBLFNBQUt5SyxDQUFDLEdBQUdvZixTQUFTLENBQUNsbEIsTUFBVixHQUFtQixDQUE1QixFQUErQjhGLENBQUMsSUFBSSxDQUFwQyxFQUF1Q0EsQ0FBQyxFQUF4QyxFQUE0QztBQUMxQyxXQUFLa2dCLGNBQUwsQ0FBb0J2YyxJQUFwQixFQUEwQnliLFNBQVMsQ0FBQ3BmLENBQUQsQ0FBbkM7QUFDRDtBQUNGOztBQUVELFNBQU8sSUFBUDtBQUNELENBakRMOztBQW1EQSxTQUFTNmdCLFVBQVQsQ0FBb0IxakIsTUFBcEIsRUFBNEJ3RyxJQUE1QixFQUFrQ21kLE1BQWxDLEVBQTBDO0FBQ3hDLE1BQUk3QixNQUFNLEdBQUc5aEIsTUFBTSxDQUFDa2hCLE9BQXBCO0FBRUEsTUFBSVksTUFBTSxLQUFLMXBCLFNBQWYsRUFDRSxPQUFPLEVBQVA7QUFFRixNQUFJd3JCLFVBQVUsR0FBRzlCLE1BQU0sQ0FBQ3RiLElBQUQsQ0FBdkI7QUFDQSxNQUFJb2QsVUFBVSxLQUFLeHJCLFNBQW5CLEVBQ0UsT0FBTyxFQUFQO0FBRUYsTUFBSSxPQUFPd3JCLFVBQVAsS0FBc0IsVUFBMUIsRUFDRSxPQUFPRCxNQUFNLEdBQUcsQ0FBQ0MsVUFBVSxDQUFDckMsUUFBWCxJQUF1QnFDLFVBQXhCLENBQUgsR0FBeUMsQ0FBQ0EsVUFBRCxDQUF0RDtBQUVGLFNBQU9ELE1BQU0sR0FDWEUsZUFBZSxDQUFDRCxVQUFELENBREosR0FDbUIxQixVQUFVLENBQUMwQixVQUFELEVBQWFBLFVBQVUsQ0FBQzdtQixNQUF4QixDQUQxQztBQUVEOztBQUVEZ2tCLFlBQVksQ0FBQ2huQixTQUFiLENBQXVCa29CLFNBQXZCLEdBQW1DLFNBQVNBLFNBQVQsQ0FBbUJ6YixJQUFuQixFQUF5QjtBQUMxRCxTQUFPa2QsVUFBVSxDQUFDLElBQUQsRUFBT2xkLElBQVAsRUFBYSxJQUFiLENBQWpCO0FBQ0QsQ0FGRDs7QUFJQXVhLFlBQVksQ0FBQ2huQixTQUFiLENBQXVCK3BCLFlBQXZCLEdBQXNDLFNBQVNBLFlBQVQsQ0FBc0J0ZCxJQUF0QixFQUE0QjtBQUNoRSxTQUFPa2QsVUFBVSxDQUFDLElBQUQsRUFBT2xkLElBQVAsRUFBYSxLQUFiLENBQWpCO0FBQ0QsQ0FGRDs7QUFJQXVhLFlBQVksQ0FBQ2dELGFBQWIsR0FBNkIsVUFBU3ZCLE9BQVQsRUFBa0JoYyxJQUFsQixFQUF3QjtBQUNuRCxNQUFJLE9BQU9nYyxPQUFPLENBQUN1QixhQUFmLEtBQWlDLFVBQXJDLEVBQWlEO0FBQy9DLFdBQU92QixPQUFPLENBQUN1QixhQUFSLENBQXNCdmQsSUFBdEIsQ0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU91ZCxhQUFhLENBQUN2bEIsSUFBZCxDQUFtQmdrQixPQUFuQixFQUE0QmhjLElBQTVCLENBQVA7QUFDRDtBQUNGLENBTkQ7O0FBUUF1YSxZQUFZLENBQUNobkIsU0FBYixDQUF1QmdxQixhQUF2QixHQUF1Q0EsYUFBdkM7O0FBQ0EsU0FBU0EsYUFBVCxDQUF1QnZkLElBQXZCLEVBQTZCO0FBQzNCLE1BQUlzYixNQUFNLEdBQUcsS0FBS1osT0FBbEI7O0FBRUEsTUFBSVksTUFBTSxLQUFLMXBCLFNBQWYsRUFBMEI7QUFDeEIsUUFBSXdyQixVQUFVLEdBQUc5QixNQUFNLENBQUN0YixJQUFELENBQXZCOztBQUVBLFFBQUksT0FBT29kLFVBQVAsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEMsYUFBTyxDQUFQO0FBQ0QsS0FGRCxNQUVPLElBQUlBLFVBQVUsS0FBS3hyQixTQUFuQixFQUE4QjtBQUNuQyxhQUFPd3JCLFVBQVUsQ0FBQzdtQixNQUFsQjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTyxDQUFQO0FBQ0Q7O0FBRURna0IsWUFBWSxDQUFDaG5CLFNBQWIsQ0FBdUJpcUIsVUFBdkIsR0FBb0MsU0FBU0EsVUFBVCxHQUFzQjtBQUN4RCxTQUFPLEtBQUs3QyxZQUFMLEdBQW9CLENBQXBCLEdBQXdCWixjQUFjLENBQUMsS0FBS1csT0FBTixDQUF0QyxHQUF1RCxFQUE5RDtBQUNELENBRkQ7O0FBSUEsU0FBU2dCLFVBQVQsQ0FBb0I1YixHQUFwQixFQUF5QnlKLENBQXpCLEVBQTRCO0FBQzFCLE1BQUk2RSxJQUFJLEdBQUcsSUFBSWhZLEtBQUosQ0FBVW1ULENBQVYsQ0FBWDs7QUFDQSxPQUFLLElBQUlsTixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHa04sQ0FBcEIsRUFBdUIsRUFBRWxOLENBQXpCO0FBQ0UrUixJQUFBQSxJQUFJLENBQUMvUixDQUFELENBQUosR0FBVXlELEdBQUcsQ0FBQ3pELENBQUQsQ0FBYjtBQURGOztBQUVBLFNBQU8rUixJQUFQO0FBQ0Q7O0FBRUQsU0FBUzJPLFNBQVQsQ0FBbUJuTyxJQUFuQixFQUF5QjZPLEtBQXpCLEVBQWdDO0FBQzlCLFNBQU9BLEtBQUssR0FBRyxDQUFSLEdBQVk3TyxJQUFJLENBQUNyWSxNQUF4QixFQUFnQ2tuQixLQUFLLEVBQXJDO0FBQ0U3TyxJQUFBQSxJQUFJLENBQUM2TyxLQUFELENBQUosR0FBYzdPLElBQUksQ0FBQzZPLEtBQUssR0FBRyxDQUFULENBQWxCO0FBREY7O0FBRUE3TyxFQUFBQSxJQUFJLENBQUNwRyxHQUFMO0FBQ0Q7O0FBRUQsU0FBUzZVLGVBQVQsQ0FBeUJ2ZCxHQUF6QixFQUE4QjtBQUM1QixNQUFJMFMsR0FBRyxHQUFHLElBQUlwYyxLQUFKLENBQVUwSixHQUFHLENBQUN2SixNQUFkLENBQVY7O0FBQ0EsT0FBSyxJQUFJOEYsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR21XLEdBQUcsQ0FBQ2pjLE1BQXhCLEVBQWdDLEVBQUU4RixDQUFsQyxFQUFxQztBQUNuQ21XLElBQUFBLEdBQUcsQ0FBQ25XLENBQUQsQ0FBSCxHQUFTeUQsR0FBRyxDQUFDekQsQ0FBRCxDQUFILENBQU8wZSxRQUFQLElBQW1CamIsR0FBRyxDQUFDekQsQ0FBRCxDQUEvQjtBQUNEOztBQUNELFNBQU9tVyxHQUFQO0FBQ0Q7O0FBRUQsU0FBU2lJLElBQVQsQ0FBY3VCLE9BQWQsRUFBdUJ0akIsSUFBdkIsRUFBNkI7QUFDM0IsU0FBTyxJQUFJdEssT0FBSixDQUFZLFVBQVVFLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQzVDLGFBQVNtdkIsYUFBVCxDQUF1QjFXLEdBQXZCLEVBQTRCO0FBQzFCZ1YsTUFBQUEsT0FBTyxDQUFDTyxjQUFSLENBQXVCN2pCLElBQXZCLEVBQTZCaWxCLFFBQTdCO0FBQ0FwdkIsTUFBQUEsTUFBTSxDQUFDeVksR0FBRCxDQUFOO0FBQ0Q7O0FBRUQsYUFBUzJXLFFBQVQsR0FBb0I7QUFDbEIsVUFBSSxPQUFPM0IsT0FBTyxDQUFDTyxjQUFmLEtBQWtDLFVBQXRDLEVBQWtEO0FBQ2hEUCxRQUFBQSxPQUFPLENBQUNPLGNBQVIsQ0FBdUIsT0FBdkIsRUFBZ0NtQixhQUFoQztBQUNEOztBQUNEcHZCLE1BQUFBLE9BQU8sQ0FBQyxHQUFHekIsS0FBSCxDQUFTbUwsSUFBVCxDQUFjN0MsU0FBZCxDQUFELENBQVA7QUFDRDs7QUFBQTtBQUVEeW9CLElBQUFBLDhCQUE4QixDQUFDNUIsT0FBRCxFQUFVdGpCLElBQVYsRUFBZ0JpbEIsUUFBaEIsRUFBMEI7QUFBRWxELE1BQUFBLElBQUksRUFBRTtBQUFSLEtBQTFCLENBQTlCOztBQUNBLFFBQUkvaEIsSUFBSSxLQUFLLE9BQWIsRUFBc0I7QUFDcEJtbEIsTUFBQUEsNkJBQTZCLENBQUM3QixPQUFELEVBQVUwQixhQUFWLEVBQXlCO0FBQUVqRCxRQUFBQSxJQUFJLEVBQUU7QUFBUixPQUF6QixDQUE3QjtBQUNEO0FBQ0YsR0FqQk0sQ0FBUDtBQWtCRDs7QUFFRCxTQUFTb0QsNkJBQVQsQ0FBdUM3QixPQUF2QyxFQUFnRFIsT0FBaEQsRUFBeURzQyxLQUF6RCxFQUFnRTtBQUM5RCxNQUFJLE9BQU85QixPQUFPLENBQUNHLEVBQWYsS0FBc0IsVUFBMUIsRUFBc0M7QUFDcEN5QixJQUFBQSw4QkFBOEIsQ0FBQzVCLE9BQUQsRUFBVSxPQUFWLEVBQW1CUixPQUFuQixFQUE0QnNDLEtBQTVCLENBQTlCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTRiw4QkFBVCxDQUF3QzVCLE9BQXhDLEVBQWlEdGpCLElBQWpELEVBQXVEcWlCLFFBQXZELEVBQWlFK0MsS0FBakUsRUFBd0U7QUFDdEUsTUFBSSxPQUFPOUIsT0FBTyxDQUFDRyxFQUFmLEtBQXNCLFVBQTFCLEVBQXNDO0FBQ3BDLFFBQUkyQixLQUFLLENBQUNyRCxJQUFWLEVBQWdCO0FBQ2R1QixNQUFBQSxPQUFPLENBQUN2QixJQUFSLENBQWEvaEIsSUFBYixFQUFtQnFpQixRQUFuQjtBQUNELEtBRkQsTUFFTztBQUNMaUIsTUFBQUEsT0FBTyxDQUFDRyxFQUFSLENBQVd6akIsSUFBWCxFQUFpQnFpQixRQUFqQjtBQUNEO0FBQ0YsR0FORCxNQU1PLElBQUksT0FBT2lCLE9BQU8sQ0FBQzNwQixnQkFBZixLQUFvQyxVQUF4QyxFQUFvRDtBQUN6RDtBQUNBO0FBQ0EycEIsSUFBQUEsT0FBTyxDQUFDM3BCLGdCQUFSLENBQXlCcUcsSUFBekIsRUFBK0IsU0FBU3FsQixZQUFULENBQXNCalIsR0FBdEIsRUFBMkI7QUFDeEQ7QUFDQTtBQUNBLFVBQUlnUixLQUFLLENBQUNyRCxJQUFWLEVBQWdCO0FBQ2R1QixRQUFBQSxPQUFPLENBQUNnQyxtQkFBUixDQUE0QnRsQixJQUE1QixFQUFrQ3FsQixZQUFsQztBQUNEOztBQUNEaEQsTUFBQUEsUUFBUSxDQUFDak8sR0FBRCxDQUFSO0FBQ0QsS0FQRDtBQVFELEdBWE0sTUFXQTtBQUNMLFVBQU0sSUFBSXhZLFNBQUosQ0FBYyxnRkFBK0UwbkIsT0FBL0UsQ0FBZCxDQUFOO0FBQ0Q7QUFDRjs7Ozs7Ozs7Ozs7O0FDaGZEO0FBQ0F2dUIsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixRQUFPb3lCLElBQVAseUNBQU9BLElBQVAsTUFBZSxRQUFmLEdBQTBCQSxJQUFJLENBQUM3YyxRQUEvQixHQUEwQ2pDLE1BQU0sQ0FBQ2lDLFFBQWxFOzs7Ozs7Ozs7O0FDREE7QUFDQXZWLFlBQUEsR0FBZSxVQUFVK1AsTUFBVixFQUFrQjRTLE1BQWxCLEVBQTBCMFAsSUFBMUIsRUFBZ0NDLElBQWhDLEVBQXNDQyxNQUF0QyxFQUE4QztBQUMzRCxNQUFJaGpCLENBQUosRUFBT2lQLENBQVA7QUFDQSxNQUFJZ1UsSUFBSSxHQUFJRCxNQUFNLEdBQUcsQ0FBVixHQUFlRCxJQUFmLEdBQXNCLENBQWpDO0FBQ0EsTUFBSUcsSUFBSSxHQUFHLENBQUMsS0FBS0QsSUFBTixJQUFjLENBQXpCO0FBQ0EsTUFBSUUsS0FBSyxHQUFHRCxJQUFJLElBQUksQ0FBcEI7QUFDQSxNQUFJRSxLQUFLLEdBQUcsQ0FBQyxDQUFiO0FBQ0EsTUFBSW5pQixDQUFDLEdBQUc2aEIsSUFBSSxHQUFJRSxNQUFNLEdBQUcsQ0FBYixHQUFrQixDQUE5QjtBQUNBLE1BQUluVSxDQUFDLEdBQUdpVSxJQUFJLEdBQUcsQ0FBQyxDQUFKLEdBQVEsQ0FBcEI7QUFDQSxNQUFJL1csQ0FBQyxHQUFHdkwsTUFBTSxDQUFDNFMsTUFBTSxHQUFHblMsQ0FBVixDQUFkO0FBRUFBLEVBQUFBLENBQUMsSUFBSTROLENBQUw7QUFFQTdPLEVBQUFBLENBQUMsR0FBRytMLENBQUMsR0FBSSxDQUFDLEtBQU0sQ0FBQ3FYLEtBQVIsSUFBa0IsQ0FBM0I7QUFDQXJYLEVBQUFBLENBQUMsS0FBTSxDQUFDcVgsS0FBUjtBQUNBQSxFQUFBQSxLQUFLLElBQUlILElBQVQ7O0FBQ0EsU0FBT0csS0FBSyxHQUFHLENBQWYsRUFBa0JwakIsQ0FBQyxHQUFJQSxDQUFDLEdBQUcsR0FBTCxHQUFZUSxNQUFNLENBQUM0UyxNQUFNLEdBQUduUyxDQUFWLENBQXRCLEVBQW9DQSxDQUFDLElBQUk0TixDQUF6QyxFQUE0Q3VVLEtBQUssSUFBSSxDQUF2RSxFQUEwRSxDQUFFOztBQUU1RW5VLEVBQUFBLENBQUMsR0FBR2pQLENBQUMsR0FBSSxDQUFDLEtBQU0sQ0FBQ29qQixLQUFSLElBQWtCLENBQTNCO0FBQ0FwakIsRUFBQUEsQ0FBQyxLQUFNLENBQUNvakIsS0FBUjtBQUNBQSxFQUFBQSxLQUFLLElBQUlMLElBQVQ7O0FBQ0EsU0FBT0ssS0FBSyxHQUFHLENBQWYsRUFBa0JuVSxDQUFDLEdBQUlBLENBQUMsR0FBRyxHQUFMLEdBQVl6TyxNQUFNLENBQUM0UyxNQUFNLEdBQUduUyxDQUFWLENBQXRCLEVBQW9DQSxDQUFDLElBQUk0TixDQUF6QyxFQUE0Q3VVLEtBQUssSUFBSSxDQUF2RSxFQUEwRSxDQUFFOztBQUU1RSxNQUFJcGpCLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWEEsSUFBQUEsQ0FBQyxHQUFHLElBQUltakIsS0FBUjtBQUNELEdBRkQsTUFFTyxJQUFJbmpCLENBQUMsS0FBS2tqQixJQUFWLEVBQWdCO0FBQ3JCLFdBQU9qVSxDQUFDLEdBQUdvVSxHQUFILEdBQVUsQ0FBQ3RYLENBQUMsR0FBRyxDQUFDLENBQUosR0FBUSxDQUFWLElBQWU4UixRQUFqQztBQUNELEdBRk0sTUFFQTtBQUNMNU8sSUFBQUEsQ0FBQyxHQUFHQSxDQUFDLEdBQUc3RCxJQUFJLENBQUM4TixHQUFMLENBQVMsQ0FBVCxFQUFZNkosSUFBWixDQUFSO0FBQ0EvaUIsSUFBQUEsQ0FBQyxHQUFHQSxDQUFDLEdBQUdtakIsS0FBUjtBQUNEOztBQUNELFNBQU8sQ0FBQ3BYLENBQUMsR0FBRyxDQUFDLENBQUosR0FBUSxDQUFWLElBQWVrRCxDQUFmLEdBQW1CN0QsSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWWxaLENBQUMsR0FBRytpQixJQUFoQixDQUExQjtBQUNELENBL0JEOztBQWlDQXR5QixhQUFBLEdBQWdCLFVBQVUrUCxNQUFWLEVBQWtCOVAsS0FBbEIsRUFBeUIwaUIsTUFBekIsRUFBaUMwUCxJQUFqQyxFQUF1Q0MsSUFBdkMsRUFBNkNDLE1BQTdDLEVBQXFEO0FBQ25FLE1BQUloakIsQ0FBSixFQUFPaVAsQ0FBUCxFQUFVeFYsQ0FBVjtBQUNBLE1BQUl3cEIsSUFBSSxHQUFJRCxNQUFNLEdBQUcsQ0FBVixHQUFlRCxJQUFmLEdBQXNCLENBQWpDO0FBQ0EsTUFBSUcsSUFBSSxHQUFHLENBQUMsS0FBS0QsSUFBTixJQUFjLENBQXpCO0FBQ0EsTUFBSUUsS0FBSyxHQUFHRCxJQUFJLElBQUksQ0FBcEI7QUFDQSxNQUFJSSxFQUFFLEdBQUlQLElBQUksS0FBSyxFQUFULEdBQWMzWCxJQUFJLENBQUM4TixHQUFMLENBQVMsQ0FBVCxFQUFZLENBQUMsRUFBYixJQUFtQjlOLElBQUksQ0FBQzhOLEdBQUwsQ0FBUyxDQUFULEVBQVksQ0FBQyxFQUFiLENBQWpDLEdBQW9ELENBQTlEO0FBQ0EsTUFBSWpZLENBQUMsR0FBRzZoQixJQUFJLEdBQUcsQ0FBSCxHQUFRRSxNQUFNLEdBQUcsQ0FBN0I7QUFDQSxNQUFJblUsQ0FBQyxHQUFHaVUsSUFBSSxHQUFHLENBQUgsR0FBTyxDQUFDLENBQXBCO0FBQ0EsTUFBSS9XLENBQUMsR0FBR3JiLEtBQUssR0FBRyxDQUFSLElBQWNBLEtBQUssS0FBSyxDQUFWLElBQWUsSUFBSUEsS0FBSixHQUFZLENBQXpDLEdBQThDLENBQTlDLEdBQWtELENBQTFEO0FBRUFBLEVBQUFBLEtBQUssR0FBRzBhLElBQUksQ0FBQ0UsR0FBTCxDQUFTNWEsS0FBVCxDQUFSOztBQUVBLE1BQUl3dUIsS0FBSyxDQUFDeHVCLEtBQUQsQ0FBTCxJQUFnQkEsS0FBSyxLQUFLbXRCLFFBQTlCLEVBQXdDO0FBQ3RDNU8sSUFBQUEsQ0FBQyxHQUFHaVEsS0FBSyxDQUFDeHVCLEtBQUQsQ0FBTCxHQUFlLENBQWYsR0FBbUIsQ0FBdkI7QUFDQXNQLElBQUFBLENBQUMsR0FBR2tqQixJQUFKO0FBQ0QsR0FIRCxNQUdPO0FBQ0xsakIsSUFBQUEsQ0FBQyxHQUFHb0wsSUFBSSxDQUFDb1MsS0FBTCxDQUFXcFMsSUFBSSxDQUFDbVksR0FBTCxDQUFTN3lCLEtBQVQsSUFBa0IwYSxJQUFJLENBQUNvWSxHQUFsQyxDQUFKOztBQUNBLFFBQUk5eUIsS0FBSyxJQUFJK0ksQ0FBQyxHQUFHMlIsSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWSxDQUFDbFosQ0FBYixDQUFSLENBQUwsR0FBZ0MsQ0FBcEMsRUFBdUM7QUFDckNBLE1BQUFBLENBQUM7QUFDRHZHLE1BQUFBLENBQUMsSUFBSSxDQUFMO0FBQ0Q7O0FBQ0QsUUFBSXVHLENBQUMsR0FBR21qQixLQUFKLElBQWEsQ0FBakIsRUFBb0I7QUFDbEJ6eUIsTUFBQUEsS0FBSyxJQUFJNHlCLEVBQUUsR0FBRzdwQixDQUFkO0FBQ0QsS0FGRCxNQUVPO0FBQ0wvSSxNQUFBQSxLQUFLLElBQUk0eUIsRUFBRSxHQUFHbFksSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWSxJQUFJaUssS0FBaEIsQ0FBZDtBQUNEOztBQUNELFFBQUl6eUIsS0FBSyxHQUFHK0ksQ0FBUixJQUFhLENBQWpCLEVBQW9CO0FBQ2xCdUcsTUFBQUEsQ0FBQztBQUNEdkcsTUFBQUEsQ0FBQyxJQUFJLENBQUw7QUFDRDs7QUFFRCxRQUFJdUcsQ0FBQyxHQUFHbWpCLEtBQUosSUFBYUQsSUFBakIsRUFBdUI7QUFDckJqVSxNQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNBalAsTUFBQUEsQ0FBQyxHQUFHa2pCLElBQUo7QUFDRCxLQUhELE1BR08sSUFBSWxqQixDQUFDLEdBQUdtakIsS0FBSixJQUFhLENBQWpCLEVBQW9CO0FBQ3pCbFUsTUFBQUEsQ0FBQyxHQUFHLENBQUV2ZSxLQUFLLEdBQUcrSSxDQUFULEdBQWMsQ0FBZixJQUFvQjJSLElBQUksQ0FBQzhOLEdBQUwsQ0FBUyxDQUFULEVBQVk2SixJQUFaLENBQXhCO0FBQ0EvaUIsTUFBQUEsQ0FBQyxHQUFHQSxDQUFDLEdBQUdtakIsS0FBUjtBQUNELEtBSE0sTUFHQTtBQUNMbFUsTUFBQUEsQ0FBQyxHQUFHdmUsS0FBSyxHQUFHMGEsSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWWlLLEtBQUssR0FBRyxDQUFwQixDQUFSLEdBQWlDL1gsSUFBSSxDQUFDOE4sR0FBTCxDQUFTLENBQVQsRUFBWTZKLElBQVosQ0FBckM7QUFDQS9pQixNQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEO0FBQ0Y7O0FBRUQsU0FBTytpQixJQUFJLElBQUksQ0FBZixFQUFrQnZpQixNQUFNLENBQUM0UyxNQUFNLEdBQUduUyxDQUFWLENBQU4sR0FBcUJnTyxDQUFDLEdBQUcsSUFBekIsRUFBK0JoTyxDQUFDLElBQUk0TixDQUFwQyxFQUF1Q0ksQ0FBQyxJQUFJLEdBQTVDLEVBQWlEOFQsSUFBSSxJQUFJLENBQTNFLEVBQThFLENBQUU7O0FBRWhGL2lCLEVBQUFBLENBQUMsR0FBSUEsQ0FBQyxJQUFJK2lCLElBQU4sR0FBYzlULENBQWxCO0FBQ0FnVSxFQUFBQSxJQUFJLElBQUlGLElBQVI7O0FBQ0EsU0FBT0UsSUFBSSxHQUFHLENBQWQsRUFBaUJ6aUIsTUFBTSxDQUFDNFMsTUFBTSxHQUFHblMsQ0FBVixDQUFOLEdBQXFCakIsQ0FBQyxHQUFHLElBQXpCLEVBQStCaUIsQ0FBQyxJQUFJNE4sQ0FBcEMsRUFBdUM3TyxDQUFDLElBQUksR0FBNUMsRUFBaURpakIsSUFBSSxJQUFJLENBQTFFLEVBQTZFLENBQUU7O0FBRS9FemlCLEVBQUFBLE1BQU0sQ0FBQzRTLE1BQU0sR0FBR25TLENBQVQsR0FBYTROLENBQWQsQ0FBTixJQUEwQjlDLENBQUMsR0FBRyxHQUE5QjtBQUNELENBbEREOzs7Ozs7Ozs7O0FDbENBLElBQUksT0FBT3hiLE1BQU0sQ0FBQytILE1BQWQsS0FBeUIsVUFBN0IsRUFBeUM7QUFDdkM7QUFDQWpHLEVBQUFBLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsU0FBU2d6QixRQUFULENBQWtCQyxJQUFsQixFQUF3QkMsU0FBeEIsRUFBbUM7QUFDbEQsUUFBSUEsU0FBSixFQUFlO0FBQ2JELE1BQUFBLElBQUksQ0FBQ0UsTUFBTCxHQUFjRCxTQUFkO0FBQ0FELE1BQUFBLElBQUksQ0FBQ3ZyQixTQUFMLEdBQWlCNUgsTUFBTSxDQUFDK0gsTUFBUCxDQUFjcXJCLFNBQVMsQ0FBQ3hyQixTQUF4QixFQUFtQztBQUNsRDROLFFBQUFBLFdBQVcsRUFBRTtBQUNYclYsVUFBQUEsS0FBSyxFQUFFZ3pCLElBREk7QUFFWHJTLFVBQUFBLFVBQVUsRUFBRSxLQUZEO0FBR1h5TCxVQUFBQSxRQUFRLEVBQUUsSUFIQztBQUlYQyxVQUFBQSxZQUFZLEVBQUU7QUFKSDtBQURxQyxPQUFuQyxDQUFqQjtBQVFEO0FBQ0YsR0FaRDtBQWFELENBZkQsTUFlTztBQUNMO0FBQ0ExcUIsRUFBQUEsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixTQUFTZ3pCLFFBQVQsQ0FBa0JDLElBQWxCLEVBQXdCQyxTQUF4QixFQUFtQztBQUNsRCxRQUFJQSxTQUFKLEVBQWU7QUFDYkQsTUFBQUEsSUFBSSxDQUFDRSxNQUFMLEdBQWNELFNBQWQ7O0FBQ0EsVUFBSUUsUUFBUSxHQUFHLFNBQVhBLFFBQVcsR0FBWSxDQUFFLENBQTdCOztBQUNBQSxNQUFBQSxRQUFRLENBQUMxckIsU0FBVCxHQUFxQndyQixTQUFTLENBQUN4ckIsU0FBL0I7QUFDQXVyQixNQUFBQSxJQUFJLENBQUN2ckIsU0FBTCxHQUFpQixJQUFJMHJCLFFBQUosRUFBakI7QUFDQUgsTUFBQUEsSUFBSSxDQUFDdnJCLFNBQUwsQ0FBZTROLFdBQWYsR0FBNkIyZCxJQUE3QjtBQUNEO0FBQ0YsR0FSRDtBQVNEOzs7Ozs7Ozs7O0FDMUJEeFgsTUFBTSxDQUFDNFgsUUFBUCxHQUFrQkEsUUFBbEI7QUFDQTVYLE1BQU0sQ0FBQzZYLEtBQVAsR0FBZUEsS0FBZjtBQUNBN1gsTUFBTSxDQUFDOFgsS0FBUCxHQUFlQSxLQUFmO0FBQ0E5WCxNQUFNLENBQUMrWCxFQUFQLEdBQVkvWCxNQUFaO0FBRUE3WixNQUFNLENBQUM1QixPQUFQLEdBQWlCeWIsTUFBakI7O0FBRUEsU0FBUzhYLEtBQVQsQ0FBZ0JuZCxDQUFoQixFQUFtQkMsQ0FBbkIsRUFBc0JtSSxDQUF0QixFQUF5QjtBQUN2Qi9DLEVBQUFBLE1BQU0sQ0FBQ3JGLENBQUMsSUFBSUMsQ0FBTixFQUFTbUksQ0FBVCxDQUFOLENBRHVCLENBQ0w7QUFDbkI7O0FBRUQsU0FBUzZVLFFBQVQsQ0FBbUJqZCxDQUFuQixFQUFzQkMsQ0FBdEIsRUFBeUJtSSxDQUF6QixFQUE0QjtBQUMxQi9DLEVBQUFBLE1BQU0sQ0FBQ3JGLENBQUMsSUFBSUMsQ0FBTixFQUFTbUksQ0FBVCxDQUFOLENBRDBCLENBQ1I7QUFDbkI7O0FBRUQsU0FBUzhVLEtBQVQsQ0FBZ0JqVSxDQUFoQixFQUFtQmIsQ0FBbkIsRUFBc0I7QUFDcEIvQyxFQUFBQSxNQUFNLENBQUMsQ0FBQzRELENBQUYsRUFBS2IsQ0FBTCxDQUFOO0FBQ0Q7O0FBRUQsU0FBUy9DLE1BQVQsQ0FBaUI0RCxDQUFqQixFQUFvQmIsQ0FBcEIsRUFBdUI7QUFDckIsTUFBSSxDQUFDYSxDQUFMLEVBQVEsTUFBTSxJQUFJM2QsS0FBSixDQUFVOGMsQ0FBQyxJQUFJLGdCQUFmLENBQU47QUFDVDs7Ozs7Ozs7OztBQ3JCRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0NBSUE7QUFDQTtBQUNBOztBQUNBLFNBQVN0SSxjQUFULENBQXdCRixHQUF4QixFQUE2QmpJLElBQTdCLEVBQW1DO0FBQ2pDLFNBQU9qTyxNQUFNLENBQUM0SCxTQUFQLENBQWlCd08sY0FBakIsQ0FBZ0MvSixJQUFoQyxDQUFxQzZKLEdBQXJDLEVBQTBDakksSUFBMUMsQ0FBUDtBQUNEOztBQUVEbk0sTUFBTSxDQUFDNUIsT0FBUCxHQUFpQixVQUFTeXpCLEVBQVQsRUFBYUMsR0FBYixFQUFrQkMsRUFBbEIsRUFBc0Jyb0IsT0FBdEIsRUFBK0I7QUFDOUNvb0IsRUFBQUEsR0FBRyxHQUFHQSxHQUFHLElBQUksR0FBYjtBQUNBQyxFQUFBQSxFQUFFLEdBQUdBLEVBQUUsSUFBSSxHQUFYO0FBQ0EsTUFBSTNkLEdBQUcsR0FBRyxFQUFWOztBQUVBLE1BQUksT0FBT3lkLEVBQVAsS0FBYyxRQUFkLElBQTBCQSxFQUFFLENBQUMvb0IsTUFBSCxLQUFjLENBQTVDLEVBQStDO0FBQzdDLFdBQU9zTCxHQUFQO0FBQ0Q7O0FBRUQsTUFBSTRkLE1BQU0sR0FBRyxLQUFiO0FBQ0FILEVBQUFBLEVBQUUsR0FBR0EsRUFBRSxDQUFDNWYsS0FBSCxDQUFTNmYsR0FBVCxDQUFMO0FBRUEsTUFBSUcsT0FBTyxHQUFHLElBQWQ7O0FBQ0EsTUFBSXZvQixPQUFPLElBQUksT0FBT0EsT0FBTyxDQUFDdW9CLE9BQWYsS0FBMkIsUUFBMUMsRUFBb0Q7QUFDbERBLElBQUFBLE9BQU8sR0FBR3ZvQixPQUFPLENBQUN1b0IsT0FBbEI7QUFDRDs7QUFFRCxNQUFJOWMsR0FBRyxHQUFHMGMsRUFBRSxDQUFDL29CLE1BQWIsQ0FqQjhDLENBa0I5Qzs7QUFDQSxNQUFJbXBCLE9BQU8sR0FBRyxDQUFWLElBQWU5YyxHQUFHLEdBQUc4YyxPQUF6QixFQUFrQztBQUNoQzljLElBQUFBLEdBQUcsR0FBRzhjLE9BQU47QUFDRDs7QUFFRCxPQUFLLElBQUlyakIsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3VHLEdBQXBCLEVBQXlCLEVBQUV2RyxDQUEzQixFQUE4QjtBQUM1QixRQUFJOEgsQ0FBQyxHQUFHbWIsRUFBRSxDQUFDampCLENBQUQsQ0FBRixDQUFNdkYsT0FBTixDQUFjMm9CLE1BQWQsRUFBc0IsS0FBdEIsQ0FBUjtBQUFBLFFBQ0lFLEdBQUcsR0FBR3hiLENBQUMsQ0FBQ3ZULE9BQUYsQ0FBVTR1QixFQUFWLENBRFY7QUFBQSxRQUVJSSxJQUZKO0FBQUEsUUFFVUMsSUFGVjtBQUFBLFFBRWdCQyxDQUZoQjtBQUFBLFFBRW1CcGpCLENBRm5COztBQUlBLFFBQUlpakIsR0FBRyxJQUFJLENBQVgsRUFBYztBQUNaQyxNQUFBQSxJQUFJLEdBQUd6YixDQUFDLENBQUN2RSxNQUFGLENBQVMsQ0FBVCxFQUFZK2YsR0FBWixDQUFQO0FBQ0FFLE1BQUFBLElBQUksR0FBRzFiLENBQUMsQ0FBQ3ZFLE1BQUYsQ0FBUytmLEdBQUcsR0FBRyxDQUFmLENBQVA7QUFDRCxLQUhELE1BR087QUFDTEMsTUFBQUEsSUFBSSxHQUFHemIsQ0FBUDtBQUNBMGIsTUFBQUEsSUFBSSxHQUFHLEVBQVA7QUFDRDs7QUFFREMsSUFBQUEsQ0FBQyxHQUFHamlCLGtCQUFrQixDQUFDK2hCLElBQUQsQ0FBdEI7QUFDQWxqQixJQUFBQSxDQUFDLEdBQUdtQixrQkFBa0IsQ0FBQ2dpQixJQUFELENBQXRCOztBQUVBLFFBQUksQ0FBQzlkLGNBQWMsQ0FBQ0YsR0FBRCxFQUFNaWUsQ0FBTixDQUFuQixFQUE2QjtBQUMzQmplLE1BQUFBLEdBQUcsQ0FBQ2llLENBQUQsQ0FBSCxHQUFTcGpCLENBQVQ7QUFDRCxLQUZELE1BRU8sSUFBSXRHLEtBQUssQ0FBQ3NELE9BQU4sQ0FBY21JLEdBQUcsQ0FBQ2llLENBQUQsQ0FBakIsQ0FBSixFQUEyQjtBQUNoQ2plLE1BQUFBLEdBQUcsQ0FBQ2llLENBQUQsQ0FBSCxDQUFPNXBCLElBQVAsQ0FBWXdHLENBQVo7QUFDRCxLQUZNLE1BRUE7QUFDTG1GLE1BQUFBLEdBQUcsQ0FBQ2llLENBQUQsQ0FBSCxHQUFTLENBQUNqZSxHQUFHLENBQUNpZSxDQUFELENBQUosRUFBU3BqQixDQUFULENBQVQ7QUFDRDtBQUNGOztBQUVELFNBQU9tRixHQUFQO0FBQ0QsQ0FqREQ7Ozs7Ozs7Ozs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVhOzs7O0FBRWIsSUFBSWtlLGtCQUFrQixHQUFHLFNBQXJCQSxrQkFBcUIsQ0FBU3JqQixDQUFULEVBQVk7QUFDbkMsa0JBQWVBLENBQWY7QUFDRSxTQUFLLFFBQUw7QUFDRSxhQUFPQSxDQUFQOztBQUVGLFNBQUssU0FBTDtBQUNFLGFBQU9BLENBQUMsR0FBRyxNQUFILEdBQVksT0FBcEI7O0FBRUYsU0FBSyxRQUFMO0FBQ0UsYUFBT2lWLFFBQVEsQ0FBQ2pWLENBQUQsQ0FBUixHQUFjQSxDQUFkLEdBQWtCLEVBQXpCOztBQUVGO0FBQ0UsYUFBTyxFQUFQO0FBWEo7QUFhRCxDQWREOztBQWdCQWpQLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsVUFBU2dXLEdBQVQsRUFBYzBkLEdBQWQsRUFBbUJDLEVBQW5CLEVBQXVCOW1CLElBQXZCLEVBQTZCO0FBQzVDNm1CLEVBQUFBLEdBQUcsR0FBR0EsR0FBRyxJQUFJLEdBQWI7QUFDQUMsRUFBQUEsRUFBRSxHQUFHQSxFQUFFLElBQUksR0FBWDs7QUFDQSxNQUFJM2QsR0FBRyxLQUFLLElBQVosRUFBa0I7QUFDaEJBLElBQUFBLEdBQUcsR0FBR2pRLFNBQU47QUFDRDs7QUFFRCxNQUFJLFFBQU9pUSxHQUFQLE1BQWUsUUFBbkIsRUFBNkI7QUFDM0IsV0FBT2xXLE1BQU0sQ0FBQ3NPLElBQVAsQ0FBWTRILEdBQVosRUFBaUJ3RixHQUFqQixDQUFxQixVQUFTeVksQ0FBVCxFQUFZO0FBQ3RDLFVBQUlFLEVBQUUsR0FBRzV3QixrQkFBa0IsQ0FBQzJ3QixrQkFBa0IsQ0FBQ0QsQ0FBRCxDQUFuQixDQUFsQixHQUE0Q04sRUFBckQ7O0FBQ0EsVUFBSXBwQixLQUFLLENBQUNzRCxPQUFOLENBQWNtSSxHQUFHLENBQUNpZSxDQUFELENBQWpCLENBQUosRUFBMkI7QUFDekIsZUFBT2plLEdBQUcsQ0FBQ2llLENBQUQsQ0FBSCxDQUFPelksR0FBUCxDQUFXLFVBQVMzSyxDQUFULEVBQVk7QUFDNUIsaUJBQU9zakIsRUFBRSxHQUFHNXdCLGtCQUFrQixDQUFDMndCLGtCQUFrQixDQUFDcmpCLENBQUQsQ0FBbkIsQ0FBOUI7QUFDRCxTQUZNLEVBRUpHLElBRkksQ0FFQzBpQixHQUZELENBQVA7QUFHRCxPQUpELE1BSU87QUFDTCxlQUFPUyxFQUFFLEdBQUc1d0Isa0JBQWtCLENBQUMyd0Isa0JBQWtCLENBQUNsZSxHQUFHLENBQUNpZSxDQUFELENBQUosQ0FBbkIsQ0FBOUI7QUFDRDtBQUNGLEtBVE0sRUFTSmpqQixJQVRJLENBU0MwaUIsR0FURCxDQUFQO0FBV0Q7O0FBRUQsTUFBSSxDQUFDN21CLElBQUwsRUFBVyxPQUFPLEVBQVA7QUFDWCxTQUFPdEosa0JBQWtCLENBQUMyd0Isa0JBQWtCLENBQUNybkIsSUFBRCxDQUFuQixDQUFsQixHQUErQzhtQixFQUEvQyxHQUNBcHdCLGtCQUFrQixDQUFDMndCLGtCQUFrQixDQUFDbGUsR0FBRCxDQUFuQixDQUR6QjtBQUVELENBeEJEOzs7Ozs7Ozs7O0FDdkNhOztBQUViaFcsY0FBQSxHQUFpQkEsMkZBQWpCO0FBQ0FBLGNBQUEsR0FBaUJBLCtGQUFqQjs7Ozs7Ozs7OztBQ0hhOzs7O0FBRWIsU0FBU28wQixjQUFULENBQXdCQyxRQUF4QixFQUFrQ0MsVUFBbEMsRUFBOEM7QUFBRUQsRUFBQUEsUUFBUSxDQUFDM3NCLFNBQVQsR0FBcUI1SCxNQUFNLENBQUMrSCxNQUFQLENBQWN5c0IsVUFBVSxDQUFDNXNCLFNBQXpCLENBQXJCO0FBQTBEMnNCLEVBQUFBLFFBQVEsQ0FBQzNzQixTQUFULENBQW1CNE4sV0FBbkIsR0FBaUMrZSxRQUFqQztBQUEyQ0EsRUFBQUEsUUFBUSxDQUFDRSxTQUFULEdBQXFCRCxVQUFyQjtBQUFrQzs7QUFFdkwsSUFBSUUsS0FBSyxHQUFHLEVBQVo7O0FBRUEsU0FBU0MsZUFBVCxDQUF5QnpvQixJQUF6QixFQUErQjFELE9BQS9CLEVBQXdDOGpCLElBQXhDLEVBQThDO0FBQzVDLE1BQUksQ0FBQ0EsSUFBTCxFQUFXO0FBQ1RBLElBQUFBLElBQUksR0FBRzFxQixLQUFQO0FBQ0Q7O0FBRUQsV0FBU3lxQixVQUFULENBQW9CdUksSUFBcEIsRUFBMEJDLElBQTFCLEVBQWdDQyxJQUFoQyxFQUFzQztBQUNwQyxRQUFJLE9BQU90c0IsT0FBUCxLQUFtQixRQUF2QixFQUFpQztBQUMvQixhQUFPQSxPQUFQO0FBQ0QsS0FGRCxNQUVPO0FBQ0wsYUFBT0EsT0FBTyxDQUFDb3NCLElBQUQsRUFBT0MsSUFBUCxFQUFhQyxJQUFiLENBQWQ7QUFDRDtBQUNGOztBQUVELE1BQUlDLFNBQVMsR0FDYixhQUNBLFVBQVVDLEtBQVYsRUFBaUI7QUFDZlYsSUFBQUEsY0FBYyxDQUFDUyxTQUFELEVBQVlDLEtBQVosQ0FBZDs7QUFFQSxhQUFTRCxTQUFULENBQW1CSCxJQUFuQixFQUF5QkMsSUFBekIsRUFBK0JDLElBQS9CLEVBQXFDO0FBQ25DLGFBQU9FLEtBQUssQ0FBQzNvQixJQUFOLENBQVcsSUFBWCxFQUFpQmdnQixVQUFVLENBQUN1SSxJQUFELEVBQU9DLElBQVAsRUFBYUMsSUFBYixDQUEzQixLQUFrRCxJQUF6RDtBQUNEOztBQUVELFdBQU9DLFNBQVA7QUFDRCxHQVJELENBUUV6SSxJQVJGLENBRkE7O0FBWUF5SSxFQUFBQSxTQUFTLENBQUNudEIsU0FBVixDQUFvQm1GLElBQXBCLEdBQTJCdWYsSUFBSSxDQUFDdmYsSUFBaEM7QUFDQWdvQixFQUFBQSxTQUFTLENBQUNudEIsU0FBVixDQUFvQnNFLElBQXBCLEdBQTJCQSxJQUEzQjtBQUNBd29CLEVBQUFBLEtBQUssQ0FBQ3hvQixJQUFELENBQUwsR0FBYzZvQixTQUFkO0FBQ0QsRUFBQzs7O0FBR0YsU0FBU0UsS0FBVCxDQUFlQyxRQUFmLEVBQXlCNWdCLEtBQXpCLEVBQWdDO0FBQzlCLE1BQUk3SixLQUFLLENBQUNzRCxPQUFOLENBQWNtbkIsUUFBZCxDQUFKLEVBQTZCO0FBQzNCLFFBQUlqZSxHQUFHLEdBQUdpZSxRQUFRLENBQUN0cUIsTUFBbkI7QUFDQXNxQixJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQ3haLEdBQVQsQ0FBYSxVQUFVaEwsQ0FBVixFQUFhO0FBQ25DLGFBQU9zUyxNQUFNLENBQUN0UyxDQUFELENBQWI7QUFDRCxLQUZVLENBQVg7O0FBSUEsUUFBSXVHLEdBQUcsR0FBRyxDQUFWLEVBQWE7QUFDWCxhQUFPLFVBQVV0TSxNQUFWLENBQWlCMkosS0FBakIsRUFBd0IsR0FBeEIsRUFBNkIzSixNQUE3QixDQUFvQ3VxQixRQUFRLENBQUNoMEIsS0FBVCxDQUFlLENBQWYsRUFBa0IrVixHQUFHLEdBQUcsQ0FBeEIsRUFBMkIvRixJQUEzQixDQUFnQyxJQUFoQyxDQUFwQyxFQUEyRSxPQUEzRSxJQUFzRmdrQixRQUFRLENBQUNqZSxHQUFHLEdBQUcsQ0FBUCxDQUFyRztBQUNELEtBRkQsTUFFTyxJQUFJQSxHQUFHLEtBQUssQ0FBWixFQUFlO0FBQ3BCLGFBQU8sVUFBVXRNLE1BQVYsQ0FBaUIySixLQUFqQixFQUF3QixHQUF4QixFQUE2QjNKLE1BQTdCLENBQW9DdXFCLFFBQVEsQ0FBQyxDQUFELENBQTVDLEVBQWlELE1BQWpELEVBQXlEdnFCLE1BQXpELENBQWdFdXFCLFFBQVEsQ0FBQyxDQUFELENBQXhFLENBQVA7QUFDRCxLQUZNLE1BRUE7QUFDTCxhQUFPLE1BQU12cUIsTUFBTixDQUFhMkosS0FBYixFQUFvQixHQUFwQixFQUF5QjNKLE1BQXpCLENBQWdDdXFCLFFBQVEsQ0FBQyxDQUFELENBQXhDLENBQVA7QUFDRDtBQUNGLEdBYkQsTUFhTztBQUNMLFdBQU8sTUFBTXZxQixNQUFOLENBQWEySixLQUFiLEVBQW9CLEdBQXBCLEVBQXlCM0osTUFBekIsQ0FBZ0NxWSxNQUFNLENBQUNrUyxRQUFELENBQXRDLENBQVA7QUFDRDtBQUNGLEVBQUM7OztBQUdGLFNBQVNDLFVBQVQsQ0FBb0JuZixHQUFwQixFQUF5QjdDLE1BQXpCLEVBQWlDK1AsR0FBakMsRUFBc0M7QUFDcEMsU0FBT2xOLEdBQUcsQ0FBQy9CLE1BQUosQ0FBVyxDQUFDaVAsR0FBRCxJQUFRQSxHQUFHLEdBQUcsQ0FBZCxHQUFrQixDQUFsQixHQUFzQixDQUFDQSxHQUFsQyxFQUF1Qy9QLE1BQU0sQ0FBQ3ZJLE1BQTlDLE1BQTBEdUksTUFBakU7QUFDRCxFQUFDOzs7QUFHRixTQUFTaWlCLFFBQVQsQ0FBa0JwZixHQUFsQixFQUF1QjdDLE1BQXZCLEVBQStCa2lCLFFBQS9CLEVBQXlDO0FBQ3ZDLE1BQUlBLFFBQVEsS0FBS3B2QixTQUFiLElBQTBCb3ZCLFFBQVEsR0FBR3JmLEdBQUcsQ0FBQ3BMLE1BQTdDLEVBQXFEO0FBQ25EeXFCLElBQUFBLFFBQVEsR0FBR3JmLEdBQUcsQ0FBQ3BMLE1BQWY7QUFDRDs7QUFFRCxTQUFPb0wsR0FBRyxDQUFDc2YsU0FBSixDQUFjRCxRQUFRLEdBQUdsaUIsTUFBTSxDQUFDdkksTUFBaEMsRUFBd0N5cUIsUUFBeEMsTUFBc0RsaUIsTUFBN0Q7QUFDRCxFQUFDOzs7QUFHRixTQUFTZ1MsUUFBVCxDQUFrQm5QLEdBQWxCLEVBQXVCN0MsTUFBdkIsRUFBK0IyRSxLQUEvQixFQUFzQztBQUNwQyxNQUFJLE9BQU9BLEtBQVAsS0FBaUIsUUFBckIsRUFBK0I7QUFDN0JBLElBQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0Q7O0FBRUQsTUFBSUEsS0FBSyxHQUFHM0UsTUFBTSxDQUFDdkksTUFBZixHQUF3Qm9MLEdBQUcsQ0FBQ3BMLE1BQWhDLEVBQXdDO0FBQ3RDLFdBQU8sS0FBUDtBQUNELEdBRkQsTUFFTztBQUNMLFdBQU9vTCxHQUFHLENBQUMvUSxPQUFKLENBQVlrTyxNQUFaLEVBQW9CMkUsS0FBcEIsTUFBK0IsQ0FBQyxDQUF2QztBQUNEO0FBQ0Y7O0FBRUQ2YyxlQUFlLENBQUMsdUJBQUQsRUFBMEIsVUFBVTVuQixJQUFWLEVBQWdCNU0sS0FBaEIsRUFBdUI7QUFDOUQsU0FBTyxnQkFBZ0JBLEtBQWhCLEdBQXdCLDJCQUF4QixHQUFzRDRNLElBQXRELEdBQTZELEdBQXBFO0FBQ0QsQ0FGYyxFQUVacEUsU0FGWSxDQUFmO0FBR0Fnc0IsZUFBZSxDQUFDLHNCQUFELEVBQXlCLFVBQVU1bkIsSUFBVixFQUFnQm1vQixRQUFoQixFQUEwQjdTLE1BQTFCLEVBQWtDO0FBQ3hFO0FBQ0EsTUFBSWtULFVBQUo7O0FBRUEsTUFBSSxPQUFPTCxRQUFQLEtBQW9CLFFBQXBCLElBQWdDQyxVQUFVLENBQUNELFFBQUQsRUFBVyxNQUFYLENBQTlDLEVBQWtFO0FBQ2hFSyxJQUFBQSxVQUFVLEdBQUcsYUFBYjtBQUNBTCxJQUFBQSxRQUFRLEdBQUdBLFFBQVEsQ0FBQy9wQixPQUFULENBQWlCLE9BQWpCLEVBQTBCLEVBQTFCLENBQVg7QUFDRCxHQUhELE1BR087QUFDTG9xQixJQUFBQSxVQUFVLEdBQUcsU0FBYjtBQUNEOztBQUVELE1BQUk3SSxHQUFKOztBQUVBLE1BQUkwSSxRQUFRLENBQUNyb0IsSUFBRCxFQUFPLFdBQVAsQ0FBWixFQUFpQztBQUMvQjtBQUNBMmYsSUFBQUEsR0FBRyxHQUFHLE9BQU8vaEIsTUFBUCxDQUFjb0MsSUFBZCxFQUFvQixHQUFwQixFQUF5QnBDLE1BQXpCLENBQWdDNHFCLFVBQWhDLEVBQTRDLEdBQTVDLEVBQWlENXFCLE1BQWpELENBQXdEc3FCLEtBQUssQ0FBQ0MsUUFBRCxFQUFXLE1BQVgsQ0FBN0QsQ0FBTjtBQUNELEdBSEQsTUFHTztBQUNMLFFBQUk3Z0IsSUFBSSxHQUFHOFEsUUFBUSxDQUFDcFksSUFBRCxFQUFPLEdBQVAsQ0FBUixHQUFzQixVQUF0QixHQUFtQyxVQUE5QztBQUNBMmYsSUFBQUEsR0FBRyxHQUFHLFNBQVMvaEIsTUFBVCxDQUFnQm9DLElBQWhCLEVBQXNCLEtBQXRCLEVBQTZCcEMsTUFBN0IsQ0FBb0MwSixJQUFwQyxFQUEwQyxHQUExQyxFQUErQzFKLE1BQS9DLENBQXNENHFCLFVBQXRELEVBQWtFLEdBQWxFLEVBQXVFNXFCLE1BQXZFLENBQThFc3FCLEtBQUssQ0FBQ0MsUUFBRCxFQUFXLE1BQVgsQ0FBbkYsQ0FBTjtBQUNEOztBQUVEeEksRUFBQUEsR0FBRyxJQUFJLG1CQUFtQi9oQixNQUFuQixTQUFpQzBYLE1BQWpDLEVBQVA7QUFDQSxTQUFPcUssR0FBUDtBQUNELENBdkJjLEVBdUJaL2pCLFNBdkJZLENBQWY7QUF3QkFnc0IsZUFBZSxDQUFDLDJCQUFELEVBQThCLHlCQUE5QixDQUFmO0FBQ0FBLGVBQWUsQ0FBQyw0QkFBRCxFQUErQixVQUFVNW5CLElBQVYsRUFBZ0I7QUFDNUQsU0FBTyxTQUFTQSxJQUFULEdBQWdCLDRCQUF2QjtBQUNELENBRmMsQ0FBZjtBQUdBNG5CLGVBQWUsQ0FBQyw0QkFBRCxFQUErQixpQkFBL0IsQ0FBZjtBQUNBQSxlQUFlLENBQUMsc0JBQUQsRUFBeUIsVUFBVTVuQixJQUFWLEVBQWdCO0FBQ3RELFNBQU8saUJBQWlCQSxJQUFqQixHQUF3QiwrQkFBL0I7QUFDRCxDQUZjLENBQWY7QUFHQTRuQixlQUFlLENBQUMsdUJBQUQsRUFBMEIsZ0NBQTFCLENBQWY7QUFDQUEsZUFBZSxDQUFDLHdCQUFELEVBQTJCLDJCQUEzQixDQUFmO0FBQ0FBLGVBQWUsQ0FBQyw0QkFBRCxFQUErQixpQkFBL0IsQ0FBZjtBQUNBQSxlQUFlLENBQUMsd0JBQUQsRUFBMkIscUNBQTNCLEVBQWtFaHNCLFNBQWxFLENBQWY7QUFDQWdzQixlQUFlLENBQUMsc0JBQUQsRUFBeUIsVUFBVXhULEdBQVYsRUFBZTtBQUNyRCxTQUFPLHVCQUF1QkEsR0FBOUI7QUFDRCxDQUZjLEVBRVp4WSxTQUZZLENBQWY7QUFHQWdzQixlQUFlLENBQUMsb0NBQUQsRUFBdUMsa0NBQXZDLENBQWY7QUFDQTd5QixvQkFBQSxHQUF1QjR5QixLQUF2Qjs7Ozs7Ozs7OztBQzlIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDYTtBQUNiOztBQUVBLElBQUljLFVBQVUsR0FBR3gxQixNQUFNLENBQUNzTyxJQUFQLElBQWUsVUFBVTRILEdBQVYsRUFBZTtBQUM3QyxNQUFJNUgsSUFBSSxHQUFHLEVBQVg7O0FBRUEsT0FBSyxJQUFJaEksR0FBVCxJQUFnQjRQLEdBQWhCLEVBQXFCO0FBQ25CNUgsSUFBQUEsSUFBSSxDQUFDL0QsSUFBTCxDQUFVakUsR0FBVjtBQUNEOztBQUVELFNBQU9nSSxJQUFQO0FBQ0QsQ0FSRDtBQVNBOzs7QUFHQXhNLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUJ1MUIsTUFBakI7O0FBRUEsSUFBSUMsUUFBUSxHQUFHcjFCLG1CQUFPLENBQUMsa0ZBQUQsQ0FBdEI7O0FBRUEsSUFBSXMxQixRQUFRLEdBQUd0MUIsbUJBQU8sQ0FBQyxrRkFBRCxDQUF0Qjs7QUFFQUEsbUJBQU8sQ0FBQyw2REFBRCxDQUFQLENBQW9CbzFCLE1BQXBCLEVBQTRCQyxRQUE1Qjs7QUFFQTtBQUNFO0FBQ0EsTUFBSXBuQixJQUFJLEdBQUdrbkIsVUFBVSxDQUFDRyxRQUFRLENBQUMvdEIsU0FBVixDQUFyQjs7QUFFQSxPQUFLLElBQUltSixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHekMsSUFBSSxDQUFDMUQsTUFBekIsRUFBaUNtRyxDQUFDLEVBQWxDLEVBQXNDO0FBQ3BDLFFBQUkvTSxNQUFNLEdBQUdzSyxJQUFJLENBQUN5QyxDQUFELENBQWpCO0FBQ0EsUUFBSSxDQUFDMGtCLE1BQU0sQ0FBQzd0QixTQUFQLENBQWlCNUQsTUFBakIsQ0FBTCxFQUErQnl4QixNQUFNLENBQUM3dEIsU0FBUCxDQUFpQjVELE1BQWpCLElBQTJCMnhCLFFBQVEsQ0FBQy90QixTQUFULENBQW1CNUQsTUFBbkIsQ0FBM0I7QUFDaEM7QUFDRjs7QUFFRCxTQUFTeXhCLE1BQVQsQ0FBZ0JqcUIsT0FBaEIsRUFBeUI7QUFDdkIsTUFBSSxFQUFFLGdCQUFnQmlxQixNQUFsQixDQUFKLEVBQStCLE9BQU8sSUFBSUEsTUFBSixDQUFXanFCLE9BQVgsQ0FBUDtBQUMvQmtxQixFQUFBQSxRQUFRLENBQUNycEIsSUFBVCxDQUFjLElBQWQsRUFBb0JiLE9BQXBCO0FBQ0FtcUIsRUFBQUEsUUFBUSxDQUFDdHBCLElBQVQsQ0FBYyxJQUFkLEVBQW9CYixPQUFwQjtBQUNBLE9BQUtvcUIsYUFBTCxHQUFxQixJQUFyQjs7QUFFQSxNQUFJcHFCLE9BQUosRUFBYTtBQUNYLFFBQUlBLE9BQU8sQ0FBQ3FxQixRQUFSLEtBQXFCLEtBQXpCLEVBQWdDLEtBQUtBLFFBQUwsR0FBZ0IsS0FBaEI7QUFDaEMsUUFBSXJxQixPQUFPLENBQUMrZ0IsUUFBUixLQUFxQixLQUF6QixFQUFnQyxLQUFLQSxRQUFMLEdBQWdCLEtBQWhCOztBQUVoQyxRQUFJL2dCLE9BQU8sQ0FBQ29xQixhQUFSLEtBQTBCLEtBQTlCLEVBQXFDO0FBQ25DLFdBQUtBLGFBQUwsR0FBcUIsS0FBckI7QUFDQSxXQUFLOUcsSUFBTCxDQUFVLEtBQVYsRUFBaUJnSCxLQUFqQjtBQUNEO0FBQ0Y7QUFDRjs7QUFFRDkxQixNQUFNLENBQUNDLGNBQVAsQ0FBc0J3MUIsTUFBTSxDQUFDN3RCLFNBQTdCLEVBQXdDLHVCQUF4QyxFQUFpRTtBQUMvRDtBQUNBO0FBQ0E7QUFDQWtaLEVBQUFBLFVBQVUsRUFBRSxLQUptRDtBQUsvREMsRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixXQUFPLEtBQUtnVixjQUFMLENBQW9CQyxhQUEzQjtBQUNEO0FBUDhELENBQWpFO0FBU0FoMkIsTUFBTSxDQUFDQyxjQUFQLENBQXNCdzFCLE1BQU0sQ0FBQzd0QixTQUE3QixFQUF3QyxnQkFBeEMsRUFBMEQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0FrWixFQUFBQSxVQUFVLEVBQUUsS0FKNEM7QUFLeERDLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsV0FBTyxLQUFLZ1YsY0FBTCxJQUF1QixLQUFLQSxjQUFMLENBQW9CRSxTQUFwQixFQUE5QjtBQUNEO0FBUHVELENBQTFEO0FBU0FqMkIsTUFBTSxDQUFDQyxjQUFQLENBQXNCdzFCLE1BQU0sQ0FBQzd0QixTQUE3QixFQUF3QyxnQkFBeEMsRUFBMEQ7QUFDeEQ7QUFDQTtBQUNBO0FBQ0FrWixFQUFBQSxVQUFVLEVBQUUsS0FKNEM7QUFLeERDLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsV0FBTyxLQUFLZ1YsY0FBTCxDQUFvQm5yQixNQUEzQjtBQUNEO0FBUHVELENBQTFELEdBUUk7O0FBRUosU0FBU2tyQixLQUFULEdBQWlCO0FBQ2Y7QUFDQSxNQUFJLEtBQUtDLGNBQUwsQ0FBb0JHLEtBQXhCLEVBQStCLE9BRmhCLENBRXdCO0FBQ3ZDOztBQUVBbG5CLEVBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCQyxPQUFqQixFQUEwQixJQUExQjtBQUNEOztBQUVELFNBQVNBLE9BQVQsQ0FBaUI5RCxJQUFqQixFQUF1QjtBQUNyQkEsRUFBQUEsSUFBSSxDQUFDdmEsR0FBTDtBQUNEOztBQUVEL1gsTUFBTSxDQUFDQyxjQUFQLENBQXNCdzFCLE1BQU0sQ0FBQzd0QixTQUE3QixFQUF3QyxXQUF4QyxFQUFxRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQWtaLEVBQUFBLFVBQVUsRUFBRSxLQUp1QztBQUtuREMsRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixRQUFJLEtBQUtzVixjQUFMLEtBQXdCcHdCLFNBQXhCLElBQXFDLEtBQUs4dkIsY0FBTCxLQUF3Qjl2QixTQUFqRSxFQUE0RTtBQUMxRSxhQUFPLEtBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUtvd0IsY0FBTCxDQUFvQkMsU0FBcEIsSUFBaUMsS0FBS1AsY0FBTCxDQUFvQk8sU0FBNUQ7QUFDRCxHQVhrRDtBQVluRHZaLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWE1YyxLQUFiLEVBQW9CO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFJLEtBQUtrMkIsY0FBTCxLQUF3QnB3QixTQUF4QixJQUFxQyxLQUFLOHZCLGNBQUwsS0FBd0I5dkIsU0FBakUsRUFBNEU7QUFDMUU7QUFDRCxLQUxzQixDQUtyQjtBQUNGOzs7QUFHQSxTQUFLb3dCLGNBQUwsQ0FBb0JDLFNBQXBCLEdBQWdDbjJCLEtBQWhDO0FBQ0EsU0FBSzQxQixjQUFMLENBQW9CTyxTQUFwQixHQUFnQ24yQixLQUFoQztBQUNEO0FBdkJrRCxDQUFyRDs7Ozs7Ozs7OztBQ2xIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWIyQixNQUFNLENBQUM1QixPQUFQLEdBQWlCcTJCLFdBQWpCOztBQUVBLElBQUlDLFNBQVMsR0FBR24yQixtQkFBTyxDQUFDLG9GQUFELENBQXZCOztBQUVBQSxtQkFBTyxDQUFDLDZEQUFELENBQVAsQ0FBb0JrMkIsV0FBcEIsRUFBaUNDLFNBQWpDOztBQUVBLFNBQVNELFdBQVQsQ0FBcUIvcUIsT0FBckIsRUFBOEI7QUFDNUIsTUFBSSxFQUFFLGdCQUFnQitxQixXQUFsQixDQUFKLEVBQW9DLE9BQU8sSUFBSUEsV0FBSixDQUFnQi9xQixPQUFoQixDQUFQO0FBQ3BDZ3JCLEVBQUFBLFNBQVMsQ0FBQ25xQixJQUFWLENBQWUsSUFBZixFQUFxQmIsT0FBckI7QUFDRDs7QUFFRCtxQixXQUFXLENBQUMzdUIsU0FBWixDQUFzQjZ1QixVQUF0QixHQUFtQyxVQUFVQyxLQUFWLEVBQWlCbmQsUUFBakIsRUFBMkJ5QixFQUEzQixFQUErQjtBQUNoRUEsRUFBQUEsRUFBRSxDQUFDLElBQUQsRUFBTzBiLEtBQVAsQ0FBRjtBQUNELENBRkQ7Ozs7Ozs7Ozs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNhOztBQUViNTBCLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUJ3MUIsUUFBakI7QUFDQTs7QUFFQSxJQUFJRCxNQUFKO0FBQ0E7O0FBRUFDLFFBQVEsQ0FBQ2lCLGFBQVQsR0FBeUJBLGFBQXpCO0FBQ0E7O0FBRUEsSUFBSUMsRUFBRSxHQUFHdjJCLG1GQUFUOztBQUVBLElBQUl3MkIsZUFBZSxHQUFHLFNBQVNBLGVBQVQsQ0FBeUJ4RyxPQUF6QixFQUFrQ2hjLElBQWxDLEVBQXdDO0FBQzVELFNBQU9nYyxPQUFPLENBQUNQLFNBQVIsQ0FBa0J6YixJQUFsQixFQUF3QnpKLE1BQS9CO0FBQ0QsQ0FGRDtBQUdBOztBQUVBOzs7QUFHQSxJQUFJa3NCLE1BQU0sR0FBR3oyQixtQkFBTyxDQUFDLHdHQUFELENBQXBCO0FBQ0E7OztBQUdBLElBQUlTLE1BQU0sR0FBR1QsNEVBQWI7O0FBRUEsSUFBSTAyQixhQUFhLEdBQUdDLHFCQUFNLENBQUN6MUIsVUFBUCxJQUFxQixZQUFZLENBQUUsQ0FBdkQ7O0FBRUEsU0FBUzAxQixtQkFBVCxDQUE2QlAsS0FBN0IsRUFBb0M7QUFDbEMsU0FBTzUxQixNQUFNLENBQUNDLElBQVAsQ0FBWTIxQixLQUFaLENBQVA7QUFDRDs7QUFFRCxTQUFTUSxhQUFULENBQXVCaGhCLEdBQXZCLEVBQTRCO0FBQzFCLFNBQU9wVixNQUFNLENBQUM4TyxRQUFQLENBQWdCc0csR0FBaEIsS0FBd0JBLEdBQUcsWUFBWTZnQixhQUE5QztBQUNEO0FBQ0Q7OztBQUdBLElBQUlJLFNBQVMsR0FBRzkyQixtQkFBTyxDQUFDLG1CQUFELENBQXZCOztBQUVBLElBQUkrMkIsS0FBSjs7QUFFQSxJQUFJRCxTQUFTLElBQUlBLFNBQVMsQ0FBQ0UsUUFBM0IsRUFBcUM7QUFDbkNELEVBQUFBLEtBQUssR0FBR0QsU0FBUyxDQUFDRSxRQUFWLENBQW1CLFFBQW5CLENBQVI7QUFDRCxDQUZELE1BRU87QUFDTEQsRUFBQUEsS0FBSyxHQUFHLFNBQVNBLEtBQVQsR0FBaUIsQ0FBRSxDQUEzQjtBQUNEO0FBQ0Q7OztBQUdBLElBQUlFLFVBQVUsR0FBR2ozQixtQkFBTyxDQUFDLDBHQUFELENBQXhCOztBQUVBLElBQUlrM0IsV0FBVyxHQUFHbDNCLG1CQUFPLENBQUMsa0dBQUQsQ0FBekI7O0FBRUEsSUFBSW0zQixRQUFRLEdBQUduM0IsbUJBQU8sQ0FBQyw4RkFBRCxDQUF0QjtBQUFBLElBQ0lvM0IsZ0JBQWdCLEdBQUdELFFBQVEsQ0FBQ0MsZ0JBRGhDOztBQUdBLElBQUlDLGNBQWMsR0FBR3IzQixnR0FBckI7QUFBQSxJQUNJMnNCLG9CQUFvQixHQUFHMEssY0FBYyxDQUFDMUssb0JBRDFDO0FBQUEsSUFFSTJLLHlCQUF5QixHQUFHRCxjQUFjLENBQUNDLHlCQUYvQztBQUFBLElBR0lDLDBCQUEwQixHQUFHRixjQUFjLENBQUNFLDBCQUhoRDtBQUFBLElBSUlDLGtDQUFrQyxHQUFHSCxjQUFjLENBQUNHLGtDQUp4RCxFQUk0Rjs7O0FBRzVGLElBQUlDLGFBQUo7QUFDQSxJQUFJQyxpQ0FBSjtBQUNBLElBQUloM0IsSUFBSjs7QUFFQVYsbUJBQU8sQ0FBQyw2REFBRCxDQUFQLENBQW9CcTFCLFFBQXBCLEVBQThCb0IsTUFBOUI7O0FBRUEsSUFBSWtCLGNBQWMsR0FBR1QsV0FBVyxDQUFDUyxjQUFqQztBQUNBLElBQUlDLFlBQVksR0FBRyxDQUFDLE9BQUQsRUFBVSxPQUFWLEVBQW1CLFNBQW5CLEVBQThCLE9BQTlCLEVBQXVDLFFBQXZDLENBQW5COztBQUVBLFNBQVN4SCxlQUFULENBQXlCSixPQUF6QixFQUFrQzZILEtBQWxDLEVBQXlDdnNCLEVBQXpDLEVBQTZDO0FBQzNDO0FBQ0E7QUFDQSxNQUFJLE9BQU8wa0IsT0FBTyxDQUFDSSxlQUFmLEtBQW1DLFVBQXZDLEVBQW1ELE9BQU9KLE9BQU8sQ0FBQ0ksZUFBUixDQUF3QnlILEtBQXhCLEVBQStCdnNCLEVBQS9CLENBQVAsQ0FIUixDQUdtRDtBQUM5RjtBQUNBO0FBQ0E7O0FBRUEsTUFBSSxDQUFDMGtCLE9BQU8sQ0FBQ3RCLE9BQVQsSUFBb0IsQ0FBQ3NCLE9BQU8sQ0FBQ3RCLE9BQVIsQ0FBZ0JtSixLQUFoQixDQUF6QixFQUFpRDdILE9BQU8sQ0FBQ0csRUFBUixDQUFXMEgsS0FBWCxFQUFrQnZzQixFQUFsQixFQUFqRCxLQUE0RSxJQUFJbEIsS0FBSyxDQUFDc0QsT0FBTixDQUFjc2lCLE9BQU8sQ0FBQ3RCLE9BQVIsQ0FBZ0JtSixLQUFoQixDQUFkLENBQUosRUFBMkM3SCxPQUFPLENBQUN0QixPQUFSLENBQWdCbUosS0FBaEIsRUFBdUJodUIsT0FBdkIsQ0FBK0J5QixFQUEvQixFQUEzQyxLQUFtRjBrQixPQUFPLENBQUN0QixPQUFSLENBQWdCbUosS0FBaEIsSUFBeUIsQ0FBQ3ZzQixFQUFELEVBQUswa0IsT0FBTyxDQUFDdEIsT0FBUixDQUFnQm1KLEtBQWhCLENBQUwsQ0FBekI7QUFDaEs7O0FBRUQsU0FBU3ZCLGFBQVQsQ0FBdUJuckIsT0FBdkIsRUFBZ0Myc0IsTUFBaEMsRUFBd0NDLFFBQXhDLEVBQWtEO0FBQ2hEM0MsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLElBQUlwMUIsbUJBQU8sQ0FBQyw4RUFBRCxDQUExQjtBQUNBbUwsRUFBQUEsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckIsQ0FGZ0QsQ0FFdkI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSSxPQUFPNHNCLFFBQVAsS0FBb0IsU0FBeEIsRUFBbUNBLFFBQVEsR0FBR0QsTUFBTSxZQUFZMUMsTUFBN0IsQ0FSYSxDQVF3QjtBQUN4RTs7QUFFQSxPQUFLNEMsVUFBTCxHQUFrQixDQUFDLENBQUM3c0IsT0FBTyxDQUFDNnNCLFVBQTVCO0FBQ0EsTUFBSUQsUUFBSixFQUFjLEtBQUtDLFVBQUwsR0FBa0IsS0FBS0EsVUFBTCxJQUFtQixDQUFDLENBQUM3c0IsT0FBTyxDQUFDOHNCLGtCQUEvQyxDQVprQyxDQVlpQztBQUNqRjs7QUFFQSxPQUFLdEMsYUFBTCxHQUFxQnlCLGdCQUFnQixDQUFDLElBQUQsRUFBT2pzQixPQUFQLEVBQWdCLHVCQUFoQixFQUF5QzRzQixRQUF6QyxDQUFyQyxDQWZnRCxDQWV5QztBQUN6RjtBQUNBOztBQUVBLE9BQUtub0IsTUFBTCxHQUFjLElBQUlxbkIsVUFBSixFQUFkO0FBQ0EsT0FBSzFzQixNQUFMLEdBQWMsQ0FBZDtBQUNBLE9BQUsydEIsS0FBTCxHQUFhLElBQWI7QUFDQSxPQUFLQyxVQUFMLEdBQWtCLENBQWxCO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLdkMsS0FBTCxHQUFhLEtBQWI7QUFDQSxPQUFLd0MsVUFBTCxHQUFrQixLQUFsQjtBQUNBLE9BQUtDLE9BQUwsR0FBZSxLQUFmLENBMUJnRCxDQTBCMUI7QUFDdEI7QUFDQTtBQUNBOztBQUVBLE9BQUtDLElBQUwsR0FBWSxJQUFaLENBL0JnRCxDQStCOUI7QUFDbEI7O0FBRUEsT0FBS0MsWUFBTCxHQUFvQixLQUFwQjtBQUNBLE9BQUtDLGVBQUwsR0FBdUIsS0FBdkI7QUFDQSxPQUFLQyxpQkFBTCxHQUF5QixLQUF6QjtBQUNBLE9BQUtDLGVBQUwsR0FBdUIsS0FBdkI7QUFDQSxPQUFLQyxNQUFMLEdBQWMsSUFBZCxDQXRDZ0QsQ0FzQzVCOztBQUVwQixPQUFLQyxTQUFMLEdBQWlCMXRCLE9BQU8sQ0FBQzB0QixTQUFSLEtBQXNCLEtBQXZDLENBeENnRCxDQXdDRjs7QUFFOUMsT0FBS0MsV0FBTCxHQUFtQixDQUFDLENBQUMzdEIsT0FBTyxDQUFDMnRCLFdBQTdCLENBMUNnRCxDQTBDTjs7QUFFMUMsT0FBSzdDLFNBQUwsR0FBaUIsS0FBakIsQ0E1Q2dELENBNEN4QjtBQUN4QjtBQUNBOztBQUVBLE9BQUs4QyxlQUFMLEdBQXVCNXRCLE9BQU8sQ0FBQzR0QixlQUFSLElBQTJCLE1BQWxELENBaERnRCxDQWdEVTs7QUFFMUQsT0FBS0MsVUFBTCxHQUFrQixDQUFsQixDQWxEZ0QsQ0FrRDNCOztBQUVyQixPQUFLQyxXQUFMLEdBQW1CLEtBQW5CO0FBQ0EsT0FBS0MsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLaGdCLFFBQUwsR0FBZ0IsSUFBaEI7O0FBRUEsTUFBSS9OLE9BQU8sQ0FBQytOLFFBQVosRUFBc0I7QUFDcEIsUUFBSSxDQUFDdWUsYUFBTCxFQUFvQkEsYUFBYSxHQUFHejNCLGlIQUFoQjtBQUNwQixTQUFLazVCLE9BQUwsR0FBZSxJQUFJekIsYUFBSixDQUFrQnRzQixPQUFPLENBQUMrTixRQUExQixDQUFmO0FBQ0EsU0FBS0EsUUFBTCxHQUFnQi9OLE9BQU8sQ0FBQytOLFFBQXhCO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbWMsUUFBVCxDQUFrQmxxQixPQUFsQixFQUEyQjtBQUN6QmlxQixFQUFBQSxNQUFNLEdBQUdBLE1BQU0sSUFBSXAxQixtQkFBTyxDQUFDLDhFQUFELENBQTFCO0FBQ0EsTUFBSSxFQUFFLGdCQUFnQnExQixRQUFsQixDQUFKLEVBQWlDLE9BQU8sSUFBSUEsUUFBSixDQUFhbHFCLE9BQWIsQ0FBUCxDQUZSLENBRXNDO0FBQy9EOztBQUVBLE1BQUk0c0IsUUFBUSxHQUFHLGdCQUFnQjNDLE1BQS9CO0FBQ0EsT0FBS1ksY0FBTCxHQUFzQixJQUFJTSxhQUFKLENBQWtCbnJCLE9BQWxCLEVBQTJCLElBQTNCLEVBQWlDNHNCLFFBQWpDLENBQXRCLENBTnlCLENBTXlDOztBQUVsRSxPQUFLdkMsUUFBTCxHQUFnQixJQUFoQjs7QUFFQSxNQUFJcnFCLE9BQUosRUFBYTtBQUNYLFFBQUksT0FBT0EsT0FBTyxDQUFDeEYsSUFBZixLQUF3QixVQUE1QixFQUF3QyxLQUFLd3pCLEtBQUwsR0FBYWh1QixPQUFPLENBQUN4RixJQUFyQjtBQUN4QyxRQUFJLE9BQU93RixPQUFPLENBQUNpdUIsT0FBZixLQUEyQixVQUEvQixFQUEyQyxLQUFLQyxRQUFMLEdBQWdCbHVCLE9BQU8sQ0FBQ2l1QixPQUF4QjtBQUM1Qzs7QUFFRDNDLEVBQUFBLE1BQU0sQ0FBQ3pxQixJQUFQLENBQVksSUFBWjtBQUNEOztBQUVEck0sTUFBTSxDQUFDQyxjQUFQLENBQXNCeTFCLFFBQVEsQ0FBQzl0QixTQUEvQixFQUEwQyxXQUExQyxFQUF1RDtBQUNyRDtBQUNBO0FBQ0E7QUFDQWtaLEVBQUFBLFVBQVUsRUFBRSxLQUp5QztBQUtyREMsRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixRQUFJLEtBQUtzVixjQUFMLEtBQXdCcHdCLFNBQTVCLEVBQXVDO0FBQ3JDLGFBQU8sS0FBUDtBQUNEOztBQUVELFdBQU8sS0FBS293QixjQUFMLENBQW9CQyxTQUEzQjtBQUNELEdBWG9EO0FBWXJEdlosRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsQ0FBYTVjLEtBQWIsRUFBb0I7QUFDdkI7QUFDQTtBQUNBLFFBQUksQ0FBQyxLQUFLazJCLGNBQVYsRUFBMEI7QUFDeEI7QUFDRCxLQUxzQixDQUtyQjtBQUNGOzs7QUFHQSxTQUFLQSxjQUFMLENBQW9CQyxTQUFwQixHQUFnQ24yQixLQUFoQztBQUNEO0FBdEJvRCxDQUF2RDtBQXdCQXUxQixRQUFRLENBQUM5dEIsU0FBVCxDQUFtQjZ4QixPQUFuQixHQUE2QmxDLFdBQVcsQ0FBQ2tDLE9BQXpDO0FBQ0EvRCxRQUFRLENBQUM5dEIsU0FBVCxDQUFtQit4QixVQUFuQixHQUFnQ3BDLFdBQVcsQ0FBQ3FDLFNBQTVDOztBQUVBbEUsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUI4eEIsUUFBbkIsR0FBOEIsVUFBVXJlLEdBQVYsRUFBZUwsRUFBZixFQUFtQjtBQUMvQ0EsRUFBQUEsRUFBRSxDQUFDSyxHQUFELENBQUY7QUFDRCxDQUZELEVBRUc7QUFDSDtBQUNBO0FBQ0E7OztBQUdBcWEsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUIyQyxJQUFuQixHQUEwQixVQUFVbXNCLEtBQVYsRUFBaUJuZCxRQUFqQixFQUEyQjtBQUNuRCxNQUFJd1gsS0FBSyxHQUFHLEtBQUtzRixjQUFqQjtBQUNBLE1BQUl3RCxjQUFKOztBQUVBLE1BQUksQ0FBQzlJLEtBQUssQ0FBQ3NILFVBQVgsRUFBdUI7QUFDckIsUUFBSSxPQUFPM0IsS0FBUCxLQUFpQixRQUFyQixFQUErQjtBQUM3Qm5kLE1BQUFBLFFBQVEsR0FBR0EsUUFBUSxJQUFJd1gsS0FBSyxDQUFDcUksZUFBN0I7O0FBRUEsVUFBSTdmLFFBQVEsS0FBS3dYLEtBQUssQ0FBQ3hYLFFBQXZCLEVBQWlDO0FBQy9CbWQsUUFBQUEsS0FBSyxHQUFHNTFCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZMjFCLEtBQVosRUFBbUJuZCxRQUFuQixDQUFSO0FBQ0FBLFFBQUFBLFFBQVEsR0FBRyxFQUFYO0FBQ0Q7O0FBRURzZ0IsTUFBQUEsY0FBYyxHQUFHLElBQWpCO0FBQ0Q7QUFDRixHQVhELE1BV087QUFDTEEsSUFBQUEsY0FBYyxHQUFHLElBQWpCO0FBQ0Q7O0FBRUQsU0FBT0MsZ0JBQWdCLENBQUMsSUFBRCxFQUFPcEQsS0FBUCxFQUFjbmQsUUFBZCxFQUF3QixLQUF4QixFQUErQnNnQixjQUEvQixDQUF2QjtBQUNELENBcEJELEVBb0JHOzs7QUFHSG5FLFFBQVEsQ0FBQzl0QixTQUFULENBQW1Cc0MsT0FBbkIsR0FBNkIsVUFBVXdzQixLQUFWLEVBQWlCO0FBQzVDLFNBQU9vRCxnQkFBZ0IsQ0FBQyxJQUFELEVBQU9wRCxLQUFQLEVBQWMsSUFBZCxFQUFvQixJQUFwQixFQUEwQixLQUExQixDQUF2QjtBQUNELENBRkQ7O0FBSUEsU0FBU29ELGdCQUFULENBQTBCM0IsTUFBMUIsRUFBa0N6QixLQUFsQyxFQUF5Q25kLFFBQXpDLEVBQW1Ed2dCLFVBQW5ELEVBQStERixjQUEvRCxFQUErRTtBQUM3RXpDLEVBQUFBLEtBQUssQ0FBQyxrQkFBRCxFQUFxQlYsS0FBckIsQ0FBTDtBQUNBLE1BQUkzRixLQUFLLEdBQUdvSCxNQUFNLENBQUM5QixjQUFuQjs7QUFFQSxNQUFJSyxLQUFLLEtBQUssSUFBZCxFQUFvQjtBQUNsQjNGLElBQUFBLEtBQUssQ0FBQzRILE9BQU4sR0FBZ0IsS0FBaEI7QUFDQXFCLElBQUFBLFVBQVUsQ0FBQzdCLE1BQUQsRUFBU3BILEtBQVQsQ0FBVjtBQUNELEdBSEQsTUFHTztBQUNMLFFBQUluQixFQUFKO0FBQ0EsUUFBSSxDQUFDaUssY0FBTCxFQUFxQmpLLEVBQUUsR0FBR3FLLFlBQVksQ0FBQ2xKLEtBQUQsRUFBUTJGLEtBQVIsQ0FBakI7O0FBRXJCLFFBQUk5RyxFQUFKLEVBQVE7QUFDTm9JLE1BQUFBLGNBQWMsQ0FBQ0csTUFBRCxFQUFTdkksRUFBVCxDQUFkO0FBQ0QsS0FGRCxNQUVPLElBQUltQixLQUFLLENBQUNzSCxVQUFOLElBQW9CM0IsS0FBSyxJQUFJQSxLQUFLLENBQUM5ckIsTUFBTixHQUFlLENBQWhELEVBQW1EO0FBQ3hELFVBQUksT0FBTzhyQixLQUFQLEtBQWlCLFFBQWpCLElBQTZCLENBQUMzRixLQUFLLENBQUNzSCxVQUFwQyxJQUFrRHI0QixNQUFNLENBQUM0VixjQUFQLENBQXNCOGdCLEtBQXRCLE1BQWlDNTFCLE1BQU0sQ0FBQzhHLFNBQTlGLEVBQXlHO0FBQ3ZHOHVCLFFBQUFBLEtBQUssR0FBR08sbUJBQW1CLENBQUNQLEtBQUQsQ0FBM0I7QUFDRDs7QUFFRCxVQUFJcUQsVUFBSixFQUFnQjtBQUNkLFlBQUloSixLQUFLLENBQUMySCxVQUFWLEVBQXNCVixjQUFjLENBQUNHLE1BQUQsRUFBUyxJQUFJTixrQ0FBSixFQUFULENBQWQsQ0FBdEIsS0FBNEZxQyxRQUFRLENBQUMvQixNQUFELEVBQVNwSCxLQUFULEVBQWdCMkYsS0FBaEIsRUFBdUIsSUFBdkIsQ0FBUjtBQUM3RixPQUZELE1BRU8sSUFBSTNGLEtBQUssQ0FBQ21GLEtBQVYsRUFBaUI7QUFDdEI4QixRQUFBQSxjQUFjLENBQUNHLE1BQUQsRUFBUyxJQUFJUix5QkFBSixFQUFULENBQWQ7QUFDRCxPQUZNLE1BRUEsSUFBSTVHLEtBQUssQ0FBQ3VGLFNBQVYsRUFBcUI7QUFDMUIsZUFBTyxLQUFQO0FBQ0QsT0FGTSxNQUVBO0FBQ0x2RixRQUFBQSxLQUFLLENBQUM0SCxPQUFOLEdBQWdCLEtBQWhCOztBQUVBLFlBQUk1SCxLQUFLLENBQUN3SSxPQUFOLElBQWlCLENBQUNoZ0IsUUFBdEIsRUFBZ0M7QUFDOUJtZCxVQUFBQSxLQUFLLEdBQUczRixLQUFLLENBQUN3SSxPQUFOLENBQWNqb0IsS0FBZCxDQUFvQm9sQixLQUFwQixDQUFSO0FBQ0EsY0FBSTNGLEtBQUssQ0FBQ3NILFVBQU4sSUFBb0IzQixLQUFLLENBQUM5ckIsTUFBTixLQUFpQixDQUF6QyxFQUE0Q3N2QixRQUFRLENBQUMvQixNQUFELEVBQVNwSCxLQUFULEVBQWdCMkYsS0FBaEIsRUFBdUIsS0FBdkIsQ0FBUixDQUE1QyxLQUF1RnlELGFBQWEsQ0FBQ2hDLE1BQUQsRUFBU3BILEtBQVQsQ0FBYjtBQUN4RixTQUhELE1BR087QUFDTG1KLFVBQUFBLFFBQVEsQ0FBQy9CLE1BQUQsRUFBU3BILEtBQVQsRUFBZ0IyRixLQUFoQixFQUF1QixLQUF2QixDQUFSO0FBQ0Q7QUFDRjtBQUNGLEtBckJNLE1BcUJBLElBQUksQ0FBQ3FELFVBQUwsRUFBaUI7QUFDdEJoSixNQUFBQSxLQUFLLENBQUM0SCxPQUFOLEdBQWdCLEtBQWhCO0FBQ0F3QixNQUFBQSxhQUFhLENBQUNoQyxNQUFELEVBQVNwSCxLQUFULENBQWI7QUFDRDtBQUNGLEdBdEM0RSxDQXNDM0U7QUFDRjtBQUNBOzs7QUFHQSxTQUFPLENBQUNBLEtBQUssQ0FBQ21GLEtBQVAsS0FBaUJuRixLQUFLLENBQUNubUIsTUFBTixHQUFlbW1CLEtBQUssQ0FBQ2lGLGFBQXJCLElBQXNDakYsS0FBSyxDQUFDbm1CLE1BQU4sS0FBaUIsQ0FBeEUsQ0FBUDtBQUNEOztBQUVELFNBQVNzdkIsUUFBVCxDQUFrQi9CLE1BQWxCLEVBQTBCcEgsS0FBMUIsRUFBaUMyRixLQUFqQyxFQUF3Q3FELFVBQXhDLEVBQW9EO0FBQ2xELE1BQUloSixLQUFLLENBQUMwSCxPQUFOLElBQWlCMUgsS0FBSyxDQUFDbm1CLE1BQU4sS0FBaUIsQ0FBbEMsSUFBdUMsQ0FBQ21tQixLQUFLLENBQUM2SCxJQUFsRCxFQUF3RDtBQUN0RDdILElBQUFBLEtBQUssQ0FBQ3NJLFVBQU4sR0FBbUIsQ0FBbkI7QUFDQWxCLElBQUFBLE1BQU0sQ0FBQzFJLElBQVAsQ0FBWSxNQUFaLEVBQW9CaUgsS0FBcEI7QUFDRCxHQUhELE1BR087QUFDTDtBQUNBM0YsSUFBQUEsS0FBSyxDQUFDbm1CLE1BQU4sSUFBZ0JtbUIsS0FBSyxDQUFDc0gsVUFBTixHQUFtQixDQUFuQixHQUF1QjNCLEtBQUssQ0FBQzlyQixNQUE3QztBQUNBLFFBQUltdkIsVUFBSixFQUFnQmhKLEtBQUssQ0FBQzlnQixNQUFOLENBQWEvRixPQUFiLENBQXFCd3NCLEtBQXJCLEVBQWhCLEtBQWlEM0YsS0FBSyxDQUFDOWdCLE1BQU4sQ0FBYTFGLElBQWIsQ0FBa0Jtc0IsS0FBbEI7QUFDakQsUUFBSTNGLEtBQUssQ0FBQzhILFlBQVYsRUFBd0J1QixZQUFZLENBQUNqQyxNQUFELENBQVo7QUFDekI7O0FBRURnQyxFQUFBQSxhQUFhLENBQUNoQyxNQUFELEVBQVNwSCxLQUFULENBQWI7QUFDRDs7QUFFRCxTQUFTa0osWUFBVCxDQUFzQmxKLEtBQXRCLEVBQTZCMkYsS0FBN0IsRUFBb0M7QUFDbEMsTUFBSTlHLEVBQUo7O0FBRUEsTUFBSSxDQUFDc0gsYUFBYSxDQUFDUixLQUFELENBQWQsSUFBeUIsT0FBT0EsS0FBUCxLQUFpQixRQUExQyxJQUFzREEsS0FBSyxLQUFLendCLFNBQWhFLElBQTZFLENBQUM4cUIsS0FBSyxDQUFDc0gsVUFBeEYsRUFBb0c7QUFDbEd6SSxJQUFBQSxFQUFFLEdBQUcsSUFBSTVDLG9CQUFKLENBQXlCLE9BQXpCLEVBQWtDLENBQUMsUUFBRCxFQUFXLFFBQVgsRUFBcUIsWUFBckIsQ0FBbEMsRUFBc0UwSixLQUF0RSxDQUFMO0FBQ0Q7O0FBRUQsU0FBTzlHLEVBQVA7QUFDRDs7QUFFRDhGLFFBQVEsQ0FBQzl0QixTQUFULENBQW1CeXlCLFFBQW5CLEdBQThCLFlBQVk7QUFDeEMsU0FBTyxLQUFLaEUsY0FBTCxDQUFvQm9DLE9BQXBCLEtBQWdDLEtBQXZDO0FBQ0QsQ0FGRCxFQUVHOzs7QUFHSC9DLFFBQVEsQ0FBQzl0QixTQUFULENBQW1CMHlCLFdBQW5CLEdBQWlDLFVBQVVuZCxHQUFWLEVBQWU7QUFDOUMsTUFBSSxDQUFDMmEsYUFBTCxFQUFvQkEsYUFBYSxHQUFHejNCLGlIQUFoQjtBQUNwQixNQUFJazVCLE9BQU8sR0FBRyxJQUFJekIsYUFBSixDQUFrQjNhLEdBQWxCLENBQWQ7QUFDQSxPQUFLa1osY0FBTCxDQUFvQmtELE9BQXBCLEdBQThCQSxPQUE5QixDQUg4QyxDQUdQOztBQUV2QyxPQUFLbEQsY0FBTCxDQUFvQjljLFFBQXBCLEdBQStCLEtBQUs4YyxjQUFMLENBQW9Ca0QsT0FBcEIsQ0FBNEJoZ0IsUUFBM0QsQ0FMOEMsQ0FLdUI7O0FBRXJFLE1BQUlrRSxDQUFDLEdBQUcsS0FBSzRZLGNBQUwsQ0FBb0JwbUIsTUFBcEIsQ0FBMkIyTCxJQUFuQztBQUNBLE1BQUluRixPQUFPLEdBQUcsRUFBZDs7QUFFQSxTQUFPZ0gsQ0FBQyxLQUFLLElBQWIsRUFBbUI7QUFDakJoSCxJQUFBQSxPQUFPLElBQUk4aUIsT0FBTyxDQUFDam9CLEtBQVIsQ0FBY21NLENBQUMsQ0FBQzNhLElBQWhCLENBQVg7QUFDQTJhLElBQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDOGMsSUFBTjtBQUNEOztBQUVELE9BQUtsRSxjQUFMLENBQW9CcG1CLE1BQXBCLENBQTJCdXFCLEtBQTNCOztBQUVBLE1BQUkvakIsT0FBTyxLQUFLLEVBQWhCLEVBQW9CLEtBQUs0ZixjQUFMLENBQW9CcG1CLE1BQXBCLENBQTJCMUYsSUFBM0IsQ0FBZ0NrTSxPQUFoQztBQUNwQixPQUFLNGYsY0FBTCxDQUFvQnpyQixNQUFwQixHQUE2QjZMLE9BQU8sQ0FBQzdMLE1BQXJDO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FwQkQsRUFvQkc7OztBQUdILElBQUk2dkIsT0FBTyxHQUFHLFVBQWQ7O0FBRUEsU0FBU0MsdUJBQVQsQ0FBaUM5YyxDQUFqQyxFQUFvQztBQUNsQyxNQUFJQSxDQUFDLElBQUk2YyxPQUFULEVBQWtCO0FBQ2hCO0FBQ0E3YyxJQUFBQSxDQUFDLEdBQUc2YyxPQUFKO0FBQ0QsR0FIRCxNQUdPO0FBQ0w7QUFDQTtBQUNBN2MsSUFBQUEsQ0FBQztBQUNEQSxJQUFBQSxDQUFDLElBQUlBLENBQUMsS0FBSyxDQUFYO0FBQ0FBLElBQUFBLENBQUMsSUFBSUEsQ0FBQyxLQUFLLENBQVg7QUFDQUEsSUFBQUEsQ0FBQyxJQUFJQSxDQUFDLEtBQUssQ0FBWDtBQUNBQSxJQUFBQSxDQUFDLElBQUlBLENBQUMsS0FBSyxDQUFYO0FBQ0FBLElBQUFBLENBQUMsSUFBSUEsQ0FBQyxLQUFLLEVBQVg7QUFDQUEsSUFBQUEsQ0FBQztBQUNGOztBQUVELFNBQU9BLENBQVA7QUFDRCxFQUFDO0FBQ0Y7OztBQUdBLFNBQVMrYyxhQUFULENBQXVCL2MsQ0FBdkIsRUFBMEJtVCxLQUExQixFQUFpQztBQUMvQixNQUFJblQsQ0FBQyxJQUFJLENBQUwsSUFBVW1ULEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQWpCLElBQXNCbW1CLEtBQUssQ0FBQ21GLEtBQTFDLEVBQWlELE9BQU8sQ0FBUDtBQUNqRCxNQUFJbkYsS0FBSyxDQUFDc0gsVUFBVixFQUFzQixPQUFPLENBQVA7O0FBRXRCLE1BQUl6YSxDQUFDLEtBQUtBLENBQVYsRUFBYTtBQUNYO0FBQ0EsUUFBSW1ULEtBQUssQ0FBQzBILE9BQU4sSUFBaUIxSCxLQUFLLENBQUNubUIsTUFBM0IsRUFBbUMsT0FBT21tQixLQUFLLENBQUM5Z0IsTUFBTixDQUFhMkwsSUFBYixDQUFrQjlZLElBQWxCLENBQXVCOEgsTUFBOUIsQ0FBbkMsS0FBNkUsT0FBT21tQixLQUFLLENBQUNubUIsTUFBYjtBQUM5RSxHQVA4QixDQU83Qjs7O0FBR0YsTUFBSWdULENBQUMsR0FBR21ULEtBQUssQ0FBQ2lGLGFBQWQsRUFBNkJqRixLQUFLLENBQUNpRixhQUFOLEdBQXNCMEUsdUJBQXVCLENBQUM5YyxDQUFELENBQTdDO0FBQzdCLE1BQUlBLENBQUMsSUFBSW1ULEtBQUssQ0FBQ25tQixNQUFmLEVBQXVCLE9BQU9nVCxDQUFQLENBWFEsQ0FXRTs7QUFFakMsTUFBSSxDQUFDbVQsS0FBSyxDQUFDbUYsS0FBWCxFQUFrQjtBQUNoQm5GLElBQUFBLEtBQUssQ0FBQzhILFlBQU4sR0FBcUIsSUFBckI7QUFDQSxXQUFPLENBQVA7QUFDRDs7QUFFRCxTQUFPOUgsS0FBSyxDQUFDbm1CLE1BQWI7QUFDRCxFQUFDOzs7QUFHRjhxQixRQUFRLENBQUM5dEIsU0FBVCxDQUFtQjVCLElBQW5CLEdBQTBCLFVBQVU0WCxDQUFWLEVBQWE7QUFDckN3WixFQUFBQSxLQUFLLENBQUMsTUFBRCxFQUFTeFosQ0FBVCxDQUFMO0FBQ0FBLEVBQUFBLENBQUMsR0FBRzRILFFBQVEsQ0FBQzVILENBQUQsRUFBSSxFQUFKLENBQVo7QUFDQSxNQUFJbVQsS0FBSyxHQUFHLEtBQUtzRixjQUFqQjtBQUNBLE1BQUl1RSxLQUFLLEdBQUdoZCxDQUFaO0FBQ0EsTUFBSUEsQ0FBQyxLQUFLLENBQVYsRUFBYW1ULEtBQUssQ0FBQytILGVBQU4sR0FBd0IsS0FBeEIsQ0FMd0IsQ0FLTztBQUM1QztBQUNBOztBQUVBLE1BQUlsYixDQUFDLEtBQUssQ0FBTixJQUFXbVQsS0FBSyxDQUFDOEgsWUFBakIsS0FBa0MsQ0FBQzlILEtBQUssQ0FBQ2lGLGFBQU4sS0FBd0IsQ0FBeEIsR0FBNEJqRixLQUFLLENBQUNubUIsTUFBTixJQUFnQm1tQixLQUFLLENBQUNpRixhQUFsRCxHQUFrRWpGLEtBQUssQ0FBQ25tQixNQUFOLEdBQWUsQ0FBbEYsS0FBd0ZtbUIsS0FBSyxDQUFDbUYsS0FBaEksQ0FBSixFQUE0STtBQUMxSWtCLElBQUFBLEtBQUssQ0FBQyxvQkFBRCxFQUF1QnJHLEtBQUssQ0FBQ25tQixNQUE3QixFQUFxQ21tQixLQUFLLENBQUNtRixLQUEzQyxDQUFMO0FBQ0EsUUFBSW5GLEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQWpCLElBQXNCbW1CLEtBQUssQ0FBQ21GLEtBQWhDLEVBQXVDMkUsV0FBVyxDQUFDLElBQUQsQ0FBWCxDQUF2QyxLQUE4RFQsWUFBWSxDQUFDLElBQUQsQ0FBWjtBQUM5RCxXQUFPLElBQVA7QUFDRDs7QUFFRHhjLEVBQUFBLENBQUMsR0FBRytjLGFBQWEsQ0FBQy9jLENBQUQsRUFBSW1ULEtBQUosQ0FBakIsQ0FmcUMsQ0FlUjs7QUFFN0IsTUFBSW5ULENBQUMsS0FBSyxDQUFOLElBQVdtVCxLQUFLLENBQUNtRixLQUFyQixFQUE0QjtBQUMxQixRQUFJbkYsS0FBSyxDQUFDbm1CLE1BQU4sS0FBaUIsQ0FBckIsRUFBd0Jpd0IsV0FBVyxDQUFDLElBQUQsQ0FBWDtBQUN4QixXQUFPLElBQVA7QUFDRCxHQXBCb0MsQ0FvQm5DO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQSxNQUFJQyxNQUFNLEdBQUcvSixLQUFLLENBQUM4SCxZQUFuQjtBQUNBekIsRUFBQUEsS0FBSyxDQUFDLGVBQUQsRUFBa0IwRCxNQUFsQixDQUFMLENBN0NxQyxDQTZDTDs7QUFFaEMsTUFBSS9KLEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQWpCLElBQXNCbW1CLEtBQUssQ0FBQ25tQixNQUFOLEdBQWVnVCxDQUFmLEdBQW1CbVQsS0FBSyxDQUFDaUYsYUFBbkQsRUFBa0U7QUFDaEU4RSxJQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNBMUQsSUFBQUEsS0FBSyxDQUFDLDRCQUFELEVBQStCMEQsTUFBL0IsQ0FBTDtBQUNELEdBbERvQyxDQWtEbkM7QUFDRjs7O0FBR0EsTUFBSS9KLEtBQUssQ0FBQ21GLEtBQU4sSUFBZW5GLEtBQUssQ0FBQzRILE9BQXpCLEVBQWtDO0FBQ2hDbUMsSUFBQUEsTUFBTSxHQUFHLEtBQVQ7QUFDQTFELElBQUFBLEtBQUssQ0FBQyxrQkFBRCxFQUFxQjBELE1BQXJCLENBQUw7QUFDRCxHQUhELE1BR08sSUFBSUEsTUFBSixFQUFZO0FBQ2pCMUQsSUFBQUEsS0FBSyxDQUFDLFNBQUQsQ0FBTDtBQUNBckcsSUFBQUEsS0FBSyxDQUFDNEgsT0FBTixHQUFnQixJQUFoQjtBQUNBNUgsSUFBQUEsS0FBSyxDQUFDNkgsSUFBTixHQUFhLElBQWIsQ0FIaUIsQ0FHRTs7QUFFbkIsUUFBSTdILEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQXJCLEVBQXdCbW1CLEtBQUssQ0FBQzhILFlBQU4sR0FBcUIsSUFBckIsQ0FMUCxDQUtrQzs7QUFFbkQsU0FBS1csS0FBTCxDQUFXekksS0FBSyxDQUFDaUYsYUFBakI7O0FBRUFqRixJQUFBQSxLQUFLLENBQUM2SCxJQUFOLEdBQWEsS0FBYixDQVRpQixDQVNHO0FBQ3BCOztBQUVBLFFBQUksQ0FBQzdILEtBQUssQ0FBQzRILE9BQVgsRUFBb0IvYSxDQUFDLEdBQUcrYyxhQUFhLENBQUNDLEtBQUQsRUFBUTdKLEtBQVIsQ0FBakI7QUFDckI7O0FBRUQsTUFBSWxLLEdBQUo7QUFDQSxNQUFJakosQ0FBQyxHQUFHLENBQVIsRUFBV2lKLEdBQUcsR0FBR2tVLFFBQVEsQ0FBQ25kLENBQUQsRUFBSW1ULEtBQUosQ0FBZCxDQUFYLEtBQXlDbEssR0FBRyxHQUFHLElBQU47O0FBRXpDLE1BQUlBLEdBQUcsS0FBSyxJQUFaLEVBQWtCO0FBQ2hCa0ssSUFBQUEsS0FBSyxDQUFDOEgsWUFBTixHQUFxQjlILEtBQUssQ0FBQ25tQixNQUFOLElBQWdCbW1CLEtBQUssQ0FBQ2lGLGFBQTNDO0FBQ0FwWSxJQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNELEdBSEQsTUFHTztBQUNMbVQsSUFBQUEsS0FBSyxDQUFDbm1CLE1BQU4sSUFBZ0JnVCxDQUFoQjtBQUNBbVQsSUFBQUEsS0FBSyxDQUFDc0ksVUFBTixHQUFtQixDQUFuQjtBQUNEOztBQUVELE1BQUl0SSxLQUFLLENBQUNubUIsTUFBTixLQUFpQixDQUFyQixFQUF3QjtBQUN0QjtBQUNBO0FBQ0EsUUFBSSxDQUFDbW1CLEtBQUssQ0FBQ21GLEtBQVgsRUFBa0JuRixLQUFLLENBQUM4SCxZQUFOLEdBQXFCLElBQXJCLENBSEksQ0FHdUI7O0FBRTdDLFFBQUkrQixLQUFLLEtBQUtoZCxDQUFWLElBQWVtVCxLQUFLLENBQUNtRixLQUF6QixFQUFnQzJFLFdBQVcsQ0FBQyxJQUFELENBQVg7QUFDakM7O0FBRUQsTUFBSWhVLEdBQUcsS0FBSyxJQUFaLEVBQWtCLEtBQUs0SSxJQUFMLENBQVUsTUFBVixFQUFrQjVJLEdBQWxCO0FBQ2xCLFNBQU9BLEdBQVA7QUFDRCxDQTdGRDs7QUErRkEsU0FBU21ULFVBQVQsQ0FBb0I3QixNQUFwQixFQUE0QnBILEtBQTVCLEVBQW1DO0FBQ2pDcUcsRUFBQUEsS0FBSyxDQUFDLFlBQUQsQ0FBTDtBQUNBLE1BQUlyRyxLQUFLLENBQUNtRixLQUFWLEVBQWlCOztBQUVqQixNQUFJbkYsS0FBSyxDQUFDd0ksT0FBVixFQUFtQjtBQUNqQixRQUFJN0MsS0FBSyxHQUFHM0YsS0FBSyxDQUFDd0ksT0FBTixDQUFjeGhCLEdBQWQsRUFBWjs7QUFFQSxRQUFJMmUsS0FBSyxJQUFJQSxLQUFLLENBQUM5ckIsTUFBbkIsRUFBMkI7QUFDekJtbUIsTUFBQUEsS0FBSyxDQUFDOWdCLE1BQU4sQ0FBYTFGLElBQWIsQ0FBa0Jtc0IsS0FBbEI7QUFDQTNGLE1BQUFBLEtBQUssQ0FBQ25tQixNQUFOLElBQWdCbW1CLEtBQUssQ0FBQ3NILFVBQU4sR0FBbUIsQ0FBbkIsR0FBdUIzQixLQUFLLENBQUM5ckIsTUFBN0M7QUFDRDtBQUNGOztBQUVEbW1CLEVBQUFBLEtBQUssQ0FBQ21GLEtBQU4sR0FBYyxJQUFkOztBQUVBLE1BQUluRixLQUFLLENBQUM2SCxJQUFWLEVBQWdCO0FBQ2Q7QUFDQTtBQUNBO0FBQ0F3QixJQUFBQSxZQUFZLENBQUNqQyxNQUFELENBQVo7QUFDRCxHQUxELE1BS087QUFDTDtBQUNBcEgsSUFBQUEsS0FBSyxDQUFDOEgsWUFBTixHQUFxQixLQUFyQjs7QUFFQSxRQUFJLENBQUM5SCxLQUFLLENBQUMrSCxlQUFYLEVBQTRCO0FBQzFCL0gsTUFBQUEsS0FBSyxDQUFDK0gsZUFBTixHQUF3QixJQUF4QjtBQUNBa0MsTUFBQUEsYUFBYSxDQUFDN0MsTUFBRCxDQUFiO0FBQ0Q7QUFDRjtBQUNGLEVBQUM7QUFDRjtBQUNBOzs7QUFHQSxTQUFTaUMsWUFBVCxDQUFzQmpDLE1BQXRCLEVBQThCO0FBQzVCLE1BQUlwSCxLQUFLLEdBQUdvSCxNQUFNLENBQUM5QixjQUFuQjtBQUNBZSxFQUFBQSxLQUFLLENBQUMsY0FBRCxFQUFpQnJHLEtBQUssQ0FBQzhILFlBQXZCLEVBQXFDOUgsS0FBSyxDQUFDK0gsZUFBM0MsQ0FBTDtBQUNBL0gsRUFBQUEsS0FBSyxDQUFDOEgsWUFBTixHQUFxQixLQUFyQjs7QUFFQSxNQUFJLENBQUM5SCxLQUFLLENBQUMrSCxlQUFYLEVBQTRCO0FBQzFCMUIsSUFBQUEsS0FBSyxDQUFDLGNBQUQsRUFBaUJyRyxLQUFLLENBQUMwSCxPQUF2QixDQUFMO0FBQ0ExSCxJQUFBQSxLQUFLLENBQUMrSCxlQUFOLEdBQXdCLElBQXhCO0FBQ0E5cEIsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUI2RSxhQUFqQixFQUFnQzdDLE1BQWhDO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTNkMsYUFBVCxDQUF1QjdDLE1BQXZCLEVBQStCO0FBQzdCLE1BQUlwSCxLQUFLLEdBQUdvSCxNQUFNLENBQUM5QixjQUFuQjtBQUNBZSxFQUFBQSxLQUFLLENBQUMsZUFBRCxFQUFrQnJHLEtBQUssQ0FBQ3VGLFNBQXhCLEVBQW1DdkYsS0FBSyxDQUFDbm1CLE1BQXpDLEVBQWlEbW1CLEtBQUssQ0FBQ21GLEtBQXZELENBQUw7O0FBRUEsTUFBSSxDQUFDbkYsS0FBSyxDQUFDdUYsU0FBUCxLQUFxQnZGLEtBQUssQ0FBQ25tQixNQUFOLElBQWdCbW1CLEtBQUssQ0FBQ21GLEtBQTNDLENBQUosRUFBdUQ7QUFDckRpQyxJQUFBQSxNQUFNLENBQUMxSSxJQUFQLENBQVksVUFBWjtBQUNBc0IsSUFBQUEsS0FBSyxDQUFDK0gsZUFBTixHQUF3QixLQUF4QjtBQUNELEdBUDRCLENBTzNCO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EvSCxFQUFBQSxLQUFLLENBQUM4SCxZQUFOLEdBQXFCLENBQUM5SCxLQUFLLENBQUMwSCxPQUFQLElBQWtCLENBQUMxSCxLQUFLLENBQUNtRixLQUF6QixJQUFrQ25GLEtBQUssQ0FBQ25tQixNQUFOLElBQWdCbW1CLEtBQUssQ0FBQ2lGLGFBQTdFO0FBQ0FpRixFQUFBQSxJQUFJLENBQUM5QyxNQUFELENBQUo7QUFDRCxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsU0FBU2dDLGFBQVQsQ0FBdUJoQyxNQUF2QixFQUErQnBILEtBQS9CLEVBQXNDO0FBQ3BDLE1BQUksQ0FBQ0EsS0FBSyxDQUFDdUksV0FBWCxFQUF3QjtBQUN0QnZJLElBQUFBLEtBQUssQ0FBQ3VJLFdBQU4sR0FBb0IsSUFBcEI7QUFDQXRxQixJQUFBQSxPQUFPLENBQUNtbkIsUUFBUixDQUFpQitFLGNBQWpCLEVBQWlDL0MsTUFBakMsRUFBeUNwSCxLQUF6QztBQUNEO0FBQ0Y7O0FBRUQsU0FBU21LLGNBQVQsQ0FBd0IvQyxNQUF4QixFQUFnQ3BILEtBQWhDLEVBQXVDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFPLENBQUNBLEtBQUssQ0FBQzRILE9BQVAsSUFBa0IsQ0FBQzVILEtBQUssQ0FBQ21GLEtBQXpCLEtBQW1DbkYsS0FBSyxDQUFDbm1CLE1BQU4sR0FBZW1tQixLQUFLLENBQUNpRixhQUFyQixJQUFzQ2pGLEtBQUssQ0FBQzBILE9BQU4sSUFBaUIxSCxLQUFLLENBQUNubUIsTUFBTixLQUFpQixDQUEzRyxDQUFQLEVBQXNIO0FBQ3BILFFBQUlxTSxHQUFHLEdBQUc4WixLQUFLLENBQUNubUIsTUFBaEI7QUFDQXdzQixJQUFBQSxLQUFLLENBQUMsc0JBQUQsQ0FBTDtBQUNBZSxJQUFBQSxNQUFNLENBQUNueUIsSUFBUCxDQUFZLENBQVo7QUFDQSxRQUFJaVIsR0FBRyxLQUFLOFosS0FBSyxDQUFDbm1CLE1BQWxCLEVBQTBCO0FBQ3hCO0FBQ0g7O0FBRURtbUIsRUFBQUEsS0FBSyxDQUFDdUksV0FBTixHQUFvQixLQUFwQjtBQUNELEVBQUM7QUFDRjtBQUNBO0FBQ0E7OztBQUdBNUQsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUI0eEIsS0FBbkIsR0FBMkIsVUFBVTViLENBQVYsRUFBYTtBQUN0Q29hLEVBQUFBLGNBQWMsQ0FBQyxJQUFELEVBQU8sSUFBSUosMEJBQUosQ0FBK0IsU0FBL0IsQ0FBUCxDQUFkO0FBQ0QsQ0FGRDs7QUFJQWxDLFFBQVEsQ0FBQzl0QixTQUFULENBQW1Ca08sSUFBbkIsR0FBMEIsVUFBVXFsQixJQUFWLEVBQWdCQyxRQUFoQixFQUEwQjtBQUNsRCxNQUFJM04sR0FBRyxHQUFHLElBQVY7QUFDQSxNQUFJc0QsS0FBSyxHQUFHLEtBQUtzRixjQUFqQjs7QUFFQSxVQUFRdEYsS0FBSyxDQUFDeUgsVUFBZDtBQUNFLFNBQUssQ0FBTDtBQUNFekgsTUFBQUEsS0FBSyxDQUFDd0gsS0FBTixHQUFjNEMsSUFBZDtBQUNBOztBQUVGLFNBQUssQ0FBTDtBQUNFcEssTUFBQUEsS0FBSyxDQUFDd0gsS0FBTixHQUFjLENBQUN4SCxLQUFLLENBQUN3SCxLQUFQLEVBQWM0QyxJQUFkLENBQWQ7QUFDQTs7QUFFRjtBQUNFcEssTUFBQUEsS0FBSyxDQUFDd0gsS0FBTixDQUFZaHVCLElBQVosQ0FBaUI0d0IsSUFBakI7QUFDQTtBQVhKOztBQWNBcEssRUFBQUEsS0FBSyxDQUFDeUgsVUFBTixJQUFvQixDQUFwQjtBQUNBcEIsRUFBQUEsS0FBSyxDQUFDLHVCQUFELEVBQTBCckcsS0FBSyxDQUFDeUgsVUFBaEMsRUFBNEM0QyxRQUE1QyxDQUFMO0FBQ0EsTUFBSUMsS0FBSyxHQUFHLENBQUMsQ0FBQ0QsUUFBRCxJQUFhQSxRQUFRLENBQUNyakIsR0FBVCxLQUFpQixLQUEvQixLQUF5Q29qQixJQUFJLEtBQUtuc0IsT0FBTyxDQUFDc3NCLE1BQTFELElBQW9FSCxJQUFJLEtBQUtuc0IsT0FBTyxDQUFDdXNCLE1BQWpHO0FBQ0EsTUFBSUMsS0FBSyxHQUFHSCxLQUFLLEdBQUd2RixLQUFILEdBQVcyRixNQUE1QjtBQUNBLE1BQUkxSyxLQUFLLENBQUMySCxVQUFWLEVBQXNCMXBCLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCcUYsS0FBakIsRUFBdEIsS0FBbUQvTixHQUFHLENBQUNxQixJQUFKLENBQVMsS0FBVCxFQUFnQjBNLEtBQWhCO0FBQ25ETCxFQUFBQSxJQUFJLENBQUMzSyxFQUFMLENBQVEsUUFBUixFQUFrQmtMLFFBQWxCOztBQUVBLFdBQVNBLFFBQVQsQ0FBa0I3RixRQUFsQixFQUE0QjhGLFVBQTVCLEVBQXdDO0FBQ3RDdkUsSUFBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTDs7QUFFQSxRQUFJdkIsUUFBUSxLQUFLcEksR0FBakIsRUFBc0I7QUFDcEIsVUFBSWtPLFVBQVUsSUFBSUEsVUFBVSxDQUFDQyxVQUFYLEtBQTBCLEtBQTVDLEVBQW1EO0FBQ2pERCxRQUFBQSxVQUFVLENBQUNDLFVBQVgsR0FBd0IsSUFBeEI7QUFDQUMsUUFBQUEsT0FBTztBQUNSO0FBQ0Y7QUFDRjs7QUFFRCxXQUFTL0YsS0FBVCxHQUFpQjtBQUNmc0IsSUFBQUEsS0FBSyxDQUFDLE9BQUQsQ0FBTDtBQUNBK0QsSUFBQUEsSUFBSSxDQUFDcGpCLEdBQUw7QUFDRCxHQXZDaUQsQ0F1Q2hEO0FBQ0Y7QUFDQTtBQUNBOzs7QUFHQSxNQUFJK2pCLE9BQU8sR0FBR0MsV0FBVyxDQUFDdE8sR0FBRCxDQUF6QjtBQUNBME4sRUFBQUEsSUFBSSxDQUFDM0ssRUFBTCxDQUFRLE9BQVIsRUFBaUJzTCxPQUFqQjtBQUNBLE1BQUlFLFNBQVMsR0FBRyxLQUFoQjs7QUFFQSxXQUFTSCxPQUFULEdBQW1CO0FBQ2pCekUsSUFBQUEsS0FBSyxDQUFDLFNBQUQsQ0FBTCxDQURpQixDQUNDOztBQUVsQitELElBQUFBLElBQUksQ0FBQ3ZLLGNBQUwsQ0FBb0IsT0FBcEIsRUFBNkJxTCxPQUE3QjtBQUNBZCxJQUFBQSxJQUFJLENBQUN2SyxjQUFMLENBQW9CLFFBQXBCLEVBQThCc0wsUUFBOUI7QUFDQWYsSUFBQUEsSUFBSSxDQUFDdkssY0FBTCxDQUFvQixPQUFwQixFQUE2QmtMLE9BQTdCO0FBQ0FYLElBQUFBLElBQUksQ0FBQ3ZLLGNBQUwsQ0FBb0IsT0FBcEIsRUFBNkJ2ckIsT0FBN0I7QUFDQTgxQixJQUFBQSxJQUFJLENBQUN2SyxjQUFMLENBQW9CLFFBQXBCLEVBQThCOEssUUFBOUI7QUFDQWpPLElBQUFBLEdBQUcsQ0FBQ21ELGNBQUosQ0FBbUIsS0FBbkIsRUFBMEJrRixLQUExQjtBQUNBckksSUFBQUEsR0FBRyxDQUFDbUQsY0FBSixDQUFtQixLQUFuQixFQUEwQjZLLE1BQTFCO0FBQ0FoTyxJQUFBQSxHQUFHLENBQUNtRCxjQUFKLENBQW1CLE1BQW5CLEVBQTJCdUwsTUFBM0I7QUFDQUgsSUFBQUEsU0FBUyxHQUFHLElBQVosQ0FYaUIsQ0FXQztBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFJakwsS0FBSyxDQUFDc0ksVUFBTixLQUFxQixDQUFDOEIsSUFBSSxDQUFDcEYsY0FBTixJQUF3Qm9GLElBQUksQ0FBQ3BGLGNBQUwsQ0FBb0JxRyxTQUFqRSxDQUFKLEVBQWlGTixPQUFPO0FBQ3pGOztBQUVEck8sRUFBQUEsR0FBRyxDQUFDK0MsRUFBSixDQUFPLE1BQVAsRUFBZTJMLE1BQWY7O0FBRUEsV0FBU0EsTUFBVCxDQUFnQnpGLEtBQWhCLEVBQXVCO0FBQ3JCVSxJQUFBQSxLQUFLLENBQUMsUUFBRCxDQUFMO0FBQ0EsUUFBSXZRLEdBQUcsR0FBR3NVLElBQUksQ0FBQzdwQixLQUFMLENBQVdvbEIsS0FBWCxDQUFWO0FBQ0FVLElBQUFBLEtBQUssQ0FBQyxZQUFELEVBQWV2USxHQUFmLENBQUw7O0FBRUEsUUFBSUEsR0FBRyxLQUFLLEtBQVosRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFJLENBQUNrSyxLQUFLLENBQUN5SCxVQUFOLEtBQXFCLENBQXJCLElBQTBCekgsS0FBSyxDQUFDd0gsS0FBTixLQUFnQjRDLElBQTFDLElBQWtEcEssS0FBSyxDQUFDeUgsVUFBTixHQUFtQixDQUFuQixJQUF3QnZ6QixPQUFPLENBQUM4ckIsS0FBSyxDQUFDd0gsS0FBUCxFQUFjNEMsSUFBZCxDQUFQLEtBQStCLENBQUMsQ0FBM0csS0FBaUgsQ0FBQ2EsU0FBdEgsRUFBaUk7QUFDL0g1RSxRQUFBQSxLQUFLLENBQUMsNkJBQUQsRUFBZ0NyRyxLQUFLLENBQUNzSSxVQUF0QyxDQUFMO0FBQ0F0SSxRQUFBQSxLQUFLLENBQUNzSSxVQUFOO0FBQ0Q7O0FBRUQ1TCxNQUFBQSxHQUFHLENBQUM0TyxLQUFKO0FBQ0Q7QUFDRixHQXhGaUQsQ0F3RmhEO0FBQ0Y7OztBQUdBLFdBQVNoM0IsT0FBVCxDQUFpQnVxQixFQUFqQixFQUFxQjtBQUNuQndILElBQUFBLEtBQUssQ0FBQyxTQUFELEVBQVl4SCxFQUFaLENBQUw7QUFDQTZMLElBQUFBLE1BQU07QUFDTk4sSUFBQUEsSUFBSSxDQUFDdkssY0FBTCxDQUFvQixPQUFwQixFQUE2QnZyQixPQUE3QjtBQUNBLFFBQUl3eEIsZUFBZSxDQUFDc0UsSUFBRCxFQUFPLE9BQVAsQ0FBZixLQUFtQyxDQUF2QyxFQUEwQ25ELGNBQWMsQ0FBQ21ELElBQUQsRUFBT3ZMLEVBQVAsQ0FBZDtBQUMzQyxHQWpHaUQsQ0FpR2hEOzs7QUFHRmEsRUFBQUEsZUFBZSxDQUFDMEssSUFBRCxFQUFPLE9BQVAsRUFBZ0I5MUIsT0FBaEIsQ0FBZixDQXBHa0QsQ0FvR1Q7O0FBRXpDLFdBQVM0MkIsT0FBVCxHQUFtQjtBQUNqQmQsSUFBQUEsSUFBSSxDQUFDdkssY0FBTCxDQUFvQixRQUFwQixFQUE4QnNMLFFBQTlCO0FBQ0FULElBQUFBLE1BQU07QUFDUDs7QUFFRE4sRUFBQUEsSUFBSSxDQUFDck0sSUFBTCxDQUFVLE9BQVYsRUFBbUJtTixPQUFuQjs7QUFFQSxXQUFTQyxRQUFULEdBQW9CO0FBQ2xCOUUsSUFBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTDtBQUNBK0QsSUFBQUEsSUFBSSxDQUFDdkssY0FBTCxDQUFvQixPQUFwQixFQUE2QnFMLE9BQTdCO0FBQ0FSLElBQUFBLE1BQU07QUFDUDs7QUFFRE4sRUFBQUEsSUFBSSxDQUFDck0sSUFBTCxDQUFVLFFBQVYsRUFBb0JvTixRQUFwQjs7QUFFQSxXQUFTVCxNQUFULEdBQWtCO0FBQ2hCckUsSUFBQUEsS0FBSyxDQUFDLFFBQUQsQ0FBTDtBQUNBM0osSUFBQUEsR0FBRyxDQUFDZ08sTUFBSixDQUFXTixJQUFYO0FBQ0QsR0F4SGlELENBd0hoRDs7O0FBR0ZBLEVBQUFBLElBQUksQ0FBQzFMLElBQUwsQ0FBVSxNQUFWLEVBQWtCaEMsR0FBbEIsRUEzSGtELENBMkgxQjs7QUFFeEIsTUFBSSxDQUFDc0QsS0FBSyxDQUFDMEgsT0FBWCxFQUFvQjtBQUNsQnJCLElBQUFBLEtBQUssQ0FBQyxhQUFELENBQUw7QUFDQTNKLElBQUFBLEdBQUcsQ0FBQzZPLE1BQUo7QUFDRDs7QUFFRCxTQUFPbkIsSUFBUDtBQUNELENBbklEOztBQXFJQSxTQUFTWSxXQUFULENBQXFCdE8sR0FBckIsRUFBMEI7QUFDeEIsU0FBTyxTQUFTOE8seUJBQVQsR0FBcUM7QUFDMUMsUUFBSXhMLEtBQUssR0FBR3RELEdBQUcsQ0FBQzRJLGNBQWhCO0FBQ0FlLElBQUFBLEtBQUssQ0FBQyxhQUFELEVBQWdCckcsS0FBSyxDQUFDc0ksVUFBdEIsQ0FBTDtBQUNBLFFBQUl0SSxLQUFLLENBQUNzSSxVQUFWLEVBQXNCdEksS0FBSyxDQUFDc0ksVUFBTjs7QUFFdEIsUUFBSXRJLEtBQUssQ0FBQ3NJLFVBQU4sS0FBcUIsQ0FBckIsSUFBMEJ4QyxlQUFlLENBQUNwSixHQUFELEVBQU0sTUFBTixDQUE3QyxFQUE0RDtBQUMxRHNELE1BQUFBLEtBQUssQ0FBQzBILE9BQU4sR0FBZ0IsSUFBaEI7QUFDQXdDLE1BQUFBLElBQUksQ0FBQ3hOLEdBQUQsQ0FBSjtBQUNEO0FBQ0YsR0FURDtBQVVEOztBQUVEaUksUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUI2ekIsTUFBbkIsR0FBNEIsVUFBVU4sSUFBVixFQUFnQjtBQUMxQyxNQUFJcEssS0FBSyxHQUFHLEtBQUtzRixjQUFqQjtBQUNBLE1BQUlzRixVQUFVLEdBQUc7QUFDZkMsSUFBQUEsVUFBVSxFQUFFO0FBREcsR0FBakIsQ0FGMEMsQ0FJdkM7O0FBRUgsTUFBSTdLLEtBQUssQ0FBQ3lILFVBQU4sS0FBcUIsQ0FBekIsRUFBNEIsT0FBTyxJQUFQLENBTmMsQ0FNRDs7QUFFekMsTUFBSXpILEtBQUssQ0FBQ3lILFVBQU4sS0FBcUIsQ0FBekIsRUFBNEI7QUFDMUI7QUFDQSxRQUFJMkMsSUFBSSxJQUFJQSxJQUFJLEtBQUtwSyxLQUFLLENBQUN3SCxLQUEzQixFQUFrQyxPQUFPLElBQVA7QUFDbEMsUUFBSSxDQUFDNEMsSUFBTCxFQUFXQSxJQUFJLEdBQUdwSyxLQUFLLENBQUN3SCxLQUFiLENBSGUsQ0FHSzs7QUFFL0J4SCxJQUFBQSxLQUFLLENBQUN3SCxLQUFOLEdBQWMsSUFBZDtBQUNBeEgsSUFBQUEsS0FBSyxDQUFDeUgsVUFBTixHQUFtQixDQUFuQjtBQUNBekgsSUFBQUEsS0FBSyxDQUFDMEgsT0FBTixHQUFnQixLQUFoQjtBQUNBLFFBQUkwQyxJQUFKLEVBQVVBLElBQUksQ0FBQzFMLElBQUwsQ0FBVSxRQUFWLEVBQW9CLElBQXBCLEVBQTBCa00sVUFBMUI7QUFDVixXQUFPLElBQVA7QUFDRCxHQWxCeUMsQ0FrQnhDOzs7QUFHRixNQUFJLENBQUNSLElBQUwsRUFBVztBQUNUO0FBQ0EsUUFBSXFCLEtBQUssR0FBR3pMLEtBQUssQ0FBQ3dILEtBQWxCO0FBQ0EsUUFBSXRoQixHQUFHLEdBQUc4WixLQUFLLENBQUN5SCxVQUFoQjtBQUNBekgsSUFBQUEsS0FBSyxDQUFDd0gsS0FBTixHQUFjLElBQWQ7QUFDQXhILElBQUFBLEtBQUssQ0FBQ3lILFVBQU4sR0FBbUIsQ0FBbkI7QUFDQXpILElBQUFBLEtBQUssQ0FBQzBILE9BQU4sR0FBZ0IsS0FBaEI7O0FBRUEsU0FBSyxJQUFJL25CLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUd1RyxHQUFwQixFQUF5QnZHLENBQUMsRUFBMUIsRUFBOEI7QUFDNUI4ckIsTUFBQUEsS0FBSyxDQUFDOXJCLENBQUQsQ0FBTCxDQUFTK2UsSUFBVCxDQUFjLFFBQWQsRUFBd0IsSUFBeEIsRUFBOEI7QUFDNUJtTSxRQUFBQSxVQUFVLEVBQUU7QUFEZ0IsT0FBOUI7QUFHRDs7QUFFRCxXQUFPLElBQVA7QUFDRCxHQXBDeUMsQ0FvQ3hDOzs7QUFHRixNQUFJOUosS0FBSyxHQUFHN3NCLE9BQU8sQ0FBQzhyQixLQUFLLENBQUN3SCxLQUFQLEVBQWM0QyxJQUFkLENBQW5CO0FBQ0EsTUFBSXJKLEtBQUssS0FBSyxDQUFDLENBQWYsRUFBa0IsT0FBTyxJQUFQO0FBQ2xCZixFQUFBQSxLQUFLLENBQUN3SCxLQUFOLENBQVlrRSxNQUFaLENBQW1CM0ssS0FBbkIsRUFBMEIsQ0FBMUI7QUFDQWYsRUFBQUEsS0FBSyxDQUFDeUgsVUFBTixJQUFvQixDQUFwQjtBQUNBLE1BQUl6SCxLQUFLLENBQUN5SCxVQUFOLEtBQXFCLENBQXpCLEVBQTRCekgsS0FBSyxDQUFDd0gsS0FBTixHQUFjeEgsS0FBSyxDQUFDd0gsS0FBTixDQUFZLENBQVosQ0FBZDtBQUM1QjRDLEVBQUFBLElBQUksQ0FBQzFMLElBQUwsQ0FBVSxRQUFWLEVBQW9CLElBQXBCLEVBQTBCa00sVUFBMUI7QUFDQSxTQUFPLElBQVA7QUFDRCxDQTlDRCxFQThDRztBQUNIOzs7QUFHQWpHLFFBQVEsQ0FBQzl0QixTQUFULENBQW1CNG9CLEVBQW5CLEdBQXdCLFVBQVVrTSxFQUFWLEVBQWMvd0IsRUFBZCxFQUFrQjtBQUN4QyxNQUFJME4sR0FBRyxHQUFHeWQsTUFBTSxDQUFDbHZCLFNBQVAsQ0FBaUI0b0IsRUFBakIsQ0FBb0Jua0IsSUFBcEIsQ0FBeUIsSUFBekIsRUFBK0Jxd0IsRUFBL0IsRUFBbUMvd0IsRUFBbkMsQ0FBVjtBQUNBLE1BQUlvbEIsS0FBSyxHQUFHLEtBQUtzRixjQUFqQjs7QUFFQSxNQUFJcUcsRUFBRSxLQUFLLE1BQVgsRUFBbUI7QUFDakI7QUFDQTtBQUNBM0wsSUFBQUEsS0FBSyxDQUFDZ0ksaUJBQU4sR0FBMEIsS0FBS25ILGFBQUwsQ0FBbUIsVUFBbkIsSUFBaUMsQ0FBM0QsQ0FIaUIsQ0FHNkM7O0FBRTlELFFBQUliLEtBQUssQ0FBQzBILE9BQU4sS0FBa0IsS0FBdEIsRUFBNkIsS0FBSzZELE1BQUw7QUFDOUIsR0FORCxNQU1PLElBQUlJLEVBQUUsS0FBSyxVQUFYLEVBQXVCO0FBQzVCLFFBQUksQ0FBQzNMLEtBQUssQ0FBQzJILFVBQVAsSUFBcUIsQ0FBQzNILEtBQUssQ0FBQ2dJLGlCQUFoQyxFQUFtRDtBQUNqRGhJLE1BQUFBLEtBQUssQ0FBQ2dJLGlCQUFOLEdBQTBCaEksS0FBSyxDQUFDOEgsWUFBTixHQUFxQixJQUEvQztBQUNBOUgsTUFBQUEsS0FBSyxDQUFDMEgsT0FBTixHQUFnQixLQUFoQjtBQUNBMUgsTUFBQUEsS0FBSyxDQUFDK0gsZUFBTixHQUF3QixLQUF4QjtBQUNBMUIsTUFBQUEsS0FBSyxDQUFDLGFBQUQsRUFBZ0JyRyxLQUFLLENBQUNubUIsTUFBdEIsRUFBOEJtbUIsS0FBSyxDQUFDNEgsT0FBcEMsQ0FBTDs7QUFFQSxVQUFJNUgsS0FBSyxDQUFDbm1CLE1BQVYsRUFBa0I7QUFDaEJ3dkIsUUFBQUEsWUFBWSxDQUFDLElBQUQsQ0FBWjtBQUNELE9BRkQsTUFFTyxJQUFJLENBQUNySixLQUFLLENBQUM0SCxPQUFYLEVBQW9CO0FBQ3pCM3BCLFFBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCd0csZ0JBQWpCLEVBQW1DLElBQW5DO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQU90akIsR0FBUDtBQUNELENBMUJEOztBQTRCQXFjLFFBQVEsQ0FBQzl0QixTQUFULENBQW1CMm9CLFdBQW5CLEdBQWlDbUYsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUI0b0IsRUFBcEQ7O0FBRUFrRixRQUFRLENBQUM5dEIsU0FBVCxDQUFtQmdwQixjQUFuQixHQUFvQyxVQUFVOEwsRUFBVixFQUFjL3dCLEVBQWQsRUFBa0I7QUFDcEQsTUFBSTBOLEdBQUcsR0FBR3lkLE1BQU0sQ0FBQ2x2QixTQUFQLENBQWlCZ3BCLGNBQWpCLENBQWdDdmtCLElBQWhDLENBQXFDLElBQXJDLEVBQTJDcXdCLEVBQTNDLEVBQStDL3dCLEVBQS9DLENBQVY7O0FBRUEsTUFBSSt3QixFQUFFLEtBQUssVUFBWCxFQUF1QjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTF0QixJQUFBQSxPQUFPLENBQUNtbkIsUUFBUixDQUFpQnlHLHVCQUFqQixFQUEwQyxJQUExQztBQUNEOztBQUVELFNBQU92akIsR0FBUDtBQUNELENBZEQ7O0FBZ0JBcWMsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUIwcEIsa0JBQW5CLEdBQXdDLFVBQVVvTCxFQUFWLEVBQWM7QUFDcEQsTUFBSXJqQixHQUFHLEdBQUd5ZCxNQUFNLENBQUNsdkIsU0FBUCxDQUFpQjBwQixrQkFBakIsQ0FBb0M1bUIsS0FBcEMsQ0FBMEMsSUFBMUMsRUFBZ0RsQixTQUFoRCxDQUFWOztBQUVBLE1BQUlrekIsRUFBRSxLQUFLLFVBQVAsSUFBcUJBLEVBQUUsS0FBS3oyQixTQUFoQyxFQUEyQztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQStJLElBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCeUcsdUJBQWpCLEVBQTBDLElBQTFDO0FBQ0Q7O0FBRUQsU0FBT3ZqQixHQUFQO0FBQ0QsQ0FkRDs7QUFnQkEsU0FBU3VqQix1QkFBVCxDQUFpQ3RLLElBQWpDLEVBQXVDO0FBQ3JDLE1BQUl2QixLQUFLLEdBQUd1QixJQUFJLENBQUMrRCxjQUFqQjtBQUNBdEYsRUFBQUEsS0FBSyxDQUFDZ0ksaUJBQU4sR0FBMEJ6RyxJQUFJLENBQUNWLGFBQUwsQ0FBbUIsVUFBbkIsSUFBaUMsQ0FBM0Q7O0FBRUEsTUFBSWIsS0FBSyxDQUFDaUksZUFBTixJQUF5QixDQUFDakksS0FBSyxDQUFDa0ksTUFBcEMsRUFBNEM7QUFDMUM7QUFDQTtBQUNBbEksSUFBQUEsS0FBSyxDQUFDMEgsT0FBTixHQUFnQixJQUFoQixDQUgwQyxDQUdwQjtBQUN2QixHQUpELE1BSU8sSUFBSW5HLElBQUksQ0FBQ1YsYUFBTCxDQUFtQixNQUFuQixJQUE2QixDQUFqQyxFQUFvQztBQUN6Q1UsSUFBQUEsSUFBSSxDQUFDZ0ssTUFBTDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU0ssZ0JBQVQsQ0FBMEJySyxJQUExQixFQUFnQztBQUM5QjhFLEVBQUFBLEtBQUssQ0FBQywwQkFBRCxDQUFMO0FBQ0E5RSxFQUFBQSxJQUFJLENBQUN0c0IsSUFBTCxDQUFVLENBQVY7QUFDRCxFQUFDO0FBQ0Y7OztBQUdBMHZCLFFBQVEsQ0FBQzl0QixTQUFULENBQW1CMDBCLE1BQW5CLEdBQTRCLFlBQVk7QUFDdEMsTUFBSXZMLEtBQUssR0FBRyxLQUFLc0YsY0FBakI7O0FBRUEsTUFBSSxDQUFDdEYsS0FBSyxDQUFDMEgsT0FBWCxFQUFvQjtBQUNsQnJCLElBQUFBLEtBQUssQ0FBQyxRQUFELENBQUwsQ0FEa0IsQ0FDRDtBQUNqQjtBQUNBOztBQUVBckcsSUFBQUEsS0FBSyxDQUFDMEgsT0FBTixHQUFnQixDQUFDMUgsS0FBSyxDQUFDZ0ksaUJBQXZCO0FBQ0F1RCxJQUFBQSxNQUFNLENBQUMsSUFBRCxFQUFPdkwsS0FBUCxDQUFOO0FBQ0Q7O0FBRURBLEVBQUFBLEtBQUssQ0FBQ2tJLE1BQU4sR0FBZSxLQUFmO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FkRDs7QUFnQkEsU0FBU3FELE1BQVQsQ0FBZ0JuRSxNQUFoQixFQUF3QnBILEtBQXhCLEVBQStCO0FBQzdCLE1BQUksQ0FBQ0EsS0FBSyxDQUFDaUksZUFBWCxFQUE0QjtBQUMxQmpJLElBQUFBLEtBQUssQ0FBQ2lJLGVBQU4sR0FBd0IsSUFBeEI7QUFDQWhxQixJQUFBQSxPQUFPLENBQUNtbkIsUUFBUixDQUFpQjBHLE9BQWpCLEVBQTBCMUUsTUFBMUIsRUFBa0NwSCxLQUFsQztBQUNEO0FBQ0Y7O0FBRUQsU0FBUzhMLE9BQVQsQ0FBaUIxRSxNQUFqQixFQUF5QnBILEtBQXpCLEVBQWdDO0FBQzlCcUcsRUFBQUEsS0FBSyxDQUFDLFFBQUQsRUFBV3JHLEtBQUssQ0FBQzRILE9BQWpCLENBQUw7O0FBRUEsTUFBSSxDQUFDNUgsS0FBSyxDQUFDNEgsT0FBWCxFQUFvQjtBQUNsQlIsSUFBQUEsTUFBTSxDQUFDbnlCLElBQVAsQ0FBWSxDQUFaO0FBQ0Q7O0FBRUQrcUIsRUFBQUEsS0FBSyxDQUFDaUksZUFBTixHQUF3QixLQUF4QjtBQUNBYixFQUFBQSxNQUFNLENBQUMxSSxJQUFQLENBQVksUUFBWjtBQUNBd0wsRUFBQUEsSUFBSSxDQUFDOUMsTUFBRCxDQUFKO0FBQ0EsTUFBSXBILEtBQUssQ0FBQzBILE9BQU4sSUFBaUIsQ0FBQzFILEtBQUssQ0FBQzRILE9BQTVCLEVBQXFDUixNQUFNLENBQUNueUIsSUFBUCxDQUFZLENBQVo7QUFDdEM7O0FBRUQwdkIsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUJ5MEIsS0FBbkIsR0FBMkIsWUFBWTtBQUNyQ2pGLEVBQUFBLEtBQUssQ0FBQyx1QkFBRCxFQUEwQixLQUFLZixjQUFMLENBQW9Cb0MsT0FBOUMsQ0FBTDs7QUFFQSxNQUFJLEtBQUtwQyxjQUFMLENBQW9Cb0MsT0FBcEIsS0FBZ0MsS0FBcEMsRUFBMkM7QUFDekNyQixJQUFBQSxLQUFLLENBQUMsT0FBRCxDQUFMO0FBQ0EsU0FBS2YsY0FBTCxDQUFvQm9DLE9BQXBCLEdBQThCLEtBQTlCO0FBQ0EsU0FBS2hKLElBQUwsQ0FBVSxPQUFWO0FBQ0Q7O0FBRUQsT0FBSzRHLGNBQUwsQ0FBb0I0QyxNQUFwQixHQUE2QixJQUE3QjtBQUNBLFNBQU8sSUFBUDtBQUNELENBWEQ7O0FBYUEsU0FBU2dDLElBQVQsQ0FBYzlDLE1BQWQsRUFBc0I7QUFDcEIsTUFBSXBILEtBQUssR0FBR29ILE1BQU0sQ0FBQzlCLGNBQW5CO0FBQ0FlLEVBQUFBLEtBQUssQ0FBQyxNQUFELEVBQVNyRyxLQUFLLENBQUMwSCxPQUFmLENBQUw7O0FBRUEsU0FBTzFILEtBQUssQ0FBQzBILE9BQU4sSUFBaUJOLE1BQU0sQ0FBQ255QixJQUFQLE9BQWtCLElBQTFDLEVBQWdEO0FBQzlDO0FBQ0Q7QUFDRixFQUFDO0FBQ0Y7QUFDQTs7O0FBR0EwdkIsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUI0SSxJQUFuQixHQUEwQixVQUFVMm5CLE1BQVYsRUFBa0I7QUFDMUMsTUFBSTJFLEtBQUssR0FBRyxJQUFaOztBQUVBLE1BQUkvTCxLQUFLLEdBQUcsS0FBS3NGLGNBQWpCO0FBQ0EsTUFBSTRDLE1BQU0sR0FBRyxLQUFiO0FBQ0FkLEVBQUFBLE1BQU0sQ0FBQzNILEVBQVAsQ0FBVSxLQUFWLEVBQWlCLFlBQVk7QUFDM0I0RyxJQUFBQSxLQUFLLENBQUMsYUFBRCxDQUFMOztBQUVBLFFBQUlyRyxLQUFLLENBQUN3SSxPQUFOLElBQWlCLENBQUN4SSxLQUFLLENBQUNtRixLQUE1QixFQUFtQztBQUNqQyxVQUFJUSxLQUFLLEdBQUczRixLQUFLLENBQUN3SSxPQUFOLENBQWN4aEIsR0FBZCxFQUFaO0FBQ0EsVUFBSTJlLEtBQUssSUFBSUEsS0FBSyxDQUFDOXJCLE1BQW5CLEVBQTJCa3lCLEtBQUssQ0FBQ3Z5QixJQUFOLENBQVdtc0IsS0FBWDtBQUM1Qjs7QUFFRG9HLElBQUFBLEtBQUssQ0FBQ3Z5QixJQUFOLENBQVcsSUFBWDtBQUNELEdBVEQ7QUFVQTR0QixFQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFVa0csS0FBVixFQUFpQjtBQUNqQ1UsSUFBQUEsS0FBSyxDQUFDLGNBQUQsQ0FBTDtBQUNBLFFBQUlyRyxLQUFLLENBQUN3SSxPQUFWLEVBQW1CN0MsS0FBSyxHQUFHM0YsS0FBSyxDQUFDd0ksT0FBTixDQUFjam9CLEtBQWQsQ0FBb0JvbEIsS0FBcEIsQ0FBUixDQUZjLENBRXNCOztBQUV2RCxRQUFJM0YsS0FBSyxDQUFDc0gsVUFBTixLQUFxQjNCLEtBQUssS0FBSyxJQUFWLElBQWtCQSxLQUFLLEtBQUt6d0IsU0FBakQsQ0FBSixFQUFpRSxPQUFqRSxLQUE2RSxJQUFJLENBQUM4cUIsS0FBSyxDQUFDc0gsVUFBUCxLQUFzQixDQUFDM0IsS0FBRCxJQUFVLENBQUNBLEtBQUssQ0FBQzlyQixNQUF2QyxDQUFKLEVBQW9EOztBQUVqSSxRQUFJaWMsR0FBRyxHQUFHaVcsS0FBSyxDQUFDdnlCLElBQU4sQ0FBV21zQixLQUFYLENBQVY7O0FBRUEsUUFBSSxDQUFDN1AsR0FBTCxFQUFVO0FBQ1JvUyxNQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNBZCxNQUFBQSxNQUFNLENBQUNrRSxLQUFQO0FBQ0Q7QUFDRixHQVpELEVBZjBDLENBMkJ0QztBQUNKOztBQUVBLE9BQUssSUFBSTNyQixDQUFULElBQWN5bkIsTUFBZCxFQUFzQjtBQUNwQixRQUFJLEtBQUt6bkIsQ0FBTCxNQUFZekssU0FBWixJQUF5QixPQUFPa3lCLE1BQU0sQ0FBQ3puQixDQUFELENBQWIsS0FBcUIsVUFBbEQsRUFBOEQ7QUFDNUQsV0FBS0EsQ0FBTCxJQUFVLFNBQVNxc0IsVUFBVCxDQUFvQi80QixNQUFwQixFQUE0QjtBQUNwQyxlQUFPLFNBQVNnNUIsd0JBQVQsR0FBb0M7QUFDekMsaUJBQU83RSxNQUFNLENBQUNuMEIsTUFBRCxDQUFOLENBQWUwRyxLQUFmLENBQXFCeXRCLE1BQXJCLEVBQTZCM3VCLFNBQTdCLENBQVA7QUFDRCxTQUZEO0FBR0QsT0FKUyxDQUlSa0gsQ0FKUSxDQUFWO0FBS0Q7QUFDRixHQXRDeUMsQ0FzQ3hDOzs7QUFHRixPQUFLLElBQUlrTixDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHcWEsWUFBWSxDQUFDcnRCLE1BQWpDLEVBQXlDZ1QsQ0FBQyxFQUExQyxFQUE4QztBQUM1Q3VhLElBQUFBLE1BQU0sQ0FBQzNILEVBQVAsQ0FBVXlILFlBQVksQ0FBQ3JhLENBQUQsQ0FBdEIsRUFBMkIsS0FBSzZSLElBQUwsQ0FBVXJvQixJQUFWLENBQWUsSUFBZixFQUFxQjZ3QixZQUFZLENBQUNyYSxDQUFELENBQWpDLENBQTNCO0FBQ0QsR0EzQ3lDLENBMkN4QztBQUNGOzs7QUFHQSxPQUFLNGIsS0FBTCxHQUFhLFVBQVU1YixDQUFWLEVBQWE7QUFDeEJ3WixJQUFBQSxLQUFLLENBQUMsZUFBRCxFQUFrQnhaLENBQWxCLENBQUw7O0FBRUEsUUFBSXFiLE1BQUosRUFBWTtBQUNWQSxNQUFBQSxNQUFNLEdBQUcsS0FBVDtBQUNBZCxNQUFBQSxNQUFNLENBQUNtRSxNQUFQO0FBQ0Q7QUFDRixHQVBEOztBQVNBLFNBQU8sSUFBUDtBQUNELENBekREOztBQTJEQSxJQUFJLE9BQU9sYyxNQUFQLEtBQWtCLFVBQXRCLEVBQWtDO0FBQ2hDc1YsRUFBQUEsUUFBUSxDQUFDOXRCLFNBQVQsQ0FBbUJ3WSxNQUFNLENBQUM2YyxhQUExQixJQUEyQyxZQUFZO0FBQ3JELFFBQUlsRixpQ0FBaUMsS0FBSzl4QixTQUExQyxFQUFxRDtBQUNuRDh4QixNQUFBQSxpQ0FBaUMsR0FBRzEzQixtQkFBTyxDQUFDLGdIQUFELENBQTNDO0FBQ0Q7O0FBRUQsV0FBTzAzQixpQ0FBaUMsQ0FBQyxJQUFELENBQXhDO0FBQ0QsR0FORDtBQU9EOztBQUVELzNCLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQnkxQixRQUFRLENBQUM5dEIsU0FBL0IsRUFBMEMsdUJBQTFDLEVBQW1FO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBa1osRUFBQUEsVUFBVSxFQUFFLEtBSnFEO0FBS2pFQyxFQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFdBQU8sS0FBS3NWLGNBQUwsQ0FBb0JMLGFBQTNCO0FBQ0Q7QUFQZ0UsQ0FBbkU7QUFTQWgyQixNQUFNLENBQUNDLGNBQVAsQ0FBc0J5MUIsUUFBUSxDQUFDOXRCLFNBQS9CLEVBQTBDLGdCQUExQyxFQUE0RDtBQUMxRDtBQUNBO0FBQ0E7QUFDQWtaLEVBQUFBLFVBQVUsRUFBRSxLQUo4QztBQUsxREMsRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixXQUFPLEtBQUtzVixjQUFMLElBQXVCLEtBQUtBLGNBQUwsQ0FBb0JwbUIsTUFBbEQ7QUFDRDtBQVB5RCxDQUE1RDtBQVNBalEsTUFBTSxDQUFDQyxjQUFQLENBQXNCeTFCLFFBQVEsQ0FBQzl0QixTQUEvQixFQUEwQyxpQkFBMUMsRUFBNkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0FrWixFQUFBQSxVQUFVLEVBQUUsS0FKK0M7QUFLM0RDLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsV0FBTyxLQUFLc1YsY0FBTCxDQUFvQm9DLE9BQTNCO0FBQ0QsR0FQMEQ7QUFRM0QxYixFQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxDQUFhZ1UsS0FBYixFQUFvQjtBQUN2QixRQUFJLEtBQUtzRixjQUFULEVBQXlCO0FBQ3ZCLFdBQUtBLGNBQUwsQ0FBb0JvQyxPQUFwQixHQUE4QjFILEtBQTlCO0FBQ0Q7QUFDRjtBQVowRCxDQUE3RCxHQWFJOztBQUVKMkUsUUFBUSxDQUFDd0gsU0FBVCxHQUFxQm5DLFFBQXJCO0FBQ0EvNkIsTUFBTSxDQUFDQyxjQUFQLENBQXNCeTFCLFFBQVEsQ0FBQzl0QixTQUEvQixFQUEwQyxnQkFBMUMsRUFBNEQ7QUFDMUQ7QUFDQTtBQUNBO0FBQ0FrWixFQUFBQSxVQUFVLEVBQUUsS0FKOEM7QUFLMURDLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsV0FBTyxLQUFLc1YsY0FBTCxDQUFvQnpyQixNQUEzQjtBQUNEO0FBUHlELENBQTVELEdBUUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUEsU0FBU213QixRQUFULENBQWtCbmQsQ0FBbEIsRUFBcUJtVCxLQUFyQixFQUE0QjtBQUMxQjtBQUNBLE1BQUlBLEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQXJCLEVBQXdCLE9BQU8sSUFBUDtBQUN4QixNQUFJaWMsR0FBSjtBQUNBLE1BQUlrSyxLQUFLLENBQUNzSCxVQUFWLEVBQXNCeFIsR0FBRyxHQUFHa0ssS0FBSyxDQUFDOWdCLE1BQU4sQ0FBYXBGLEtBQWIsRUFBTixDQUF0QixLQUFzRCxJQUFJLENBQUMrUyxDQUFELElBQU1BLENBQUMsSUFBSW1ULEtBQUssQ0FBQ25tQixNQUFyQixFQUE2QjtBQUNqRjtBQUNBLFFBQUltbUIsS0FBSyxDQUFDd0ksT0FBVixFQUFtQjFTLEdBQUcsR0FBR2tLLEtBQUssQ0FBQzlnQixNQUFOLENBQWFpQixJQUFiLENBQWtCLEVBQWxCLENBQU4sQ0FBbkIsS0FBb0QsSUFBSTZmLEtBQUssQ0FBQzlnQixNQUFOLENBQWFyRixNQUFiLEtBQXdCLENBQTVCLEVBQStCaWMsR0FBRyxHQUFHa0ssS0FBSyxDQUFDOWdCLE1BQU4sQ0FBYW1ZLEtBQWIsRUFBTixDQUEvQixLQUErRHZCLEdBQUcsR0FBR2tLLEtBQUssQ0FBQzlnQixNQUFOLENBQWF0RixNQUFiLENBQW9Cb21CLEtBQUssQ0FBQ25tQixNQUExQixDQUFOO0FBQ25IbW1CLElBQUFBLEtBQUssQ0FBQzlnQixNQUFOLENBQWF1cUIsS0FBYjtBQUNELEdBSnFELE1BSS9DO0FBQ0w7QUFDQTNULElBQUFBLEdBQUcsR0FBR2tLLEtBQUssQ0FBQzlnQixNQUFOLENBQWFrdEIsT0FBYixDQUFxQnZmLENBQXJCLEVBQXdCbVQsS0FBSyxDQUFDd0ksT0FBOUIsQ0FBTjtBQUNEO0FBQ0QsU0FBTzFTLEdBQVA7QUFDRDs7QUFFRCxTQUFTZ1UsV0FBVCxDQUFxQjFDLE1BQXJCLEVBQTZCO0FBQzNCLE1BQUlwSCxLQUFLLEdBQUdvSCxNQUFNLENBQUM5QixjQUFuQjtBQUNBZSxFQUFBQSxLQUFLLENBQUMsYUFBRCxFQUFnQnJHLEtBQUssQ0FBQzJILFVBQXRCLENBQUw7O0FBRUEsTUFBSSxDQUFDM0gsS0FBSyxDQUFDMkgsVUFBWCxFQUF1QjtBQUNyQjNILElBQUFBLEtBQUssQ0FBQ21GLEtBQU4sR0FBYyxJQUFkO0FBQ0FsbkIsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJpSCxhQUFqQixFQUFnQ3JNLEtBQWhDLEVBQXVDb0gsTUFBdkM7QUFDRDtBQUNGOztBQUVELFNBQVNpRixhQUFULENBQXVCck0sS0FBdkIsRUFBOEJvSCxNQUE5QixFQUFzQztBQUNwQ2YsRUFBQUEsS0FBSyxDQUFDLGVBQUQsRUFBa0JyRyxLQUFLLENBQUMySCxVQUF4QixFQUFvQzNILEtBQUssQ0FBQ25tQixNQUExQyxDQUFMLENBRG9DLENBQ29COztBQUV4RCxNQUFJLENBQUNtbUIsS0FBSyxDQUFDMkgsVUFBUCxJQUFxQjNILEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQTFDLEVBQTZDO0FBQzNDbW1CLElBQUFBLEtBQUssQ0FBQzJILFVBQU4sR0FBbUIsSUFBbkI7QUFDQVAsSUFBQUEsTUFBTSxDQUFDdEMsUUFBUCxHQUFrQixLQUFsQjtBQUNBc0MsSUFBQUEsTUFBTSxDQUFDMUksSUFBUCxDQUFZLEtBQVo7O0FBRUEsUUFBSXNCLEtBQUssQ0FBQ29JLFdBQVYsRUFBdUI7QUFDckI7QUFDQTtBQUNBLFVBQUlrRSxNQUFNLEdBQUdsRixNQUFNLENBQUNwQyxjQUFwQjs7QUFFQSxVQUFJLENBQUNzSCxNQUFELElBQVdBLE1BQU0sQ0FBQ2xFLFdBQVAsSUFBc0JrRSxNQUFNLENBQUNDLFFBQTVDLEVBQXNEO0FBQ3BEbkYsUUFBQUEsTUFBTSxDQUFDc0IsT0FBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGOztBQUVELElBQUksT0FBT3JaLE1BQVAsS0FBa0IsVUFBdEIsRUFBa0M7QUFDaENzVixFQUFBQSxRQUFRLENBQUMzMEIsSUFBVCxHQUFnQixVQUFVdzhCLFFBQVYsRUFBb0Jyb0IsSUFBcEIsRUFBMEI7QUFDeEMsUUFBSW5VLElBQUksS0FBS2tGLFNBQWIsRUFBd0I7QUFDdEJsRixNQUFBQSxJQUFJLEdBQUdWLG1CQUFPLENBQUMsb0dBQUQsQ0FBZDtBQUNEOztBQUVELFdBQU9VLElBQUksQ0FBQzIwQixRQUFELEVBQVc2SCxRQUFYLEVBQXFCcm9CLElBQXJCLENBQVg7QUFDRCxHQU5EO0FBT0Q7O0FBRUQsU0FBU2pRLE9BQVQsQ0FBaUJ1NEIsRUFBakIsRUFBcUJobEIsQ0FBckIsRUFBd0I7QUFDdEIsT0FBSyxJQUFJOUgsQ0FBQyxHQUFHLENBQVIsRUFBV3lGLENBQUMsR0FBR3FuQixFQUFFLENBQUM1eUIsTUFBdkIsRUFBK0I4RixDQUFDLEdBQUd5RixDQUFuQyxFQUFzQ3pGLENBQUMsRUFBdkMsRUFBMkM7QUFDekMsUUFBSThzQixFQUFFLENBQUM5c0IsQ0FBRCxDQUFGLEtBQVU4SCxDQUFkLEVBQWlCLE9BQU85SCxDQUFQO0FBQ2xCOztBQUVELFNBQU8sQ0FBQyxDQUFSO0FBQ0Q7Ozs7Ozs7Ozs7QUNubUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI1TyxNQUFNLENBQUM1QixPQUFQLEdBQWlCczJCLFNBQWpCOztBQUVBLElBQUlrQixjQUFjLEdBQUdyM0IsZ0dBQXJCO0FBQUEsSUFDSXUzQiwwQkFBMEIsR0FBR0YsY0FBYyxDQUFDRSwwQkFEaEQ7QUFBQSxJQUVJNkYscUJBQXFCLEdBQUcvRixjQUFjLENBQUMrRixxQkFGM0M7QUFBQSxJQUdJQyxrQ0FBa0MsR0FBR2hHLGNBQWMsQ0FBQ2dHLGtDQUh4RDtBQUFBLElBSUlDLDJCQUEyQixHQUFHakcsY0FBYyxDQUFDaUcsMkJBSmpEOztBQU1BLElBQUlsSSxNQUFNLEdBQUdwMUIsbUJBQU8sQ0FBQyw4RUFBRCxDQUFwQjs7QUFFQUEsbUJBQU8sQ0FBQyw2REFBRCxDQUFQLENBQW9CbTJCLFNBQXBCLEVBQStCZixNQUEvQjs7QUFFQSxTQUFTbUksY0FBVCxDQUF3QmhPLEVBQXhCLEVBQTRCOXNCLElBQTVCLEVBQWtDO0FBQ2hDLE1BQUkrNkIsRUFBRSxHQUFHLEtBQUtDLGVBQWQ7QUFDQUQsRUFBQUEsRUFBRSxDQUFDRSxZQUFILEdBQWtCLEtBQWxCO0FBQ0EsTUFBSS9pQixFQUFFLEdBQUc2aUIsRUFBRSxDQUFDRyxPQUFaOztBQUVBLE1BQUloakIsRUFBRSxLQUFLLElBQVgsRUFBaUI7QUFDZixXQUFPLEtBQUt5VSxJQUFMLENBQVUsT0FBVixFQUFtQixJQUFJZ08scUJBQUosRUFBbkIsQ0FBUDtBQUNEOztBQUVESSxFQUFBQSxFQUFFLENBQUNJLFVBQUgsR0FBZ0IsSUFBaEI7QUFDQUosRUFBQUEsRUFBRSxDQUFDRyxPQUFILEdBQWEsSUFBYjtBQUNBLE1BQUlsN0IsSUFBSSxJQUFJLElBQVosRUFBa0I7QUFDaEIsU0FBS3lILElBQUwsQ0FBVXpILElBQVY7QUFDRmtZLEVBQUFBLEVBQUUsQ0FBQzRVLEVBQUQsQ0FBRjtBQUNBLE1BQUlzTyxFQUFFLEdBQUcsS0FBSzdILGNBQWQ7QUFDQTZILEVBQUFBLEVBQUUsQ0FBQ3ZGLE9BQUgsR0FBYSxLQUFiOztBQUVBLE1BQUl1RixFQUFFLENBQUNyRixZQUFILElBQW1CcUYsRUFBRSxDQUFDdHpCLE1BQUgsR0FBWXN6QixFQUFFLENBQUNsSSxhQUF0QyxFQUFxRDtBQUNuRCxTQUFLd0QsS0FBTCxDQUFXMEUsRUFBRSxDQUFDbEksYUFBZDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU1EsU0FBVCxDQUFtQmhyQixPQUFuQixFQUE0QjtBQUMxQixNQUFJLEVBQUUsZ0JBQWdCZ3JCLFNBQWxCLENBQUosRUFBa0MsT0FBTyxJQUFJQSxTQUFKLENBQWNockIsT0FBZCxDQUFQO0FBQ2xDaXFCLEVBQUFBLE1BQU0sQ0FBQ3BwQixJQUFQLENBQVksSUFBWixFQUFrQmIsT0FBbEI7QUFDQSxPQUFLc3lCLGVBQUwsR0FBdUI7QUFDckJGLElBQUFBLGNBQWMsRUFBRUEsY0FBYyxDQUFDeDJCLElBQWYsQ0FBb0IsSUFBcEIsQ0FESztBQUVyQisyQixJQUFBQSxhQUFhLEVBQUUsS0FGTTtBQUdyQkosSUFBQUEsWUFBWSxFQUFFLEtBSE87QUFJckJDLElBQUFBLE9BQU8sRUFBRSxJQUpZO0FBS3JCQyxJQUFBQSxVQUFVLEVBQUUsSUFMUztBQU1yQkcsSUFBQUEsYUFBYSxFQUFFO0FBTk0sR0FBdkIsQ0FIMEIsQ0FVdkI7O0FBRUgsT0FBSy9ILGNBQUwsQ0FBb0J3QyxZQUFwQixHQUFtQyxJQUFuQyxDQVowQixDQVllO0FBQ3pDO0FBQ0E7O0FBRUEsT0FBS3hDLGNBQUwsQ0FBb0J1QyxJQUFwQixHQUEyQixLQUEzQjs7QUFFQSxNQUFJcHRCLE9BQUosRUFBYTtBQUNYLFFBQUksT0FBT0EsT0FBTyxDQUFDbUQsU0FBZixLQUE2QixVQUFqQyxFQUE2QyxLQUFLOG5CLFVBQUwsR0FBa0JqckIsT0FBTyxDQUFDbUQsU0FBMUI7QUFDN0MsUUFBSSxPQUFPbkQsT0FBTyxDQUFDNnlCLEtBQWYsS0FBeUIsVUFBN0IsRUFBeUMsS0FBS0MsTUFBTCxHQUFjOXlCLE9BQU8sQ0FBQzZ5QixLQUF0QjtBQUMxQyxHQXJCeUIsQ0FxQnhCOzs7QUFHRixPQUFLN04sRUFBTCxDQUFRLFdBQVIsRUFBcUIrTixTQUFyQjtBQUNEOztBQUVELFNBQVNBLFNBQVQsR0FBcUI7QUFDbkIsTUFBSXpCLEtBQUssR0FBRyxJQUFaOztBQUVBLE1BQUksT0FBTyxLQUFLd0IsTUFBWixLQUF1QixVQUF2QixJQUFxQyxDQUFDLEtBQUtqSSxjQUFMLENBQW9CQyxTQUE5RCxFQUF5RTtBQUN2RSxTQUFLZ0ksTUFBTCxDQUFZLFVBQVUxTyxFQUFWLEVBQWM5c0IsSUFBZCxFQUFvQjtBQUM5QjA3QixNQUFBQSxJQUFJLENBQUMxQixLQUFELEVBQVFsTixFQUFSLEVBQVk5c0IsSUFBWixDQUFKO0FBQ0QsS0FGRDtBQUdELEdBSkQsTUFJTztBQUNMMDdCLElBQUFBLElBQUksQ0FBQyxJQUFELEVBQU8sSUFBUCxFQUFhLElBQWIsQ0FBSjtBQUNEO0FBQ0Y7O0FBRURoSSxTQUFTLENBQUM1dUIsU0FBVixDQUFvQjJDLElBQXBCLEdBQTJCLFVBQVVtc0IsS0FBVixFQUFpQm5kLFFBQWpCLEVBQTJCO0FBQ3BELE9BQUt1a0IsZUFBTCxDQUFxQkssYUFBckIsR0FBcUMsS0FBckM7QUFDQSxTQUFPMUksTUFBTSxDQUFDN3RCLFNBQVAsQ0FBaUIyQyxJQUFqQixDQUFzQjhCLElBQXRCLENBQTJCLElBQTNCLEVBQWlDcXFCLEtBQWpDLEVBQXdDbmQsUUFBeEMsQ0FBUDtBQUNELENBSEQsRUFHRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0FpZCxTQUFTLENBQUM1dUIsU0FBVixDQUFvQjZ1QixVQUFwQixHQUFpQyxVQUFVQyxLQUFWLEVBQWlCbmQsUUFBakIsRUFBMkJ5QixFQUEzQixFQUErQjtBQUM5REEsRUFBQUEsRUFBRSxDQUFDLElBQUk0YywwQkFBSixDQUErQixjQUEvQixDQUFELENBQUY7QUFDRCxDQUZEOztBQUlBcEIsU0FBUyxDQUFDNXVCLFNBQVYsQ0FBb0I2MkIsTUFBcEIsR0FBNkIsVUFBVS9ILEtBQVYsRUFBaUJuZCxRQUFqQixFQUEyQnlCLEVBQTNCLEVBQStCO0FBQzFELE1BQUk2aUIsRUFBRSxHQUFHLEtBQUtDLGVBQWQ7QUFDQUQsRUFBQUEsRUFBRSxDQUFDRyxPQUFILEdBQWFoakIsRUFBYjtBQUNBNmlCLEVBQUFBLEVBQUUsQ0FBQ0ksVUFBSCxHQUFnQnZILEtBQWhCO0FBQ0FtSCxFQUFBQSxFQUFFLENBQUNPLGFBQUgsR0FBbUI3a0IsUUFBbkI7O0FBRUEsTUFBSSxDQUFDc2tCLEVBQUUsQ0FBQ0UsWUFBUixFQUFzQjtBQUNwQixRQUFJRyxFQUFFLEdBQUcsS0FBSzdILGNBQWQ7QUFDQSxRQUFJd0gsRUFBRSxDQUFDTSxhQUFILElBQW9CRCxFQUFFLENBQUNyRixZQUF2QixJQUF1Q3FGLEVBQUUsQ0FBQ3R6QixNQUFILEdBQVlzekIsRUFBRSxDQUFDbEksYUFBMUQsRUFBeUUsS0FBS3dELEtBQUwsQ0FBVzBFLEVBQUUsQ0FBQ2xJLGFBQWQ7QUFDMUU7QUFDRixDQVZELEVBVUc7QUFDSDtBQUNBOzs7QUFHQVEsU0FBUyxDQUFDNXVCLFNBQVYsQ0FBb0I0eEIsS0FBcEIsR0FBNEIsVUFBVTViLENBQVYsRUFBYTtBQUN2QyxNQUFJaWdCLEVBQUUsR0FBRyxLQUFLQyxlQUFkOztBQUVBLE1BQUlELEVBQUUsQ0FBQ0ksVUFBSCxLQUFrQixJQUFsQixJQUEwQixDQUFDSixFQUFFLENBQUNFLFlBQWxDLEVBQWdEO0FBQzlDRixJQUFBQSxFQUFFLENBQUNFLFlBQUgsR0FBa0IsSUFBbEI7O0FBRUEsU0FBS3RILFVBQUwsQ0FBZ0JvSCxFQUFFLENBQUNJLFVBQW5CLEVBQStCSixFQUFFLENBQUNPLGFBQWxDLEVBQWlEUCxFQUFFLENBQUNELGNBQXBEO0FBQ0QsR0FKRCxNQUlPO0FBQ0w7QUFDQTtBQUNBQyxJQUFBQSxFQUFFLENBQUNNLGFBQUgsR0FBbUIsSUFBbkI7QUFDRDtBQUNGLENBWkQ7O0FBY0EzSCxTQUFTLENBQUM1dUIsU0FBVixDQUFvQjh4QixRQUFwQixHQUErQixVQUFVcmUsR0FBVixFQUFlTCxFQUFmLEVBQW1CO0FBQ2hEeWEsRUFBQUEsTUFBTSxDQUFDN3RCLFNBQVAsQ0FBaUI4eEIsUUFBakIsQ0FBMEJydEIsSUFBMUIsQ0FBK0IsSUFBL0IsRUFBcUNnUCxHQUFyQyxFQUEwQyxVQUFVcWpCLElBQVYsRUFBZ0I7QUFDeEQxakIsSUFBQUEsRUFBRSxDQUFDMGpCLElBQUQsQ0FBRjtBQUNELEdBRkQ7QUFHRCxDQUpEOztBQU1BLFNBQVNGLElBQVQsQ0FBY3JHLE1BQWQsRUFBc0J2SSxFQUF0QixFQUEwQjlzQixJQUExQixFQUFnQztBQUM5QixNQUFJOHNCLEVBQUosRUFBUSxPQUFPdUksTUFBTSxDQUFDMUksSUFBUCxDQUFZLE9BQVosRUFBcUJHLEVBQXJCLENBQVA7QUFDUixNQUFJOXNCLElBQUksSUFBSSxJQUFaLEVBQWtCO0FBQ2hCcTFCLElBQUFBLE1BQU0sQ0FBQzV0QixJQUFQLENBQVl6SCxJQUFaLEVBSDRCLENBR1Q7QUFDckI7QUFDQTs7QUFFQSxNQUFJcTFCLE1BQU0sQ0FBQ3BDLGNBQVAsQ0FBc0JuckIsTUFBMUIsRUFBa0MsTUFBTSxJQUFJK3lCLDJCQUFKLEVBQU47QUFDbEMsTUFBSXhGLE1BQU0sQ0FBQzJGLGVBQVAsQ0FBdUJDLFlBQTNCLEVBQXlDLE1BQU0sSUFBSUwsa0NBQUosRUFBTjtBQUN6QyxTQUFPdkYsTUFBTSxDQUFDNXRCLElBQVAsQ0FBWSxJQUFaLENBQVA7QUFDRDs7Ozs7Ozs7OztBQ3hNRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWJ6SSxNQUFNLENBQUM1QixPQUFQLEdBQWlCeTFCLFFBQWpCO0FBQ0E7O0FBRUEsU0FBU2dKLFFBQVQsQ0FBa0JqSSxLQUFsQixFQUF5Qm5kLFFBQXpCLEVBQW1DeUIsRUFBbkMsRUFBdUM7QUFDckMsT0FBSzBiLEtBQUwsR0FBYUEsS0FBYjtBQUNBLE9BQUtuZCxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBLE9BQUtyRixRQUFMLEdBQWdCOEcsRUFBaEI7QUFDQSxPQUFLdWYsSUFBTCxHQUFZLElBQVo7QUFDRCxFQUFDO0FBQ0Y7OztBQUdBLFNBQVNxRSxhQUFULENBQXVCN04sS0FBdkIsRUFBOEI7QUFDNUIsTUFBSStMLEtBQUssR0FBRyxJQUFaOztBQUVBLE9BQUt2QyxJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUtzRSxLQUFMLEdBQWEsSUFBYjs7QUFFQSxPQUFLQyxNQUFMLEdBQWMsWUFBWTtBQUN4QkMsSUFBQUEsY0FBYyxDQUFDakMsS0FBRCxFQUFRL0wsS0FBUixDQUFkO0FBQ0QsR0FGRDtBQUdEO0FBQ0Q7O0FBRUE7OztBQUdBLElBQUkwRSxNQUFKO0FBQ0E7O0FBRUFFLFFBQVEsQ0FBQ3FKLGFBQVQsR0FBeUJBLGFBQXpCO0FBQ0E7O0FBRUEsSUFBSUMsWUFBWSxHQUFHO0FBQ2pCQyxFQUFBQSxTQUFTLEVBQUU3K0IsbUJBQU8sQ0FBQyxnRUFBRDtBQURELENBQW5CO0FBR0E7O0FBRUE7O0FBRUEsSUFBSXkyQixNQUFNLEdBQUd6MkIsbUJBQU8sQ0FBQyx3R0FBRCxDQUFwQjtBQUNBOzs7QUFHQSxJQUFJUyxNQUFNLEdBQUdULDRFQUFiOztBQUVBLElBQUkwMkIsYUFBYSxHQUFHQyxxQkFBTSxDQUFDejFCLFVBQVAsSUFBcUIsWUFBWSxDQUFFLENBQXZEOztBQUVBLFNBQVMwMUIsbUJBQVQsQ0FBNkJQLEtBQTdCLEVBQW9DO0FBQ2xDLFNBQU81MUIsTUFBTSxDQUFDQyxJQUFQLENBQVkyMUIsS0FBWixDQUFQO0FBQ0Q7O0FBRUQsU0FBU1EsYUFBVCxDQUF1QmhoQixHQUF2QixFQUE0QjtBQUMxQixTQUFPcFYsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQnNHLEdBQWhCLEtBQXdCQSxHQUFHLFlBQVk2Z0IsYUFBOUM7QUFDRDs7QUFFRCxJQUFJUSxXQUFXLEdBQUdsM0IsbUJBQU8sQ0FBQyxrR0FBRCxDQUF6Qjs7QUFFQSxJQUFJbTNCLFFBQVEsR0FBR24zQixtQkFBTyxDQUFDLDhGQUFELENBQXRCO0FBQUEsSUFDSW8zQixnQkFBZ0IsR0FBR0QsUUFBUSxDQUFDQyxnQkFEaEM7O0FBR0EsSUFBSUMsY0FBYyxHQUFHcjNCLGdHQUFyQjtBQUFBLElBQ0kyc0Isb0JBQW9CLEdBQUcwSyxjQUFjLENBQUMxSyxvQkFEMUM7QUFBQSxJQUVJNEssMEJBQTBCLEdBQUdGLGNBQWMsQ0FBQ0UsMEJBRmhEO0FBQUEsSUFHSTZGLHFCQUFxQixHQUFHL0YsY0FBYyxDQUFDK0YscUJBSDNDO0FBQUEsSUFJSTBCLHNCQUFzQixHQUFHekgsY0FBYyxDQUFDeUgsc0JBSjVDO0FBQUEsSUFLSUMsb0JBQW9CLEdBQUcxSCxjQUFjLENBQUMwSCxvQkFMMUM7QUFBQSxJQU1JQyxzQkFBc0IsR0FBRzNILGNBQWMsQ0FBQzJILHNCQU41QztBQUFBLElBT0lDLDBCQUEwQixHQUFHNUgsY0FBYyxDQUFDNEgsMEJBUGhEO0FBQUEsSUFRSUMsb0JBQW9CLEdBQUc3SCxjQUFjLENBQUM2SCxvQkFSMUM7O0FBVUEsSUFBSXZILGNBQWMsR0FBR1QsV0FBVyxDQUFDUyxjQUFqQzs7QUFFQTMzQixtQkFBTyxDQUFDLDZEQUFELENBQVAsQ0FBb0JzMUIsUUFBcEIsRUFBOEJtQixNQUE5Qjs7QUFFQSxTQUFTMEksR0FBVCxHQUFlLENBQUU7O0FBRWpCLFNBQVNSLGFBQVQsQ0FBdUJ4ekIsT0FBdkIsRUFBZ0Myc0IsTUFBaEMsRUFBd0NDLFFBQXhDLEVBQWtEO0FBQ2hEM0MsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLElBQUlwMUIsbUJBQU8sQ0FBQyw4RUFBRCxDQUExQjtBQUNBbUwsRUFBQUEsT0FBTyxHQUFHQSxPQUFPLElBQUksRUFBckIsQ0FGZ0QsQ0FFdkI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSSxPQUFPNHNCLFFBQVAsS0FBb0IsU0FBeEIsRUFBbUNBLFFBQVEsR0FBR0QsTUFBTSxZQUFZMUMsTUFBN0IsQ0FSYSxDQVF3QjtBQUN4RTs7QUFFQSxPQUFLNEMsVUFBTCxHQUFrQixDQUFDLENBQUM3c0IsT0FBTyxDQUFDNnNCLFVBQTVCO0FBQ0EsTUFBSUQsUUFBSixFQUFjLEtBQUtDLFVBQUwsR0FBa0IsS0FBS0EsVUFBTCxJQUFtQixDQUFDLENBQUM3c0IsT0FBTyxDQUFDaTBCLGtCQUEvQyxDQVprQyxDQVlpQztBQUNqRjtBQUNBOztBQUVBLE9BQUt6SixhQUFMLEdBQXFCeUIsZ0JBQWdCLENBQUMsSUFBRCxFQUFPanNCLE9BQVAsRUFBZ0IsdUJBQWhCLEVBQXlDNHNCLFFBQXpDLENBQXJDLENBaEJnRCxDQWdCeUM7O0FBRXpGLE9BQUtzSCxXQUFMLEdBQW1CLEtBQW5CLENBbEJnRCxDQWtCdEI7O0FBRTFCLE9BQUt0RCxTQUFMLEdBQWlCLEtBQWpCLENBcEJnRCxDQW9CeEI7O0FBRXhCLE9BQUt1RCxNQUFMLEdBQWMsS0FBZCxDQXRCZ0QsQ0FzQjNCOztBQUVyQixPQUFLekosS0FBTCxHQUFhLEtBQWIsQ0F4QmdELENBd0I1Qjs7QUFFcEIsT0FBS29ILFFBQUwsR0FBZ0IsS0FBaEIsQ0ExQmdELENBMEJ6Qjs7QUFFdkIsT0FBS2hILFNBQUwsR0FBaUIsS0FBakIsQ0E1QmdELENBNEJ4QjtBQUN4QjtBQUNBOztBQUVBLE1BQUlzSixRQUFRLEdBQUdwMEIsT0FBTyxDQUFDcTBCLGFBQVIsS0FBMEIsS0FBekM7QUFDQSxPQUFLQSxhQUFMLEdBQXFCLENBQUNELFFBQXRCLENBakNnRCxDQWlDaEI7QUFDaEM7QUFDQTs7QUFFQSxPQUFLeEcsZUFBTCxHQUF1QjV0QixPQUFPLENBQUM0dEIsZUFBUixJQUEyQixNQUFsRCxDQXJDZ0QsQ0FxQ1U7QUFDMUQ7QUFDQTs7QUFFQSxPQUFLeHVCLE1BQUwsR0FBYyxDQUFkLENBekNnRCxDQXlDL0I7O0FBRWpCLE9BQUtrMUIsT0FBTCxHQUFlLEtBQWYsQ0EzQ2dELENBMkMxQjs7QUFFdEIsT0FBS0MsTUFBTCxHQUFjLENBQWQsQ0E3Q2dELENBNkMvQjtBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsT0FBS25ILElBQUwsR0FBWSxJQUFaLENBbERnRCxDQWtEOUI7QUFDbEI7QUFDQTs7QUFFQSxPQUFLb0gsZ0JBQUwsR0FBd0IsS0FBeEIsQ0F0RGdELENBc0RqQjs7QUFFL0IsT0FBS0MsT0FBTCxHQUFlLFVBQVVyUSxFQUFWLEVBQWM7QUFDM0JxUSxJQUFBQSxPQUFPLENBQUM5SCxNQUFELEVBQVN2SSxFQUFULENBQVA7QUFDRCxHQUZELENBeERnRCxDQTBEN0M7OztBQUdILE9BQUtvTyxPQUFMLEdBQWUsSUFBZixDQTdEZ0QsQ0E2RDNCOztBQUVyQixPQUFLa0MsUUFBTCxHQUFnQixDQUFoQjtBQUNBLE9BQUtDLGVBQUwsR0FBdUIsSUFBdkI7QUFDQSxPQUFLQyxtQkFBTCxHQUEyQixJQUEzQixDQWpFZ0QsQ0FpRWY7QUFDakM7O0FBRUEsT0FBS0MsU0FBTCxHQUFpQixDQUFqQixDQXBFZ0QsQ0FvRTVCO0FBQ3BCOztBQUVBLE9BQUtDLFdBQUwsR0FBbUIsS0FBbkIsQ0F2RWdELENBdUV0Qjs7QUFFMUIsT0FBS0MsWUFBTCxHQUFvQixLQUFwQixDQXpFZ0QsQ0F5RXJCOztBQUUzQixPQUFLckgsU0FBTCxHQUFpQjF0QixPQUFPLENBQUMwdEIsU0FBUixLQUFzQixLQUF2QyxDQTNFZ0QsQ0EyRUY7O0FBRTlDLE9BQUtDLFdBQUwsR0FBbUIsQ0FBQyxDQUFDM3RCLE9BQU8sQ0FBQzJ0QixXQUE3QixDQTdFZ0QsQ0E2RU47O0FBRTFDLE9BQUtxSCxvQkFBTCxHQUE0QixDQUE1QixDQS9FZ0QsQ0ErRWpCO0FBQy9COztBQUVBLE9BQUtDLGtCQUFMLEdBQTBCLElBQUk3QixhQUFKLENBQWtCLElBQWxCLENBQTFCO0FBQ0Q7O0FBRURJLGFBQWEsQ0FBQ3AzQixTQUFkLENBQXdCcXVCLFNBQXhCLEdBQW9DLFNBQVNBLFNBQVQsR0FBcUI7QUFDdkQsTUFBSXlLLE9BQU8sR0FBRyxLQUFLUCxlQUFuQjtBQUNBLE1BQUl4Z0IsR0FBRyxHQUFHLEVBQVY7O0FBRUEsU0FBTytnQixPQUFQLEVBQWdCO0FBQ2QvZ0IsSUFBQUEsR0FBRyxDQUFDcFYsSUFBSixDQUFTbTJCLE9BQVQ7QUFDQUEsSUFBQUEsT0FBTyxHQUFHQSxPQUFPLENBQUNuRyxJQUFsQjtBQUNEOztBQUVELFNBQU81YSxHQUFQO0FBQ0QsQ0FWRDs7QUFZQSxDQUFDLFlBQVk7QUFDWCxNQUFJO0FBQ0YzZixJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0IrK0IsYUFBYSxDQUFDcDNCLFNBQXBDLEVBQStDLFFBQS9DLEVBQXlEO0FBQ3ZEbVosTUFBQUEsR0FBRyxFQUFFa2UsWUFBWSxDQUFDQyxTQUFiLENBQXVCLFNBQVN5Qix5QkFBVCxHQUFxQztBQUMvRCxlQUFPLEtBQUsxSyxTQUFMLEVBQVA7QUFDRCxPQUZJLEVBRUYsdUVBQXVFLFVBRnJFLEVBRWlGLFNBRmpGO0FBRGtELEtBQXpEO0FBS0QsR0FORCxDQU1FLE9BQU8ySyxDQUFQLEVBQVUsQ0FBRTtBQUNmLENBUkQsS0FRTTtBQUNOOzs7QUFHQSxJQUFJQyxlQUFKOztBQUVBLElBQUksT0FBT3pnQixNQUFQLEtBQWtCLFVBQWxCLElBQWdDQSxNQUFNLENBQUMwZ0IsV0FBdkMsSUFBc0QsT0FBTzNTLFFBQVEsQ0FBQ3ZtQixTQUFULENBQW1Cd1ksTUFBTSxDQUFDMGdCLFdBQTFCLENBQVAsS0FBa0QsVUFBNUcsRUFBd0g7QUFDdEhELEVBQUFBLGVBQWUsR0FBRzFTLFFBQVEsQ0FBQ3ZtQixTQUFULENBQW1Cd1ksTUFBTSxDQUFDMGdCLFdBQTFCLENBQWxCO0FBQ0E5Z0MsRUFBQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCMDFCLFFBQXRCLEVBQWdDdlYsTUFBTSxDQUFDMGdCLFdBQXZDLEVBQW9EO0FBQ2xEM2dDLElBQUFBLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWU0Z0MsTUFBZixFQUF1QjtBQUM1QixVQUFJRixlQUFlLENBQUN4MEIsSUFBaEIsQ0FBcUIsSUFBckIsRUFBMkIwMEIsTUFBM0IsQ0FBSixFQUF3QyxPQUFPLElBQVA7QUFDeEMsVUFBSSxTQUFTcEwsUUFBYixFQUF1QixPQUFPLEtBQVA7QUFDdkIsYUFBT29MLE1BQU0sSUFBSUEsTUFBTSxDQUFDaEwsY0FBUCxZQUFpQ2lKLGFBQWxEO0FBQ0Q7QUFMaUQsR0FBcEQ7QUFPRCxDQVRELE1BU087QUFDTDZCLEVBQUFBLGVBQWUsR0FBRyxTQUFTQSxlQUFULENBQXlCRSxNQUF6QixFQUFpQztBQUNqRCxXQUFPQSxNQUFNLFlBQVksSUFBekI7QUFDRCxHQUZEO0FBR0Q7O0FBRUQsU0FBU3BMLFFBQVQsQ0FBa0JucUIsT0FBbEIsRUFBMkI7QUFDekJpcUIsRUFBQUEsTUFBTSxHQUFHQSxNQUFNLElBQUlwMUIsbUJBQU8sQ0FBQyw4RUFBRCxDQUExQixDQUR5QixDQUN1QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFJKzNCLFFBQVEsR0FBRyxnQkFBZ0IzQyxNQUEvQjtBQUNBLE1BQUksQ0FBQzJDLFFBQUQsSUFBYSxDQUFDeUksZUFBZSxDQUFDeDBCLElBQWhCLENBQXFCc3BCLFFBQXJCLEVBQStCLElBQS9CLENBQWxCLEVBQXdELE9BQU8sSUFBSUEsUUFBSixDQUFhbnFCLE9BQWIsQ0FBUDtBQUN4RCxPQUFLdXFCLGNBQUwsR0FBc0IsSUFBSWlKLGFBQUosQ0FBa0J4ekIsT0FBbEIsRUFBMkIsSUFBM0IsRUFBaUM0c0IsUUFBakMsQ0FBdEIsQ0FaeUIsQ0FZeUM7O0FBRWxFLE9BQUs3TCxRQUFMLEdBQWdCLElBQWhCOztBQUVBLE1BQUkvZ0IsT0FBSixFQUFhO0FBQ1gsUUFBSSxPQUFPQSxPQUFPLENBQUM4RixLQUFmLEtBQXlCLFVBQTdCLEVBQXlDLEtBQUttdEIsTUFBTCxHQUFjanpCLE9BQU8sQ0FBQzhGLEtBQXRCO0FBQ3pDLFFBQUksT0FBTzlGLE9BQU8sQ0FBQ3cxQixNQUFmLEtBQTBCLFVBQTlCLEVBQTBDLEtBQUtDLE9BQUwsR0FBZXoxQixPQUFPLENBQUN3MUIsTUFBdkI7QUFDMUMsUUFBSSxPQUFPeDFCLE9BQU8sQ0FBQ2l1QixPQUFmLEtBQTJCLFVBQS9CLEVBQTJDLEtBQUtDLFFBQUwsR0FBZ0JsdUIsT0FBTyxDQUFDaXVCLE9BQXhCO0FBQzNDLFFBQUksT0FBT2p1QixPQUFPLFNBQWQsS0FBeUIsVUFBN0IsRUFBeUMsS0FBSzAxQixNQUFMLEdBQWMxMUIsT0FBTyxTQUFyQjtBQUMxQzs7QUFFRHNyQixFQUFBQSxNQUFNLENBQUN6cUIsSUFBUCxDQUFZLElBQVo7QUFDRCxFQUFDOzs7QUFHRnNwQixRQUFRLENBQUMvdEIsU0FBVCxDQUFtQmtPLElBQW5CLEdBQTBCLFlBQVk7QUFDcENraUIsRUFBQUEsY0FBYyxDQUFDLElBQUQsRUFBTyxJQUFJbUgsc0JBQUosRUFBUCxDQUFkO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTZ0MsYUFBVCxDQUF1QmhKLE1BQXZCLEVBQStCbmQsRUFBL0IsRUFBbUM7QUFDakMsTUFBSTRVLEVBQUUsR0FBRyxJQUFJMFAsMEJBQUosRUFBVCxDQURpQyxDQUNVOztBQUUzQ3RILEVBQUFBLGNBQWMsQ0FBQ0csTUFBRCxFQUFTdkksRUFBVCxDQUFkO0FBQ0E1Z0IsRUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJuYixFQUFqQixFQUFxQjRVLEVBQXJCO0FBQ0QsRUFBQztBQUNGO0FBQ0E7OztBQUdBLFNBQVN3UixVQUFULENBQW9CakosTUFBcEIsRUFBNEJwSCxLQUE1QixFQUFtQzJGLEtBQW5DLEVBQTBDMWIsRUFBMUMsRUFBOEM7QUFDNUMsTUFBSTRVLEVBQUo7O0FBRUEsTUFBSThHLEtBQUssS0FBSyxJQUFkLEVBQW9CO0FBQ2xCOUcsSUFBQUEsRUFBRSxHQUFHLElBQUl5UCxzQkFBSixFQUFMO0FBQ0QsR0FGRCxNQUVPLElBQUksT0FBTzNJLEtBQVAsS0FBaUIsUUFBakIsSUFBNkIsQ0FBQzNGLEtBQUssQ0FBQ3NILFVBQXhDLEVBQW9EO0FBQ3pEekksSUFBQUEsRUFBRSxHQUFHLElBQUk1QyxvQkFBSixDQUF5QixPQUF6QixFQUFrQyxDQUFDLFFBQUQsRUFBVyxRQUFYLENBQWxDLEVBQXdEMEosS0FBeEQsQ0FBTDtBQUNEOztBQUVELE1BQUk5RyxFQUFKLEVBQVE7QUFDTm9JLElBQUFBLGNBQWMsQ0FBQ0csTUFBRCxFQUFTdkksRUFBVCxDQUFkO0FBQ0E1Z0IsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJuYixFQUFqQixFQUFxQjRVLEVBQXJCO0FBQ0EsV0FBTyxLQUFQO0FBQ0Q7O0FBRUQsU0FBTyxJQUFQO0FBQ0Q7O0FBRUQrRixRQUFRLENBQUMvdEIsU0FBVCxDQUFtQjBKLEtBQW5CLEdBQTJCLFVBQVVvbEIsS0FBVixFQUFpQm5kLFFBQWpCLEVBQTJCeUIsRUFBM0IsRUFBK0I7QUFDeEQsTUFBSStWLEtBQUssR0FBRyxLQUFLZ0YsY0FBakI7QUFDQSxNQUFJbFAsR0FBRyxHQUFHLEtBQVY7O0FBRUEsTUFBSXdhLEtBQUssR0FBRyxDQUFDdFEsS0FBSyxDQUFDc0gsVUFBUCxJQUFxQm5CLGFBQWEsQ0FBQ1IsS0FBRCxDQUE5Qzs7QUFFQSxNQUFJMkssS0FBSyxJQUFJLENBQUN2Z0MsTUFBTSxDQUFDOE8sUUFBUCxDQUFnQjhtQixLQUFoQixDQUFkLEVBQXNDO0FBQ3BDQSxJQUFBQSxLQUFLLEdBQUdPLG1CQUFtQixDQUFDUCxLQUFELENBQTNCO0FBQ0Q7O0FBRUQsTUFBSSxPQUFPbmQsUUFBUCxLQUFvQixVQUF4QixFQUFvQztBQUNsQ3lCLElBQUFBLEVBQUUsR0FBR3pCLFFBQUw7QUFDQUEsSUFBQUEsUUFBUSxHQUFHLElBQVg7QUFDRDs7QUFFRCxNQUFJOG5CLEtBQUosRUFBVzluQixRQUFRLEdBQUcsUUFBWCxDQUFYLEtBQW9DLElBQUksQ0FBQ0EsUUFBTCxFQUFlQSxRQUFRLEdBQUd3WCxLQUFLLENBQUNxSSxlQUFqQjtBQUNuRCxNQUFJLE9BQU9wZSxFQUFQLEtBQWMsVUFBbEIsRUFBOEJBLEVBQUUsR0FBR3drQixHQUFMO0FBQzlCLE1BQUl6TyxLQUFLLENBQUM0TyxNQUFWLEVBQWtCd0IsYUFBYSxDQUFDLElBQUQsRUFBT25tQixFQUFQLENBQWIsQ0FBbEIsS0FBK0MsSUFBSXFtQixLQUFLLElBQUlELFVBQVUsQ0FBQyxJQUFELEVBQU9yUSxLQUFQLEVBQWMyRixLQUFkLEVBQXFCMWIsRUFBckIsQ0FBdkIsRUFBaUQ7QUFDOUYrVixJQUFBQSxLQUFLLENBQUNzUCxTQUFOO0FBQ0F4WixJQUFBQSxHQUFHLEdBQUd5YSxhQUFhLENBQUMsSUFBRCxFQUFPdlEsS0FBUCxFQUFjc1EsS0FBZCxFQUFxQjNLLEtBQXJCLEVBQTRCbmQsUUFBNUIsRUFBc0N5QixFQUF0QyxDQUFuQjtBQUNEO0FBQ0QsU0FBTzZMLEdBQVA7QUFDRCxDQXRCRDs7QUF3QkE4TyxRQUFRLENBQUMvdEIsU0FBVCxDQUFtQjI1QixJQUFuQixHQUEwQixZQUFZO0FBQ3BDLE9BQUt4TCxjQUFMLENBQW9CZ0ssTUFBcEI7QUFDRCxDQUZEOztBQUlBcEssUUFBUSxDQUFDL3RCLFNBQVQsQ0FBbUI0NUIsTUFBbkIsR0FBNEIsWUFBWTtBQUN0QyxNQUFJelEsS0FBSyxHQUFHLEtBQUtnRixjQUFqQjs7QUFFQSxNQUFJaEYsS0FBSyxDQUFDZ1AsTUFBVixFQUFrQjtBQUNoQmhQLElBQUFBLEtBQUssQ0FBQ2dQLE1BQU47QUFDQSxRQUFJLENBQUNoUCxLQUFLLENBQUMrTyxPQUFQLElBQWtCLENBQUMvTyxLQUFLLENBQUNnUCxNQUF6QixJQUFtQyxDQUFDaFAsS0FBSyxDQUFDaVAsZ0JBQTFDLElBQThEalAsS0FBSyxDQUFDb1AsZUFBeEUsRUFBeUZzQixXQUFXLENBQUMsSUFBRCxFQUFPMVEsS0FBUCxDQUFYO0FBQzFGO0FBQ0YsQ0FQRDs7QUFTQTRFLFFBQVEsQ0FBQy90QixTQUFULENBQW1CODVCLGtCQUFuQixHQUF3QyxTQUFTQSxrQkFBVCxDQUE0Qm5vQixRQUE1QixFQUFzQztBQUM1RTtBQUNBLE1BQUksT0FBT0EsUUFBUCxLQUFvQixRQUF4QixFQUFrQ0EsUUFBUSxHQUFHQSxRQUFRLENBQUNoVCxXQUFULEVBQVg7QUFDbEMsTUFBSSxFQUFFLENBQUMsS0FBRCxFQUFRLE1BQVIsRUFBZ0IsT0FBaEIsRUFBeUIsT0FBekIsRUFBa0MsUUFBbEMsRUFBNEMsUUFBNUMsRUFBc0QsTUFBdEQsRUFBOEQsT0FBOUQsRUFBdUUsU0FBdkUsRUFBa0YsVUFBbEYsRUFBOEYsS0FBOUYsRUFBcUd0QixPQUFyRyxDQUE2RyxDQUFDc1UsUUFBUSxHQUFHLEVBQVosRUFBZ0JoVCxXQUFoQixFQUE3RyxJQUE4SSxDQUFDLENBQWpKLENBQUosRUFBeUosTUFBTSxJQUFJZzVCLG9CQUFKLENBQXlCaG1CLFFBQXpCLENBQU47QUFDekosT0FBS3djLGNBQUwsQ0FBb0JxRCxlQUFwQixHQUFzQzdmLFFBQXRDO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FORDs7QUFRQXZaLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQjAxQixRQUFRLENBQUMvdEIsU0FBL0IsRUFBMEMsZ0JBQTFDLEVBQTREO0FBQzFEO0FBQ0E7QUFDQTtBQUNBa1osRUFBQUEsVUFBVSxFQUFFLEtBSjhDO0FBSzFEQyxFQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFdBQU8sS0FBS2dWLGNBQUwsSUFBdUIsS0FBS0EsY0FBTCxDQUFvQkUsU0FBcEIsRUFBOUI7QUFDRDtBQVB5RCxDQUE1RDs7QUFVQSxTQUFTMEwsV0FBVCxDQUFxQjVRLEtBQXJCLEVBQTRCMkYsS0FBNUIsRUFBbUNuZCxRQUFuQyxFQUE2QztBQUMzQyxNQUFJLENBQUN3WCxLQUFLLENBQUNzSCxVQUFQLElBQXFCdEgsS0FBSyxDQUFDOE8sYUFBTixLQUF3QixLQUE3QyxJQUFzRCxPQUFPbkosS0FBUCxLQUFpQixRQUEzRSxFQUFxRjtBQUNuRkEsSUFBQUEsS0FBSyxHQUFHNTFCLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZMjFCLEtBQVosRUFBbUJuZCxRQUFuQixDQUFSO0FBQ0Q7O0FBRUQsU0FBT21kLEtBQVA7QUFDRDs7QUFFRDEyQixNQUFNLENBQUNDLGNBQVAsQ0FBc0IwMUIsUUFBUSxDQUFDL3RCLFNBQS9CLEVBQTBDLHVCQUExQyxFQUFtRTtBQUNqRTtBQUNBO0FBQ0E7QUFDQWtaLEVBQUFBLFVBQVUsRUFBRSxLQUpxRDtBQUtqRUMsRUFBQUEsR0FBRyxFQUFFLFNBQVNBLEdBQVQsR0FBZTtBQUNsQixXQUFPLEtBQUtnVixjQUFMLENBQW9CQyxhQUEzQjtBQUNEO0FBUGdFLENBQW5FLEdBUUk7QUFDSjtBQUNBOztBQUVBLFNBQVNzTCxhQUFULENBQXVCbkosTUFBdkIsRUFBK0JwSCxLQUEvQixFQUFzQ3NRLEtBQXRDLEVBQTZDM0ssS0FBN0MsRUFBb0RuZCxRQUFwRCxFQUE4RHlCLEVBQTlELEVBQWtFO0FBQ2hFLE1BQUksQ0FBQ3FtQixLQUFMLEVBQVk7QUFDVixRQUFJTyxRQUFRLEdBQUdELFdBQVcsQ0FBQzVRLEtBQUQsRUFBUTJGLEtBQVIsRUFBZW5kLFFBQWYsQ0FBMUI7O0FBRUEsUUFBSW1kLEtBQUssS0FBS2tMLFFBQWQsRUFBd0I7QUFDdEJQLE1BQUFBLEtBQUssR0FBRyxJQUFSO0FBQ0E5bkIsTUFBQUEsUUFBUSxHQUFHLFFBQVg7QUFDQW1kLE1BQUFBLEtBQUssR0FBR2tMLFFBQVI7QUFDRDtBQUNGOztBQUVELE1BQUkzcUIsR0FBRyxHQUFHOFosS0FBSyxDQUFDc0gsVUFBTixHQUFtQixDQUFuQixHQUF1QjNCLEtBQUssQ0FBQzlyQixNQUF2QztBQUNBbW1CLEVBQUFBLEtBQUssQ0FBQ25tQixNQUFOLElBQWdCcU0sR0FBaEI7QUFDQSxNQUFJNFAsR0FBRyxHQUFHa0ssS0FBSyxDQUFDbm1CLE1BQU4sR0FBZW1tQixLQUFLLENBQUNpRixhQUEvQixDQWJnRSxDQWFsQjs7QUFFOUMsTUFBSSxDQUFDblAsR0FBTCxFQUFVa0ssS0FBSyxDQUFDcUwsU0FBTixHQUFrQixJQUFsQjs7QUFFVixNQUFJckwsS0FBSyxDQUFDK08sT0FBTixJQUFpQi9PLEtBQUssQ0FBQ2dQLE1BQTNCLEVBQW1DO0FBQ2pDLFFBQUl6Z0IsSUFBSSxHQUFHeVIsS0FBSyxDQUFDcVAsbUJBQWpCO0FBQ0FyUCxJQUFBQSxLQUFLLENBQUNxUCxtQkFBTixHQUE0QjtBQUMxQjFKLE1BQUFBLEtBQUssRUFBRUEsS0FEbUI7QUFFMUJuZCxNQUFBQSxRQUFRLEVBQUVBLFFBRmdCO0FBRzFCOG5CLE1BQUFBLEtBQUssRUFBRUEsS0FIbUI7QUFJMUJudEIsTUFBQUEsUUFBUSxFQUFFOEcsRUFKZ0I7QUFLMUJ1ZixNQUFBQSxJQUFJLEVBQUU7QUFMb0IsS0FBNUI7O0FBUUEsUUFBSWpiLElBQUosRUFBVTtBQUNSQSxNQUFBQSxJQUFJLENBQUNpYixJQUFMLEdBQVl4SixLQUFLLENBQUNxUCxtQkFBbEI7QUFDRCxLQUZELE1BRU87QUFDTHJQLE1BQUFBLEtBQUssQ0FBQ29QLGVBQU4sR0FBd0JwUCxLQUFLLENBQUNxUCxtQkFBOUI7QUFDRDs7QUFFRHJQLElBQUFBLEtBQUssQ0FBQ3lQLG9CQUFOLElBQThCLENBQTlCO0FBQ0QsR0FqQkQsTUFpQk87QUFDTHFCLElBQUFBLE9BQU8sQ0FBQzFKLE1BQUQsRUFBU3BILEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUI5WixHQUF2QixFQUE0QnlmLEtBQTVCLEVBQW1DbmQsUUFBbkMsRUFBNkN5QixFQUE3QyxDQUFQO0FBQ0Q7O0FBRUQsU0FBTzZMLEdBQVA7QUFDRDs7QUFFRCxTQUFTZ2IsT0FBVCxDQUFpQjFKLE1BQWpCLEVBQXlCcEgsS0FBekIsRUFBZ0NpUSxNQUFoQyxFQUF3Qy9wQixHQUF4QyxFQUE2Q3lmLEtBQTdDLEVBQW9EbmQsUUFBcEQsRUFBOER5QixFQUE5RCxFQUFrRTtBQUNoRStWLEVBQUFBLEtBQUssQ0FBQ21QLFFBQU4sR0FBaUJqcEIsR0FBakI7QUFDQThaLEVBQUFBLEtBQUssQ0FBQ2lOLE9BQU4sR0FBZ0JoakIsRUFBaEI7QUFDQStWLEVBQUFBLEtBQUssQ0FBQytPLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQS9PLEVBQUFBLEtBQUssQ0FBQzZILElBQU4sR0FBYSxJQUFiO0FBQ0EsTUFBSTdILEtBQUssQ0FBQ3VGLFNBQVYsRUFBcUJ2RixLQUFLLENBQUNrUCxPQUFOLENBQWMsSUFBSWIsb0JBQUosQ0FBeUIsT0FBekIsQ0FBZCxFQUFyQixLQUEyRSxJQUFJNEIsTUFBSixFQUFZN0ksTUFBTSxDQUFDOEksT0FBUCxDQUFldkssS0FBZixFQUFzQjNGLEtBQUssQ0FBQ2tQLE9BQTVCLEVBQVosS0FBc0Q5SCxNQUFNLENBQUNzRyxNQUFQLENBQWMvSCxLQUFkLEVBQXFCbmQsUUFBckIsRUFBK0J3WCxLQUFLLENBQUNrUCxPQUFyQztBQUNqSWxQLEVBQUFBLEtBQUssQ0FBQzZILElBQU4sR0FBYSxLQUFiO0FBQ0Q7O0FBRUQsU0FBU2tKLFlBQVQsQ0FBc0IzSixNQUF0QixFQUE4QnBILEtBQTlCLEVBQXFDNkgsSUFBckMsRUFBMkNoSixFQUEzQyxFQUErQzVVLEVBQS9DLEVBQW1EO0FBQ2pELElBQUUrVixLQUFLLENBQUNzUCxTQUFSOztBQUVBLE1BQUl6SCxJQUFKLEVBQVU7QUFDUjtBQUNBO0FBQ0E1cEIsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJuYixFQUFqQixFQUFxQjRVLEVBQXJCLEVBSFEsQ0FHa0I7QUFDMUI7O0FBRUE1Z0IsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUI0TCxXQUFqQixFQUE4QjVKLE1BQTlCLEVBQXNDcEgsS0FBdEM7QUFDQW9ILElBQUFBLE1BQU0sQ0FBQ3BDLGNBQVAsQ0FBc0J3SyxZQUF0QixHQUFxQyxJQUFyQztBQUNBdkksSUFBQUEsY0FBYyxDQUFDRyxNQUFELEVBQVN2SSxFQUFULENBQWQ7QUFDRCxHQVRELE1BU087QUFDTDtBQUNBO0FBQ0E1VSxJQUFBQSxFQUFFLENBQUM0VSxFQUFELENBQUY7QUFDQXVJLElBQUFBLE1BQU0sQ0FBQ3BDLGNBQVAsQ0FBc0J3SyxZQUF0QixHQUFxQyxJQUFyQztBQUNBdkksSUFBQUEsY0FBYyxDQUFDRyxNQUFELEVBQVN2SSxFQUFULENBQWQsQ0FMSyxDQUt1QjtBQUM1Qjs7QUFFQW1TLElBQUFBLFdBQVcsQ0FBQzVKLE1BQUQsRUFBU3BILEtBQVQsQ0FBWDtBQUNEO0FBQ0Y7O0FBRUQsU0FBU2lSLGtCQUFULENBQTRCalIsS0FBNUIsRUFBbUM7QUFDakNBLEVBQUFBLEtBQUssQ0FBQytPLE9BQU4sR0FBZ0IsS0FBaEI7QUFDQS9PLEVBQUFBLEtBQUssQ0FBQ2lOLE9BQU4sR0FBZ0IsSUFBaEI7QUFDQWpOLEVBQUFBLEtBQUssQ0FBQ25tQixNQUFOLElBQWdCbW1CLEtBQUssQ0FBQ21QLFFBQXRCO0FBQ0FuUCxFQUFBQSxLQUFLLENBQUNtUCxRQUFOLEdBQWlCLENBQWpCO0FBQ0Q7O0FBRUQsU0FBU0QsT0FBVCxDQUFpQjlILE1BQWpCLEVBQXlCdkksRUFBekIsRUFBNkI7QUFDM0IsTUFBSW1CLEtBQUssR0FBR29ILE1BQU0sQ0FBQ3BDLGNBQW5CO0FBQ0EsTUFBSTZDLElBQUksR0FBRzdILEtBQUssQ0FBQzZILElBQWpCO0FBQ0EsTUFBSTVkLEVBQUUsR0FBRytWLEtBQUssQ0FBQ2lOLE9BQWY7QUFDQSxNQUFJLE9BQU9oakIsRUFBUCxLQUFjLFVBQWxCLEVBQThCLE1BQU0sSUFBSXlpQixxQkFBSixFQUFOO0FBQzlCdUUsRUFBQUEsa0JBQWtCLENBQUNqUixLQUFELENBQWxCO0FBQ0EsTUFBSW5CLEVBQUosRUFBUWtTLFlBQVksQ0FBQzNKLE1BQUQsRUFBU3BILEtBQVQsRUFBZ0I2SCxJQUFoQixFQUFzQmhKLEVBQXRCLEVBQTBCNVUsRUFBMUIsQ0FBWixDQUFSLEtBQXVEO0FBQ3JEO0FBQ0EsUUFBSXNpQixRQUFRLEdBQUcyRSxVQUFVLENBQUNsUixLQUFELENBQVYsSUFBcUJvSCxNQUFNLENBQUM3QixTQUEzQzs7QUFFQSxRQUFJLENBQUNnSCxRQUFELElBQWEsQ0FBQ3ZNLEtBQUssQ0FBQ2dQLE1BQXBCLElBQThCLENBQUNoUCxLQUFLLENBQUNpUCxnQkFBckMsSUFBeURqUCxLQUFLLENBQUNvUCxlQUFuRSxFQUFvRjtBQUNsRnNCLE1BQUFBLFdBQVcsQ0FBQ3RKLE1BQUQsRUFBU3BILEtBQVQsQ0FBWDtBQUNEOztBQUVELFFBQUk2SCxJQUFKLEVBQVU7QUFDUjVwQixNQUFBQSxPQUFPLENBQUNtbkIsUUFBUixDQUFpQitMLFVBQWpCLEVBQTZCL0osTUFBN0IsRUFBcUNwSCxLQUFyQyxFQUE0Q3VNLFFBQTVDLEVBQXNEdGlCLEVBQXREO0FBQ0QsS0FGRCxNQUVPO0FBQ0xrbkIsTUFBQUEsVUFBVSxDQUFDL0osTUFBRCxFQUFTcEgsS0FBVCxFQUFnQnVNLFFBQWhCLEVBQTBCdGlCLEVBQTFCLENBQVY7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU2tuQixVQUFULENBQW9CL0osTUFBcEIsRUFBNEJwSCxLQUE1QixFQUFtQ3VNLFFBQW5DLEVBQTZDdGlCLEVBQTdDLEVBQWlEO0FBQy9DLE1BQUksQ0FBQ3NpQixRQUFMLEVBQWU2RSxZQUFZLENBQUNoSyxNQUFELEVBQVNwSCxLQUFULENBQVo7QUFDZkEsRUFBQUEsS0FBSyxDQUFDc1AsU0FBTjtBQUNBcmxCLEVBQUFBLEVBQUU7QUFDRittQixFQUFBQSxXQUFXLENBQUM1SixNQUFELEVBQVNwSCxLQUFULENBQVg7QUFDRCxFQUFDO0FBQ0Y7QUFDQTs7O0FBR0EsU0FBU29SLFlBQVQsQ0FBc0JoSyxNQUF0QixFQUE4QnBILEtBQTlCLEVBQXFDO0FBQ25DLE1BQUlBLEtBQUssQ0FBQ25tQixNQUFOLEtBQWlCLENBQWpCLElBQXNCbW1CLEtBQUssQ0FBQ3FMLFNBQWhDLEVBQTJDO0FBQ3pDckwsSUFBQUEsS0FBSyxDQUFDcUwsU0FBTixHQUFrQixLQUFsQjtBQUNBakUsSUFBQUEsTUFBTSxDQUFDMUksSUFBUCxDQUFZLE9BQVo7QUFDRDtBQUNGLEVBQUM7OztBQUdGLFNBQVNnUyxXQUFULENBQXFCdEosTUFBckIsRUFBNkJwSCxLQUE3QixFQUFvQztBQUNsQ0EsRUFBQUEsS0FBSyxDQUFDaVAsZ0JBQU4sR0FBeUIsSUFBekI7QUFDQSxNQUFJbkIsS0FBSyxHQUFHOU4sS0FBSyxDQUFDb1AsZUFBbEI7O0FBRUEsTUFBSWhJLE1BQU0sQ0FBQzhJLE9BQVAsSUFBa0JwQyxLQUFsQixJQUEyQkEsS0FBSyxDQUFDdEUsSUFBckMsRUFBMkM7QUFDekM7QUFDQSxRQUFJcGtCLENBQUMsR0FBRzRhLEtBQUssQ0FBQ3lQLG9CQUFkO0FBQ0EsUUFBSXZ3QixNQUFNLEdBQUcsSUFBSXhGLEtBQUosQ0FBVTBMLENBQVYsQ0FBYjtBQUNBLFFBQUlpc0IsTUFBTSxHQUFHclIsS0FBSyxDQUFDMFAsa0JBQW5CO0FBQ0EyQixJQUFBQSxNQUFNLENBQUN2RCxLQUFQLEdBQWVBLEtBQWY7QUFDQSxRQUFJdk8sS0FBSyxHQUFHLENBQVo7QUFDQSxRQUFJK1IsVUFBVSxHQUFHLElBQWpCOztBQUVBLFdBQU94RCxLQUFQLEVBQWM7QUFDWjV1QixNQUFBQSxNQUFNLENBQUNxZ0IsS0FBRCxDQUFOLEdBQWdCdU8sS0FBaEI7QUFDQSxVQUFJLENBQUNBLEtBQUssQ0FBQ3dDLEtBQVgsRUFBa0JnQixVQUFVLEdBQUcsS0FBYjtBQUNsQnhELE1BQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDdEUsSUFBZDtBQUNBakssTUFBQUEsS0FBSyxJQUFJLENBQVQ7QUFDRDs7QUFFRHJnQixJQUFBQSxNQUFNLENBQUNveUIsVUFBUCxHQUFvQkEsVUFBcEI7QUFDQVIsSUFBQUEsT0FBTyxDQUFDMUosTUFBRCxFQUFTcEgsS0FBVCxFQUFnQixJQUFoQixFQUFzQkEsS0FBSyxDQUFDbm1CLE1BQTVCLEVBQW9DcUYsTUFBcEMsRUFBNEMsRUFBNUMsRUFBZ0RteUIsTUFBTSxDQUFDdEQsTUFBdkQsQ0FBUCxDQWpCeUMsQ0FpQjhCO0FBQ3ZFOztBQUVBL04sSUFBQUEsS0FBSyxDQUFDc1AsU0FBTjtBQUNBdFAsSUFBQUEsS0FBSyxDQUFDcVAsbUJBQU4sR0FBNEIsSUFBNUI7O0FBRUEsUUFBSWdDLE1BQU0sQ0FBQzdILElBQVgsRUFBaUI7QUFDZnhKLE1BQUFBLEtBQUssQ0FBQzBQLGtCQUFOLEdBQTJCMkIsTUFBTSxDQUFDN0gsSUFBbEM7QUFDQTZILE1BQUFBLE1BQU0sQ0FBQzdILElBQVAsR0FBYyxJQUFkO0FBQ0QsS0FIRCxNQUdPO0FBQ0x4SixNQUFBQSxLQUFLLENBQUMwUCxrQkFBTixHQUEyQixJQUFJN0IsYUFBSixDQUFrQjdOLEtBQWxCLENBQTNCO0FBQ0Q7O0FBRURBLElBQUFBLEtBQUssQ0FBQ3lQLG9CQUFOLEdBQTZCLENBQTdCO0FBQ0QsR0EvQkQsTUErQk87QUFDTDtBQUNBLFdBQU8zQixLQUFQLEVBQWM7QUFDWixVQUFJbkksS0FBSyxHQUFHbUksS0FBSyxDQUFDbkksS0FBbEI7QUFDQSxVQUFJbmQsUUFBUSxHQUFHc2xCLEtBQUssQ0FBQ3RsQixRQUFyQjtBQUNBLFVBQUl5QixFQUFFLEdBQUc2akIsS0FBSyxDQUFDM3FCLFFBQWY7QUFDQSxVQUFJK0MsR0FBRyxHQUFHOFosS0FBSyxDQUFDc0gsVUFBTixHQUFtQixDQUFuQixHQUF1QjNCLEtBQUssQ0FBQzlyQixNQUF2QztBQUNBaTNCLE1BQUFBLE9BQU8sQ0FBQzFKLE1BQUQsRUFBU3BILEtBQVQsRUFBZ0IsS0FBaEIsRUFBdUI5WixHQUF2QixFQUE0QnlmLEtBQTVCLEVBQW1DbmQsUUFBbkMsRUFBNkN5QixFQUE3QyxDQUFQO0FBQ0E2akIsTUFBQUEsS0FBSyxHQUFHQSxLQUFLLENBQUN0RSxJQUFkO0FBQ0F4SixNQUFBQSxLQUFLLENBQUN5UCxvQkFBTixHQVBZLENBT2tCO0FBQzlCO0FBQ0E7QUFDQTs7QUFFQSxVQUFJelAsS0FBSyxDQUFDK08sT0FBVixFQUFtQjtBQUNqQjtBQUNEO0FBQ0Y7O0FBRUQsUUFBSWpCLEtBQUssS0FBSyxJQUFkLEVBQW9COU4sS0FBSyxDQUFDcVAsbUJBQU4sR0FBNEIsSUFBNUI7QUFDckI7O0FBRURyUCxFQUFBQSxLQUFLLENBQUNvUCxlQUFOLEdBQXdCdEIsS0FBeEI7QUFDQTlOLEVBQUFBLEtBQUssQ0FBQ2lQLGdCQUFOLEdBQXlCLEtBQXpCO0FBQ0Q7O0FBRURySyxRQUFRLENBQUMvdEIsU0FBVCxDQUFtQjYyQixNQUFuQixHQUE0QixVQUFVL0gsS0FBVixFQUFpQm5kLFFBQWpCLEVBQTJCeUIsRUFBM0IsRUFBK0I7QUFDekRBLEVBQUFBLEVBQUUsQ0FBQyxJQUFJNGMsMEJBQUosQ0FBK0IsVUFBL0IsQ0FBRCxDQUFGO0FBQ0QsQ0FGRDs7QUFJQWpDLFFBQVEsQ0FBQy90QixTQUFULENBQW1CcTVCLE9BQW5CLEdBQTZCLElBQTdCOztBQUVBdEwsUUFBUSxDQUFDL3RCLFNBQVQsQ0FBbUJtUSxHQUFuQixHQUF5QixVQUFVMmUsS0FBVixFQUFpQm5kLFFBQWpCLEVBQTJCeUIsRUFBM0IsRUFBK0I7QUFDdEQsTUFBSStWLEtBQUssR0FBRyxLQUFLZ0YsY0FBakI7O0FBRUEsTUFBSSxPQUFPVyxLQUFQLEtBQWlCLFVBQXJCLEVBQWlDO0FBQy9CMWIsSUFBQUEsRUFBRSxHQUFHMGIsS0FBTDtBQUNBQSxJQUFBQSxLQUFLLEdBQUcsSUFBUjtBQUNBbmQsSUFBQUEsUUFBUSxHQUFHLElBQVg7QUFDRCxHQUpELE1BSU8sSUFBSSxPQUFPQSxRQUFQLEtBQW9CLFVBQXhCLEVBQW9DO0FBQ3pDeUIsSUFBQUEsRUFBRSxHQUFHekIsUUFBTDtBQUNBQSxJQUFBQSxRQUFRLEdBQUcsSUFBWDtBQUNEOztBQUVELE1BQUltZCxLQUFLLEtBQUssSUFBVixJQUFrQkEsS0FBSyxLQUFLendCLFNBQWhDLEVBQTJDLEtBQUtxTCxLQUFMLENBQVdvbEIsS0FBWCxFQUFrQm5kLFFBQWxCLEVBWlcsQ0FZa0I7O0FBRXhFLE1BQUl3WCxLQUFLLENBQUNnUCxNQUFWLEVBQWtCO0FBQ2hCaFAsSUFBQUEsS0FBSyxDQUFDZ1AsTUFBTixHQUFlLENBQWY7QUFDQSxTQUFLeUIsTUFBTDtBQUNELEdBakJxRCxDQWlCcEQ7OztBQUdGLE1BQUksQ0FBQ3pRLEtBQUssQ0FBQzRPLE1BQVgsRUFBbUIyQyxXQUFXLENBQUMsSUFBRCxFQUFPdlIsS0FBUCxFQUFjL1YsRUFBZCxDQUFYO0FBQ25CLFNBQU8sSUFBUDtBQUNELENBdEJEOztBQXdCQWhiLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQjAxQixRQUFRLENBQUMvdEIsU0FBL0IsRUFBMEMsZ0JBQTFDLEVBQTREO0FBQzFEO0FBQ0E7QUFDQTtBQUNBa1osRUFBQUEsVUFBVSxFQUFFLEtBSjhDO0FBSzFEQyxFQUFBQSxHQUFHLEVBQUUsU0FBU0EsR0FBVCxHQUFlO0FBQ2xCLFdBQU8sS0FBS2dWLGNBQUwsQ0FBb0JuckIsTUFBM0I7QUFDRDtBQVB5RCxDQUE1RDs7QUFVQSxTQUFTcTNCLFVBQVQsQ0FBb0JsUixLQUFwQixFQUEyQjtBQUN6QixTQUFPQSxLQUFLLENBQUM0TyxNQUFOLElBQWdCNU8sS0FBSyxDQUFDbm1CLE1BQU4sS0FBaUIsQ0FBakMsSUFBc0NtbUIsS0FBSyxDQUFDb1AsZUFBTixLQUEwQixJQUFoRSxJQUF3RSxDQUFDcFAsS0FBSyxDQUFDdU0sUUFBL0UsSUFBMkYsQ0FBQ3ZNLEtBQUssQ0FBQytPLE9BQXpHO0FBQ0Q7O0FBRUQsU0FBU3lDLFNBQVQsQ0FBbUJwSyxNQUFuQixFQUEyQnBILEtBQTNCLEVBQWtDO0FBQ2hDb0gsRUFBQUEsTUFBTSxDQUFDK0ksTUFBUCxDQUFjLFVBQVU3bEIsR0FBVixFQUFlO0FBQzNCMFYsSUFBQUEsS0FBSyxDQUFDc1AsU0FBTjs7QUFFQSxRQUFJaGxCLEdBQUosRUFBUztBQUNQMmMsTUFBQUEsY0FBYyxDQUFDRyxNQUFELEVBQVM5YyxHQUFULENBQWQ7QUFDRDs7QUFFRDBWLElBQUFBLEtBQUssQ0FBQ3VQLFdBQU4sR0FBb0IsSUFBcEI7QUFDQW5JLElBQUFBLE1BQU0sQ0FBQzFJLElBQVAsQ0FBWSxXQUFaO0FBQ0FzUyxJQUFBQSxXQUFXLENBQUM1SixNQUFELEVBQVNwSCxLQUFULENBQVg7QUFDRCxHQVZEO0FBV0Q7O0FBRUQsU0FBU3dOLFNBQVQsQ0FBbUJwRyxNQUFuQixFQUEyQnBILEtBQTNCLEVBQWtDO0FBQ2hDLE1BQUksQ0FBQ0EsS0FBSyxDQUFDdVAsV0FBUCxJQUFzQixDQUFDdlAsS0FBSyxDQUFDMk8sV0FBakMsRUFBOEM7QUFDNUMsUUFBSSxPQUFPdkgsTUFBTSxDQUFDK0ksTUFBZCxLQUF5QixVQUF6QixJQUF1QyxDQUFDblEsS0FBSyxDQUFDdUYsU0FBbEQsRUFBNkQ7QUFDM0R2RixNQUFBQSxLQUFLLENBQUNzUCxTQUFOO0FBQ0F0UCxNQUFBQSxLQUFLLENBQUMyTyxXQUFOLEdBQW9CLElBQXBCO0FBQ0Exd0IsTUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJvTSxTQUFqQixFQUE0QnBLLE1BQTVCLEVBQW9DcEgsS0FBcEM7QUFDRCxLQUpELE1BSU87QUFDTEEsTUFBQUEsS0FBSyxDQUFDdVAsV0FBTixHQUFvQixJQUFwQjtBQUNBbkksTUFBQUEsTUFBTSxDQUFDMUksSUFBUCxDQUFZLFdBQVo7QUFDRDtBQUNGO0FBQ0Y7O0FBRUQsU0FBU3NTLFdBQVQsQ0FBcUI1SixNQUFyQixFQUE2QnBILEtBQTdCLEVBQW9DO0FBQ2xDLE1BQUl5UixJQUFJLEdBQUdQLFVBQVUsQ0FBQ2xSLEtBQUQsQ0FBckI7O0FBRUEsTUFBSXlSLElBQUosRUFBVTtBQUNSakUsSUFBQUEsU0FBUyxDQUFDcEcsTUFBRCxFQUFTcEgsS0FBVCxDQUFUOztBQUVBLFFBQUlBLEtBQUssQ0FBQ3NQLFNBQU4sS0FBb0IsQ0FBeEIsRUFBMkI7QUFDekJ0UCxNQUFBQSxLQUFLLENBQUN1TSxRQUFOLEdBQWlCLElBQWpCO0FBQ0FuRixNQUFBQSxNQUFNLENBQUMxSSxJQUFQLENBQVksUUFBWjs7QUFFQSxVQUFJc0IsS0FBSyxDQUFDb0ksV0FBVixFQUF1QjtBQUNyQjtBQUNBO0FBQ0EsWUFBSXNKLE1BQU0sR0FBR3RLLE1BQU0sQ0FBQzlCLGNBQXBCOztBQUVBLFlBQUksQ0FBQ29NLE1BQUQsSUFBV0EsTUFBTSxDQUFDdEosV0FBUCxJQUFzQnNKLE1BQU0sQ0FBQy9KLFVBQTVDLEVBQXdEO0FBQ3REUCxVQUFBQSxNQUFNLENBQUNzQixPQUFQO0FBQ0Q7QUFDRjtBQUNGO0FBQ0Y7O0FBRUQsU0FBTytJLElBQVA7QUFDRDs7QUFFRCxTQUFTRixXQUFULENBQXFCbkssTUFBckIsRUFBNkJwSCxLQUE3QixFQUFvQy9WLEVBQXBDLEVBQXdDO0FBQ3RDK1YsRUFBQUEsS0FBSyxDQUFDNE8sTUFBTixHQUFlLElBQWY7QUFDQW9DLEVBQUFBLFdBQVcsQ0FBQzVKLE1BQUQsRUFBU3BILEtBQVQsQ0FBWDs7QUFFQSxNQUFJL1YsRUFBSixFQUFRO0FBQ04sUUFBSStWLEtBQUssQ0FBQ3VNLFFBQVYsRUFBb0J0dUIsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJuYixFQUFqQixFQUFwQixLQUE4Q21kLE1BQU0sQ0FBQ3JKLElBQVAsQ0FBWSxRQUFaLEVBQXNCOVQsRUFBdEI7QUFDL0M7O0FBRUQrVixFQUFBQSxLQUFLLENBQUNtRixLQUFOLEdBQWMsSUFBZDtBQUNBaUMsRUFBQUEsTUFBTSxDQUFDNUwsUUFBUCxHQUFrQixLQUFsQjtBQUNEOztBQUVELFNBQVN3UyxjQUFULENBQXdCMkQsT0FBeEIsRUFBaUMzUixLQUFqQyxFQUF3QzFWLEdBQXhDLEVBQTZDO0FBQzNDLE1BQUl3akIsS0FBSyxHQUFHNkQsT0FBTyxDQUFDN0QsS0FBcEI7QUFDQTZELEVBQUFBLE9BQU8sQ0FBQzdELEtBQVIsR0FBZ0IsSUFBaEI7O0FBRUEsU0FBT0EsS0FBUCxFQUFjO0FBQ1osUUFBSTdqQixFQUFFLEdBQUc2akIsS0FBSyxDQUFDM3FCLFFBQWY7QUFDQTZjLElBQUFBLEtBQUssQ0FBQ3NQLFNBQU47QUFDQXJsQixJQUFBQSxFQUFFLENBQUNLLEdBQUQsQ0FBRjtBQUNBd2pCLElBQUFBLEtBQUssR0FBR0EsS0FBSyxDQUFDdEUsSUFBZDtBQUNELEdBVDBDLENBU3pDOzs7QUFHRnhKLEVBQUFBLEtBQUssQ0FBQzBQLGtCQUFOLENBQXlCbEcsSUFBekIsR0FBZ0NtSSxPQUFoQztBQUNEOztBQUVEMWlDLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQjAxQixRQUFRLENBQUMvdEIsU0FBL0IsRUFBMEMsV0FBMUMsRUFBdUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0FrWixFQUFBQSxVQUFVLEVBQUUsS0FKeUM7QUFLckRDLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULEdBQWU7QUFDbEIsUUFBSSxLQUFLZ1YsY0FBTCxLQUF3Qjl2QixTQUE1QixFQUF1QztBQUNyQyxhQUFPLEtBQVA7QUFDRDs7QUFFRCxXQUFPLEtBQUs4dkIsY0FBTCxDQUFvQk8sU0FBM0I7QUFDRCxHQVhvRDtBQVlyRHZaLEVBQUFBLEdBQUcsRUFBRSxTQUFTQSxHQUFULENBQWE1YyxLQUFiLEVBQW9CO0FBQ3ZCO0FBQ0E7QUFDQSxRQUFJLENBQUMsS0FBSzQxQixjQUFWLEVBQTBCO0FBQ3hCO0FBQ0QsS0FMc0IsQ0FLckI7QUFDRjs7O0FBR0EsU0FBS0EsY0FBTCxDQUFvQk8sU0FBcEIsR0FBZ0NuMkIsS0FBaEM7QUFDRDtBQXRCb0QsQ0FBdkQ7QUF3QkF3MUIsUUFBUSxDQUFDL3RCLFNBQVQsQ0FBbUI2eEIsT0FBbkIsR0FBNkJsQyxXQUFXLENBQUNrQyxPQUF6QztBQUNBOUQsUUFBUSxDQUFDL3RCLFNBQVQsQ0FBbUIreEIsVUFBbkIsR0FBZ0NwQyxXQUFXLENBQUNxQyxTQUE1Qzs7QUFFQWpFLFFBQVEsQ0FBQy90QixTQUFULENBQW1COHhCLFFBQW5CLEdBQThCLFVBQVVyZSxHQUFWLEVBQWVMLEVBQWYsRUFBbUI7QUFDL0NBLEVBQUFBLEVBQUUsQ0FBQ0ssR0FBRCxDQUFGO0FBQ0QsQ0FGRDs7Ozs7Ozs7OztBQ3RyQmE7O0FBRWIsSUFBSXNuQixxQkFBSjs7QUFFQSxTQUFTQyxlQUFULENBQXlCMXNCLEdBQXpCLEVBQThCNVAsR0FBOUIsRUFBbUNuRyxLQUFuQyxFQUEwQztBQUFFLE1BQUltRyxHQUFHLElBQUk0UCxHQUFYLEVBQWdCO0FBQUVsVyxJQUFBQSxNQUFNLENBQUNDLGNBQVAsQ0FBc0JpVyxHQUF0QixFQUEyQjVQLEdBQTNCLEVBQWdDO0FBQUVuRyxNQUFBQSxLQUFLLEVBQUVBLEtBQVQ7QUFBZ0IyZ0IsTUFBQUEsVUFBVSxFQUFFLElBQTVCO0FBQWtDMEwsTUFBQUEsWUFBWSxFQUFFLElBQWhEO0FBQXNERCxNQUFBQSxRQUFRLEVBQUU7QUFBaEUsS0FBaEM7QUFBMEcsR0FBNUgsTUFBa0k7QUFBRXJXLElBQUFBLEdBQUcsQ0FBQzVQLEdBQUQsQ0FBSCxHQUFXbkcsS0FBWDtBQUFtQjs7QUFBQyxTQUFPK1YsR0FBUDtBQUFhOztBQUVqTixJQUFJb25CLFFBQVEsR0FBR2o5QixtQkFBTyxDQUFDLDZGQUFELENBQXRCOztBQUVBLElBQUl3aUMsWUFBWSxHQUFHemlCLE1BQU0sQ0FBQyxhQUFELENBQXpCO0FBQ0EsSUFBSTBpQixXQUFXLEdBQUcxaUIsTUFBTSxDQUFDLFlBQUQsQ0FBeEI7QUFDQSxJQUFJMmlCLE1BQU0sR0FBRzNpQixNQUFNLENBQUMsT0FBRCxDQUFuQjtBQUNBLElBQUk0aUIsTUFBTSxHQUFHNWlCLE1BQU0sQ0FBQyxPQUFELENBQW5CO0FBQ0EsSUFBSTZpQixZQUFZLEdBQUc3aUIsTUFBTSxDQUFDLGFBQUQsQ0FBekI7QUFDQSxJQUFJOGlCLGNBQWMsR0FBRzlpQixNQUFNLENBQUMsZUFBRCxDQUEzQjtBQUNBLElBQUkraUIsT0FBTyxHQUFHL2lCLE1BQU0sQ0FBQyxRQUFELENBQXBCOztBQUVBLFNBQVNnakIsZ0JBQVQsQ0FBMEJqakMsS0FBMUIsRUFBaUNxK0IsSUFBakMsRUFBdUM7QUFDckMsU0FBTztBQUNMcitCLElBQUFBLEtBQUssRUFBRUEsS0FERjtBQUVMcStCLElBQUFBLElBQUksRUFBRUE7QUFGRCxHQUFQO0FBSUQ7O0FBRUQsU0FBUzZFLGNBQVQsQ0FBd0JDLElBQXhCLEVBQThCO0FBQzVCLE1BQUkzZ0MsT0FBTyxHQUFHMmdDLElBQUksQ0FBQ1QsWUFBRCxDQUFsQjs7QUFFQSxNQUFJbGdDLE9BQU8sS0FBSyxJQUFoQixFQUFzQjtBQUNwQixRQUFJRyxJQUFJLEdBQUd3Z0MsSUFBSSxDQUFDSCxPQUFELENBQUosQ0FBY245QixJQUFkLEVBQVgsQ0FEb0IsQ0FDYTtBQUNqQztBQUNBOztBQUVBLFFBQUlsRCxJQUFJLEtBQUssSUFBYixFQUFtQjtBQUNqQndnQyxNQUFBQSxJQUFJLENBQUNMLFlBQUQsQ0FBSixHQUFxQixJQUFyQjtBQUNBSyxNQUFBQSxJQUFJLENBQUNULFlBQUQsQ0FBSixHQUFxQixJQUFyQjtBQUNBUyxNQUFBQSxJQUFJLENBQUNSLFdBQUQsQ0FBSixHQUFvQixJQUFwQjtBQUNBbmdDLE1BQUFBLE9BQU8sQ0FBQ3lnQyxnQkFBZ0IsQ0FBQ3RnQyxJQUFELEVBQU8sS0FBUCxDQUFqQixDQUFQO0FBQ0Q7QUFDRjtBQUNGOztBQUVELFNBQVN5Z0MsVUFBVCxDQUFvQkQsSUFBcEIsRUFBMEI7QUFDeEI7QUFDQTtBQUNBdDBCLEVBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCa04sY0FBakIsRUFBaUNDLElBQWpDO0FBQ0Q7O0FBRUQsU0FBU0UsV0FBVCxDQUFxQkMsV0FBckIsRUFBa0NILElBQWxDLEVBQXdDO0FBQ3RDLFNBQU8sVUFBVTNnQyxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUNoQzZnQyxJQUFBQSxXQUFXLENBQUMxOEIsSUFBWixDQUFpQixZQUFZO0FBQzNCLFVBQUl1OEIsSUFBSSxDQUFDTixNQUFELENBQVIsRUFBa0I7QUFDaEJyZ0MsUUFBQUEsT0FBTyxDQUFDeWdDLGdCQUFnQixDQUFDbjlCLFNBQUQsRUFBWSxJQUFaLENBQWpCLENBQVA7QUFDQTtBQUNEOztBQUVEcTlCLE1BQUFBLElBQUksQ0FBQ0osY0FBRCxDQUFKLENBQXFCdmdDLE9BQXJCLEVBQThCQyxNQUE5QjtBQUNELEtBUEQsRUFPR0EsTUFQSDtBQVFELEdBVEQ7QUFVRDs7QUFFRCxJQUFJOGdDLHNCQUFzQixHQUFHMWpDLE1BQU0sQ0FBQzRWLGNBQVAsQ0FBc0IsWUFBWSxDQUFFLENBQXBDLENBQTdCO0FBQ0EsSUFBSSt0QixvQ0FBb0MsR0FBRzNqQyxNQUFNLENBQUM2Z0IsY0FBUCxFQUF1QjhoQixxQkFBcUIsR0FBRztBQUN4RixNQUFJeEssTUFBSixHQUFhO0FBQ1gsV0FBTyxLQUFLZ0wsT0FBTCxDQUFQO0FBQ0QsR0FIdUY7O0FBS3hGNUksRUFBQUEsSUFBSSxFQUFFLFNBQVNBLElBQVQsR0FBZ0I7QUFDcEIsUUFBSXVDLEtBQUssR0FBRyxJQUFaLENBRG9CLENBR3BCO0FBQ0E7OztBQUNBLFFBQUk3eEIsS0FBSyxHQUFHLEtBQUs4M0IsTUFBTCxDQUFaOztBQUVBLFFBQUk5M0IsS0FBSyxLQUFLLElBQWQsRUFBb0I7QUFDbEIsYUFBT3hJLE9BQU8sQ0FBQ0csTUFBUixDQUFlcUksS0FBZixDQUFQO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLKzNCLE1BQUwsQ0FBSixFQUFrQjtBQUNoQixhQUFPdmdDLE9BQU8sQ0FBQ0UsT0FBUixDQUFnQnlnQyxnQkFBZ0IsQ0FBQ245QixTQUFELEVBQVksSUFBWixDQUFoQyxDQUFQO0FBQ0Q7O0FBRUQsUUFBSSxLQUFLazlCLE9BQUwsRUFBYzdNLFNBQWxCLEVBQTZCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBTyxJQUFJN3pCLE9BQUosQ0FBWSxVQUFVRSxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUM1Q29NLFFBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCLFlBQVk7QUFDM0IsY0FBSTJHLEtBQUssQ0FBQ2lHLE1BQUQsQ0FBVCxFQUFtQjtBQUNqQm5nQyxZQUFBQSxNQUFNLENBQUNrNkIsS0FBSyxDQUFDaUcsTUFBRCxDQUFOLENBQU47QUFDRCxXQUZELE1BRU87QUFDTHBnQyxZQUFBQSxPQUFPLENBQUN5Z0MsZ0JBQWdCLENBQUNuOUIsU0FBRCxFQUFZLElBQVosQ0FBakIsQ0FBUDtBQUNEO0FBQ0YsU0FORDtBQU9ELE9BUk0sQ0FBUDtBQVNELEtBN0JtQixDQTZCbEI7QUFDRjtBQUNBO0FBQ0E7OztBQUdBLFFBQUl3OUIsV0FBVyxHQUFHLEtBQUtSLFlBQUwsQ0FBbEI7QUFDQSxRQUFJbjhCLE9BQUo7O0FBRUEsUUFBSTI4QixXQUFKLEVBQWlCO0FBQ2YzOEIsTUFBQUEsT0FBTyxHQUFHLElBQUlyRSxPQUFKLENBQVkrZ0MsV0FBVyxDQUFDQyxXQUFELEVBQWMsSUFBZCxDQUF2QixDQUFWO0FBQ0QsS0FGRCxNQUVPO0FBQ0w7QUFDQTtBQUNBLFVBQUkzZ0MsSUFBSSxHQUFHLEtBQUtxZ0MsT0FBTCxFQUFjbjlCLElBQWQsRUFBWDs7QUFFQSxVQUFJbEQsSUFBSSxLQUFLLElBQWIsRUFBbUI7QUFDakIsZUFBT0wsT0FBTyxDQUFDRSxPQUFSLENBQWdCeWdDLGdCQUFnQixDQUFDdGdDLElBQUQsRUFBTyxLQUFQLENBQWhDLENBQVA7QUFDRDs7QUFFRGdFLE1BQUFBLE9BQU8sR0FBRyxJQUFJckUsT0FBSixDQUFZLEtBQUt5Z0MsY0FBTCxDQUFaLENBQVY7QUFDRDs7QUFFRCxTQUFLRCxZQUFMLElBQXFCbjhCLE9BQXJCO0FBQ0EsV0FBT0EsT0FBUDtBQUNEO0FBM0R1RixDQUF4QixFQTREL0Q4N0IsZUFBZSxDQUFDRCxxQkFBRCxFQUF3QnZpQixNQUFNLENBQUM2YyxhQUEvQixFQUE4QyxZQUFZO0FBQzFFLFNBQU8sSUFBUDtBQUNELENBRmlCLENBNURnRCxFQThEOUQyRixlQUFlLENBQUNELHFCQUFELEVBQXdCLFFBQXhCLEVBQWtDLFNBQVNpQixPQUFULEdBQW1CO0FBQ3RFLE1BQUlDLE1BQU0sR0FBRyxJQUFiLENBRHNFLENBR3RFO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBTyxJQUFJcGhDLE9BQUosQ0FBWSxVQUFVRSxPQUFWLEVBQW1CQyxNQUFuQixFQUEyQjtBQUM1Q2loQyxJQUFBQSxNQUFNLENBQUNWLE9BQUQsQ0FBTixDQUFnQjFKLE9BQWhCLENBQXdCLElBQXhCLEVBQThCLFVBQVVwZSxHQUFWLEVBQWU7QUFDM0MsVUFBSUEsR0FBSixFQUFTO0FBQ1B6WSxRQUFBQSxNQUFNLENBQUN5WSxHQUFELENBQU47QUFDQTtBQUNEOztBQUVEMVksTUFBQUEsT0FBTyxDQUFDeWdDLGdCQUFnQixDQUFDbjlCLFNBQUQsRUFBWSxJQUFaLENBQWpCLENBQVA7QUFDRCxLQVBEO0FBUUQsR0FUTSxDQUFQO0FBVUQsQ0FoQmtCLENBOUQrQyxFQThFOUQwOEIscUJBOUV1QyxHQThFZmUsc0JBOUVlLENBQTNDOztBQWdGQSxJQUFJM0wsaUNBQWlDLEdBQUcsU0FBU0EsaUNBQVQsQ0FBMkNJLE1BQTNDLEVBQW1EO0FBQ3pGLE1BQUkyTCxjQUFKOztBQUVBLE1BQUlDLFFBQVEsR0FBRy9qQyxNQUFNLENBQUMrSCxNQUFQLENBQWM0N0Isb0NBQWQsR0FBcURHLGNBQWMsR0FBRyxFQUFqQixFQUFxQmxCLGVBQWUsQ0FBQ2tCLGNBQUQsRUFBaUJYLE9BQWpCLEVBQTBCO0FBQ2hJaGpDLElBQUFBLEtBQUssRUFBRWc0QixNQUR5SDtBQUVoSTVMLElBQUFBLFFBQVEsRUFBRTtBQUZzSCxHQUExQixDQUFwQyxFQUdoRXFXLGVBQWUsQ0FBQ2tCLGNBQUQsRUFBaUJqQixZQUFqQixFQUErQjtBQUNoRDFpQyxJQUFBQSxLQUFLLEVBQUUsSUFEeUM7QUFFaERvc0IsSUFBQUEsUUFBUSxFQUFFO0FBRnNDLEdBQS9CLENBSGlELEVBTWhFcVcsZUFBZSxDQUFDa0IsY0FBRCxFQUFpQmhCLFdBQWpCLEVBQThCO0FBQy9DM2lDLElBQUFBLEtBQUssRUFBRSxJQUR3QztBQUUvQ29zQixJQUFBQSxRQUFRLEVBQUU7QUFGcUMsR0FBOUIsQ0FOaUQsRUFTaEVxVyxlQUFlLENBQUNrQixjQUFELEVBQWlCZixNQUFqQixFQUF5QjtBQUMxQzVpQyxJQUFBQSxLQUFLLEVBQUUsSUFEbUM7QUFFMUNvc0IsSUFBQUEsUUFBUSxFQUFFO0FBRmdDLEdBQXpCLENBVGlELEVBWWhFcVcsZUFBZSxDQUFDa0IsY0FBRCxFQUFpQmQsTUFBakIsRUFBeUI7QUFDMUM3aUMsSUFBQUEsS0FBSyxFQUFFZzRCLE1BQU0sQ0FBQzlCLGNBQVAsQ0FBc0JxQyxVQURhO0FBRTFDbk0sSUFBQUEsUUFBUSxFQUFFO0FBRmdDLEdBQXpCLENBWmlELEVBZWhFcVcsZUFBZSxDQUFDa0IsY0FBRCxFQUFpQlosY0FBakIsRUFBaUM7QUFDbEQvaUMsSUFBQUEsS0FBSyxFQUFFLFNBQVNBLEtBQVQsQ0FBZXdDLE9BQWYsRUFBd0JDLE1BQXhCLEVBQWdDO0FBQ3JDLFVBQUlFLElBQUksR0FBR2loQyxRQUFRLENBQUNaLE9BQUQsQ0FBUixDQUFrQm45QixJQUFsQixFQUFYOztBQUVBLFVBQUlsRCxJQUFKLEVBQVU7QUFDUmloQyxRQUFBQSxRQUFRLENBQUNkLFlBQUQsQ0FBUixHQUF5QixJQUF6QjtBQUNBYyxRQUFBQSxRQUFRLENBQUNsQixZQUFELENBQVIsR0FBeUIsSUFBekI7QUFDQWtCLFFBQUFBLFFBQVEsQ0FBQ2pCLFdBQUQsQ0FBUixHQUF3QixJQUF4QjtBQUNBbmdDLFFBQUFBLE9BQU8sQ0FBQ3lnQyxnQkFBZ0IsQ0FBQ3RnQyxJQUFELEVBQU8sS0FBUCxDQUFqQixDQUFQO0FBQ0QsT0FMRCxNQUtPO0FBQ0xpaEMsUUFBQUEsUUFBUSxDQUFDbEIsWUFBRCxDQUFSLEdBQXlCbGdDLE9BQXpCO0FBQ0FvaEMsUUFBQUEsUUFBUSxDQUFDakIsV0FBRCxDQUFSLEdBQXdCbGdDLE1BQXhCO0FBQ0Q7QUFDRixLQWJpRDtBQWNsRDJwQixJQUFBQSxRQUFRLEVBQUU7QUFkd0MsR0FBakMsQ0FmaUQsRUE4QmhFdVgsY0E5QlcsRUFBZjtBQStCQUMsRUFBQUEsUUFBUSxDQUFDZCxZQUFELENBQVIsR0FBeUIsSUFBekI7QUFDQTNGLEVBQUFBLFFBQVEsQ0FBQ25GLE1BQUQsRUFBUyxVQUFVOWMsR0FBVixFQUFlO0FBQzlCLFFBQUlBLEdBQUcsSUFBSUEsR0FBRyxDQUFDblAsSUFBSixLQUFhLDRCQUF4QixFQUFzRDtBQUNwRCxVQUFJdEosTUFBTSxHQUFHbWhDLFFBQVEsQ0FBQ2pCLFdBQUQsQ0FBckIsQ0FEb0QsQ0FDaEI7QUFDcEM7O0FBRUEsVUFBSWxnQyxNQUFNLEtBQUssSUFBZixFQUFxQjtBQUNuQm1oQyxRQUFBQSxRQUFRLENBQUNkLFlBQUQsQ0FBUixHQUF5QixJQUF6QjtBQUNBYyxRQUFBQSxRQUFRLENBQUNsQixZQUFELENBQVIsR0FBeUIsSUFBekI7QUFDQWtCLFFBQUFBLFFBQVEsQ0FBQ2pCLFdBQUQsQ0FBUixHQUF3QixJQUF4QjtBQUNBbGdDLFFBQUFBLE1BQU0sQ0FBQ3lZLEdBQUQsQ0FBTjtBQUNEOztBQUVEMG9CLE1BQUFBLFFBQVEsQ0FBQ2hCLE1BQUQsQ0FBUixHQUFtQjFuQixHQUFuQjtBQUNBO0FBQ0Q7O0FBRUQsUUFBSTFZLE9BQU8sR0FBR29oQyxRQUFRLENBQUNsQixZQUFELENBQXRCOztBQUVBLFFBQUlsZ0MsT0FBTyxLQUFLLElBQWhCLEVBQXNCO0FBQ3BCb2hDLE1BQUFBLFFBQVEsQ0FBQ2QsWUFBRCxDQUFSLEdBQXlCLElBQXpCO0FBQ0FjLE1BQUFBLFFBQVEsQ0FBQ2xCLFlBQUQsQ0FBUixHQUF5QixJQUF6QjtBQUNBa0IsTUFBQUEsUUFBUSxDQUFDakIsV0FBRCxDQUFSLEdBQXdCLElBQXhCO0FBQ0FuZ0MsTUFBQUEsT0FBTyxDQUFDeWdDLGdCQUFnQixDQUFDbjlCLFNBQUQsRUFBWSxJQUFaLENBQWpCLENBQVA7QUFDRDs7QUFFRDg5QixJQUFBQSxRQUFRLENBQUNmLE1BQUQsQ0FBUixHQUFtQixJQUFuQjtBQUNELEdBMUJPLENBQVI7QUEyQkE3SyxFQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsVUFBVixFQUFzQitTLFVBQVUsQ0FBQ244QixJQUFYLENBQWdCLElBQWhCLEVBQXNCMjhCLFFBQXRCLENBQXRCO0FBQ0EsU0FBT0EsUUFBUDtBQUNELENBaEVEOztBQWtFQWppQyxNQUFNLENBQUM1QixPQUFQLEdBQWlCNjNCLGlDQUFqQjs7Ozs7Ozs7OztBQzlNYTs7QUFFYixTQUFTMUosT0FBVCxDQUFpQjBTLE1BQWpCLEVBQXlCaUQsY0FBekIsRUFBeUM7QUFBRSxNQUFJMTFCLElBQUksR0FBR3RPLE1BQU0sQ0FBQ3NPLElBQVAsQ0FBWXl5QixNQUFaLENBQVg7O0FBQWdDLE1BQUkvZ0MsTUFBTSxDQUFDc3VCLHFCQUFYLEVBQWtDO0FBQUUsUUFBSTJWLE9BQU8sR0FBR2prQyxNQUFNLENBQUNzdUIscUJBQVAsQ0FBNkJ5UyxNQUE3QixDQUFkO0FBQW9ELFFBQUlpRCxjQUFKLEVBQW9CQyxPQUFPLEdBQUdBLE9BQU8sQ0FBQzExQixNQUFSLENBQWUsVUFBVTZkLEdBQVYsRUFBZTtBQUFFLGFBQU9wc0IsTUFBTSxDQUFDa2tDLHdCQUFQLENBQWdDbkQsTUFBaEMsRUFBd0MzVSxHQUF4QyxFQUE2Q3RMLFVBQXBEO0FBQWlFLEtBQWpHLENBQVY7QUFBOEd4UyxJQUFBQSxJQUFJLENBQUMvRCxJQUFMLENBQVVHLEtBQVYsQ0FBZ0I0RCxJQUFoQixFQUFzQjIxQixPQUF0QjtBQUFpQzs7QUFBQyxTQUFPMzFCLElBQVA7QUFBYzs7QUFFclYsU0FBUzYxQixhQUFULENBQXVCdDJCLE1BQXZCLEVBQStCO0FBQUUsT0FBSyxJQUFJNkMsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR2xILFNBQVMsQ0FBQ29CLE1BQTlCLEVBQXNDOEYsQ0FBQyxFQUF2QyxFQUEyQztBQUFFLFFBQUl6SCxNQUFNLEdBQUdPLFNBQVMsQ0FBQ2tILENBQUQsQ0FBVCxJQUFnQixJQUFoQixHQUF1QmxILFNBQVMsQ0FBQ2tILENBQUQsQ0FBaEMsR0FBc0MsRUFBbkQ7O0FBQXVELFFBQUlBLENBQUMsR0FBRyxDQUFSLEVBQVc7QUFBRTJkLE1BQUFBLE9BQU8sQ0FBQ3J1QixNQUFNLENBQUNpSixNQUFELENBQVAsRUFBaUIsSUFBakIsQ0FBUCxDQUE4QjlDLE9BQTlCLENBQXNDLFVBQVVHLEdBQVYsRUFBZTtBQUFFczhCLFFBQUFBLGVBQWUsQ0FBQy8wQixNQUFELEVBQVN2SCxHQUFULEVBQWMyQyxNQUFNLENBQUMzQyxHQUFELENBQXBCLENBQWY7QUFBNEMsT0FBbkc7QUFBdUcsS0FBcEgsTUFBMEgsSUFBSXRHLE1BQU0sQ0FBQ29rQyx5QkFBWCxFQUFzQztBQUFFcGtDLE1BQUFBLE1BQU0sQ0FBQ3FrQyxnQkFBUCxDQUF3QngyQixNQUF4QixFQUFnQzdOLE1BQU0sQ0FBQ29rQyx5QkFBUCxDQUFpQ243QixNQUFqQyxDQUFoQztBQUE0RSxLQUFwSCxNQUEwSDtBQUFFb2xCLE1BQUFBLE9BQU8sQ0FBQ3J1QixNQUFNLENBQUNpSixNQUFELENBQVAsQ0FBUCxDQUF3QjlDLE9BQXhCLENBQWdDLFVBQVVHLEdBQVYsRUFBZTtBQUFFdEcsUUFBQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCNE4sTUFBdEIsRUFBOEJ2SCxHQUE5QixFQUFtQ3RHLE1BQU0sQ0FBQ2trQyx3QkFBUCxDQUFnQ2o3QixNQUFoQyxFQUF3QzNDLEdBQXhDLENBQW5DO0FBQW1GLE9BQXBJO0FBQXdJO0FBQUU7O0FBQUMsU0FBT3VILE1BQVA7QUFBZ0I7O0FBRXRoQixTQUFTKzBCLGVBQVQsQ0FBeUIxc0IsR0FBekIsRUFBOEI1UCxHQUE5QixFQUFtQ25HLEtBQW5DLEVBQTBDO0FBQUUsTUFBSW1HLEdBQUcsSUFBSTRQLEdBQVgsRUFBZ0I7QUFBRWxXLElBQUFBLE1BQU0sQ0FBQ0MsY0FBUCxDQUFzQmlXLEdBQXRCLEVBQTJCNVAsR0FBM0IsRUFBZ0M7QUFBRW5HLE1BQUFBLEtBQUssRUFBRUEsS0FBVDtBQUFnQjJnQixNQUFBQSxVQUFVLEVBQUUsSUFBNUI7QUFBa0MwTCxNQUFBQSxZQUFZLEVBQUUsSUFBaEQ7QUFBc0RELE1BQUFBLFFBQVEsRUFBRTtBQUFoRSxLQUFoQztBQUEwRyxHQUE1SCxNQUFrSTtBQUFFclcsSUFBQUEsR0FBRyxDQUFDNVAsR0FBRCxDQUFILEdBQVduRyxLQUFYO0FBQW1COztBQUFDLFNBQU8rVixHQUFQO0FBQWE7O0FBRWpOLFNBQVNvdUIsZUFBVCxDQUF5QjM4QixRQUF6QixFQUFtQzQ4QixXQUFuQyxFQUFnRDtBQUFFLE1BQUksRUFBRTU4QixRQUFRLFlBQVk0OEIsV0FBdEIsQ0FBSixFQUF3QztBQUFFLFVBQU0sSUFBSTU3QixTQUFKLENBQWMsbUNBQWQsQ0FBTjtBQUEyRDtBQUFFOztBQUV6SixTQUFTNjdCLGlCQUFULENBQTJCMzJCLE1BQTNCLEVBQW1DNDJCLEtBQW5DLEVBQTBDO0FBQUUsT0FBSyxJQUFJL3pCLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUcrekIsS0FBSyxDQUFDNzVCLE1BQTFCLEVBQWtDOEYsQ0FBQyxFQUFuQyxFQUF1QztBQUFFLFFBQUlnMEIsVUFBVSxHQUFHRCxLQUFLLENBQUMvekIsQ0FBRCxDQUF0QjtBQUEyQmcwQixJQUFBQSxVQUFVLENBQUM1akIsVUFBWCxHQUF3QjRqQixVQUFVLENBQUM1akIsVUFBWCxJQUF5QixLQUFqRDtBQUF3RDRqQixJQUFBQSxVQUFVLENBQUNsWSxZQUFYLEdBQTBCLElBQTFCO0FBQWdDLFFBQUksV0FBV2tZLFVBQWYsRUFBMkJBLFVBQVUsQ0FBQ25ZLFFBQVgsR0FBc0IsSUFBdEI7QUFBNEJ2c0IsSUFBQUEsTUFBTSxDQUFDQyxjQUFQLENBQXNCNE4sTUFBdEIsRUFBOEI2MkIsVUFBVSxDQUFDcCtCLEdBQXpDLEVBQThDbytCLFVBQTlDO0FBQTREO0FBQUU7O0FBRTdULFNBQVNDLFlBQVQsQ0FBc0JKLFdBQXRCLEVBQW1DSyxVQUFuQyxFQUErQ0MsV0FBL0MsRUFBNEQ7QUFBRSxNQUFJRCxVQUFKLEVBQWdCSixpQkFBaUIsQ0FBQ0QsV0FBVyxDQUFDMzhCLFNBQWIsRUFBd0JnOUIsVUFBeEIsQ0FBakI7QUFBc0QsTUFBSUMsV0FBSixFQUFpQkwsaUJBQWlCLENBQUNELFdBQUQsRUFBY00sV0FBZCxDQUFqQjtBQUE2QyxTQUFPTixXQUFQO0FBQXFCOztBQUV2TixJQUFJL00sUUFBUSxHQUFHbjNCLG1CQUFPLENBQUMsOENBQUQsQ0FBdEI7QUFBQSxJQUNJUyxNQUFNLEdBQUcwMkIsUUFBUSxDQUFDMTJCLE1BRHRCOztBQUdBLElBQUlna0MsU0FBUyxHQUFHemtDLG1CQUFPLENBQUMsbUJBQUQsQ0FBdkI7QUFBQSxJQUNJOGpCLE9BQU8sR0FBRzJnQixTQUFTLENBQUMzZ0IsT0FEeEI7O0FBR0EsSUFBSTRnQixNQUFNLEdBQUc1Z0IsT0FBTyxJQUFJQSxPQUFPLENBQUM0Z0IsTUFBbkIsSUFBNkIsU0FBMUM7O0FBRUEsU0FBU0MsVUFBVCxDQUFvQnZYLEdBQXBCLEVBQXlCNWYsTUFBekIsRUFBaUNnVixNQUFqQyxFQUF5QztBQUN2Qy9oQixFQUFBQSxNQUFNLENBQUM4RyxTQUFQLENBQWlCNmEsSUFBakIsQ0FBc0JwVyxJQUF0QixDQUEyQm9oQixHQUEzQixFQUFnQzVmLE1BQWhDLEVBQXdDZ1YsTUFBeEM7QUFDRDs7QUFFRC9nQixNQUFNLENBQUM1QixPQUFQLEdBQ0EsYUFDQSxZQUFZO0FBQ1YsV0FBU28zQixVQUFULEdBQXNCO0FBQ3BCZ04sSUFBQUEsZUFBZSxDQUFDLElBQUQsRUFBT2hOLFVBQVAsQ0FBZjs7QUFFQSxTQUFLMWIsSUFBTCxHQUFZLElBQVo7QUFDQSxTQUFLcXBCLElBQUwsR0FBWSxJQUFaO0FBQ0EsU0FBS3I2QixNQUFMLEdBQWMsQ0FBZDtBQUNEOztBQUVEKzVCLEVBQUFBLFlBQVksQ0FBQ3JOLFVBQUQsRUFBYSxDQUFDO0FBQ3hCaHhCLElBQUFBLEdBQUcsRUFBRSxNQURtQjtBQUV4Qm5HLElBQUFBLEtBQUssRUFBRSxTQUFTb0ssSUFBVCxDQUFjd0csQ0FBZCxFQUFpQjtBQUN0QixVQUFJOHRCLEtBQUssR0FBRztBQUNWLzdCLFFBQUFBLElBQUksRUFBRWlPLENBREk7QUFFVndwQixRQUFBQSxJQUFJLEVBQUU7QUFGSSxPQUFaO0FBSUEsVUFBSSxLQUFLM3ZCLE1BQUwsR0FBYyxDQUFsQixFQUFxQixLQUFLcTZCLElBQUwsQ0FBVTFLLElBQVYsR0FBaUJzRSxLQUFqQixDQUFyQixLQUFpRCxLQUFLampCLElBQUwsR0FBWWlqQixLQUFaO0FBQ2pELFdBQUtvRyxJQUFMLEdBQVlwRyxLQUFaO0FBQ0EsUUFBRSxLQUFLajBCLE1BQVA7QUFDRDtBQVZ1QixHQUFELEVBV3RCO0FBQ0R0RSxJQUFBQSxHQUFHLEVBQUUsU0FESjtBQUVEbkcsSUFBQUEsS0FBSyxFQUFFLFNBQVMrSixPQUFULENBQWlCNkcsQ0FBakIsRUFBb0I7QUFDekIsVUFBSTh0QixLQUFLLEdBQUc7QUFDVi83QixRQUFBQSxJQUFJLEVBQUVpTyxDQURJO0FBRVZ3cEIsUUFBQUEsSUFBSSxFQUFFLEtBQUszZTtBQUZELE9BQVo7QUFJQSxVQUFJLEtBQUtoUixNQUFMLEtBQWdCLENBQXBCLEVBQXVCLEtBQUtxNkIsSUFBTCxHQUFZcEcsS0FBWjtBQUN2QixXQUFLampCLElBQUwsR0FBWWlqQixLQUFaO0FBQ0EsUUFBRSxLQUFLajBCLE1BQVA7QUFDRDtBQVZBLEdBWHNCLEVBc0J0QjtBQUNEdEUsSUFBQUEsR0FBRyxFQUFFLE9BREo7QUFFRG5HLElBQUFBLEtBQUssRUFBRSxTQUFTMEssS0FBVCxHQUFpQjtBQUN0QixVQUFJLEtBQUtELE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUI7QUFDdkIsVUFBSWljLEdBQUcsR0FBRyxLQUFLakwsSUFBTCxDQUFVOVksSUFBcEI7QUFDQSxVQUFJLEtBQUs4SCxNQUFMLEtBQWdCLENBQXBCLEVBQXVCLEtBQUtnUixJQUFMLEdBQVksS0FBS3FwQixJQUFMLEdBQVksSUFBeEIsQ0FBdkIsS0FBeUQsS0FBS3JwQixJQUFMLEdBQVksS0FBS0EsSUFBTCxDQUFVMmUsSUFBdEI7QUFDekQsUUFBRSxLQUFLM3ZCLE1BQVA7QUFDQSxhQUFPaWMsR0FBUDtBQUNEO0FBUkEsR0F0QnNCLEVBK0J0QjtBQUNEdmdCLElBQUFBLEdBQUcsRUFBRSxPQURKO0FBRURuRyxJQUFBQSxLQUFLLEVBQUUsU0FBU3E2QixLQUFULEdBQWlCO0FBQ3RCLFdBQUs1ZSxJQUFMLEdBQVksS0FBS3FwQixJQUFMLEdBQVksSUFBeEI7QUFDQSxXQUFLcjZCLE1BQUwsR0FBYyxDQUFkO0FBQ0Q7QUFMQSxHQS9Cc0IsRUFxQ3RCO0FBQ0R0RSxJQUFBQSxHQUFHLEVBQUUsTUFESjtBQUVEbkcsSUFBQUEsS0FBSyxFQUFFLFNBQVMrUSxJQUFULENBQWNzSyxDQUFkLEVBQWlCO0FBQ3RCLFVBQUksS0FBSzVRLE1BQUwsS0FBZ0IsQ0FBcEIsRUFBdUIsT0FBTyxFQUFQO0FBQ3ZCLFVBQUk2UyxDQUFDLEdBQUcsS0FBSzdCLElBQWI7QUFDQSxVQUFJaUwsR0FBRyxHQUFHLEtBQUtwSixDQUFDLENBQUMzYSxJQUFqQjs7QUFFQSxhQUFPMmEsQ0FBQyxHQUFHQSxDQUFDLENBQUM4YyxJQUFiLEVBQW1CO0FBQ2pCMVQsUUFBQUEsR0FBRyxJQUFJckwsQ0FBQyxHQUFHaUMsQ0FBQyxDQUFDM2EsSUFBYjtBQUNEOztBQUVELGFBQU8rakIsR0FBUDtBQUNEO0FBWkEsR0FyQ3NCLEVBa0R0QjtBQUNEdmdCLElBQUFBLEdBQUcsRUFBRSxRQURKO0FBRURuRyxJQUFBQSxLQUFLLEVBQUUsU0FBU3dLLE1BQVQsQ0FBZ0JpVCxDQUFoQixFQUFtQjtBQUN4QixVQUFJLEtBQUtoVCxNQUFMLEtBQWdCLENBQXBCLEVBQXVCLE9BQU85SixNQUFNLENBQUNraEIsS0FBUCxDQUFhLENBQWIsQ0FBUDtBQUN2QixVQUFJNkUsR0FBRyxHQUFHL2xCLE1BQU0sQ0FBQ3VnQixXQUFQLENBQW1CekQsQ0FBQyxLQUFLLENBQXpCLENBQVY7QUFDQSxVQUFJSCxDQUFDLEdBQUcsS0FBSzdCLElBQWI7QUFDQSxVQUFJbEwsQ0FBQyxHQUFHLENBQVI7O0FBRUEsYUFBTytNLENBQVAsRUFBVTtBQUNSdW5CLFFBQUFBLFVBQVUsQ0FBQ3ZuQixDQUFDLENBQUMzYSxJQUFILEVBQVMrakIsR0FBVCxFQUFjblcsQ0FBZCxDQUFWO0FBQ0FBLFFBQUFBLENBQUMsSUFBSStNLENBQUMsQ0FBQzNhLElBQUYsQ0FBTzhILE1BQVo7QUFDQTZTLFFBQUFBLENBQUMsR0FBR0EsQ0FBQyxDQUFDOGMsSUFBTjtBQUNEOztBQUVELGFBQU8xVCxHQUFQO0FBQ0QsS0FmQSxDQWVDOztBQWZELEdBbERzQixFQW1FdEI7QUFDRHZnQixJQUFBQSxHQUFHLEVBQUUsU0FESjtBQUVEbkcsSUFBQUEsS0FBSyxFQUFFLFNBQVNnOUIsT0FBVCxDQUFpQnZmLENBQWpCLEVBQW9Cc25CLFVBQXBCLEVBQWdDO0FBQ3JDLFVBQUlyZSxHQUFKOztBQUVBLFVBQUlqSixDQUFDLEdBQUcsS0FBS2hDLElBQUwsQ0FBVTlZLElBQVYsQ0FBZThILE1BQXZCLEVBQStCO0FBQzdCO0FBQ0FpYyxRQUFBQSxHQUFHLEdBQUcsS0FBS2pMLElBQUwsQ0FBVTlZLElBQVYsQ0FBZTVCLEtBQWYsQ0FBcUIsQ0FBckIsRUFBd0IwYyxDQUF4QixDQUFOO0FBQ0EsYUFBS2hDLElBQUwsQ0FBVTlZLElBQVYsR0FBaUIsS0FBSzhZLElBQUwsQ0FBVTlZLElBQVYsQ0FBZTVCLEtBQWYsQ0FBcUIwYyxDQUFyQixDQUFqQjtBQUNELE9BSkQsTUFJTyxJQUFJQSxDQUFDLEtBQUssS0FBS2hDLElBQUwsQ0FBVTlZLElBQVYsQ0FBZThILE1BQXpCLEVBQWlDO0FBQ3RDO0FBQ0FpYyxRQUFBQSxHQUFHLEdBQUcsS0FBS2hjLEtBQUwsRUFBTjtBQUNELE9BSE0sTUFHQTtBQUNMO0FBQ0FnYyxRQUFBQSxHQUFHLEdBQUdxZSxVQUFVLEdBQUcsS0FBS0MsVUFBTCxDQUFnQnZuQixDQUFoQixDQUFILEdBQXdCLEtBQUt3bkIsVUFBTCxDQUFnQnhuQixDQUFoQixDQUF4QztBQUNEOztBQUVELGFBQU9pSixHQUFQO0FBQ0Q7QUFsQkEsR0FuRXNCLEVBc0Z0QjtBQUNEdmdCLElBQUFBLEdBQUcsRUFBRSxPQURKO0FBRURuRyxJQUFBQSxLQUFLLEVBQUUsU0FBU2lvQixLQUFULEdBQWlCO0FBQ3RCLGFBQU8sS0FBS3hNLElBQUwsQ0FBVTlZLElBQWpCO0FBQ0QsS0FKQSxDQUlDOztBQUpELEdBdEZzQixFQTRGdEI7QUFDRHdELElBQUFBLEdBQUcsRUFBRSxZQURKO0FBRURuRyxJQUFBQSxLQUFLLEVBQUUsU0FBU2dsQyxVQUFULENBQW9Cdm5CLENBQXBCLEVBQXVCO0FBQzVCLFVBQUlILENBQUMsR0FBRyxLQUFLN0IsSUFBYjtBQUNBLFVBQUkxUyxDQUFDLEdBQUcsQ0FBUjtBQUNBLFVBQUkyZCxHQUFHLEdBQUdwSixDQUFDLENBQUMzYSxJQUFaO0FBQ0E4YSxNQUFBQSxDQUFDLElBQUlpSixHQUFHLENBQUNqYyxNQUFUOztBQUVBLGFBQU82UyxDQUFDLEdBQUdBLENBQUMsQ0FBQzhjLElBQWIsRUFBbUI7QUFDakIsWUFBSXZrQixHQUFHLEdBQUd5SCxDQUFDLENBQUMzYSxJQUFaO0FBQ0EsWUFBSXVpQyxFQUFFLEdBQUd6bkIsQ0FBQyxHQUFHNUgsR0FBRyxDQUFDcEwsTUFBUixHQUFpQm9MLEdBQUcsQ0FBQ3BMLE1BQXJCLEdBQThCZ1QsQ0FBdkM7QUFDQSxZQUFJeW5CLEVBQUUsS0FBS3J2QixHQUFHLENBQUNwTCxNQUFmLEVBQXVCaWMsR0FBRyxJQUFJN1EsR0FBUCxDQUF2QixLQUF1QzZRLEdBQUcsSUFBSTdRLEdBQUcsQ0FBQzlVLEtBQUosQ0FBVSxDQUFWLEVBQWEwYyxDQUFiLENBQVA7QUFDdkNBLFFBQUFBLENBQUMsSUFBSXluQixFQUFMOztBQUVBLFlBQUl6bkIsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNYLGNBQUl5bkIsRUFBRSxLQUFLcnZCLEdBQUcsQ0FBQ3BMLE1BQWYsRUFBdUI7QUFDckIsY0FBRTFCLENBQUY7QUFDQSxnQkFBSXVVLENBQUMsQ0FBQzhjLElBQU4sRUFBWSxLQUFLM2UsSUFBTCxHQUFZNkIsQ0FBQyxDQUFDOGMsSUFBZCxDQUFaLEtBQW9DLEtBQUszZSxJQUFMLEdBQVksS0FBS3FwQixJQUFMLEdBQVksSUFBeEI7QUFDckMsV0FIRCxNQUdPO0FBQ0wsaUJBQUtycEIsSUFBTCxHQUFZNkIsQ0FBWjtBQUNBQSxZQUFBQSxDQUFDLENBQUMzYSxJQUFGLEdBQVNrVCxHQUFHLENBQUM5VSxLQUFKLENBQVVta0MsRUFBVixDQUFUO0FBQ0Q7O0FBRUQ7QUFDRDs7QUFFRCxVQUFFbjhCLENBQUY7QUFDRDs7QUFFRCxXQUFLMEIsTUFBTCxJQUFlMUIsQ0FBZjtBQUNBLGFBQU8yZCxHQUFQO0FBQ0QsS0EvQkEsQ0ErQkM7O0FBL0JELEdBNUZzQixFQTZIdEI7QUFDRHZnQixJQUFBQSxHQUFHLEVBQUUsWUFESjtBQUVEbkcsSUFBQUEsS0FBSyxFQUFFLFNBQVNpbEMsVUFBVCxDQUFvQnhuQixDQUFwQixFQUF1QjtBQUM1QixVQUFJaUosR0FBRyxHQUFHL2xCLE1BQU0sQ0FBQ3VnQixXQUFQLENBQW1CekQsQ0FBbkIsQ0FBVjtBQUNBLFVBQUlILENBQUMsR0FBRyxLQUFLN0IsSUFBYjtBQUNBLFVBQUkxUyxDQUFDLEdBQUcsQ0FBUjtBQUNBdVUsTUFBQUEsQ0FBQyxDQUFDM2EsSUFBRixDQUFPMmYsSUFBUCxDQUFZb0UsR0FBWjtBQUNBakosTUFBQUEsQ0FBQyxJQUFJSCxDQUFDLENBQUMzYSxJQUFGLENBQU84SCxNQUFaOztBQUVBLGFBQU82UyxDQUFDLEdBQUdBLENBQUMsQ0FBQzhjLElBQWIsRUFBbUI7QUFDakIsWUFBSTdjLEdBQUcsR0FBR0QsQ0FBQyxDQUFDM2EsSUFBWjtBQUNBLFlBQUl1aUMsRUFBRSxHQUFHem5CLENBQUMsR0FBR0YsR0FBRyxDQUFDOVMsTUFBUixHQUFpQjhTLEdBQUcsQ0FBQzlTLE1BQXJCLEdBQThCZ1QsQ0FBdkM7QUFDQUYsUUFBQUEsR0FBRyxDQUFDK0UsSUFBSixDQUFTb0UsR0FBVCxFQUFjQSxHQUFHLENBQUNqYyxNQUFKLEdBQWFnVCxDQUEzQixFQUE4QixDQUE5QixFQUFpQ3luQixFQUFqQztBQUNBem5CLFFBQUFBLENBQUMsSUFBSXluQixFQUFMOztBQUVBLFlBQUl6bkIsQ0FBQyxLQUFLLENBQVYsRUFBYTtBQUNYLGNBQUl5bkIsRUFBRSxLQUFLM25CLEdBQUcsQ0FBQzlTLE1BQWYsRUFBdUI7QUFDckIsY0FBRTFCLENBQUY7QUFDQSxnQkFBSXVVLENBQUMsQ0FBQzhjLElBQU4sRUFBWSxLQUFLM2UsSUFBTCxHQUFZNkIsQ0FBQyxDQUFDOGMsSUFBZCxDQUFaLEtBQW9DLEtBQUszZSxJQUFMLEdBQVksS0FBS3FwQixJQUFMLEdBQVksSUFBeEI7QUFDckMsV0FIRCxNQUdPO0FBQ0wsaUJBQUtycEIsSUFBTCxHQUFZNkIsQ0FBWjtBQUNBQSxZQUFBQSxDQUFDLENBQUMzYSxJQUFGLEdBQVM0YSxHQUFHLENBQUN4YyxLQUFKLENBQVVta0MsRUFBVixDQUFUO0FBQ0Q7O0FBRUQ7QUFDRDs7QUFFRCxVQUFFbjhCLENBQUY7QUFDRDs7QUFFRCxXQUFLMEIsTUFBTCxJQUFlMUIsQ0FBZjtBQUNBLGFBQU8yZCxHQUFQO0FBQ0QsS0FoQ0EsQ0FnQ0M7O0FBaENELEdBN0hzQixFQStKdEI7QUFDRHZnQixJQUFBQSxHQUFHLEVBQUV5K0IsTUFESjtBQUVENWtDLElBQUFBLEtBQUssRUFBRSxTQUFTQSxLQUFULENBQWV5Z0MsQ0FBZixFQUFrQnAxQixPQUFsQixFQUEyQjtBQUNoQyxhQUFPMlksT0FBTyxDQUFDLElBQUQsRUFBT2dnQixhQUFhLENBQUMsRUFBRCxFQUFLMzRCLE9BQUwsRUFBYztBQUM5QztBQUNBODVCLFFBQUFBLEtBQUssRUFBRSxDQUZ1QztBQUc5QztBQUNBQyxRQUFBQSxhQUFhLEVBQUU7QUFKK0IsT0FBZCxDQUFwQixDQUFkO0FBTUQ7QUFUQSxHQS9Kc0IsQ0FBYixDQUFaOztBQTJLQSxTQUFPak8sVUFBUDtBQUNELENBckxELEVBRkE7Ozs7Ozs7Ozs7Q0MxQmM7O0FBRWQsU0FBU21DLE9BQVQsQ0FBaUJwZSxHQUFqQixFQUFzQkwsRUFBdEIsRUFBMEI7QUFDeEIsTUFBSThoQixLQUFLLEdBQUcsSUFBWjs7QUFFQSxNQUFJMEksaUJBQWlCLEdBQUcsS0FBS25QLGNBQUwsSUFBdUIsS0FBS0EsY0FBTCxDQUFvQkMsU0FBbkU7QUFDQSxNQUFJbVAsaUJBQWlCLEdBQUcsS0FBSzFQLGNBQUwsSUFBdUIsS0FBS0EsY0FBTCxDQUFvQk8sU0FBbkU7O0FBRUEsTUFBSWtQLGlCQUFpQixJQUFJQyxpQkFBekIsRUFBNEM7QUFDMUMsUUFBSXpxQixFQUFKLEVBQVE7QUFDTkEsTUFBQUEsRUFBRSxDQUFDSyxHQUFELENBQUY7QUFDRCxLQUZELE1BRU8sSUFBSUEsR0FBSixFQUFTO0FBQ2QsVUFBSSxDQUFDLEtBQUswYSxjQUFWLEVBQTBCO0FBQ3hCL21CLFFBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCdVAsV0FBakIsRUFBOEIsSUFBOUIsRUFBb0NycUIsR0FBcEM7QUFDRCxPQUZELE1BRU8sSUFBSSxDQUFDLEtBQUswYSxjQUFMLENBQW9Cd0ssWUFBekIsRUFBdUM7QUFDNUMsYUFBS3hLLGNBQUwsQ0FBb0J3SyxZQUFwQixHQUFtQyxJQUFuQztBQUNBdnhCLFFBQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCdVAsV0FBakIsRUFBOEIsSUFBOUIsRUFBb0NycUIsR0FBcEM7QUFDRDtBQUNGOztBQUVELFdBQU8sSUFBUDtBQUNELEdBbkJ1QixDQW1CdEI7QUFDRjs7O0FBR0EsTUFBSSxLQUFLZ2IsY0FBVCxFQUF5QjtBQUN2QixTQUFLQSxjQUFMLENBQW9CQyxTQUFwQixHQUFnQyxJQUFoQztBQUNELEdBekJ1QixDQXlCdEI7OztBQUdGLE1BQUksS0FBS1AsY0FBVCxFQUF5QjtBQUN2QixTQUFLQSxjQUFMLENBQW9CTyxTQUFwQixHQUFnQyxJQUFoQztBQUNEOztBQUVELE9BQUtvRCxRQUFMLENBQWNyZSxHQUFHLElBQUksSUFBckIsRUFBMkIsVUFBVUEsR0FBVixFQUFlO0FBQ3hDLFFBQUksQ0FBQ0wsRUFBRCxJQUFPSyxHQUFYLEVBQWdCO0FBQ2QsVUFBSSxDQUFDeWhCLEtBQUssQ0FBQy9HLGNBQVgsRUFBMkI7QUFDekIvbUIsUUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJ3UCxtQkFBakIsRUFBc0M3SSxLQUF0QyxFQUE2Q3poQixHQUE3QztBQUNELE9BRkQsTUFFTyxJQUFJLENBQUN5aEIsS0FBSyxDQUFDL0csY0FBTixDQUFxQndLLFlBQTFCLEVBQXdDO0FBQzdDekQsUUFBQUEsS0FBSyxDQUFDL0csY0FBTixDQUFxQndLLFlBQXJCLEdBQW9DLElBQXBDO0FBQ0F2eEIsUUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJ3UCxtQkFBakIsRUFBc0M3SSxLQUF0QyxFQUE2Q3poQixHQUE3QztBQUNELE9BSE0sTUFHQTtBQUNMck0sUUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUJ5UCxXQUFqQixFQUE4QjlJLEtBQTlCO0FBQ0Q7QUFDRixLQVRELE1BU08sSUFBSTloQixFQUFKLEVBQVE7QUFDYmhNLE1BQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCeVAsV0FBakIsRUFBOEI5SSxLQUE5QjtBQUNBOWhCLE1BQUFBLEVBQUUsQ0FBQ0ssR0FBRCxDQUFGO0FBQ0QsS0FITSxNQUdBO0FBQ0xyTSxNQUFBQSxPQUFPLENBQUNtbkIsUUFBUixDQUFpQnlQLFdBQWpCLEVBQThCOUksS0FBOUI7QUFDRDtBQUNGLEdBaEJEOztBQWtCQSxTQUFPLElBQVA7QUFDRDs7QUFFRCxTQUFTNkksbUJBQVQsQ0FBNkJyVCxJQUE3QixFQUFtQ2pYLEdBQW5DLEVBQXdDO0FBQ3RDcXFCLEVBQUFBLFdBQVcsQ0FBQ3BULElBQUQsRUFBT2pYLEdBQVAsQ0FBWDtBQUNBdXFCLEVBQUFBLFdBQVcsQ0FBQ3RULElBQUQsQ0FBWDtBQUNEOztBQUVELFNBQVNzVCxXQUFULENBQXFCdFQsSUFBckIsRUFBMkI7QUFDekIsTUFBSUEsSUFBSSxDQUFDeUQsY0FBTCxJQUF1QixDQUFDekQsSUFBSSxDQUFDeUQsY0FBTCxDQUFvQm1ELFNBQWhELEVBQTJEO0FBQzNELE1BQUk1RyxJQUFJLENBQUMrRCxjQUFMLElBQXVCLENBQUMvRCxJQUFJLENBQUMrRCxjQUFMLENBQW9CNkMsU0FBaEQsRUFBMkQ7QUFDM0Q1RyxFQUFBQSxJQUFJLENBQUM3QyxJQUFMLENBQVUsT0FBVjtBQUNEOztBQUVELFNBQVNtSyxTQUFULEdBQXFCO0FBQ25CLE1BQUksS0FBS3ZELGNBQVQsRUFBeUI7QUFDdkIsU0FBS0EsY0FBTCxDQUFvQkMsU0FBcEIsR0FBZ0MsS0FBaEM7QUFDQSxTQUFLRCxjQUFMLENBQW9Cc0MsT0FBcEIsR0FBOEIsS0FBOUI7QUFDQSxTQUFLdEMsY0FBTCxDQUFvQkgsS0FBcEIsR0FBNEIsS0FBNUI7QUFDQSxTQUFLRyxjQUFMLENBQW9CcUMsVUFBcEIsR0FBaUMsS0FBakM7QUFDRDs7QUFFRCxNQUFJLEtBQUszQyxjQUFULEVBQXlCO0FBQ3ZCLFNBQUtBLGNBQUwsQ0FBb0JPLFNBQXBCLEdBQWdDLEtBQWhDO0FBQ0EsU0FBS1AsY0FBTCxDQUFvQkcsS0FBcEIsR0FBNEIsS0FBNUI7QUFDQSxTQUFLSCxjQUFMLENBQW9CNEosTUFBcEIsR0FBNkIsS0FBN0I7QUFDQSxTQUFLNUosY0FBTCxDQUFvQjJKLFdBQXBCLEdBQWtDLEtBQWxDO0FBQ0EsU0FBSzNKLGNBQUwsQ0FBb0J1SyxXQUFwQixHQUFrQyxLQUFsQztBQUNBLFNBQUt2SyxjQUFMLENBQW9CdUgsUUFBcEIsR0FBK0IsS0FBL0I7QUFDQSxTQUFLdkgsY0FBTCxDQUFvQndLLFlBQXBCLEdBQW1DLEtBQW5DO0FBQ0Q7QUFDRjs7QUFFRCxTQUFTbUYsV0FBVCxDQUFxQnBULElBQXJCLEVBQTJCalgsR0FBM0IsRUFBZ0M7QUFDOUJpWCxFQUFBQSxJQUFJLENBQUM3QyxJQUFMLENBQVUsT0FBVixFQUFtQnBVLEdBQW5CO0FBQ0Q7O0FBRUQsU0FBUzJjLGNBQVQsQ0FBd0JHLE1BQXhCLEVBQWdDOWMsR0FBaEMsRUFBcUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQUlvbkIsTUFBTSxHQUFHdEssTUFBTSxDQUFDOUIsY0FBcEI7QUFDQSxNQUFJZ0gsTUFBTSxHQUFHbEYsTUFBTSxDQUFDcEMsY0FBcEI7QUFDQSxNQUFJME0sTUFBTSxJQUFJQSxNQUFNLENBQUN0SixXQUFqQixJQUFnQ2tFLE1BQU0sSUFBSUEsTUFBTSxDQUFDbEUsV0FBckQsRUFBa0VoQixNQUFNLENBQUNzQixPQUFQLENBQWVwZSxHQUFmLEVBQWxFLEtBQTJGOGMsTUFBTSxDQUFDMUksSUFBUCxDQUFZLE9BQVosRUFBcUJwVSxHQUFyQjtBQUM1Rjs7QUFFRHZaLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUI7QUFDZnU1QixFQUFBQSxPQUFPLEVBQUVBLE9BRE07QUFFZkcsRUFBQUEsU0FBUyxFQUFFQSxTQUZJO0FBR2Y1QixFQUFBQSxjQUFjLEVBQUVBO0FBSEQsQ0FBakI7Ozs7Ozs7Ozs7QUNwR0E7QUFDQTtBQUNhOztBQUViLElBQUk2TiwwQkFBMEIsR0FBR3hsQyxpSUFBakM7O0FBRUEsU0FBU3l1QixJQUFULENBQWM1YSxRQUFkLEVBQXdCO0FBQ3RCLE1BQUk0eEIsTUFBTSxHQUFHLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSUEsTUFBSixFQUFZO0FBQ1pBLElBQUFBLE1BQU0sR0FBRyxJQUFUOztBQUVBLFNBQUssSUFBSUMsSUFBSSxHQUFHdjhCLFNBQVMsQ0FBQ29CLE1BQXJCLEVBQTZCNkYsSUFBSSxHQUFHLElBQUloRyxLQUFKLENBQVVzN0IsSUFBVixDQUFwQyxFQUFxREMsSUFBSSxHQUFHLENBQWpFLEVBQW9FQSxJQUFJLEdBQUdELElBQTNFLEVBQWlGQyxJQUFJLEVBQXJGLEVBQXlGO0FBQ3ZGdjFCLE1BQUFBLElBQUksQ0FBQ3UxQixJQUFELENBQUosR0FBYXg4QixTQUFTLENBQUN3OEIsSUFBRCxDQUF0QjtBQUNEOztBQUVEOXhCLElBQUFBLFFBQVEsQ0FBQ3hKLEtBQVQsQ0FBZSxJQUFmLEVBQXFCK0YsSUFBckI7QUFDRCxHQVREO0FBVUQ7O0FBRUQsU0FBUytNLElBQVQsR0FBZ0IsQ0FBRTs7QUFFbEIsU0FBU3lvQixTQUFULENBQW1COU4sTUFBbkIsRUFBMkI7QUFDekIsU0FBT0EsTUFBTSxDQUFDK04sU0FBUCxJQUFvQixPQUFPL04sTUFBTSxDQUFDanhCLEtBQWQsS0FBd0IsVUFBbkQ7QUFDRDs7QUFFRCxTQUFTaS9CLEdBQVQsQ0FBYWhPLE1BQWIsRUFBcUJqakIsSUFBckIsRUFBMkJoQixRQUEzQixFQUFxQztBQUNuQyxNQUFJLE9BQU9nQixJQUFQLEtBQWdCLFVBQXBCLEVBQWdDLE9BQU9peEIsR0FBRyxDQUFDaE8sTUFBRCxFQUFTLElBQVQsRUFBZWpqQixJQUFmLENBQVY7QUFDaEMsTUFBSSxDQUFDQSxJQUFMLEVBQVdBLElBQUksR0FBRyxFQUFQO0FBQ1hoQixFQUFBQSxRQUFRLEdBQUc0YSxJQUFJLENBQUM1YSxRQUFRLElBQUlzSixJQUFiLENBQWY7QUFDQSxNQUFJcVksUUFBUSxHQUFHM2dCLElBQUksQ0FBQzJnQixRQUFMLElBQWlCM2dCLElBQUksQ0FBQzJnQixRQUFMLEtBQWtCLEtBQWxCLElBQTJCc0MsTUFBTSxDQUFDdEMsUUFBbEU7QUFDQSxNQUFJdEosUUFBUSxHQUFHclgsSUFBSSxDQUFDcVgsUUFBTCxJQUFpQnJYLElBQUksQ0FBQ3FYLFFBQUwsS0FBa0IsS0FBbEIsSUFBMkI0TCxNQUFNLENBQUM1TCxRQUFsRTs7QUFFQSxNQUFJNlosY0FBYyxHQUFHLFNBQVNBLGNBQVQsR0FBMEI7QUFDN0MsUUFBSSxDQUFDak8sTUFBTSxDQUFDNUwsUUFBWixFQUFzQjJQLFFBQVE7QUFDL0IsR0FGRDs7QUFJQSxNQUFJbUssYUFBYSxHQUFHbE8sTUFBTSxDQUFDcEMsY0FBUCxJQUF5Qm9DLE1BQU0sQ0FBQ3BDLGNBQVAsQ0FBc0J1SCxRQUFuRTs7QUFFQSxNQUFJcEIsUUFBUSxHQUFHLFNBQVNBLFFBQVQsR0FBb0I7QUFDakMzUCxJQUFBQSxRQUFRLEdBQUcsS0FBWDtBQUNBOFosSUFBQUEsYUFBYSxHQUFHLElBQWhCO0FBQ0EsUUFBSSxDQUFDeFEsUUFBTCxFQUFlM2hCLFFBQVEsQ0FBQzdILElBQVQsQ0FBYzhyQixNQUFkO0FBQ2hCLEdBSkQ7O0FBTUEsTUFBSW1PLGFBQWEsR0FBR25PLE1BQU0sQ0FBQzlCLGNBQVAsSUFBeUI4QixNQUFNLENBQUM5QixjQUFQLENBQXNCcUMsVUFBbkU7O0FBRUEsTUFBSTVDLEtBQUssR0FBRyxTQUFTQSxLQUFULEdBQWlCO0FBQzNCRCxJQUFBQSxRQUFRLEdBQUcsS0FBWDtBQUNBeVEsSUFBQUEsYUFBYSxHQUFHLElBQWhCO0FBQ0EsUUFBSSxDQUFDL1osUUFBTCxFQUFlclksUUFBUSxDQUFDN0gsSUFBVCxDQUFjOHJCLE1BQWQ7QUFDaEIsR0FKRDs7QUFNQSxNQUFJOXlCLE9BQU8sR0FBRyxTQUFTQSxPQUFULENBQWlCZ1csR0FBakIsRUFBc0I7QUFDbENuSCxJQUFBQSxRQUFRLENBQUM3SCxJQUFULENBQWM4ckIsTUFBZCxFQUFzQjljLEdBQXRCO0FBQ0QsR0FGRDs7QUFJQSxNQUFJNGdCLE9BQU8sR0FBRyxTQUFTQSxPQUFULEdBQW1CO0FBQy9CLFFBQUk1Z0IsR0FBSjs7QUFFQSxRQUFJd2EsUUFBUSxJQUFJLENBQUN5USxhQUFqQixFQUFnQztBQUM5QixVQUFJLENBQUNuTyxNQUFNLENBQUM5QixjQUFSLElBQTBCLENBQUM4QixNQUFNLENBQUM5QixjQUFQLENBQXNCSCxLQUFyRCxFQUE0RDdhLEdBQUcsR0FBRyxJQUFJd3FCLDBCQUFKLEVBQU47QUFDNUQsYUFBTzN4QixRQUFRLENBQUM3SCxJQUFULENBQWM4ckIsTUFBZCxFQUFzQjljLEdBQXRCLENBQVA7QUFDRDs7QUFFRCxRQUFJa1IsUUFBUSxJQUFJLENBQUM4WixhQUFqQixFQUFnQztBQUM5QixVQUFJLENBQUNsTyxNQUFNLENBQUNwQyxjQUFSLElBQTBCLENBQUNvQyxNQUFNLENBQUNwQyxjQUFQLENBQXNCRyxLQUFyRCxFQUE0RDdhLEdBQUcsR0FBRyxJQUFJd3FCLDBCQUFKLEVBQU47QUFDNUQsYUFBTzN4QixRQUFRLENBQUM3SCxJQUFULENBQWM4ckIsTUFBZCxFQUFzQjljLEdBQXRCLENBQVA7QUFDRDtBQUNGLEdBWkQ7O0FBY0EsTUFBSWtyQixTQUFTLEdBQUcsU0FBU0EsU0FBVCxHQUFxQjtBQUNuQ3BPLElBQUFBLE1BQU0sQ0FBQ3FPLEdBQVAsQ0FBV2hXLEVBQVgsQ0FBYyxRQUFkLEVBQXdCMEwsUUFBeEI7QUFDRCxHQUZEOztBQUlBLE1BQUkrSixTQUFTLENBQUM5TixNQUFELENBQWIsRUFBdUI7QUFDckJBLElBQUFBLE1BQU0sQ0FBQzNILEVBQVAsQ0FBVSxVQUFWLEVBQXNCMEwsUUFBdEI7QUFDQS9ELElBQUFBLE1BQU0sQ0FBQzNILEVBQVAsQ0FBVSxPQUFWLEVBQW1CeUwsT0FBbkI7QUFDQSxRQUFJOUQsTUFBTSxDQUFDcU8sR0FBWCxFQUFnQkQsU0FBUyxHQUF6QixLQUFpQ3BPLE1BQU0sQ0FBQzNILEVBQVAsQ0FBVSxTQUFWLEVBQXFCK1YsU0FBckI7QUFDbEMsR0FKRCxNQUlPLElBQUloYSxRQUFRLElBQUksQ0FBQzRMLE1BQU0sQ0FBQ3BDLGNBQXhCLEVBQXdDO0FBQzdDO0FBQ0FvQyxJQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsS0FBVixFQUFpQjRWLGNBQWpCO0FBQ0FqTyxJQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsT0FBVixFQUFtQjRWLGNBQW5CO0FBQ0Q7O0FBRURqTyxFQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsS0FBVixFQUFpQnNGLEtBQWpCO0FBQ0FxQyxFQUFBQSxNQUFNLENBQUMzSCxFQUFQLENBQVUsUUFBVixFQUFvQjBMLFFBQXBCO0FBQ0EsTUFBSWhuQixJQUFJLENBQUNqSyxLQUFMLEtBQWUsS0FBbkIsRUFBMEJrdEIsTUFBTSxDQUFDM0gsRUFBUCxDQUFVLE9BQVYsRUFBbUJuckIsT0FBbkI7QUFDMUI4eUIsRUFBQUEsTUFBTSxDQUFDM0gsRUFBUCxDQUFVLE9BQVYsRUFBbUJ5TCxPQUFuQjtBQUNBLFNBQU8sWUFBWTtBQUNqQjlELElBQUFBLE1BQU0sQ0FBQ3ZILGNBQVAsQ0FBc0IsVUFBdEIsRUFBa0NzTCxRQUFsQztBQUNBL0QsSUFBQUEsTUFBTSxDQUFDdkgsY0FBUCxDQUFzQixPQUF0QixFQUErQnFMLE9BQS9CO0FBQ0E5RCxJQUFBQSxNQUFNLENBQUN2SCxjQUFQLENBQXNCLFNBQXRCLEVBQWlDMlYsU0FBakM7QUFDQSxRQUFJcE8sTUFBTSxDQUFDcU8sR0FBWCxFQUFnQnJPLE1BQU0sQ0FBQ3FPLEdBQVAsQ0FBVzVWLGNBQVgsQ0FBMEIsUUFBMUIsRUFBb0NzTCxRQUFwQztBQUNoQi9ELElBQUFBLE1BQU0sQ0FBQ3ZILGNBQVAsQ0FBc0IsS0FBdEIsRUFBNkJ3VixjQUE3QjtBQUNBak8sSUFBQUEsTUFBTSxDQUFDdkgsY0FBUCxDQUFzQixPQUF0QixFQUErQndWLGNBQS9CO0FBQ0FqTyxJQUFBQSxNQUFNLENBQUN2SCxjQUFQLENBQXNCLFFBQXRCLEVBQWdDc0wsUUFBaEM7QUFDQS9ELElBQUFBLE1BQU0sQ0FBQ3ZILGNBQVAsQ0FBc0IsS0FBdEIsRUFBNkJrRixLQUE3QjtBQUNBcUMsSUFBQUEsTUFBTSxDQUFDdkgsY0FBUCxDQUFzQixPQUF0QixFQUErQnZyQixPQUEvQjtBQUNBOHlCLElBQUFBLE1BQU0sQ0FBQ3ZILGNBQVAsQ0FBc0IsT0FBdEIsRUFBK0JxTCxPQUEvQjtBQUNELEdBWEQ7QUFZRDs7QUFFRG42QixNQUFNLENBQUM1QixPQUFQLEdBQWlCaW1DLEdBQWpCOzs7Ozs7Ozs7O0FDdkdBcmtDLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsWUFBWTtBQUMzQixRQUFNLElBQUkwQixLQUFKLENBQVUsK0NBQVYsQ0FBTjtBQUNELENBRkQ7Ozs7Ozs7Ozs7QUNBQTtBQUNBO0FBQ2E7O0FBRWIsSUFBSXVrQyxHQUFKOztBQUVBLFNBQVNyWCxJQUFULENBQWM1YSxRQUFkLEVBQXdCO0FBQ3RCLE1BQUk0eEIsTUFBTSxHQUFHLEtBQWI7QUFDQSxTQUFPLFlBQVk7QUFDakIsUUFBSUEsTUFBSixFQUFZO0FBQ1pBLElBQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0E1eEIsSUFBQUEsUUFBUSxDQUFDeEosS0FBVCxDQUFlLEtBQUssQ0FBcEIsRUFBdUJsQixTQUF2QjtBQUNELEdBSkQ7QUFLRDs7QUFFRCxJQUFJa3VCLGNBQWMsR0FBR3IzQixzR0FBckI7QUFBQSxJQUNJb21DLGdCQUFnQixHQUFHL08sY0FBYyxDQUFDK08sZ0JBRHRDO0FBQUEsSUFFSXJILG9CQUFvQixHQUFHMUgsY0FBYyxDQUFDMEgsb0JBRjFDOztBQUlBLFNBQVM1aEIsSUFBVCxDQUFjbkMsR0FBZCxFQUFtQjtBQUNqQjtBQUNBLE1BQUlBLEdBQUosRUFBUyxNQUFNQSxHQUFOO0FBQ1Y7O0FBRUQsU0FBUzRxQixTQUFULENBQW1COU4sTUFBbkIsRUFBMkI7QUFDekIsU0FBT0EsTUFBTSxDQUFDK04sU0FBUCxJQUFvQixPQUFPL04sTUFBTSxDQUFDanhCLEtBQWQsS0FBd0IsVUFBbkQ7QUFDRDs7QUFFRCxTQUFTdy9CLFNBQVQsQ0FBbUJ2TyxNQUFuQixFQUEyQlEsT0FBM0IsRUFBb0NtSCxPQUFwQyxFQUE2QzVyQixRQUE3QyxFQUF1RDtBQUNyREEsRUFBQUEsUUFBUSxHQUFHNGEsSUFBSSxDQUFDNWEsUUFBRCxDQUFmO0FBQ0EsTUFBSXl5QixNQUFNLEdBQUcsS0FBYjtBQUNBeE8sRUFBQUEsTUFBTSxDQUFDM0gsRUFBUCxDQUFVLE9BQVYsRUFBbUIsWUFBWTtBQUM3Qm1XLElBQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0QsR0FGRDtBQUdBLE1BQUlSLEdBQUcsS0FBS2xnQyxTQUFaLEVBQXVCa2dDLEdBQUcsR0FBRzlsQyxtQkFBTyxDQUFDLDZGQUFELENBQWI7QUFDdkI4bEMsRUFBQUEsR0FBRyxDQUFDaE8sTUFBRCxFQUFTO0FBQ1Z0QyxJQUFBQSxRQUFRLEVBQUU4QyxPQURBO0FBRVZwTSxJQUFBQSxRQUFRLEVBQUV1VDtBQUZBLEdBQVQsRUFHQSxVQUFVemtCLEdBQVYsRUFBZTtBQUNoQixRQUFJQSxHQUFKLEVBQVMsT0FBT25ILFFBQVEsQ0FBQ21ILEdBQUQsQ0FBZjtBQUNUc3JCLElBQUFBLE1BQU0sR0FBRyxJQUFUO0FBQ0F6eUIsSUFBQUEsUUFBUTtBQUNULEdBUEUsQ0FBSDtBQVFBLE1BQUlvaUIsU0FBUyxHQUFHLEtBQWhCO0FBQ0EsU0FBTyxVQUFVamIsR0FBVixFQUFlO0FBQ3BCLFFBQUlzckIsTUFBSixFQUFZO0FBQ1osUUFBSXJRLFNBQUosRUFBZTtBQUNmQSxJQUFBQSxTQUFTLEdBQUcsSUFBWixDQUhvQixDQUdGOztBQUVsQixRQUFJMlAsU0FBUyxDQUFDOU4sTUFBRCxDQUFiLEVBQXVCLE9BQU9BLE1BQU0sQ0FBQ2p4QixLQUFQLEVBQVA7QUFDdkIsUUFBSSxPQUFPaXhCLE1BQU0sQ0FBQ3NCLE9BQWQsS0FBMEIsVUFBOUIsRUFBMEMsT0FBT3RCLE1BQU0sQ0FBQ3NCLE9BQVAsRUFBUDtBQUMxQ3ZsQixJQUFBQSxRQUFRLENBQUNtSCxHQUFHLElBQUksSUFBSStqQixvQkFBSixDQUF5QixNQUF6QixDQUFSLENBQVI7QUFDRCxHQVJEO0FBU0Q7O0FBRUQsU0FBUy95QixJQUFULENBQWNWLEVBQWQsRUFBa0I7QUFDaEJBLEVBQUFBLEVBQUU7QUFDSDs7QUFFRCxTQUFTbUssSUFBVCxDQUFjL1UsSUFBZCxFQUFvQjZsQyxFQUFwQixFQUF3QjtBQUN0QixTQUFPN2xDLElBQUksQ0FBQytVLElBQUwsQ0FBVTh3QixFQUFWLENBQVA7QUFDRDs7QUFFRCxTQUFTQyxXQUFULENBQXFCQyxPQUFyQixFQUE4QjtBQUM1QixNQUFJLENBQUNBLE9BQU8sQ0FBQ2w4QixNQUFiLEVBQXFCLE9BQU80UyxJQUFQO0FBQ3JCLE1BQUksT0FBT3NwQixPQUFPLENBQUNBLE9BQU8sQ0FBQ2w4QixNQUFSLEdBQWlCLENBQWxCLENBQWQsS0FBdUMsVUFBM0MsRUFBdUQsT0FBTzRTLElBQVA7QUFDdkQsU0FBT3NwQixPQUFPLENBQUNqcUIsR0FBUixFQUFQO0FBQ0Q7O0FBRUQsU0FBU2txQixRQUFULEdBQW9CO0FBQ2xCLE9BQUssSUFBSWhCLElBQUksR0FBR3Y4QixTQUFTLENBQUNvQixNQUFyQixFQUE2Qms4QixPQUFPLEdBQUcsSUFBSXI4QixLQUFKLENBQVVzN0IsSUFBVixDQUF2QyxFQUF3REMsSUFBSSxHQUFHLENBQXBFLEVBQXVFQSxJQUFJLEdBQUdELElBQTlFLEVBQW9GQyxJQUFJLEVBQXhGLEVBQTRGO0FBQzFGYyxJQUFBQSxPQUFPLENBQUNkLElBQUQsQ0FBUCxHQUFnQng4QixTQUFTLENBQUN3OEIsSUFBRCxDQUF6QjtBQUNEOztBQUVELE1BQUk5eEIsUUFBUSxHQUFHMnlCLFdBQVcsQ0FBQ0MsT0FBRCxDQUExQjtBQUNBLE1BQUlyOEIsS0FBSyxDQUFDc0QsT0FBTixDQUFjKzRCLE9BQU8sQ0FBQyxDQUFELENBQXJCLENBQUosRUFBK0JBLE9BQU8sR0FBR0EsT0FBTyxDQUFDLENBQUQsQ0FBakI7O0FBRS9CLE1BQUlBLE9BQU8sQ0FBQ2w4QixNQUFSLEdBQWlCLENBQXJCLEVBQXdCO0FBQ3RCLFVBQU0sSUFBSTY3QixnQkFBSixDQUFxQixTQUFyQixDQUFOO0FBQ0Q7O0FBRUQsTUFBSXg3QixLQUFKO0FBQ0EsTUFBSSs3QixRQUFRLEdBQUdGLE9BQU8sQ0FBQ3ByQixHQUFSLENBQVksVUFBVXljLE1BQVYsRUFBa0J6bkIsQ0FBbEIsRUFBcUI7QUFDOUMsUUFBSWlvQixPQUFPLEdBQUdqb0IsQ0FBQyxHQUFHbzJCLE9BQU8sQ0FBQ2w4QixNQUFSLEdBQWlCLENBQW5DO0FBQ0EsUUFBSWsxQixPQUFPLEdBQUdwdkIsQ0FBQyxHQUFHLENBQWxCO0FBQ0EsV0FBT2cyQixTQUFTLENBQUN2TyxNQUFELEVBQVNRLE9BQVQsRUFBa0JtSCxPQUFsQixFQUEyQixVQUFVemtCLEdBQVYsRUFBZTtBQUN4RCxVQUFJLENBQUNwUSxLQUFMLEVBQVlBLEtBQUssR0FBR29RLEdBQVI7QUFDWixVQUFJQSxHQUFKLEVBQVMyckIsUUFBUSxDQUFDN2dDLE9BQVQsQ0FBaUJrRyxJQUFqQjtBQUNULFVBQUlzc0IsT0FBSixFQUFhO0FBQ2JxTyxNQUFBQSxRQUFRLENBQUM3Z0MsT0FBVCxDQUFpQmtHLElBQWpCO0FBQ0E2SCxNQUFBQSxRQUFRLENBQUNqSixLQUFELENBQVI7QUFDRCxLQU5lLENBQWhCO0FBT0QsR0FWYyxDQUFmO0FBV0EsU0FBTzY3QixPQUFPLENBQUNHLE1BQVIsQ0FBZW54QixJQUFmLENBQVA7QUFDRDs7QUFFRGhVLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUI2bUMsUUFBakI7Ozs7Ozs7Ozs7QUNoR2E7O0FBRWIsSUFBSUcscUJBQXFCLEdBQUc3bUMsNEhBQTVCOztBQUVBLFNBQVM4bUMsaUJBQVQsQ0FBMkIzN0IsT0FBM0IsRUFBb0M0c0IsUUFBcEMsRUFBOENnUCxTQUE5QyxFQUF5RDtBQUN2RCxTQUFPNTdCLE9BQU8sQ0FBQ3dxQixhQUFSLElBQXlCLElBQXpCLEdBQWdDeHFCLE9BQU8sQ0FBQ3dxQixhQUF4QyxHQUF3RG9DLFFBQVEsR0FBRzVzQixPQUFPLENBQUM0N0IsU0FBRCxDQUFWLEdBQXdCLElBQS9GO0FBQ0Q7O0FBRUQsU0FBUzNQLGdCQUFULENBQTBCMUcsS0FBMUIsRUFBaUN2bEIsT0FBakMsRUFBMEM0N0IsU0FBMUMsRUFBcURoUCxRQUFyRCxFQUErRDtBQUM3RCxNQUFJaVAsR0FBRyxHQUFHRixpQkFBaUIsQ0FBQzM3QixPQUFELEVBQVU0c0IsUUFBVixFQUFvQmdQLFNBQXBCLENBQTNCOztBQUVBLE1BQUlDLEdBQUcsSUFBSSxJQUFYLEVBQWlCO0FBQ2YsUUFBSSxFQUFFcmhCLFFBQVEsQ0FBQ3FoQixHQUFELENBQVIsSUFBaUJ4c0IsSUFBSSxDQUFDb1MsS0FBTCxDQUFXb2EsR0FBWCxNQUFvQkEsR0FBdkMsS0FBK0NBLEdBQUcsR0FBRyxDQUF6RCxFQUE0RDtBQUMxRCxVQUFJdDZCLElBQUksR0FBR3FyQixRQUFRLEdBQUdnUCxTQUFILEdBQWUsZUFBbEM7QUFDQSxZQUFNLElBQUlGLHFCQUFKLENBQTBCbjZCLElBQTFCLEVBQWdDczZCLEdBQWhDLENBQU47QUFDRDs7QUFFRCxXQUFPeHNCLElBQUksQ0FBQ29TLEtBQUwsQ0FBV29hLEdBQVgsQ0FBUDtBQUNELEdBVjRELENBVTNEOzs7QUFHRixTQUFPdFcsS0FBSyxDQUFDc0gsVUFBTixHQUFtQixFQUFuQixHQUF3QixLQUFLLElBQXBDO0FBQ0Q7O0FBRUR2MkIsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQjtBQUNmdTNCLEVBQUFBLGdCQUFnQixFQUFFQTtBQURILENBQWpCOzs7Ozs7Ozs7O0FDeEJBMzFCLGtHQUFBOzs7Ozs7Ozs7O0FDQUE1QixPQUFPLEdBQUc0QiwrSEFBVjtBQUNBNUIsY0FBQSxHQUFpQkEsT0FBakI7QUFDQUEsZ0JBQUEsR0FBbUJBLE9BQW5CO0FBQ0FBLGlJQUFBO0FBQ0FBLDJIQUFBO0FBQ0FBLG9JQUFBO0FBQ0FBLDBJQUFBO0FBQ0FBLDZKQUFBO0FBQ0FBLG1KQUFBOzs7Ozs7Ozs7O0FDUkE7O0FBQ0E7QUFDQSxJQUFJK1AsTUFBTSxHQUFHNVAsbUJBQU8sQ0FBQyw4Q0FBRCxDQUFwQjs7QUFDQSxJQUFJUyxNQUFNLEdBQUdtUCxNQUFNLENBQUNuUCxNQUFwQixFQUVBOztBQUNBLFNBQVN3bUMsU0FBVCxDQUFvQjdaLEdBQXBCLEVBQXlCQyxHQUF6QixFQUE4QjtBQUM1QixPQUFLLElBQUlwbkIsR0FBVCxJQUFnQm1uQixHQUFoQixFQUFxQjtBQUNuQkMsSUFBQUEsR0FBRyxDQUFDcG5CLEdBQUQsQ0FBSCxHQUFXbW5CLEdBQUcsQ0FBQ25uQixHQUFELENBQWQ7QUFDRDtBQUNGOztBQUNELElBQUl4RixNQUFNLENBQUNDLElBQVAsSUFBZUQsTUFBTSxDQUFDa2hCLEtBQXRCLElBQStCbGhCLE1BQU0sQ0FBQ3VnQixXQUF0QyxJQUFxRHZnQixNQUFNLENBQUNvaEIsZUFBaEUsRUFBaUY7QUFDL0VwZ0IsRUFBQUEsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQitQLE1BQWpCO0FBQ0QsQ0FGRCxNQUVPO0FBQ0w7QUFDQXEzQixFQUFBQSxTQUFTLENBQUNyM0IsTUFBRCxFQUFTL1AsT0FBVCxDQUFUO0FBQ0FBLEVBQUFBLGNBQUEsR0FBaUJxbkMsVUFBakI7QUFDRDs7QUFFRCxTQUFTQSxVQUFULENBQXFCcG1CLEdBQXJCLEVBQTBCQyxnQkFBMUIsRUFBNEN4VyxNQUE1QyxFQUFvRDtBQUNsRCxTQUFPOUosTUFBTSxDQUFDcWdCLEdBQUQsRUFBTUMsZ0JBQU4sRUFBd0J4VyxNQUF4QixDQUFiO0FBQ0Q7O0FBRUQyOEIsVUFBVSxDQUFDMy9CLFNBQVgsR0FBdUI1SCxNQUFNLENBQUMrSCxNQUFQLENBQWNqSCxNQUFNLENBQUM4RyxTQUFyQixDQUF2QixFQUVBOztBQUNBMC9CLFNBQVMsQ0FBQ3htQyxNQUFELEVBQVN5bUMsVUFBVCxDQUFUOztBQUVBQSxVQUFVLENBQUN4bUMsSUFBWCxHQUFrQixVQUFVb2dCLEdBQVYsRUFBZUMsZ0JBQWYsRUFBaUN4VyxNQUFqQyxFQUF5QztBQUN6RCxNQUFJLE9BQU91VyxHQUFQLEtBQWUsUUFBbkIsRUFBNkI7QUFDM0IsVUFBTSxJQUFJeFksU0FBSixDQUFjLCtCQUFkLENBQU47QUFDRDs7QUFDRCxTQUFPN0gsTUFBTSxDQUFDcWdCLEdBQUQsRUFBTUMsZ0JBQU4sRUFBd0J4VyxNQUF4QixDQUFiO0FBQ0QsQ0FMRDs7QUFPQTI4QixVQUFVLENBQUN2bEIsS0FBWCxHQUFtQixVQUFVckgsSUFBVixFQUFnQm1DLElBQWhCLEVBQXNCdkQsUUFBdEIsRUFBZ0M7QUFDakQsTUFBSSxPQUFPb0IsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixVQUFNLElBQUloUyxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUNELE1BQUkrVSxHQUFHLEdBQUc1YyxNQUFNLENBQUM2WixJQUFELENBQWhCOztBQUNBLE1BQUltQyxJQUFJLEtBQUs3VyxTQUFiLEVBQXdCO0FBQ3RCLFFBQUksT0FBT3NULFFBQVAsS0FBb0IsUUFBeEIsRUFBa0M7QUFDaENtRSxNQUFBQSxHQUFHLENBQUNaLElBQUosQ0FBU0EsSUFBVCxFQUFldkQsUUFBZjtBQUNELEtBRkQsTUFFTztBQUNMbUUsTUFBQUEsR0FBRyxDQUFDWixJQUFKLENBQVNBLElBQVQ7QUFDRDtBQUNGLEdBTkQsTUFNTztBQUNMWSxJQUFBQSxHQUFHLENBQUNaLElBQUosQ0FBUyxDQUFUO0FBQ0Q7O0FBQ0QsU0FBT1ksR0FBUDtBQUNELENBZkQ7O0FBaUJBNnBCLFVBQVUsQ0FBQ2xtQixXQUFYLEdBQXlCLFVBQVUxRyxJQUFWLEVBQWdCO0FBQ3ZDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixVQUFNLElBQUloUyxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUNELFNBQU83SCxNQUFNLENBQUM2WixJQUFELENBQWI7QUFDRCxDQUxEOztBQU9BNHNCLFVBQVUsQ0FBQ3JsQixlQUFYLEdBQTZCLFVBQVV2SCxJQUFWLEVBQWdCO0FBQzNDLE1BQUksT0FBT0EsSUFBUCxLQUFnQixRQUFwQixFQUE4QjtBQUM1QixVQUFNLElBQUloUyxTQUFKLENBQWMsMkJBQWQsQ0FBTjtBQUNEOztBQUNELFNBQU9zSCxNQUFNLENBQUNvUSxVQUFQLENBQWtCMUYsSUFBbEIsQ0FBUDtBQUNELENBTEQ7Ozs7Ozs7Ozs7QUMzREEsSUFBSTZzQixhQUFhLEdBQUdubkMsbUJBQU8sQ0FBQyxnRUFBRCxDQUEzQjs7QUFDQSxJQUFJcUUsUUFBUSxHQUFHckUsbUJBQU8sQ0FBQyxrRUFBRCxDQUF0Qjs7QUFDQSxJQUFJd0gsTUFBTSxHQUFHeEgsbUJBQU8sQ0FBQyxnREFBRCxDQUFwQjs7QUFDQSxJQUFJb25DLFdBQVcsR0FBR3BuQyxtQkFBTyxDQUFDLDRFQUFELENBQXpCOztBQUNBLElBQUl5RCxHQUFHLEdBQUd6RCxtQkFBTyxDQUFDLHNDQUFELENBQWpCOztBQUVBLElBQUlxbkMsSUFBSSxHQUFHeG5DLE9BQVg7O0FBRUF3bkMsSUFBSSxDQUFDdmtDLE9BQUwsR0FBZSxVQUFVK1IsSUFBVixFQUFnQjhGLEVBQWhCLEVBQW9CO0FBQ2xDLE1BQUksT0FBTzlGLElBQVAsS0FBZ0IsUUFBcEIsRUFDQ0EsSUFBSSxHQUFHcFIsR0FBRyxDQUFDeUwsS0FBSixDQUFVMkYsSUFBVixDQUFQLENBREQsS0FHQ0EsSUFBSSxHQUFHck4sTUFBTSxDQUFDcU4sSUFBRCxDQUFiLENBSmlDLENBTWxDO0FBQ0E7QUFDQTs7QUFDQSxNQUFJeXlCLGVBQWUsR0FBRzNRLHFCQUFNLENBQUN2akIsUUFBUCxDQUFnQlIsUUFBaEIsQ0FBeUJFLE1BQXpCLENBQWdDLFdBQWhDLE1BQWlELENBQUMsQ0FBbEQsR0FBc0QsT0FBdEQsR0FBZ0UsRUFBdEY7QUFFQSxNQUFJRixRQUFRLEdBQUdpQyxJQUFJLENBQUNqQyxRQUFMLElBQWlCMDBCLGVBQWhDO0FBQ0EsTUFBSXowQixJQUFJLEdBQUdnQyxJQUFJLENBQUM5QixRQUFMLElBQWlCOEIsSUFBSSxDQUFDaEMsSUFBakM7QUFDQSxNQUFJRyxJQUFJLEdBQUc2QixJQUFJLENBQUM3QixJQUFoQjtBQUNBLE1BQUk3QixJQUFJLEdBQUcwRCxJQUFJLENBQUMxRCxJQUFMLElBQWEsR0FBeEIsQ0Fka0MsQ0FnQmxDOztBQUNBLE1BQUkwQixJQUFJLElBQUlBLElBQUksQ0FBQ2pPLE9BQUwsQ0FBYSxHQUFiLE1BQXNCLENBQUMsQ0FBbkMsRUFDQ2lPLElBQUksR0FBRyxNQUFNQSxJQUFOLEdBQWEsR0FBcEIsQ0FsQmlDLENBb0JsQzs7QUFDQWdDLEVBQUFBLElBQUksQ0FBQ3BSLEdBQUwsR0FBVyxDQUFDb1AsSUFBSSxHQUFJRCxRQUFRLEdBQUcsSUFBWCxHQUFrQkMsSUFBdEIsR0FBOEIsRUFBbkMsS0FBMENHLElBQUksR0FBRyxNQUFNQSxJQUFULEdBQWdCLEVBQTlELElBQW9FN0IsSUFBL0U7QUFDQTBELEVBQUFBLElBQUksQ0FBQ2xSLE1BQUwsR0FBYyxDQUFDa1IsSUFBSSxDQUFDbFIsTUFBTCxJQUFlLEtBQWhCLEVBQXVCQyxXQUF2QixFQUFkO0FBQ0FpUixFQUFBQSxJQUFJLENBQUNsUyxPQUFMLEdBQWVrUyxJQUFJLENBQUNsUyxPQUFMLElBQWdCLEVBQS9CLENBdkJrQyxDQXlCbEM7O0FBRUEsTUFBSXdqQyxHQUFHLEdBQUcsSUFBSWdCLGFBQUosQ0FBa0J0eUIsSUFBbEIsQ0FBVjtBQUNBLE1BQUk4RixFQUFKLEVBQ0N3ckIsR0FBRyxDQUFDaFcsRUFBSixDQUFPLFVBQVAsRUFBbUJ4VixFQUFuQjtBQUNELFNBQU93ckIsR0FBUDtBQUNBLENBL0JEOztBQWlDQWtCLElBQUksQ0FBQzNtQixHQUFMLEdBQVcsU0FBU0EsR0FBVCxDQUFjN0wsSUFBZCxFQUFvQjhGLEVBQXBCLEVBQXdCO0FBQ2xDLE1BQUl3ckIsR0FBRyxHQUFHa0IsSUFBSSxDQUFDdmtDLE9BQUwsQ0FBYStSLElBQWIsRUFBbUI4RixFQUFuQixDQUFWO0FBQ0F3ckIsRUFBQUEsR0FBRyxDQUFDenVCLEdBQUo7QUFDQSxTQUFPeXVCLEdBQVA7QUFDQSxDQUpEOztBQU1Ba0IsSUFBSSxDQUFDRixhQUFMLEdBQXFCQSxhQUFyQjtBQUNBRSxJQUFJLENBQUNFLGVBQUwsR0FBdUJsakMsUUFBUSxDQUFDa2pDLGVBQWhDOztBQUVBRixJQUFJLENBQUNHLEtBQUwsR0FBYSxZQUFZLENBQUUsQ0FBM0I7O0FBQ0FILElBQUksQ0FBQ0csS0FBTCxDQUFXQyxpQkFBWCxHQUErQixDQUEvQjtBQUVBSixJQUFJLENBQUNLLFdBQUwsR0FBbUIsSUFBSUwsSUFBSSxDQUFDRyxLQUFULEVBQW5CO0FBRUFILElBQUksQ0FBQ00sWUFBTCxHQUFvQlAsV0FBcEI7QUFFQUMsSUFBSSxDQUFDTyxPQUFMLEdBQWUsQ0FDZCxVQURjLEVBRWQsU0FGYyxFQUdkLE1BSGMsRUFJZCxRQUpjLEVBS2QsS0FMYyxFQU1kLE1BTmMsRUFPZCxNQVBjLEVBUWQsVUFSYyxFQVNkLE9BVGMsRUFVZCxZQVZjLEVBV2QsT0FYYyxFQVlkLE1BWmMsRUFhZCxRQWJjLEVBY2QsU0FkYyxFQWVkLE9BZmMsRUFnQmQsTUFoQmMsRUFpQmQsVUFqQmMsRUFrQmQsV0FsQmMsRUFtQmQsT0FuQmMsRUFvQmQsS0FwQmMsRUFxQmQsUUFyQmMsRUFzQmQsUUF0QmMsRUF1QmQsV0F2QmMsRUF3QmQsT0F4QmMsRUF5QmQsUUF6QmMsRUEwQmQsYUExQmMsQ0FBZjs7Ozs7Ozs7OztBQ3pEQS9uQyxhQUFBLEdBQWdCMlYsVUFBVSxDQUFDbWhCLHFCQUFNLENBQUNrUixLQUFSLENBQVYsSUFBNEJyeUIsVUFBVSxDQUFDbWhCLHFCQUFNLENBQUNtUixjQUFSLENBQXREO0FBRUFqb0Msc0JBQUEsR0FBeUIyVixVQUFVLENBQUNtaEIscUJBQU0sQ0FBQ3FSLGNBQVIsQ0FBbkM7QUFFQW5vQyx1QkFBQSxHQUEwQjJWLFVBQVUsQ0FBQ21oQixxQkFBTSxDQUFDdVIsZUFBUixDQUFwQyxFQUVBO0FBQ0E7QUFDQTs7QUFDQSxJQUFJQyxHQUFKOztBQUNBLFNBQVNDLE1BQVQsR0FBbUI7QUFDbEI7QUFDQSxNQUFJRCxHQUFHLEtBQUt2aUMsU0FBWixFQUF1QixPQUFPdWlDLEdBQVA7O0FBRXZCLE1BQUl4UixxQkFBTSxDQUFDNXpCLGNBQVgsRUFBMkI7QUFDMUJvbEMsSUFBQUEsR0FBRyxHQUFHLElBQUl4UixxQkFBTSxDQUFDNXpCLGNBQVgsRUFBTixDQUQwQixDQUUxQjtBQUNBO0FBQ0E7O0FBQ0EsUUFBSTtBQUNIb2xDLE1BQUFBLEdBQUcsQ0FBQ3prQyxJQUFKLENBQVMsS0FBVCxFQUFnQml6QixxQkFBTSxDQUFDMFIsY0FBUCxHQUF3QixHQUF4QixHQUE4QixxQkFBOUM7QUFDQSxLQUZELENBRUUsT0FBTWo1QixDQUFOLEVBQVM7QUFDVis0QixNQUFBQSxHQUFHLEdBQUcsSUFBTjtBQUNBO0FBQ0QsR0FWRCxNQVVPO0FBQ047QUFDQUEsSUFBQUEsR0FBRyxHQUFHLElBQU47QUFDQTs7QUFDRCxTQUFPQSxHQUFQO0FBQ0E7O0FBRUQsU0FBU0csZ0JBQVQsQ0FBMkJ0MEIsSUFBM0IsRUFBaUM7QUFDaEMsTUFBSW0wQixHQUFHLEdBQUdDLE1BQU0sRUFBaEI7QUFDQSxNQUFJLENBQUNELEdBQUwsRUFBVSxPQUFPLEtBQVA7O0FBQ1YsTUFBSTtBQUNIQSxJQUFBQSxHQUFHLENBQUN2bEMsWUFBSixHQUFtQm9SLElBQW5CO0FBQ0EsV0FBT20wQixHQUFHLENBQUN2bEMsWUFBSixLQUFxQm9SLElBQTVCO0FBQ0EsR0FIRCxDQUdFLE9BQU81RSxDQUFQLEVBQVUsQ0FBRTs7QUFDZCxTQUFPLEtBQVA7QUFDQSxFQUVEO0FBQ0E7OztBQUNBdlAsbUJBQUEsR0FBc0JBLE9BQU8sQ0FBQ2dvQyxLQUFSLElBQWlCUyxnQkFBZ0IsQ0FBQyxhQUFELENBQXZELEVBRUE7QUFDQTs7QUFDQXpvQyxnQkFBQSxHQUFtQixDQUFDQSxPQUFPLENBQUNnb0MsS0FBVCxJQUFrQlMsZ0JBQWdCLENBQUMsV0FBRCxDQUFyRDtBQUNBem9DLDZCQUFBLEdBQWdDLENBQUNBLE9BQU8sQ0FBQ2dvQyxLQUFULElBQWtCUyxnQkFBZ0IsQ0FBQyx5QkFBRCxDQUFsRSxFQUVBO0FBQ0E7O0FBQ0F6b0Msd0JBQUEsR0FBMkJBLE9BQU8sQ0FBQ2dvQyxLQUFSLEtBQWtCTyxNQUFNLEtBQUs1eUIsVUFBVSxDQUFDNHlCLE1BQU0sR0FBR00sZ0JBQVYsQ0FBZixHQUE2QyxLQUFyRSxDQUEzQjs7QUFFQSxTQUFTbHpCLFVBQVQsQ0FBcUIxVixLQUFyQixFQUE0QjtBQUMzQixTQUFPLE9BQU9BLEtBQVAsS0FBaUIsVUFBeEI7QUFDQTs7QUFFRHFvQyxHQUFHLEdBQUcsSUFBTixFQUFXOzs7Ozs7Ozs7O0FDMURYLElBQUlRLFVBQVUsR0FBRzNvQyxtQkFBTyxDQUFDLGtFQUFELENBQXhCOztBQUNBLElBQUk2eUIsUUFBUSxHQUFHN3lCLG1CQUFPLENBQUMsNkRBQUQsQ0FBdEI7O0FBQ0EsSUFBSXFFLFFBQVEsR0FBR3JFLG1CQUFPLENBQUMsOERBQUQsQ0FBdEI7O0FBQ0EsSUFBSTgzQixNQUFNLEdBQUc5M0IsbUJBQU8sQ0FBQywyRUFBRCxDQUFwQjs7QUFFQSxJQUFJdW5DLGVBQWUsR0FBR2xqQyxRQUFRLENBQUNrakMsZUFBL0I7QUFDQSxJQUFJcUIsT0FBTyxHQUFHdmtDLFFBQVEsQ0FBQ3drQyxXQUF2Qjs7QUFFQSxTQUFTQyxVQUFULENBQXFCQyxZQUFyQixFQUFtQ0MsUUFBbkMsRUFBNkM7QUFDNUMsTUFBSUwsVUFBVSxDQUFDZCxLQUFYLElBQW9CbUIsUUFBeEIsRUFBa0M7QUFDakMsV0FBTyxPQUFQO0FBQ0EsR0FGRCxNQUVPLElBQUlMLFVBQVUsQ0FBQ0YscUJBQWYsRUFBc0M7QUFDNUMsV0FBTyx5QkFBUDtBQUNBLEdBRk0sTUFFQSxJQUFJRSxVQUFVLENBQUNILFFBQWYsRUFBeUI7QUFDL0IsV0FBTyxXQUFQO0FBQ0EsR0FGTSxNQUVBLElBQUlHLFVBQVUsQ0FBQ0osV0FBWCxJQUEwQlEsWUFBOUIsRUFBNEM7QUFDbEQsV0FBTyxhQUFQO0FBQ0EsR0FGTSxNQUVBO0FBQ04sV0FBTyxNQUFQO0FBQ0E7QUFDRDs7QUFFRCxJQUFJNUIsYUFBYSxHQUFHMWxDLE1BQU0sQ0FBQzVCLE9BQVAsR0FBaUIsVUFBVWdWLElBQVYsRUFBZ0I7QUFDcEQsTUFBSW9kLElBQUksR0FBRyxJQUFYO0FBQ0E2RixFQUFBQSxNQUFNLENBQUN4QyxRQUFQLENBQWdCdHBCLElBQWhCLENBQXFCaW1CLElBQXJCO0FBRUFBLEVBQUFBLElBQUksQ0FBQ2dYLEtBQUwsR0FBYXAwQixJQUFiO0FBQ0FvZCxFQUFBQSxJQUFJLENBQUNpWCxLQUFMLEdBQWEsRUFBYjtBQUNBalgsRUFBQUEsSUFBSSxDQUFDa1gsUUFBTCxHQUFnQixFQUFoQjtBQUNBLE1BQUl0MEIsSUFBSSxDQUFDN1IsSUFBVCxFQUNDaXZCLElBQUksQ0FBQzRULFNBQUwsQ0FBZSxlQUFmLEVBQWdDLFdBQVdwbEMsTUFBTSxDQUFDQyxJQUFQLENBQVltVSxJQUFJLENBQUM3UixJQUFqQixFQUF1QnJDLFFBQXZCLENBQWdDLFFBQWhDLENBQTNDO0FBQ0RoQixFQUFBQSxNQUFNLENBQUNzTyxJQUFQLENBQVk0RyxJQUFJLENBQUNsUyxPQUFqQixFQUEwQm1ELE9BQTFCLENBQWtDLFVBQVU0RyxJQUFWLEVBQWdCO0FBQ2pEdWxCLElBQUFBLElBQUksQ0FBQzRULFNBQUwsQ0FBZW41QixJQUFmLEVBQXFCbUksSUFBSSxDQUFDbFMsT0FBTCxDQUFhK0osSUFBYixDQUFyQjtBQUNBLEdBRkQ7QUFJQSxNQUFJcThCLFlBQUo7QUFDQSxNQUFJQyxRQUFRLEdBQUcsSUFBZjs7QUFDQSxNQUFJbjBCLElBQUksQ0FBQ3UwQixJQUFMLEtBQWMsZUFBZCxJQUFrQyxvQkFBb0J2MEIsSUFBcEIsSUFBNEIsQ0FBQzh6QixVQUFVLENBQUNWLGVBQTlFLEVBQWdHO0FBQy9GO0FBQ0FlLElBQUFBLFFBQVEsR0FBRyxLQUFYO0FBQ0FELElBQUFBLFlBQVksR0FBRyxJQUFmO0FBQ0EsR0FKRCxNQUlPLElBQUlsMEIsSUFBSSxDQUFDdTBCLElBQUwsS0FBYyxrQkFBbEIsRUFBc0M7QUFDNUM7QUFDQTtBQUNBTCxJQUFBQSxZQUFZLEdBQUcsS0FBZjtBQUNBLEdBSk0sTUFJQSxJQUFJbDBCLElBQUksQ0FBQ3UwQixJQUFMLEtBQWMsMEJBQWxCLEVBQThDO0FBQ3BEO0FBQ0FMLElBQUFBLFlBQVksR0FBRyxDQUFDSixVQUFVLENBQUNELGdCQUEzQjtBQUNBLEdBSE0sTUFHQSxJQUFJLENBQUM3ekIsSUFBSSxDQUFDdTBCLElBQU4sSUFBY3YwQixJQUFJLENBQUN1MEIsSUFBTCxLQUFjLFNBQTVCLElBQXlDdjBCLElBQUksQ0FBQ3UwQixJQUFMLEtBQWMsYUFBM0QsRUFBMEU7QUFDaEY7QUFDQUwsSUFBQUEsWUFBWSxHQUFHLElBQWY7QUFDQSxHQUhNLE1BR0E7QUFDTixVQUFNLElBQUl4bkMsS0FBSixDQUFVLDZCQUFWLENBQU47QUFDQTs7QUFDRDB3QixFQUFBQSxJQUFJLENBQUNvWCxLQUFMLEdBQWFQLFVBQVUsQ0FBQ0MsWUFBRCxFQUFlQyxRQUFmLENBQXZCO0FBQ0EvVyxFQUFBQSxJQUFJLENBQUNxWCxXQUFMLEdBQW1CLElBQW5CO0FBQ0FyWCxFQUFBQSxJQUFJLENBQUNzWCxjQUFMLEdBQXNCLElBQXRCO0FBQ0F0WCxFQUFBQSxJQUFJLENBQUN1WCxZQUFMLEdBQW9CLElBQXBCO0FBRUF2WCxFQUFBQSxJQUFJLENBQUM5QixFQUFMLENBQVEsUUFBUixFQUFrQixZQUFZO0FBQzdCOEIsSUFBQUEsSUFBSSxDQUFDd1gsU0FBTDtBQUNBLEdBRkQ7QUFHQSxDQXhDRDs7QUEwQ0E1VyxRQUFRLENBQUNzVSxhQUFELEVBQWdCclAsTUFBTSxDQUFDeEMsUUFBdkIsQ0FBUjs7QUFFQTZSLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCcytCLFNBQXhCLEdBQW9DLFVBQVVuNUIsSUFBVixFQUFnQjVNLEtBQWhCLEVBQXVCO0FBQzFELE1BQUlteUIsSUFBSSxHQUFHLElBQVg7QUFDQSxNQUFJeVgsU0FBUyxHQUFHaDlCLElBQUksQ0FBQ3hHLFdBQUwsRUFBaEIsQ0FGMEQsQ0FHMUQ7QUFDQTtBQUNBOztBQUNBLE1BQUl5akMsYUFBYSxDQUFDL2tDLE9BQWQsQ0FBc0I4a0MsU0FBdEIsTUFBcUMsQ0FBQyxDQUExQyxFQUNDO0FBRUR6WCxFQUFBQSxJQUFJLENBQUNrWCxRQUFMLENBQWNPLFNBQWQsSUFBMkI7QUFDMUJoOUIsSUFBQUEsSUFBSSxFQUFFQSxJQURvQjtBQUUxQjVNLElBQUFBLEtBQUssRUFBRUE7QUFGbUIsR0FBM0I7QUFJQSxDQWJEOztBQWVBcW5DLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCcWlDLFNBQXhCLEdBQW9DLFVBQVVsOUIsSUFBVixFQUFnQjtBQUNuRCxNQUFJbTlCLE1BQU0sR0FBRyxLQUFLVixRQUFMLENBQWN6OEIsSUFBSSxDQUFDeEcsV0FBTCxFQUFkLENBQWI7O0FBQ0EsTUFBSTJqQyxNQUFKLEVBQ0MsT0FBT0EsTUFBTSxDQUFDL3BDLEtBQWQ7QUFDRCxTQUFPLElBQVA7QUFDQSxDQUxEOztBQU9BcW5DLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCdWlDLFlBQXhCLEdBQXVDLFVBQVVwOUIsSUFBVixFQUFnQjtBQUN0RCxNQUFJdWxCLElBQUksR0FBRyxJQUFYO0FBQ0EsU0FBT0EsSUFBSSxDQUFDa1gsUUFBTCxDQUFjejhCLElBQUksQ0FBQ3hHLFdBQUwsRUFBZCxDQUFQO0FBQ0EsQ0FIRDs7QUFLQWloQyxhQUFhLENBQUM1L0IsU0FBZCxDQUF3QmtpQyxTQUF4QixHQUFvQyxZQUFZO0FBQy9DLE1BQUl4WCxJQUFJLEdBQUcsSUFBWDtBQUVBLE1BQUlBLElBQUksQ0FBQzhYLFVBQVQsRUFDQztBQUNELE1BQUlsMUIsSUFBSSxHQUFHb2QsSUFBSSxDQUFDZ1gsS0FBaEI7O0FBRUEsTUFBSSxhQUFhcDBCLElBQWIsSUFBcUJBLElBQUksQ0FBQzlRLE9BQUwsS0FBaUIsQ0FBMUMsRUFBNkM7QUFDNUNrdUIsSUFBQUEsSUFBSSxDQUFDcHRCLFVBQUwsQ0FBZ0JnUSxJQUFJLENBQUM5USxPQUFyQjtBQUNBOztBQUVELE1BQUlpbUMsVUFBVSxHQUFHL1gsSUFBSSxDQUFDa1gsUUFBdEI7QUFDQSxNQUFJYyxJQUFJLEdBQUcsSUFBWDs7QUFDQSxNQUFJcDFCLElBQUksQ0FBQ2xSLE1BQUwsS0FBZ0IsS0FBaEIsSUFBeUJrUixJQUFJLENBQUNsUixNQUFMLEtBQWdCLE1BQTdDLEVBQXFEO0FBQzlDc21DLElBQUFBLElBQUksR0FBRyxJQUFJQyxJQUFKLENBQVNqWSxJQUFJLENBQUNpWCxLQUFkLEVBQXFCO0FBQ3hCbDFCLE1BQUFBLElBQUksRUFBRSxDQUFDZzJCLFVBQVUsQ0FBQyxjQUFELENBQVYsSUFBOEIsRUFBL0IsRUFBbUNscUMsS0FBbkMsSUFBNEM7QUFEMUIsS0FBckIsQ0FBUDtBQUdILEdBakIyQyxDQW1CL0M7OztBQUNBLE1BQUlxcUMsV0FBVyxHQUFHLEVBQWxCO0FBQ0F4cUMsRUFBQUEsTUFBTSxDQUFDc08sSUFBUCxDQUFZKzdCLFVBQVosRUFBd0Jsa0MsT0FBeEIsQ0FBZ0MsVUFBVXNrQyxPQUFWLEVBQW1CO0FBQ2xELFFBQUkxOUIsSUFBSSxHQUFHczlCLFVBQVUsQ0FBQ0ksT0FBRCxDQUFWLENBQW9CMTlCLElBQS9CO0FBQ0EsUUFBSTVNLEtBQUssR0FBR2txQyxVQUFVLENBQUNJLE9BQUQsQ0FBVixDQUFvQnRxQyxLQUFoQzs7QUFDQSxRQUFJc0ssS0FBSyxDQUFDc0QsT0FBTixDQUFjNU4sS0FBZCxDQUFKLEVBQTBCO0FBQ3pCQSxNQUFBQSxLQUFLLENBQUNnRyxPQUFOLENBQWMsVUFBVTRLLENBQVYsRUFBYTtBQUMxQnk1QixRQUFBQSxXQUFXLENBQUNqZ0MsSUFBWixDQUFpQixDQUFDd0MsSUFBRCxFQUFPZ0UsQ0FBUCxDQUFqQjtBQUNBLE9BRkQ7QUFHQSxLQUpELE1BSU87QUFDTnk1QixNQUFBQSxXQUFXLENBQUNqZ0MsSUFBWixDQUFpQixDQUFDd0MsSUFBRCxFQUFPNU0sS0FBUCxDQUFqQjtBQUNBO0FBQ0QsR0FWRDs7QUFZQSxNQUFJbXlCLElBQUksQ0FBQ29YLEtBQUwsS0FBZSxPQUFuQixFQUE0QjtBQUMzQixRQUFJZ0IsTUFBTSxHQUFHLElBQWI7O0FBQ0EsUUFBSTFCLFVBQVUsQ0FBQ1YsZUFBZixFQUFnQztBQUMvQixVQUFJcUMsVUFBVSxHQUFHLElBQUlwQyxlQUFKLEVBQWpCO0FBQ0FtQyxNQUFBQSxNQUFNLEdBQUdDLFVBQVUsQ0FBQ0QsTUFBcEI7QUFDQXBZLE1BQUFBLElBQUksQ0FBQ3NZLHFCQUFMLEdBQTZCRCxVQUE3Qjs7QUFFQSxVQUFJLG9CQUFvQnoxQixJQUFwQixJQUE0QkEsSUFBSSxDQUFDMjFCLGNBQUwsS0FBd0IsQ0FBeEQsRUFBMkQ7QUFDMUR2WSxRQUFBQSxJQUFJLENBQUNxWCxXQUFMLEdBQW1CM1MscUJBQU0sQ0FBQzl4QixVQUFQLENBQWtCLFlBQVk7QUFDaERvdEIsVUFBQUEsSUFBSSxDQUFDN0MsSUFBTCxDQUFVLGdCQUFWO0FBQ0EsY0FBSTZDLElBQUksQ0FBQ3NZLHFCQUFULEVBQ0N0WSxJQUFJLENBQUNzWSxxQkFBTCxDQUEyQjFqQyxLQUEzQjtBQUNELFNBSmtCLEVBSWhCZ08sSUFBSSxDQUFDMjFCLGNBSlcsQ0FBbkI7QUFLQTtBQUNEOztBQUVEN1QsSUFBQUEscUJBQU0sQ0FBQ2tSLEtBQVAsQ0FBYTVWLElBQUksQ0FBQ2dYLEtBQUwsQ0FBV3hsQyxHQUF4QixFQUE2QjtBQUM1QkUsTUFBQUEsTUFBTSxFQUFFc3VCLElBQUksQ0FBQ2dYLEtBQUwsQ0FBV3RsQyxNQURTO0FBRTVCaEIsTUFBQUEsT0FBTyxFQUFFd25DLFdBRm1CO0FBRzVCRixNQUFBQSxJQUFJLEVBQUVBLElBQUksSUFBSXJrQyxTQUhjO0FBSTVCd2pDLE1BQUFBLElBQUksRUFBRSxNQUpzQjtBQUs1QnFCLE1BQUFBLFdBQVcsRUFBRTUxQixJQUFJLENBQUNwUCxlQUFMLEdBQXVCLFNBQXZCLEdBQW1DLGFBTHBCO0FBTTVCNGtDLE1BQUFBLE1BQU0sRUFBRUE7QUFOb0IsS0FBN0IsRUFPRzNqQyxJQVBILENBT1EsVUFBVXJDLFFBQVYsRUFBb0I7QUFDM0I0dEIsTUFBQUEsSUFBSSxDQUFDeVksY0FBTCxHQUFzQnJtQyxRQUF0Qjs7QUFDQTR0QixNQUFBQSxJQUFJLENBQUMwWSxZQUFMLENBQWtCLEtBQWxCOztBQUNBMVksTUFBQUEsSUFBSSxDQUFDMlksUUFBTDtBQUNBLEtBWEQsRUFXRyxVQUFVbGlDLE1BQVYsRUFBa0I7QUFDcEJ1cEIsTUFBQUEsSUFBSSxDQUFDMFksWUFBTCxDQUFrQixJQUFsQjs7QUFDQSxVQUFJLENBQUMxWSxJQUFJLENBQUM4WCxVQUFWLEVBQ0M5WCxJQUFJLENBQUM3QyxJQUFMLENBQVUsT0FBVixFQUFtQjFtQixNQUFuQjtBQUNELEtBZkQ7QUFnQkEsR0FoQ0QsTUFnQ087QUFDTixRQUFJeS9CLEdBQUcsR0FBR2xXLElBQUksQ0FBQzRZLElBQUwsR0FBWSxJQUFJbFUscUJBQU0sQ0FBQzV6QixjQUFYLEVBQXRCOztBQUNBLFFBQUk7QUFDSG9sQyxNQUFBQSxHQUFHLENBQUN6a0MsSUFBSixDQUFTdXVCLElBQUksQ0FBQ2dYLEtBQUwsQ0FBV3RsQyxNQUFwQixFQUE0QnN1QixJQUFJLENBQUNnWCxLQUFMLENBQVd4bEMsR0FBdkMsRUFBNEMsSUFBNUM7QUFDQSxLQUZELENBRUUsT0FBT3VYLEdBQVAsRUFBWTtBQUNick0sTUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUIsWUFBWTtBQUM1QjdELFFBQUFBLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWLEVBQW1CcFUsR0FBbkI7QUFDQSxPQUZEO0FBR0E7QUFDQSxLQVRLLENBV047OztBQUNBLFFBQUksa0JBQWtCbXRCLEdBQXRCLEVBQ0NBLEdBQUcsQ0FBQ3ZsQyxZQUFKLEdBQW1CcXZCLElBQUksQ0FBQ29YLEtBQXhCO0FBRUQsUUFBSSxxQkFBcUJsQixHQUF6QixFQUNDQSxHQUFHLENBQUMxaUMsZUFBSixHQUFzQixDQUFDLENBQUNvUCxJQUFJLENBQUNwUCxlQUE3QjtBQUVELFFBQUl3c0IsSUFBSSxDQUFDb1gsS0FBTCxLQUFlLE1BQWYsSUFBeUIsc0JBQXNCbEIsR0FBbkQsRUFDQ0EsR0FBRyxDQUFDTyxnQkFBSixDQUFxQixvQ0FBckI7O0FBRUQsUUFBSSxvQkFBb0I3ekIsSUFBeEIsRUFBOEI7QUFDN0JzekIsTUFBQUEsR0FBRyxDQUFDcGtDLE9BQUosR0FBYzhRLElBQUksQ0FBQzIxQixjQUFuQjs7QUFDQXJDLE1BQUFBLEdBQUcsQ0FBQ2pqQyxTQUFKLEdBQWdCLFlBQVk7QUFDM0Irc0IsUUFBQUEsSUFBSSxDQUFDN0MsSUFBTCxDQUFVLGdCQUFWO0FBQ0EsT0FGRDtBQUdBOztBQUVEK2EsSUFBQUEsV0FBVyxDQUFDcmtDLE9BQVosQ0FBb0IsVUFBVStqQyxNQUFWLEVBQWtCO0FBQ3JDMUIsTUFBQUEsR0FBRyxDQUFDcGlDLGdCQUFKLENBQXFCOGpDLE1BQU0sQ0FBQyxDQUFELENBQTNCLEVBQWdDQSxNQUFNLENBQUMsQ0FBRCxDQUF0QztBQUNBLEtBRkQ7QUFJQTVYLElBQUFBLElBQUksQ0FBQzZZLFNBQUwsR0FBaUIsSUFBakI7O0FBQ0EzQyxJQUFBQSxHQUFHLENBQUMzakMsa0JBQUosR0FBeUIsWUFBWTtBQUNwQyxjQUFRMmpDLEdBQUcsQ0FBQ3pqQyxVQUFaO0FBQ0MsYUFBS2trQyxPQUFPLENBQUNtQyxPQUFiO0FBQ0EsYUFBS25DLE9BQU8sQ0FBQ29DLElBQWI7QUFDQy9ZLFVBQUFBLElBQUksQ0FBQ2daLGNBQUw7O0FBQ0E7QUFKRjtBQU1BLEtBUEQsQ0FqQ00sQ0F5Q047QUFDQTs7O0FBQ0EsUUFBSWhaLElBQUksQ0FBQ29YLEtBQUwsS0FBZSx5QkFBbkIsRUFBOEM7QUFDN0NsQixNQUFBQSxHQUFHLENBQUMrQyxVQUFKLEdBQWlCLFlBQVk7QUFDNUJqWixRQUFBQSxJQUFJLENBQUNnWixjQUFMO0FBQ0EsT0FGRDtBQUdBOztBQUVEOUMsSUFBQUEsR0FBRyxDQUFDbmpDLE9BQUosR0FBYyxZQUFZO0FBQ3pCLFVBQUlpdEIsSUFBSSxDQUFDOFgsVUFBVCxFQUNDOztBQUNEOVgsTUFBQUEsSUFBSSxDQUFDMFksWUFBTCxDQUFrQixJQUFsQjs7QUFDQTFZLE1BQUFBLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWLEVBQW1CLElBQUk3dEIsS0FBSixDQUFVLFdBQVYsQ0FBbkI7QUFDQSxLQUxEOztBQU9BLFFBQUk7QUFDSDRtQyxNQUFBQSxHQUFHLENBQUNyaEMsSUFBSixDQUFTbWpDLElBQVQ7QUFDQSxLQUZELENBRUUsT0FBT2p2QixHQUFQLEVBQVk7QUFDYnJNLE1BQUFBLE9BQU8sQ0FBQ21uQixRQUFSLENBQWlCLFlBQVk7QUFDNUI3RCxRQUFBQSxJQUFJLENBQUM3QyxJQUFMLENBQVUsT0FBVixFQUFtQnBVLEdBQW5CO0FBQ0EsT0FGRDtBQUdBO0FBQ0E7QUFDRDtBQUNELENBbElEO0FBb0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLFNBQVNtd0IsV0FBVCxDQUFzQmhELEdBQXRCLEVBQTJCO0FBQzFCLE1BQUk7QUFDSCxRQUFJN2pDLE1BQU0sR0FBRzZqQyxHQUFHLENBQUM3akMsTUFBakI7QUFDQSxXQUFRQSxNQUFNLEtBQUssSUFBWCxJQUFtQkEsTUFBTSxLQUFLLENBQXRDO0FBQ0EsR0FIRCxDQUdFLE9BQU84SyxDQUFQLEVBQVU7QUFDWCxXQUFPLEtBQVA7QUFDQTtBQUNEOztBQUVEKzNCLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCMGpDLGNBQXhCLEdBQXlDLFlBQVk7QUFDcEQsTUFBSWhaLElBQUksR0FBRyxJQUFYOztBQUVBQSxFQUFBQSxJQUFJLENBQUMwWSxZQUFMLENBQWtCLEtBQWxCOztBQUVBLE1BQUksQ0FBQ1EsV0FBVyxDQUFDbFosSUFBSSxDQUFDNFksSUFBTixDQUFaLElBQTJCNVksSUFBSSxDQUFDOFgsVUFBcEMsRUFDQztBQUVELE1BQUksQ0FBQzlYLElBQUksQ0FBQzZZLFNBQVYsRUFDQzdZLElBQUksQ0FBQzJZLFFBQUw7O0FBRUQzWSxFQUFBQSxJQUFJLENBQUM2WSxTQUFMLENBQWVHLGNBQWYsQ0FBOEJoWixJQUFJLENBQUMwWSxZQUFMLENBQWtCNWpDLElBQWxCLENBQXVCa3JCLElBQXZCLENBQTlCO0FBQ0EsQ0FaRDs7QUFjQWtWLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCcWpDLFFBQXhCLEdBQW1DLFlBQVk7QUFDOUMsTUFBSTNZLElBQUksR0FBRyxJQUFYO0FBRUEsTUFBSUEsSUFBSSxDQUFDOFgsVUFBVCxFQUNDO0FBRUQ5WCxFQUFBQSxJQUFJLENBQUM2WSxTQUFMLEdBQWlCLElBQUl2RCxlQUFKLENBQW9CdFYsSUFBSSxDQUFDNFksSUFBekIsRUFBK0I1WSxJQUFJLENBQUN5WSxjQUFwQyxFQUFvRHpZLElBQUksQ0FBQ29YLEtBQXpELEVBQWdFcFgsSUFBSSxDQUFDMFksWUFBTCxDQUFrQjVqQyxJQUFsQixDQUF1QmtyQixJQUF2QixDQUFoRSxDQUFqQjs7QUFDQUEsRUFBQUEsSUFBSSxDQUFDNlksU0FBTCxDQUFlM2EsRUFBZixDQUFrQixPQUFsQixFQUEyQixVQUFTblYsR0FBVCxFQUFjO0FBQ3hDaVgsSUFBQUEsSUFBSSxDQUFDN0MsSUFBTCxDQUFVLE9BQVYsRUFBbUJwVSxHQUFuQjtBQUNBLEdBRkQ7O0FBSUFpWCxFQUFBQSxJQUFJLENBQUM3QyxJQUFMLENBQVUsVUFBVixFQUFzQjZDLElBQUksQ0FBQzZZLFNBQTNCO0FBQ0EsQ0FaRDs7QUFjQTNELGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCNjJCLE1BQXhCLEdBQWlDLFVBQVUvSCxLQUFWLEVBQWlCbmQsUUFBakIsRUFBMkJ5QixFQUEzQixFQUErQjtBQUMvRCxNQUFJc1gsSUFBSSxHQUFHLElBQVg7O0FBRUFBLEVBQUFBLElBQUksQ0FBQ2lYLEtBQUwsQ0FBV2gvQixJQUFYLENBQWdCbXNCLEtBQWhCOztBQUNBMWIsRUFBQUEsRUFBRTtBQUNGLENBTEQ7O0FBT0F3c0IsYUFBYSxDQUFDNS9CLFNBQWQsQ0FBd0JvakMsWUFBeEIsR0FBdUMsVUFBVXhNLElBQVYsRUFBZ0I7QUFDdEQsTUFBSWxNLElBQUksR0FBRyxJQUFYO0FBRUEwRSxFQUFBQSxxQkFBTSxDQUFDeVUsWUFBUCxDQUFvQm5aLElBQUksQ0FBQ3VYLFlBQXpCO0FBQ0F2WCxFQUFBQSxJQUFJLENBQUN1WCxZQUFMLEdBQW9CLElBQXBCOztBQUVBLE1BQUlyTCxJQUFKLEVBQVU7QUFDVHhILElBQUFBLHFCQUFNLENBQUN5VSxZQUFQLENBQW9CblosSUFBSSxDQUFDcVgsV0FBekI7QUFDQXJYLElBQUFBLElBQUksQ0FBQ3FYLFdBQUwsR0FBbUIsSUFBbkI7QUFDQSxHQUhELE1BR08sSUFBSXJYLElBQUksQ0FBQ3NYLGNBQVQsRUFBeUI7QUFDL0J0WCxJQUFBQSxJQUFJLENBQUN1WCxZQUFMLEdBQW9CN1MscUJBQU0sQ0FBQzl4QixVQUFQLENBQWtCLFlBQVk7QUFDakRvdEIsTUFBQUEsSUFBSSxDQUFDN0MsSUFBTCxDQUFVLFNBQVY7QUFDQSxLQUZtQixFQUVqQjZDLElBQUksQ0FBQ3NYLGNBRlksQ0FBcEI7QUFHQTtBQUNELENBZEQ7O0FBZ0JBcEMsYUFBYSxDQUFDNS9CLFNBQWQsQ0FBd0JWLEtBQXhCLEdBQWdDc2dDLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCNnhCLE9BQXhCLEdBQWtDLFVBQVVwZSxHQUFWLEVBQWU7QUFDaEYsTUFBSWlYLElBQUksR0FBRyxJQUFYO0FBQ0FBLEVBQUFBLElBQUksQ0FBQzhYLFVBQUwsR0FBa0IsSUFBbEI7O0FBQ0E5WCxFQUFBQSxJQUFJLENBQUMwWSxZQUFMLENBQWtCLElBQWxCOztBQUNBLE1BQUkxWSxJQUFJLENBQUM2WSxTQUFULEVBQ0M3WSxJQUFJLENBQUM2WSxTQUFMLENBQWVmLFVBQWYsR0FBNEIsSUFBNUI7QUFDRCxNQUFJOVgsSUFBSSxDQUFDNFksSUFBVCxFQUNDNVksSUFBSSxDQUFDNFksSUFBTCxDQUFVaGtDLEtBQVYsR0FERCxLQUVLLElBQUlvckIsSUFBSSxDQUFDc1kscUJBQVQsRUFDSnRZLElBQUksQ0FBQ3NZLHFCQUFMLENBQTJCMWpDLEtBQTNCO0FBRUQsTUFBSW1VLEdBQUosRUFDQ2lYLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWLEVBQW1CcFUsR0FBbkI7QUFDRCxDQWJEOztBQWVBbXNCLGFBQWEsQ0FBQzUvQixTQUFkLENBQXdCbVEsR0FBeEIsR0FBOEIsVUFBVWpWLElBQVYsRUFBZ0J5VyxRQUFoQixFQUEwQnlCLEVBQTFCLEVBQThCO0FBQzNELE1BQUlzWCxJQUFJLEdBQUcsSUFBWDs7QUFDQSxNQUFJLE9BQU94dkIsSUFBUCxLQUFnQixVQUFwQixFQUFnQztBQUMvQmtZLElBQUFBLEVBQUUsR0FBR2xZLElBQUw7QUFDQUEsSUFBQUEsSUFBSSxHQUFHbUQsU0FBUDtBQUNBOztBQUVEa3lCLEVBQUFBLE1BQU0sQ0FBQ3hDLFFBQVAsQ0FBZ0IvdEIsU0FBaEIsQ0FBMEJtUSxHQUExQixDQUE4QjFMLElBQTlCLENBQW1DaW1CLElBQW5DLEVBQXlDeHZCLElBQXpDLEVBQStDeVcsUUFBL0MsRUFBeUR5QixFQUF6RDtBQUNBLENBUkQ7O0FBVUF3c0IsYUFBYSxDQUFDNS9CLFNBQWQsQ0FBd0IxQyxVQUF4QixHQUFxQyxVQUFVZCxPQUFWLEVBQW1CNFcsRUFBbkIsRUFBdUI7QUFDM0QsTUFBSXNYLElBQUksR0FBRyxJQUFYO0FBRUEsTUFBSXRYLEVBQUosRUFDQ3NYLElBQUksQ0FBQ3hELElBQUwsQ0FBVSxTQUFWLEVBQXFCOVQsRUFBckI7QUFFRHNYLEVBQUFBLElBQUksQ0FBQ3NYLGNBQUwsR0FBc0J4bEMsT0FBdEI7O0FBQ0FrdUIsRUFBQUEsSUFBSSxDQUFDMFksWUFBTCxDQUFrQixLQUFsQjtBQUNBLENBUkQ7O0FBVUF4RCxhQUFhLENBQUM1L0IsU0FBZCxDQUF3QjhqQyxZQUF4QixHQUF1QyxZQUFZLENBQUUsQ0FBckQ7O0FBQ0FsRSxhQUFhLENBQUM1L0IsU0FBZCxDQUF3QitqQyxVQUF4QixHQUFxQyxZQUFZLENBQUUsQ0FBbkQ7O0FBQ0FuRSxhQUFhLENBQUM1L0IsU0FBZCxDQUF3QmdrQyxrQkFBeEIsR0FBNkMsWUFBWSxDQUFFLENBQTNELEVBRUE7OztBQUNBLElBQUk1QixhQUFhLEdBQUcsQ0FDbkIsZ0JBRG1CLEVBRW5CLGlCQUZtQixFQUduQixnQ0FIbUIsRUFJbkIsK0JBSm1CLEVBS25CLFlBTG1CLEVBTW5CLGdCQU5tQixFQU9uQixRQVBtQixFQVFuQixTQVJtQixFQVNuQixNQVRtQixFQVVuQixLQVZtQixFQVduQixRQVhtQixFQVluQixNQVptQixFQWFuQixZQWJtQixFQWNuQixRQWRtQixFQWVuQixTQWZtQixFQWdCbkIsSUFoQm1CLEVBaUJuQixTQWpCbUIsRUFrQm5CLG1CQWxCbUIsRUFtQm5CLFNBbkJtQixFQW9CbkIsS0FwQm1CLENBQXBCOzs7Ozs7Ozs7O0FDMVVBLElBQUloQixVQUFVLEdBQUczb0MsbUJBQU8sQ0FBQyxrRUFBRCxDQUF4Qjs7QUFDQSxJQUFJNnlCLFFBQVEsR0FBRzd5QixtQkFBTyxDQUFDLDZEQUFELENBQXRCOztBQUNBLElBQUk4M0IsTUFBTSxHQUFHOTNCLG1CQUFPLENBQUMsMkVBQUQsQ0FBcEI7O0FBRUEsSUFBSTRvQyxPQUFPLEdBQUcvb0MsbUJBQUEsR0FBc0I7QUFDbkMyckMsRUFBQUEsTUFBTSxFQUFFLENBRDJCO0FBRW5DQyxFQUFBQSxNQUFNLEVBQUUsQ0FGMkI7QUFHbkNDLEVBQUFBLGdCQUFnQixFQUFFLENBSGlCO0FBSW5DWCxFQUFBQSxPQUFPLEVBQUUsQ0FKMEI7QUFLbkNDLEVBQUFBLElBQUksRUFBRTtBQUw2QixDQUFwQzs7QUFRQSxJQUFJekQsZUFBZSxHQUFHMW5DLHVCQUFBLEdBQTBCLFVBQVVzb0MsR0FBVixFQUFlOWpDLFFBQWYsRUFBeUIra0MsSUFBekIsRUFBK0J1QyxXQUEvQixFQUE0QztBQUMzRixNQUFJMVosSUFBSSxHQUFHLElBQVg7QUFDQTZGLEVBQUFBLE1BQU0sQ0FBQ3pDLFFBQVAsQ0FBZ0JycEIsSUFBaEIsQ0FBcUJpbUIsSUFBckI7QUFFQUEsRUFBQUEsSUFBSSxDQUFDb1gsS0FBTCxHQUFhRCxJQUFiO0FBQ0FuWCxFQUFBQSxJQUFJLENBQUN0dkIsT0FBTCxHQUFlLEVBQWY7QUFDQXN2QixFQUFBQSxJQUFJLENBQUMyWixVQUFMLEdBQWtCLEVBQWxCO0FBQ0EzWixFQUFBQSxJQUFJLENBQUM0WixRQUFMLEdBQWdCLEVBQWhCO0FBQ0E1WixFQUFBQSxJQUFJLENBQUM2WixXQUFMLEdBQW1CLEVBQW5CLENBUjJGLENBVTNGOztBQUNBN1osRUFBQUEsSUFBSSxDQUFDOUIsRUFBTCxDQUFRLEtBQVIsRUFBZSxZQUFZO0FBQzFCO0FBQ0F4aEIsSUFBQUEsT0FBTyxDQUFDbW5CLFFBQVIsQ0FBaUIsWUFBWTtBQUM1QjdELE1BQUFBLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWO0FBQ0EsS0FGRDtBQUdBLEdBTEQ7O0FBT0EsTUFBSWdhLElBQUksS0FBSyxPQUFiLEVBQXNCO0FBQUEsUUFpRFp6akMsSUFqRFksR0FpRHJCLFNBQVNBLElBQVQsR0FBaUI7QUFDaEJvbUMsTUFBQUEsTUFBTSxDQUFDcG1DLElBQVAsR0FBY2UsSUFBZCxDQUFtQixVQUFVd08sTUFBVixFQUFrQjtBQUNwQyxZQUFJK2MsSUFBSSxDQUFDOFgsVUFBVCxFQUNDO0FBQ0Q0QixRQUFBQSxXQUFXLENBQUN6MkIsTUFBTSxDQUFDaXBCLElBQVIsQ0FBWDs7QUFDQSxZQUFJanBCLE1BQU0sQ0FBQ2lwQixJQUFYLEVBQWlCO0FBQ2hCbE0sVUFBQUEsSUFBSSxDQUFDL25CLElBQUwsQ0FBVSxJQUFWO0FBQ0E7QUFDQTs7QUFDRCtuQixRQUFBQSxJQUFJLENBQUMvbkIsSUFBTCxDQUFVekosTUFBTSxDQUFDQyxJQUFQLENBQVl3VSxNQUFNLENBQUNwVixLQUFuQixDQUFWO0FBQ0E2RixRQUFBQSxJQUFJO0FBQ0osT0FWRCxXQVVTLFVBQVVxVixHQUFWLEVBQWU7QUFDdkIyd0IsUUFBQUEsV0FBVyxDQUFDLElBQUQsQ0FBWDtBQUNBLFlBQUksQ0FBQzFaLElBQUksQ0FBQzhYLFVBQVYsRUFDQzlYLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWLEVBQW1CcFUsR0FBbkI7QUFDRCxPQWREO0FBZUEsS0FqRW9COztBQUNyQmlYLElBQUFBLElBQUksQ0FBQ3lZLGNBQUwsR0FBc0JybUMsUUFBdEI7QUFFQTR0QixJQUFBQSxJQUFJLENBQUN4dUIsR0FBTCxHQUFXWSxRQUFRLENBQUNaLEdBQXBCO0FBQ0F3dUIsSUFBQUEsSUFBSSxDQUFDK1osVUFBTCxHQUFrQjNuQyxRQUFRLENBQUNDLE1BQTNCO0FBQ0EydEIsSUFBQUEsSUFBSSxDQUFDZ2EsYUFBTCxHQUFxQjVuQyxRQUFRLENBQUNFLFVBQTlCO0FBRUFGLElBQUFBLFFBQVEsQ0FBQzFCLE9BQVQsQ0FBaUJtRCxPQUFqQixDQUF5QixVQUFVK2pDLE1BQVYsRUFBa0I1akMsR0FBbEIsRUFBc0I7QUFDOUNnc0IsTUFBQUEsSUFBSSxDQUFDdHZCLE9BQUwsQ0FBYXNELEdBQUcsQ0FBQ0MsV0FBSixFQUFiLElBQWtDMmpDLE1BQWxDO0FBQ0E1WCxNQUFBQSxJQUFJLENBQUMyWixVQUFMLENBQWdCMWhDLElBQWhCLENBQXFCakUsR0FBckIsRUFBMEI0akMsTUFBMUI7QUFDQSxLQUhEOztBQUtBLFFBQUlsQixVQUFVLENBQUNaLGNBQWYsRUFBK0I7QUFDOUIsVUFBSTdiLFFBQVEsR0FBRyxJQUFJOGIsY0FBSixDQUFtQjtBQUNqQy8yQixRQUFBQSxLQUFLLEVBQUUsZUFBVW9sQixLQUFWLEVBQWlCO0FBQ3ZCc1YsVUFBQUEsV0FBVyxDQUFDLEtBQUQsQ0FBWDtBQUNBLGlCQUFPLElBQUl2cEMsT0FBSixDQUFZLFVBQVVFLE9BQVYsRUFBbUJDLE1BQW5CLEVBQTJCO0FBQzdDLGdCQUFJMHZCLElBQUksQ0FBQzhYLFVBQVQsRUFBcUI7QUFDcEJ4bkMsY0FBQUEsTUFBTTtBQUNOLGFBRkQsTUFFTyxJQUFHMHZCLElBQUksQ0FBQy9uQixJQUFMLENBQVV6SixNQUFNLENBQUNDLElBQVAsQ0FBWTIxQixLQUFaLENBQVYsQ0FBSCxFQUFrQztBQUN4Qy96QixjQUFBQSxPQUFPO0FBQ1AsYUFGTSxNQUVBO0FBQ04ydkIsY0FBQUEsSUFBSSxDQUFDaWEsWUFBTCxHQUFvQjVwQyxPQUFwQjtBQUNBO0FBQ0QsV0FSTSxDQUFQO0FBU0EsU0FaZ0M7QUFhakM2cEMsUUFBQUEsS0FBSyxFQUFFLGlCQUFZO0FBQ2xCUixVQUFBQSxXQUFXLENBQUMsSUFBRCxDQUFYO0FBQ0EsY0FBSSxDQUFDMVosSUFBSSxDQUFDOFgsVUFBVixFQUNDOVgsSUFBSSxDQUFDL25CLElBQUwsQ0FBVSxJQUFWO0FBQ0QsU0FqQmdDO0FBa0JqQ3JELFFBQUFBLEtBQUssRUFBRSxlQUFVbVUsR0FBVixFQUFlO0FBQ3JCMndCLFVBQUFBLFdBQVcsQ0FBQyxJQUFELENBQVg7QUFDQSxjQUFJLENBQUMxWixJQUFJLENBQUM4WCxVQUFWLEVBQ0M5WCxJQUFJLENBQUM3QyxJQUFMLENBQVUsT0FBVixFQUFtQnBVLEdBQW5CO0FBQ0Q7QUF0QmdDLE9BQW5CLENBQWY7O0FBeUJBLFVBQUk7QUFDSDNXLFFBQUFBLFFBQVEsQ0FBQzRsQyxJQUFULENBQWNtQyxNQUFkLENBQXFCbGdCLFFBQXJCLFdBQXFDLFVBQVVsUixHQUFWLEVBQWU7QUFDbkQyd0IsVUFBQUEsV0FBVyxDQUFDLElBQUQsQ0FBWDtBQUNBLGNBQUksQ0FBQzFaLElBQUksQ0FBQzhYLFVBQVYsRUFDQzlYLElBQUksQ0FBQzdDLElBQUwsQ0FBVSxPQUFWLEVBQW1CcFUsR0FBbkI7QUFDRCxTQUpEO0FBS0E7QUFDQSxPQVBELENBT0UsT0FBTzVMLENBQVAsRUFBVSxDQUFFLENBakNnQixDQWlDZjs7QUFDZixLQTlDb0IsQ0ErQ3JCOzs7QUFDQSxRQUFJMjhCLE1BQU0sR0FBRzFuQyxRQUFRLENBQUM0bEMsSUFBVCxDQUFjb0MsU0FBZCxFQUFiO0FBa0JBMW1DLElBQUFBLElBQUk7QUFDSixHQW5FRCxNQW1FTztBQUNOc3NCLElBQUFBLElBQUksQ0FBQzRZLElBQUwsR0FBWTFDLEdBQVo7QUFDQWxXLElBQUFBLElBQUksQ0FBQ3FhLElBQUwsR0FBWSxDQUFaO0FBRUFyYSxJQUFBQSxJQUFJLENBQUN4dUIsR0FBTCxHQUFXMGtDLEdBQUcsQ0FBQ3hqQyxXQUFmO0FBQ0FzdEIsSUFBQUEsSUFBSSxDQUFDK1osVUFBTCxHQUFrQjdELEdBQUcsQ0FBQzdqQyxNQUF0QjtBQUNBMnRCLElBQUFBLElBQUksQ0FBQ2dhLGFBQUwsR0FBcUI5RCxHQUFHLENBQUM1akMsVUFBekI7QUFDQSxRQUFJNUIsT0FBTyxHQUFHd2xDLEdBQUcsQ0FBQ2prQyxxQkFBSixHQUE0QndQLEtBQTVCLENBQWtDLE9BQWxDLENBQWQ7QUFDQS9RLElBQUFBLE9BQU8sQ0FBQ21ELE9BQVIsQ0FBZ0IsVUFBVStqQyxNQUFWLEVBQWtCO0FBQ2pDLFVBQUkwQyxPQUFPLEdBQUcxQyxNQUFNLENBQUNsNEIsS0FBUCxDQUFhLGtCQUFiLENBQWQ7O0FBQ0EsVUFBSTQ2QixPQUFKLEVBQWE7QUFDWixZQUFJdG1DLEdBQUcsR0FBR3NtQyxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVdybUMsV0FBWCxFQUFWOztBQUNBLFlBQUlELEdBQUcsS0FBSyxZQUFaLEVBQTBCO0FBQ3pCLGNBQUlnc0IsSUFBSSxDQUFDdHZCLE9BQUwsQ0FBYXNELEdBQWIsTUFBc0JMLFNBQTFCLEVBQXFDO0FBQ3BDcXNCLFlBQUFBLElBQUksQ0FBQ3R2QixPQUFMLENBQWFzRCxHQUFiLElBQW9CLEVBQXBCO0FBQ0E7O0FBQ0Rnc0IsVUFBQUEsSUFBSSxDQUFDdHZCLE9BQUwsQ0FBYXNELEdBQWIsRUFBa0JpRSxJQUFsQixDQUF1QnFpQyxPQUFPLENBQUMsQ0FBRCxDQUE5QjtBQUNBLFNBTEQsTUFLTyxJQUFJdGEsSUFBSSxDQUFDdHZCLE9BQUwsQ0FBYXNELEdBQWIsTUFBc0JMLFNBQTFCLEVBQXFDO0FBQzNDcXNCLFVBQUFBLElBQUksQ0FBQ3R2QixPQUFMLENBQWFzRCxHQUFiLEtBQXFCLE9BQU9zbUMsT0FBTyxDQUFDLENBQUQsQ0FBbkM7QUFDQSxTQUZNLE1BRUE7QUFDTnRhLFVBQUFBLElBQUksQ0FBQ3R2QixPQUFMLENBQWFzRCxHQUFiLElBQW9Cc21DLE9BQU8sQ0FBQyxDQUFELENBQTNCO0FBQ0E7O0FBQ0R0YSxRQUFBQSxJQUFJLENBQUMyWixVQUFMLENBQWdCMWhDLElBQWhCLENBQXFCcWlDLE9BQU8sQ0FBQyxDQUFELENBQTVCLEVBQWlDQSxPQUFPLENBQUMsQ0FBRCxDQUF4QztBQUNBO0FBQ0QsS0FoQkQ7QUFrQkF0YSxJQUFBQSxJQUFJLENBQUN1YSxRQUFMLEdBQWdCLGdCQUFoQjs7QUFDQSxRQUFJLENBQUM3RCxVQUFVLENBQUNELGdCQUFoQixFQUFrQztBQUNqQyxVQUFJK0QsUUFBUSxHQUFHeGEsSUFBSSxDQUFDMlosVUFBTCxDQUFnQixXQUFoQixDQUFmOztBQUNBLFVBQUlhLFFBQUosRUFBYztBQUNiLFlBQUlDLFlBQVksR0FBR0QsUUFBUSxDQUFDOTZCLEtBQVQsQ0FBZSx5QkFBZixDQUFuQjs7QUFDQSxZQUFJKzZCLFlBQUosRUFBa0I7QUFDakJ6YSxVQUFBQSxJQUFJLENBQUN1YSxRQUFMLEdBQWdCRSxZQUFZLENBQUMsQ0FBRCxDQUFaLENBQWdCeG1DLFdBQWhCLEVBQWhCO0FBQ0E7QUFDRDs7QUFDRCxVQUFJLENBQUMrckIsSUFBSSxDQUFDdWEsUUFBVixFQUNDdmEsSUFBSSxDQUFDdWEsUUFBTCxHQUFnQixPQUFoQixDQVRnQyxDQVNSO0FBQ3pCO0FBQ0Q7QUFDRCxDQTVIRDs7QUE4SEEzWixRQUFRLENBQUMwVSxlQUFELEVBQWtCelAsTUFBTSxDQUFDekMsUUFBekIsQ0FBUjs7QUFFQWtTLGVBQWUsQ0FBQ2hnQyxTQUFoQixDQUEwQjR4QixLQUExQixHQUFrQyxZQUFZO0FBQzdDLE1BQUlsSCxJQUFJLEdBQUcsSUFBWDtBQUVBLE1BQUkzdkIsT0FBTyxHQUFHMnZCLElBQUksQ0FBQ2lhLFlBQW5COztBQUNBLE1BQUk1cEMsT0FBSixFQUFhO0FBQ1oydkIsSUFBQUEsSUFBSSxDQUFDaWEsWUFBTCxHQUFvQixJQUFwQjtBQUNBNXBDLElBQUFBLE9BQU87QUFDUDtBQUNELENBUkQ7O0FBVUFpbEMsZUFBZSxDQUFDaGdDLFNBQWhCLENBQTBCMGpDLGNBQTFCLEdBQTJDLFVBQVVVLFdBQVYsRUFBdUI7QUFDakUsTUFBSTFaLElBQUksR0FBRyxJQUFYO0FBRUEsTUFBSWtXLEdBQUcsR0FBR2xXLElBQUksQ0FBQzRZLElBQWY7QUFFQSxNQUFJeG1DLFFBQVEsR0FBRyxJQUFmOztBQUNBLFVBQVE0dEIsSUFBSSxDQUFDb1gsS0FBYjtBQUNDLFNBQUssTUFBTDtBQUNDaGxDLE1BQUFBLFFBQVEsR0FBRzhqQyxHQUFHLENBQUMvakMsWUFBZjs7QUFDQSxVQUFJQyxRQUFRLENBQUNrRyxNQUFULEdBQWtCMG5CLElBQUksQ0FBQ3FhLElBQTNCLEVBQWlDO0FBQ2hDLFlBQUlLLE9BQU8sR0FBR3RvQyxRQUFRLENBQUN1UCxNQUFULENBQWdCcWUsSUFBSSxDQUFDcWEsSUFBckIsQ0FBZDs7QUFDQSxZQUFJcmEsSUFBSSxDQUFDdWEsUUFBTCxLQUFrQixnQkFBdEIsRUFBd0M7QUFDdkMsY0FBSTU4QixNQUFNLEdBQUduUCxNQUFNLENBQUNraEIsS0FBUCxDQUFhZ3JCLE9BQU8sQ0FBQ3BpQyxNQUFyQixDQUFiOztBQUNBLGVBQUssSUFBSThGLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdzOEIsT0FBTyxDQUFDcGlDLE1BQTVCLEVBQW9DOEYsQ0FBQyxFQUFyQztBQUNDVCxZQUFBQSxNQUFNLENBQUNTLENBQUQsQ0FBTixHQUFZczhCLE9BQU8sQ0FBQ3QyQixVQUFSLENBQW1CaEcsQ0FBbkIsSUFBd0IsSUFBcEM7QUFERDs7QUFHQTRoQixVQUFBQSxJQUFJLENBQUMvbkIsSUFBTCxDQUFVMEYsTUFBVjtBQUNBLFNBTkQsTUFNTztBQUNOcWlCLFVBQUFBLElBQUksQ0FBQy9uQixJQUFMLENBQVV5aUMsT0FBVixFQUFtQjFhLElBQUksQ0FBQ3VhLFFBQXhCO0FBQ0E7O0FBQ0R2YSxRQUFBQSxJQUFJLENBQUNxYSxJQUFMLEdBQVlqb0MsUUFBUSxDQUFDa0csTUFBckI7QUFDQTs7QUFDRDs7QUFDRCxTQUFLLGFBQUw7QUFDQyxVQUFJNDlCLEdBQUcsQ0FBQ3pqQyxVQUFKLEtBQW1Ca2tDLE9BQU8sQ0FBQ29DLElBQTNCLElBQW1DLENBQUM3QyxHQUFHLENBQUM5akMsUUFBNUMsRUFDQztBQUNEQSxNQUFBQSxRQUFRLEdBQUc4akMsR0FBRyxDQUFDOWpDLFFBQWY7QUFDQTR0QixNQUFBQSxJQUFJLENBQUMvbkIsSUFBTCxDQUFVekosTUFBTSxDQUFDQyxJQUFQLENBQVksSUFBSVEsVUFBSixDQUFlbUQsUUFBZixDQUFaLENBQVY7QUFDQTs7QUFDRCxTQUFLLHlCQUFMO0FBQWdDO0FBQy9CQSxNQUFBQSxRQUFRLEdBQUc4akMsR0FBRyxDQUFDOWpDLFFBQWY7QUFDQSxVQUFJOGpDLEdBQUcsQ0FBQ3pqQyxVQUFKLEtBQW1Ca2tDLE9BQU8sQ0FBQ21DLE9BQTNCLElBQXNDLENBQUMxbUMsUUFBM0MsRUFDQztBQUNENHRCLE1BQUFBLElBQUksQ0FBQy9uQixJQUFMLENBQVV6SixNQUFNLENBQUNDLElBQVAsQ0FBWSxJQUFJUSxVQUFKLENBQWVtRCxRQUFmLENBQVosQ0FBVjtBQUNBOztBQUNELFNBQUssV0FBTDtBQUNDQSxNQUFBQSxRQUFRLEdBQUc4akMsR0FBRyxDQUFDOWpDLFFBQWY7QUFDQSxVQUFJOGpDLEdBQUcsQ0FBQ3pqQyxVQUFKLEtBQW1Ca2tDLE9BQU8sQ0FBQ21DLE9BQS9CLEVBQ0M7QUFDRCxVQUFJZ0IsTUFBTSxHQUFHLElBQUlwVixxQkFBTSxDQUFDaVcsY0FBWCxFQUFiOztBQUNBYixNQUFBQSxNQUFNLENBQUNiLFVBQVAsR0FBb0IsWUFBWTtBQUMvQixZQUFJYSxNQUFNLENBQUM3MkIsTUFBUCxDQUFjb0IsVUFBZCxHQUEyQjJiLElBQUksQ0FBQ3FhLElBQXBDLEVBQTBDO0FBQ3pDcmEsVUFBQUEsSUFBSSxDQUFDL25CLElBQUwsQ0FBVXpKLE1BQU0sQ0FBQ0MsSUFBUCxDQUFZLElBQUlRLFVBQUosQ0FBZTZxQyxNQUFNLENBQUM3MkIsTUFBUCxDQUFjclUsS0FBZCxDQUFvQm94QixJQUFJLENBQUNxYSxJQUF6QixDQUFmLENBQVosQ0FBVjtBQUNBcmEsVUFBQUEsSUFBSSxDQUFDcWEsSUFBTCxHQUFZUCxNQUFNLENBQUM3MkIsTUFBUCxDQUFjb0IsVUFBMUI7QUFDQTtBQUNELE9BTEQ7O0FBTUF5MUIsTUFBQUEsTUFBTSxDQUFDMXhCLE1BQVAsR0FBZ0IsWUFBWTtBQUMzQnN4QixRQUFBQSxXQUFXLENBQUMsSUFBRCxDQUFYO0FBQ0ExWixRQUFBQSxJQUFJLENBQUMvbkIsSUFBTCxDQUFVLElBQVY7QUFDQSxPQUhELENBWEQsQ0FlQzs7O0FBQ0E2aEMsTUFBQUEsTUFBTSxDQUFDYyxpQkFBUCxDQUF5QnhvQyxRQUF6QjtBQUNBO0FBOUNGLEdBTmlFLENBdURqRTs7O0FBQ0EsTUFBSTR0QixJQUFJLENBQUM0WSxJQUFMLENBQVVubUMsVUFBVixLQUF5QmtrQyxPQUFPLENBQUNvQyxJQUFqQyxJQUF5Qy9ZLElBQUksQ0FBQ29YLEtBQUwsS0FBZSxXQUE1RCxFQUF5RTtBQUN4RXNDLElBQUFBLFdBQVcsQ0FBQyxJQUFELENBQVg7QUFDQTFaLElBQUFBLElBQUksQ0FBQy9uQixJQUFMLENBQVUsSUFBVjtBQUNBO0FBQ0QsQ0E1REQ7Ozs7Ozs7Ozs7QUN0SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVhO0FBRWI7O0FBRUEsSUFBSXpKLE1BQU0sR0FBR1Qsc0ZBQWI7QUFDQTs7O0FBRUEsSUFBSStoQixVQUFVLEdBQUd0aEIsTUFBTSxDQUFDc2hCLFVBQVAsSUFBcUIsVUFBVTdJLFFBQVYsRUFBb0I7QUFDeERBLEVBQUFBLFFBQVEsR0FBRyxLQUFLQSxRQUFoQjs7QUFDQSxVQUFRQSxRQUFRLElBQUlBLFFBQVEsQ0FBQ2hULFdBQVQsRUFBcEI7QUFDRSxTQUFLLEtBQUw7QUFBVyxTQUFLLE1BQUw7QUFBWSxTQUFLLE9BQUw7QUFBYSxTQUFLLE9BQUw7QUFBYSxTQUFLLFFBQUw7QUFBYyxTQUFLLFFBQUw7QUFBYyxTQUFLLE1BQUw7QUFBWSxTQUFLLE9BQUw7QUFBYSxTQUFLLFNBQUw7QUFBZSxTQUFLLFVBQUw7QUFBZ0IsU0FBSyxLQUFMO0FBQ25JLGFBQU8sSUFBUDs7QUFDRjtBQUNFLGFBQU8sS0FBUDtBQUpKO0FBTUQsQ0FSRDs7QUFVQSxTQUFTNG1DLGtCQUFULENBQTRCaHdCLEdBQTVCLEVBQWlDO0FBQy9CLE1BQUksQ0FBQ0EsR0FBTCxFQUFVLE9BQU8sTUFBUDtBQUNWLE1BQUlpd0IsT0FBSjs7QUFDQSxTQUFPLElBQVAsRUFBYTtBQUNYLFlBQVFqd0IsR0FBUjtBQUNFLFdBQUssTUFBTDtBQUNBLFdBQUssT0FBTDtBQUNFLGVBQU8sTUFBUDs7QUFDRixXQUFLLE1BQUw7QUFDQSxXQUFLLE9BQUw7QUFDQSxXQUFLLFNBQUw7QUFDQSxXQUFLLFVBQUw7QUFDRSxlQUFPLFNBQVA7O0FBQ0YsV0FBSyxRQUFMO0FBQ0EsV0FBSyxRQUFMO0FBQ0UsZUFBTyxRQUFQOztBQUNGLFdBQUssUUFBTDtBQUNBLFdBQUssT0FBTDtBQUNBLFdBQUssS0FBTDtBQUNFLGVBQU9BLEdBQVA7O0FBQ0Y7QUFDRSxZQUFJaXdCLE9BQUosRUFBYSxPQURmLENBQ3VCOztBQUNyQmp3QixRQUFBQSxHQUFHLEdBQUcsQ0FBQyxLQUFLQSxHQUFOLEVBQVc1VyxXQUFYLEVBQU47QUFDQTZtQyxRQUFBQSxPQUFPLEdBQUcsSUFBVjtBQW5CSjtBQXFCRDtBQUNGOztBQUFBLEVBRUQ7QUFDQTs7QUFDQSxTQUFTQyxpQkFBVCxDQUEyQmx3QixHQUEzQixFQUFnQztBQUM5QixNQUFJbXdCLElBQUksR0FBR0gsa0JBQWtCLENBQUNod0IsR0FBRCxDQUE3Qjs7QUFDQSxNQUFJLE9BQU9td0IsSUFBUCxLQUFnQixRQUFoQixLQUE2QnhzQyxNQUFNLENBQUNzaEIsVUFBUCxLQUFzQkEsVUFBdEIsSUFBb0MsQ0FBQ0EsVUFBVSxDQUFDakYsR0FBRCxDQUE1RSxDQUFKLEVBQXdGLE1BQU0sSUFBSXZiLEtBQUosQ0FBVSx1QkFBdUJ1YixHQUFqQyxDQUFOO0FBQ3hGLFNBQU9td0IsSUFBSSxJQUFJbndCLEdBQWY7QUFDRCxFQUVEO0FBQ0E7QUFDQTs7O0FBQ0FqZCxxQkFBQSxHQUF3QjQzQixhQUF4Qjs7QUFDQSxTQUFTQSxhQUFULENBQXVCdmUsUUFBdkIsRUFBaUM7QUFDL0IsT0FBS0EsUUFBTCxHQUFnQjh6QixpQkFBaUIsQ0FBQzl6QixRQUFELENBQWpDO0FBQ0EsTUFBSThyQixFQUFKOztBQUNBLFVBQVEsS0FBSzlyQixRQUFiO0FBQ0UsU0FBSyxTQUFMO0FBQ0UsV0FBS2cwQixJQUFMLEdBQVlDLFNBQVo7QUFDQSxXQUFLejFCLEdBQUwsR0FBVzAxQixRQUFYO0FBQ0FwSSxNQUFBQSxFQUFFLEdBQUcsQ0FBTDtBQUNBOztBQUNGLFNBQUssTUFBTDtBQUNFLFdBQUtxSSxRQUFMLEdBQWdCQyxZQUFoQjtBQUNBdEksTUFBQUEsRUFBRSxHQUFHLENBQUw7QUFDQTs7QUFDRixTQUFLLFFBQUw7QUFDRSxXQUFLa0ksSUFBTCxHQUFZSyxVQUFaO0FBQ0EsV0FBSzcxQixHQUFMLEdBQVc4MUIsU0FBWDtBQUNBeEksTUFBQUEsRUFBRSxHQUFHLENBQUw7QUFDQTs7QUFDRjtBQUNFLFdBQUsvekIsS0FBTCxHQUFhdzhCLFdBQWI7QUFDQSxXQUFLLzFCLEdBQUwsR0FBV2cyQixTQUFYO0FBQ0E7QUFsQko7O0FBb0JBLE9BQUtDLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxPQUFLQyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsT0FBS0MsUUFBTCxHQUFnQnB0QyxNQUFNLENBQUN1Z0IsV0FBUCxDQUFtQmdrQixFQUFuQixDQUFoQjtBQUNEOztBQUVEdk4sYUFBYSxDQUFDbHdCLFNBQWQsQ0FBd0IwSixLQUF4QixHQUFnQyxVQUFVb00sR0FBVixFQUFlO0FBQzdDLE1BQUlBLEdBQUcsQ0FBQzlTLE1BQUosS0FBZSxDQUFuQixFQUFzQixPQUFPLEVBQVA7QUFDdEIsTUFBSXVqQyxDQUFKO0FBQ0EsTUFBSXo5QixDQUFKOztBQUNBLE1BQUksS0FBS3M5QixRQUFULEVBQW1CO0FBQ2pCRyxJQUFBQSxDQUFDLEdBQUcsS0FBS1QsUUFBTCxDQUFjaHdCLEdBQWQsQ0FBSjtBQUNBLFFBQUl5d0IsQ0FBQyxLQUFLbG9DLFNBQVYsRUFBcUIsT0FBTyxFQUFQO0FBQ3JCeUssSUFBQUEsQ0FBQyxHQUFHLEtBQUtzOUIsUUFBVDtBQUNBLFNBQUtBLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDRCxHQUxELE1BS087QUFDTHQ5QixJQUFBQSxDQUFDLEdBQUcsQ0FBSjtBQUNEOztBQUNELE1BQUlBLENBQUMsR0FBR2dOLEdBQUcsQ0FBQzlTLE1BQVosRUFBb0IsT0FBT3VqQyxDQUFDLEdBQUdBLENBQUMsR0FBRyxLQUFLWixJQUFMLENBQVU3dkIsR0FBVixFQUFlaE4sQ0FBZixDQUFQLEdBQTJCLEtBQUs2OEIsSUFBTCxDQUFVN3ZCLEdBQVYsRUFBZWhOLENBQWYsQ0FBbkM7QUFDcEIsU0FBT3k5QixDQUFDLElBQUksRUFBWjtBQUNELENBZEQ7O0FBZ0JBclcsYUFBYSxDQUFDbHdCLFNBQWQsQ0FBd0JtUSxHQUF4QixHQUE4QnEyQixPQUE5QixFQUVBOztBQUNBdFcsYUFBYSxDQUFDbHdCLFNBQWQsQ0FBd0IybEMsSUFBeEIsR0FBK0JjLFFBQS9CLEVBRUE7O0FBQ0F2VyxhQUFhLENBQUNsd0IsU0FBZCxDQUF3QjhsQyxRQUF4QixHQUFtQyxVQUFVaHdCLEdBQVYsRUFBZTtBQUNoRCxNQUFJLEtBQUtzd0IsUUFBTCxJQUFpQnR3QixHQUFHLENBQUM5UyxNQUF6QixFQUFpQztBQUMvQjhTLElBQUFBLEdBQUcsQ0FBQytFLElBQUosQ0FBUyxLQUFLeXJCLFFBQWQsRUFBd0IsS0FBS0QsU0FBTCxHQUFpQixLQUFLRCxRQUE5QyxFQUF3RCxDQUF4RCxFQUEyRCxLQUFLQSxRQUFoRTtBQUNBLFdBQU8sS0FBS0UsUUFBTCxDQUFjbHRDLFFBQWQsQ0FBdUIsS0FBS3VZLFFBQTVCLEVBQXNDLENBQXRDLEVBQXlDLEtBQUswMEIsU0FBOUMsQ0FBUDtBQUNEOztBQUNEdndCLEVBQUFBLEdBQUcsQ0FBQytFLElBQUosQ0FBUyxLQUFLeXJCLFFBQWQsRUFBd0IsS0FBS0QsU0FBTCxHQUFpQixLQUFLRCxRQUE5QyxFQUF3RCxDQUF4RCxFQUEyRHR3QixHQUFHLENBQUM5UyxNQUEvRDtBQUNBLE9BQUtvakMsUUFBTCxJQUFpQnR3QixHQUFHLENBQUM5UyxNQUFyQjtBQUNELENBUEQsRUFTQTtBQUNBOzs7QUFDQSxTQUFTMGpDLGFBQVQsQ0FBdUJDLEtBQXZCLEVBQTZCO0FBQzNCLE1BQUlBLEtBQUksSUFBSSxJQUFaLEVBQWtCLE9BQU8sQ0FBUCxDQUFsQixLQUFnQyxJQUFJQSxLQUFJLElBQUksQ0FBUixLQUFjLElBQWxCLEVBQXdCLE9BQU8sQ0FBUCxDQUF4QixLQUFzQyxJQUFJQSxLQUFJLElBQUksQ0FBUixLQUFjLElBQWxCLEVBQXdCLE9BQU8sQ0FBUCxDQUF4QixLQUFzQyxJQUFJQSxLQUFJLElBQUksQ0FBUixLQUFjLElBQWxCLEVBQXdCLE9BQU8sQ0FBUDtBQUNwSSxTQUFPQSxLQUFJLElBQUksQ0FBUixLQUFjLElBQWQsR0FBcUIsQ0FBQyxDQUF0QixHQUEwQixDQUFDLENBQWxDO0FBQ0QsRUFFRDtBQUNBO0FBQ0E7OztBQUNBLFNBQVNDLG1CQUFULENBQTZCbGMsSUFBN0IsRUFBbUM1VSxHQUFuQyxFQUF3Q2hOLENBQXhDLEVBQTJDO0FBQ3pDLE1BQUl3VSxDQUFDLEdBQUd4SCxHQUFHLENBQUM5UyxNQUFKLEdBQWEsQ0FBckI7QUFDQSxNQUFJc2EsQ0FBQyxHQUFHeFUsQ0FBUixFQUFXLE9BQU8sQ0FBUDtBQUNYLE1BQUkyMEIsRUFBRSxHQUFHaUosYUFBYSxDQUFDNXdCLEdBQUcsQ0FBQ3dILENBQUQsQ0FBSixDQUF0Qjs7QUFDQSxNQUFJbWdCLEVBQUUsSUFBSSxDQUFWLEVBQWE7QUFDWCxRQUFJQSxFQUFFLEdBQUcsQ0FBVCxFQUFZL1MsSUFBSSxDQUFDMGIsUUFBTCxHQUFnQjNJLEVBQUUsR0FBRyxDQUFyQjtBQUNaLFdBQU9BLEVBQVA7QUFDRDs7QUFDRCxNQUFJLEVBQUVuZ0IsQ0FBRixHQUFNeFUsQ0FBTixJQUFXMjBCLEVBQUUsS0FBSyxDQUFDLENBQXZCLEVBQTBCLE9BQU8sQ0FBUDtBQUMxQkEsRUFBQUEsRUFBRSxHQUFHaUosYUFBYSxDQUFDNXdCLEdBQUcsQ0FBQ3dILENBQUQsQ0FBSixDQUFsQjs7QUFDQSxNQUFJbWdCLEVBQUUsSUFBSSxDQUFWLEVBQWE7QUFDWCxRQUFJQSxFQUFFLEdBQUcsQ0FBVCxFQUFZL1MsSUFBSSxDQUFDMGIsUUFBTCxHQUFnQjNJLEVBQUUsR0FBRyxDQUFyQjtBQUNaLFdBQU9BLEVBQVA7QUFDRDs7QUFDRCxNQUFJLEVBQUVuZ0IsQ0FBRixHQUFNeFUsQ0FBTixJQUFXMjBCLEVBQUUsS0FBSyxDQUFDLENBQXZCLEVBQTBCLE9BQU8sQ0FBUDtBQUMxQkEsRUFBQUEsRUFBRSxHQUFHaUosYUFBYSxDQUFDNXdCLEdBQUcsQ0FBQ3dILENBQUQsQ0FBSixDQUFsQjs7QUFDQSxNQUFJbWdCLEVBQUUsSUFBSSxDQUFWLEVBQWE7QUFDWCxRQUFJQSxFQUFFLEdBQUcsQ0FBVCxFQUFZO0FBQ1YsVUFBSUEsRUFBRSxLQUFLLENBQVgsRUFBY0EsRUFBRSxHQUFHLENBQUwsQ0FBZCxLQUEwQi9TLElBQUksQ0FBQzBiLFFBQUwsR0FBZ0IzSSxFQUFFLEdBQUcsQ0FBckI7QUFDM0I7O0FBQ0QsV0FBT0EsRUFBUDtBQUNEOztBQUNELFNBQU8sQ0FBUDtBQUNELEVBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU29KLG1CQUFULENBQTZCbmMsSUFBN0IsRUFBbUM1VSxHQUFuQyxFQUF3Q0QsQ0FBeEMsRUFBMkM7QUFDekMsTUFBSSxDQUFDQyxHQUFHLENBQUMsQ0FBRCxDQUFILEdBQVMsSUFBVixNQUFvQixJQUF4QixFQUE4QjtBQUM1QjRVLElBQUFBLElBQUksQ0FBQzBiLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxXQUFPLFFBQVA7QUFDRDs7QUFDRCxNQUFJMWIsSUFBSSxDQUFDMGIsUUFBTCxHQUFnQixDQUFoQixJQUFxQnR3QixHQUFHLENBQUM5UyxNQUFKLEdBQWEsQ0FBdEMsRUFBeUM7QUFDdkMsUUFBSSxDQUFDOFMsR0FBRyxDQUFDLENBQUQsQ0FBSCxHQUFTLElBQVYsTUFBb0IsSUFBeEIsRUFBOEI7QUFDNUI0VSxNQUFBQSxJQUFJLENBQUMwYixRQUFMLEdBQWdCLENBQWhCO0FBQ0EsYUFBTyxRQUFQO0FBQ0Q7O0FBQ0QsUUFBSTFiLElBQUksQ0FBQzBiLFFBQUwsR0FBZ0IsQ0FBaEIsSUFBcUJ0d0IsR0FBRyxDQUFDOVMsTUFBSixHQUFhLENBQXRDLEVBQXlDO0FBQ3ZDLFVBQUksQ0FBQzhTLEdBQUcsQ0FBQyxDQUFELENBQUgsR0FBUyxJQUFWLE1BQW9CLElBQXhCLEVBQThCO0FBQzVCNFUsUUFBQUEsSUFBSSxDQUFDMGIsUUFBTCxHQUFnQixDQUFoQjtBQUNBLGVBQU8sUUFBUDtBQUNEO0FBQ0Y7QUFDRjtBQUNGLEVBRUQ7OztBQUNBLFNBQVNMLFlBQVQsQ0FBc0Jqd0IsR0FBdEIsRUFBMkI7QUFDekIsTUFBSUQsQ0FBQyxHQUFHLEtBQUt3d0IsU0FBTCxHQUFpQixLQUFLRCxRQUE5QjtBQUNBLE1BQUlHLENBQUMsR0FBR00sbUJBQW1CLENBQUMsSUFBRCxFQUFPL3dCLEdBQVAsRUFBWUQsQ0FBWixDQUEzQjtBQUNBLE1BQUkwd0IsQ0FBQyxLQUFLbG9DLFNBQVYsRUFBcUIsT0FBT2tvQyxDQUFQOztBQUNyQixNQUFJLEtBQUtILFFBQUwsSUFBaUJ0d0IsR0FBRyxDQUFDOVMsTUFBekIsRUFBaUM7QUFDL0I4UyxJQUFBQSxHQUFHLENBQUMrRSxJQUFKLENBQVMsS0FBS3lyQixRQUFkLEVBQXdCendCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCLEtBQUt1d0IsUUFBbkM7QUFDQSxXQUFPLEtBQUtFLFFBQUwsQ0FBY2x0QyxRQUFkLENBQXVCLEtBQUt1WSxRQUE1QixFQUFzQyxDQUF0QyxFQUF5QyxLQUFLMDBCLFNBQTlDLENBQVA7QUFDRDs7QUFDRHZ3QixFQUFBQSxHQUFHLENBQUMrRSxJQUFKLENBQVMsS0FBS3lyQixRQUFkLEVBQXdCendCLENBQXhCLEVBQTJCLENBQTNCLEVBQThCQyxHQUFHLENBQUM5UyxNQUFsQztBQUNBLE9BQUtvakMsUUFBTCxJQUFpQnR3QixHQUFHLENBQUM5UyxNQUFyQjtBQUNELEVBRUQ7QUFDQTtBQUNBOzs7QUFDQSxTQUFTeWpDLFFBQVQsQ0FBa0Izd0IsR0FBbEIsRUFBdUJoTixDQUF2QixFQUEwQjtBQUN4QixNQUFJZytCLEtBQUssR0FBR0YsbUJBQW1CLENBQUMsSUFBRCxFQUFPOXdCLEdBQVAsRUFBWWhOLENBQVosQ0FBL0I7QUFDQSxNQUFJLENBQUMsS0FBS3M5QixRQUFWLEVBQW9CLE9BQU90d0IsR0FBRyxDQUFDMWMsUUFBSixDQUFhLE1BQWIsRUFBcUIwUCxDQUFyQixDQUFQO0FBQ3BCLE9BQUt1OUIsU0FBTCxHQUFpQlMsS0FBakI7QUFDQSxNQUFJMzJCLEdBQUcsR0FBRzJGLEdBQUcsQ0FBQzlTLE1BQUosSUFBYzhqQyxLQUFLLEdBQUcsS0FBS1YsUUFBM0IsQ0FBVjtBQUNBdHdCLEVBQUFBLEdBQUcsQ0FBQytFLElBQUosQ0FBUyxLQUFLeXJCLFFBQWQsRUFBd0IsQ0FBeEIsRUFBMkJuMkIsR0FBM0I7QUFDQSxTQUFPMkYsR0FBRyxDQUFDMWMsUUFBSixDQUFhLE1BQWIsRUFBcUIwUCxDQUFyQixFQUF3QnFILEdBQXhCLENBQVA7QUFDRCxFQUVEO0FBQ0E7OztBQUNBLFNBQVNxMkIsT0FBVCxDQUFpQjF3QixHQUFqQixFQUFzQjtBQUNwQixNQUFJeXdCLENBQUMsR0FBR3p3QixHQUFHLElBQUlBLEdBQUcsQ0FBQzlTLE1BQVgsR0FBb0IsS0FBSzBHLEtBQUwsQ0FBV29NLEdBQVgsQ0FBcEIsR0FBc0MsRUFBOUM7QUFDQSxNQUFJLEtBQUtzd0IsUUFBVCxFQUFtQixPQUFPRyxDQUFDLEdBQUcsUUFBWDtBQUNuQixTQUFPQSxDQUFQO0FBQ0QsRUFFRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0EsU0FBU1gsU0FBVCxDQUFtQjl2QixHQUFuQixFQUF3QmhOLENBQXhCLEVBQTJCO0FBQ3pCLE1BQUksQ0FBQ2dOLEdBQUcsQ0FBQzlTLE1BQUosR0FBYThGLENBQWQsSUFBbUIsQ0FBbkIsS0FBeUIsQ0FBN0IsRUFBZ0M7QUFDOUIsUUFBSXk5QixDQUFDLEdBQUd6d0IsR0FBRyxDQUFDMWMsUUFBSixDQUFhLFNBQWIsRUFBd0IwUCxDQUF4QixDQUFSOztBQUNBLFFBQUl5OUIsQ0FBSixFQUFPO0FBQ0wsVUFBSWpsQyxDQUFDLEdBQUdpbEMsQ0FBQyxDQUFDejNCLFVBQUYsQ0FBYXkzQixDQUFDLENBQUN2akMsTUFBRixHQUFXLENBQXhCLENBQVI7O0FBQ0EsVUFBSTFCLENBQUMsSUFBSSxNQUFMLElBQWVBLENBQUMsSUFBSSxNQUF4QixFQUFnQztBQUM5QixhQUFLOGtDLFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxhQUFLQyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsYUFBS0MsUUFBTCxDQUFjLENBQWQsSUFBbUJ4d0IsR0FBRyxDQUFDQSxHQUFHLENBQUM5UyxNQUFKLEdBQWEsQ0FBZCxDQUF0QjtBQUNBLGFBQUtzakMsUUFBTCxDQUFjLENBQWQsSUFBbUJ4d0IsR0FBRyxDQUFDQSxHQUFHLENBQUM5UyxNQUFKLEdBQWEsQ0FBZCxDQUF0QjtBQUNBLGVBQU91akMsQ0FBQyxDQUFDanRDLEtBQUYsQ0FBUSxDQUFSLEVBQVcsQ0FBQyxDQUFaLENBQVA7QUFDRDtBQUNGOztBQUNELFdBQU9pdEMsQ0FBUDtBQUNEOztBQUNELE9BQUtILFFBQUwsR0FBZ0IsQ0FBaEI7QUFDQSxPQUFLQyxTQUFMLEdBQWlCLENBQWpCO0FBQ0EsT0FBS0MsUUFBTCxDQUFjLENBQWQsSUFBbUJ4d0IsR0FBRyxDQUFDQSxHQUFHLENBQUM5UyxNQUFKLEdBQWEsQ0FBZCxDQUF0QjtBQUNBLFNBQU84UyxHQUFHLENBQUMxYyxRQUFKLENBQWEsU0FBYixFQUF3QjBQLENBQXhCLEVBQTJCZ04sR0FBRyxDQUFDOVMsTUFBSixHQUFhLENBQXhDLENBQVA7QUFDRCxFQUVEO0FBQ0E7OztBQUNBLFNBQVM2aUMsUUFBVCxDQUFrQi92QixHQUFsQixFQUF1QjtBQUNyQixNQUFJeXdCLENBQUMsR0FBR3p3QixHQUFHLElBQUlBLEdBQUcsQ0FBQzlTLE1BQVgsR0FBb0IsS0FBSzBHLEtBQUwsQ0FBV29NLEdBQVgsQ0FBcEIsR0FBc0MsRUFBOUM7O0FBQ0EsTUFBSSxLQUFLc3dCLFFBQVQsRUFBbUI7QUFDakIsUUFBSWoyQixHQUFHLEdBQUcsS0FBS2syQixTQUFMLEdBQWlCLEtBQUtELFFBQWhDO0FBQ0EsV0FBT0csQ0FBQyxHQUFHLEtBQUtELFFBQUwsQ0FBY2x0QyxRQUFkLENBQXVCLFNBQXZCLEVBQWtDLENBQWxDLEVBQXFDK1csR0FBckMsQ0FBWDtBQUNEOztBQUNELFNBQU9vMkIsQ0FBUDtBQUNEOztBQUVELFNBQVNQLFVBQVQsQ0FBb0Jsd0IsR0FBcEIsRUFBeUJoTixDQUF6QixFQUE0QjtBQUMxQixNQUFJa04sQ0FBQyxHQUFHLENBQUNGLEdBQUcsQ0FBQzlTLE1BQUosR0FBYThGLENBQWQsSUFBbUIsQ0FBM0I7QUFDQSxNQUFJa04sQ0FBQyxLQUFLLENBQVYsRUFBYSxPQUFPRixHQUFHLENBQUMxYyxRQUFKLENBQWEsUUFBYixFQUF1QjBQLENBQXZCLENBQVA7QUFDYixPQUFLczlCLFFBQUwsR0FBZ0IsSUFBSXB3QixDQUFwQjtBQUNBLE9BQUtxd0IsU0FBTCxHQUFpQixDQUFqQjs7QUFDQSxNQUFJcndCLENBQUMsS0FBSyxDQUFWLEVBQWE7QUFDWCxTQUFLc3dCLFFBQUwsQ0FBYyxDQUFkLElBQW1CeHdCLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDOVMsTUFBSixHQUFhLENBQWQsQ0FBdEI7QUFDRCxHQUZELE1BRU87QUFDTCxTQUFLc2pDLFFBQUwsQ0FBYyxDQUFkLElBQW1CeHdCLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDOVMsTUFBSixHQUFhLENBQWQsQ0FBdEI7QUFDQSxTQUFLc2pDLFFBQUwsQ0FBYyxDQUFkLElBQW1CeHdCLEdBQUcsQ0FBQ0EsR0FBRyxDQUFDOVMsTUFBSixHQUFhLENBQWQsQ0FBdEI7QUFDRDs7QUFDRCxTQUFPOFMsR0FBRyxDQUFDMWMsUUFBSixDQUFhLFFBQWIsRUFBdUIwUCxDQUF2QixFQUEwQmdOLEdBQUcsQ0FBQzlTLE1BQUosR0FBYWdULENBQXZDLENBQVA7QUFDRDs7QUFFRCxTQUFTaXdCLFNBQVQsQ0FBbUJud0IsR0FBbkIsRUFBd0I7QUFDdEIsTUFBSXl3QixDQUFDLEdBQUd6d0IsR0FBRyxJQUFJQSxHQUFHLENBQUM5UyxNQUFYLEdBQW9CLEtBQUswRyxLQUFMLENBQVdvTSxHQUFYLENBQXBCLEdBQXNDLEVBQTlDO0FBQ0EsTUFBSSxLQUFLc3dCLFFBQVQsRUFBbUIsT0FBT0csQ0FBQyxHQUFHLEtBQUtELFFBQUwsQ0FBY2x0QyxRQUFkLENBQXVCLFFBQXZCLEVBQWlDLENBQWpDLEVBQW9DLElBQUksS0FBS2d0QyxRQUE3QyxDQUFYO0FBQ25CLFNBQU9HLENBQVA7QUFDRCxFQUVEOzs7QUFDQSxTQUFTTCxXQUFULENBQXFCcHdCLEdBQXJCLEVBQTBCO0FBQ3hCLFNBQU9BLEdBQUcsQ0FBQzFjLFFBQUosQ0FBYSxLQUFLdVksUUFBbEIsQ0FBUDtBQUNEOztBQUVELFNBQVN3MEIsU0FBVCxDQUFtQnJ3QixHQUFuQixFQUF3QjtBQUN0QixTQUFPQSxHQUFHLElBQUlBLEdBQUcsQ0FBQzlTLE1BQVgsR0FBb0IsS0FBSzBHLEtBQUwsQ0FBV29NLEdBQVgsQ0FBcEIsR0FBc0MsRUFBN0M7QUFDRDs7Ozs7Ozs7Ozs7OztBQ3ZTRDtBQUNBOztBQUFFLFdBQVNpeEIsSUFBVCxFQUFlO0FBRWhCO0FBQ0EsTUFBSUMsV0FBVyxHQUFHLHNCQUFPMXVDLE9BQVAsTUFBa0IsUUFBbEIsSUFBOEJBLE9BQTlCLElBQ2pCLENBQUNBLE9BQU8sQ0FBQzJ1QyxRQURRLElBQ0kzdUMsT0FEdEI7QUFFQSxNQUFJNHVDLFVBQVUsR0FBRyxzQkFBT2h0QyxNQUFQLE1BQWlCLFFBQWpCLElBQTZCQSxNQUE3QixJQUNoQixDQUFDQSxNQUFNLENBQUMrc0MsUUFEUSxJQUNJL3NDLE1BRHJCO0FBRUEsTUFBSWl0QyxVQUFVLEdBQUcsUUFBTy9YLHFCQUFQLHlDQUFPQSxxQkFBUCxNQUFpQixRQUFqQixJQUE2QkEscUJBQTlDOztBQUNBLE1BQ0MrWCxVQUFVLENBQUMvWCxNQUFYLEtBQXNCK1gsVUFBdEIsSUFDQUEsVUFBVSxDQUFDdjdCLE1BQVgsS0FBc0J1N0IsVUFEdEIsSUFFQUEsVUFBVSxDQUFDemMsSUFBWCxLQUFvQnljLFVBSHJCLEVBSUU7QUFDREosSUFBQUEsSUFBSSxHQUFHSSxVQUFQO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQyxNQUFJQyxRQUFKOztBQUVBO0FBQ0FDLEVBQUFBLE1BQU0sR0FBRyxVQUhUO0FBQUEsTUFHcUI7O0FBRXJCO0FBQ0FDLEVBQUFBLElBQUksR0FBRyxFQU5QO0FBQUEsTUFPQUMsSUFBSSxHQUFHLENBUFA7QUFBQSxNQVFBQyxJQUFJLEdBQUcsRUFSUDtBQUFBLE1BU0FDLElBQUksR0FBRyxFQVRQO0FBQUEsTUFVQUMsSUFBSSxHQUFHLEdBVlA7QUFBQSxNQVdBQyxXQUFXLEdBQUcsRUFYZDtBQUFBLE1BWUFDLFFBQVEsR0FBRyxHQVpYO0FBQUEsTUFZZ0I7QUFDaEJDLEVBQUFBLFNBQVMsR0FBRyxHQWJaO0FBQUEsTUFhaUI7O0FBRWpCO0FBQ0FDLEVBQUFBLGFBQWEsR0FBRyxPQWhCaEI7QUFBQSxNQWlCQUMsYUFBYSxHQUFHLGNBakJoQjtBQUFBLE1BaUJnQztBQUNoQ0MsRUFBQUEsZUFBZSxHQUFHLDJCQWxCbEI7QUFBQSxNQWtCK0M7O0FBRS9DO0FBQ0ExakIsRUFBQUEsTUFBTSxHQUFHO0FBQ1IsZ0JBQVksaURBREo7QUFFUixpQkFBYSxnREFGTDtBQUdSLHFCQUFpQjtBQUhULEdBckJUOztBQTJCQTtBQUNBMmpCLEVBQUFBLGFBQWEsR0FBR1gsSUFBSSxHQUFHQyxJQTVCdkI7QUFBQSxNQTZCQWxpQixLQUFLLEdBQUdwUyxJQUFJLENBQUNvUyxLQTdCYjtBQUFBLE1BOEJBNmlCLGtCQUFrQixHQUFHOXNCLE1BQU0sQ0FBQzRELFlBOUI1Qjs7QUFnQ0E7QUFDQXRnQixFQUFBQSxHQWpDQTtBQW1DQTs7QUFFQTtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0MsV0FBUzJFLEtBQVQsQ0FBZW9KLElBQWYsRUFBcUI7QUFDcEIsVUFBTTZNLFVBQVUsQ0FBQ2dMLE1BQU0sQ0FBQzdYLElBQUQsQ0FBUCxDQUFoQjtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3FILEdBQVQsQ0FBYTZHLEtBQWIsRUFBb0I1VyxFQUFwQixFQUF3QjtBQUN2QixRQUFJZixNQUFNLEdBQUcyWCxLQUFLLENBQUMzWCxNQUFuQjtBQUNBLFFBQUkySyxNQUFNLEdBQUcsRUFBYjs7QUFDQSxXQUFPM0ssTUFBTSxFQUFiLEVBQWlCO0FBQ2hCMkssTUFBQUEsTUFBTSxDQUFDM0ssTUFBRCxDQUFOLEdBQWlCZSxFQUFFLENBQUM0VyxLQUFLLENBQUMzWCxNQUFELENBQU4sQ0FBbkI7QUFDQTs7QUFDRCxXQUFPMkssTUFBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUNDLFdBQVN3NkIsU0FBVCxDQUFtQjV0QixNQUFuQixFQUEyQnhXLEVBQTNCLEVBQStCO0FBQzlCLFFBQUlpRixLQUFLLEdBQUd1UixNQUFNLENBQUNwTyxLQUFQLENBQWEsR0FBYixDQUFaO0FBQ0EsUUFBSXdCLE1BQU0sR0FBRyxFQUFiOztBQUNBLFFBQUkzRSxLQUFLLENBQUNoRyxNQUFOLEdBQWUsQ0FBbkIsRUFBc0I7QUFDckI7QUFDQTtBQUNBMkssTUFBQUEsTUFBTSxHQUFHM0UsS0FBSyxDQUFDLENBQUQsQ0FBTCxHQUFXLEdBQXBCO0FBQ0F1UixNQUFBQSxNQUFNLEdBQUd2UixLQUFLLENBQUMsQ0FBRCxDQUFkO0FBQ0EsS0FSNkIsQ0FTOUI7OztBQUNBdVIsSUFBQUEsTUFBTSxHQUFHQSxNQUFNLENBQUNoWCxPQUFQLENBQWV5a0MsZUFBZixFQUFnQyxNQUFoQyxDQUFUO0FBQ0EsUUFBSUksTUFBTSxHQUFHN3RCLE1BQU0sQ0FBQ3BPLEtBQVAsQ0FBYSxHQUFiLENBQWI7QUFDQSxRQUFJazhCLE9BQU8sR0FBR3YwQixHQUFHLENBQUNzMEIsTUFBRCxFQUFTcmtDLEVBQVQsQ0FBSCxDQUFnQnVGLElBQWhCLENBQXFCLEdBQXJCLENBQWQ7QUFDQSxXQUFPcUUsTUFBTSxHQUFHMDZCLE9BQWhCO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU0MsVUFBVCxDQUFvQi90QixNQUFwQixFQUE0QjtBQUMzQixRQUFJbkssTUFBTSxHQUFHLEVBQWI7QUFBQSxRQUNJbTRCLE9BQU8sR0FBRyxDQURkO0FBQUEsUUFFSXZsQyxNQUFNLEdBQUd1WCxNQUFNLENBQUN2WCxNQUZwQjtBQUFBLFFBR0l6SyxLQUhKO0FBQUEsUUFJSWl3QyxLQUpKOztBQUtBLFdBQU9ELE9BQU8sR0FBR3ZsQyxNQUFqQixFQUF5QjtBQUN4QnpLLE1BQUFBLEtBQUssR0FBR2dpQixNQUFNLENBQUN6TCxVQUFQLENBQWtCeTVCLE9BQU8sRUFBekIsQ0FBUjs7QUFDQSxVQUFJaHdDLEtBQUssSUFBSSxNQUFULElBQW1CQSxLQUFLLElBQUksTUFBNUIsSUFBc0Nnd0MsT0FBTyxHQUFHdmxDLE1BQXBELEVBQTREO0FBQzNEO0FBQ0F3bEMsUUFBQUEsS0FBSyxHQUFHanVCLE1BQU0sQ0FBQ3pMLFVBQVAsQ0FBa0J5NUIsT0FBTyxFQUF6QixDQUFSOztBQUNBLFlBQUksQ0FBQ0MsS0FBSyxHQUFHLE1BQVQsS0FBb0IsTUFBeEIsRUFBZ0M7QUFBRTtBQUNqQ3A0QixVQUFBQSxNQUFNLENBQUN6TixJQUFQLENBQVksQ0FBQyxDQUFDcEssS0FBSyxHQUFHLEtBQVQsS0FBbUIsRUFBcEIsS0FBMkJpd0MsS0FBSyxHQUFHLEtBQW5DLElBQTRDLE9BQXhEO0FBQ0EsU0FGRCxNQUVPO0FBQ047QUFDQTtBQUNBcDRCLFVBQUFBLE1BQU0sQ0FBQ3pOLElBQVAsQ0FBWXBLLEtBQVo7QUFDQWd3QyxVQUFBQSxPQUFPO0FBQ1A7QUFDRCxPQVhELE1BV087QUFDTm40QixRQUFBQSxNQUFNLENBQUN6TixJQUFQLENBQVlwSyxLQUFaO0FBQ0E7QUFDRDs7QUFDRCxXQUFPNlgsTUFBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3E0QixVQUFULENBQW9COXRCLEtBQXBCLEVBQTJCO0FBQzFCLFdBQU83RyxHQUFHLENBQUM2RyxLQUFELEVBQVEsVUFBU3BpQixLQUFULEVBQWdCO0FBQ2pDLFVBQUk2WCxNQUFNLEdBQUcsRUFBYjs7QUFDQSxVQUFJN1gsS0FBSyxHQUFHLE1BQVosRUFBb0I7QUFDbkJBLFFBQUFBLEtBQUssSUFBSSxPQUFUO0FBQ0E2WCxRQUFBQSxNQUFNLElBQUk4M0Isa0JBQWtCLENBQUMzdkMsS0FBSyxLQUFLLEVBQVYsR0FBZSxLQUFmLEdBQXVCLE1BQXhCLENBQTVCO0FBQ0FBLFFBQUFBLEtBQUssR0FBRyxTQUFTQSxLQUFLLEdBQUcsS0FBekI7QUFDQTs7QUFDRDZYLE1BQUFBLE1BQU0sSUFBSTgzQixrQkFBa0IsQ0FBQzN2QyxLQUFELENBQTVCO0FBQ0EsYUFBTzZYLE1BQVA7QUFDQSxLQVRTLENBQUgsQ0FTSjlHLElBVEksQ0FTQyxFQVRELENBQVA7QUFVQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU28vQixZQUFULENBQXNCbnFCLFNBQXRCLEVBQWlDO0FBQ2hDLFFBQUlBLFNBQVMsR0FBRyxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLGFBQU9BLFNBQVMsR0FBRyxFQUFuQjtBQUNBOztBQUNELFFBQUlBLFNBQVMsR0FBRyxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLGFBQU9BLFNBQVMsR0FBRyxFQUFuQjtBQUNBOztBQUNELFFBQUlBLFNBQVMsR0FBRyxFQUFaLEdBQWlCLEVBQXJCLEVBQXlCO0FBQ3hCLGFBQU9BLFNBQVMsR0FBRyxFQUFuQjtBQUNBOztBQUNELFdBQU8rb0IsSUFBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3FCLFlBQVQsQ0FBc0JDLEtBQXRCLEVBQTZCQyxJQUE3QixFQUFtQztBQUNsQztBQUNBO0FBQ0EsV0FBT0QsS0FBSyxHQUFHLEVBQVIsR0FBYSxNQUFNQSxLQUFLLEdBQUcsRUFBZCxDQUFiLElBQWtDLENBQUNDLElBQUksSUFBSSxDQUFULEtBQWUsQ0FBakQsQ0FBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU0MsS0FBVCxDQUFlQyxLQUFmLEVBQXNCQyxTQUF0QixFQUFpQ0MsU0FBakMsRUFBNEM7QUFDM0MsUUFBSTFjLENBQUMsR0FBRyxDQUFSO0FBQ0F3YyxJQUFBQSxLQUFLLEdBQUdFLFNBQVMsR0FBRzVqQixLQUFLLENBQUMwakIsS0FBSyxHQUFHckIsSUFBVCxDQUFSLEdBQXlCcUIsS0FBSyxJQUFJLENBQW5EO0FBQ0FBLElBQUFBLEtBQUssSUFBSTFqQixLQUFLLENBQUMwakIsS0FBSyxHQUFHQyxTQUFULENBQWQ7O0FBQ0EsV0FBOEJELEtBQUssR0FBR2QsYUFBYSxHQUFHVCxJQUFoQixJQUF3QixDQUE5RCxFQUFpRWpiLENBQUMsSUFBSSthLElBQXRFLEVBQTRFO0FBQzNFeUIsTUFBQUEsS0FBSyxHQUFHMWpCLEtBQUssQ0FBQzBqQixLQUFLLEdBQUdkLGFBQVQsQ0FBYjtBQUNBOztBQUNELFdBQU81aUIsS0FBSyxDQUFDa0gsQ0FBQyxHQUFHLENBQUMwYixhQUFhLEdBQUcsQ0FBakIsSUFBc0JjLEtBQXRCLElBQStCQSxLQUFLLEdBQUd0QixJQUF2QyxDQUFMLENBQVo7QUFDQTtBQUVEO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQyxXQUFTM3RDLE1BQVQsQ0FBZ0J1YixLQUFoQixFQUF1QjtBQUN0QjtBQUNBLFFBQUlqRixNQUFNLEdBQUcsRUFBYjtBQUFBLFFBQ0k4NEIsV0FBVyxHQUFHN3pCLEtBQUssQ0FBQ3JTLE1BRHhCO0FBQUEsUUFFSStVLEdBRko7QUFBQSxRQUdJalAsQ0FBQyxHQUFHLENBSFI7QUFBQSxRQUlJa04sQ0FBQyxHQUFHNHhCLFFBSlI7QUFBQSxRQUtJdUIsSUFBSSxHQUFHeEIsV0FMWDtBQUFBLFFBTUl5QixLQU5KO0FBQUEsUUFPSTlyQixDQVBKO0FBQUEsUUFRSTRNLEtBUko7QUFBQSxRQVNJbWYsSUFUSjtBQUFBLFFBVUkxMUIsQ0FWSjtBQUFBLFFBV0k0WSxDQVhKO0FBQUEsUUFZSXFjLEtBWko7QUFBQSxRQWFJanhCLENBYko7O0FBY0k7QUFDQTJ4QixJQUFBQSxVQWZKLENBRnNCLENBbUJ0QjtBQUNBO0FBQ0E7O0FBRUFGLElBQUFBLEtBQUssR0FBRy96QixLQUFLLENBQUNwRCxXQUFOLENBQWtCNDFCLFNBQWxCLENBQVI7O0FBQ0EsUUFBSXVCLEtBQUssR0FBRyxDQUFaLEVBQWU7QUFDZEEsTUFBQUEsS0FBSyxHQUFHLENBQVI7QUFDQTs7QUFFRCxTQUFLOXJCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzhyQixLQUFoQixFQUF1QixFQUFFOXJCLENBQXpCLEVBQTRCO0FBQzNCO0FBQ0EsVUFBSWpJLEtBQUssQ0FBQ3ZHLFVBQU4sQ0FBaUJ3TyxDQUFqQixLQUF1QixJQUEzQixFQUFpQztBQUNoQ2phLFFBQUFBLEtBQUssQ0FBQyxXQUFELENBQUw7QUFDQTs7QUFDRCtNLE1BQUFBLE1BQU0sQ0FBQ3pOLElBQVAsQ0FBWTBTLEtBQUssQ0FBQ3ZHLFVBQU4sQ0FBaUJ3TyxDQUFqQixDQUFaO0FBQ0EsS0FsQ3FCLENBb0N0QjtBQUNBOzs7QUFFQSxTQUFLNE0sS0FBSyxHQUFHa2YsS0FBSyxHQUFHLENBQVIsR0FBWUEsS0FBSyxHQUFHLENBQXBCLEdBQXdCLENBQXJDLEVBQXdDbGYsS0FBSyxHQUFHZ2YsV0FBaEQsR0FBd0Y7QUFFdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQUtHLElBQUksR0FBR3ZnQyxDQUFQLEVBQVU2SyxDQUFDLEdBQUcsQ0FBZCxFQUFpQjRZLENBQUMsR0FBRythLElBQTFCLEdBQW9EL2EsQ0FBQyxJQUFJK2EsSUFBekQsRUFBK0Q7QUFFOUQsWUFBSXBkLEtBQUssSUFBSWdmLFdBQWIsRUFBMEI7QUFDekI3bEMsVUFBQUEsS0FBSyxDQUFDLGVBQUQsQ0FBTDtBQUNBOztBQUVEdWxDLFFBQUFBLEtBQUssR0FBR0YsWUFBWSxDQUFDcnpCLEtBQUssQ0FBQ3ZHLFVBQU4sQ0FBaUJvYixLQUFLLEVBQXRCLENBQUQsQ0FBcEI7O0FBRUEsWUFBSTBlLEtBQUssSUFBSXRCLElBQVQsSUFBaUJzQixLQUFLLEdBQUd2akIsS0FBSyxDQUFDLENBQUNnaUIsTUFBTSxHQUFHditCLENBQVYsSUFBZTZLLENBQWhCLENBQWxDLEVBQXNEO0FBQ3JEdFEsVUFBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTDtBQUNBOztBQUVEeUYsUUFBQUEsQ0FBQyxJQUFJOC9CLEtBQUssR0FBR2oxQixDQUFiO0FBQ0FnRSxRQUFBQSxDQUFDLEdBQUc0VSxDQUFDLElBQUk0YyxJQUFMLEdBQVk1QixJQUFaLEdBQW9CaGIsQ0FBQyxJQUFJNGMsSUFBSSxHQUFHM0IsSUFBWixHQUFtQkEsSUFBbkIsR0FBMEJqYixDQUFDLEdBQUc0YyxJQUF0RDs7QUFFQSxZQUFJUCxLQUFLLEdBQUdqeEIsQ0FBWixFQUFlO0FBQ2Q7QUFDQTs7QUFFRDJ4QixRQUFBQSxVQUFVLEdBQUdoQyxJQUFJLEdBQUczdkIsQ0FBcEI7O0FBQ0EsWUFBSWhFLENBQUMsR0FBRzBSLEtBQUssQ0FBQ2dpQixNQUFNLEdBQUdpQyxVQUFWLENBQWIsRUFBb0M7QUFDbkNqbUMsVUFBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTDtBQUNBOztBQUVEc1EsUUFBQUEsQ0FBQyxJQUFJMjFCLFVBQUw7QUFFQTs7QUFFRHZ4QixNQUFBQSxHQUFHLEdBQUczSCxNQUFNLENBQUNwTixNQUFQLEdBQWdCLENBQXRCO0FBQ0FtbUMsTUFBQUEsSUFBSSxHQUFHTCxLQUFLLENBQUNoZ0MsQ0FBQyxHQUFHdWdDLElBQUwsRUFBV3R4QixHQUFYLEVBQWdCc3hCLElBQUksSUFBSSxDQUF4QixDQUFaLENBcEN1RixDQXNDdkY7QUFDQTs7QUFDQSxVQUFJaGtCLEtBQUssQ0FBQ3ZjLENBQUMsR0FBR2lQLEdBQUwsQ0FBTCxHQUFpQnN2QixNQUFNLEdBQUdyeEIsQ0FBOUIsRUFBaUM7QUFDaEMzUyxRQUFBQSxLQUFLLENBQUMsVUFBRCxDQUFMO0FBQ0E7O0FBRUQyUyxNQUFBQSxDQUFDLElBQUlxUCxLQUFLLENBQUN2YyxDQUFDLEdBQUdpUCxHQUFMLENBQVY7QUFDQWpQLE1BQUFBLENBQUMsSUFBSWlQLEdBQUwsQ0E3Q3VGLENBK0N2Rjs7QUFDQTNILE1BQUFBLE1BQU0sQ0FBQ3lrQixNQUFQLENBQWMvckIsQ0FBQyxFQUFmLEVBQW1CLENBQW5CLEVBQXNCa04sQ0FBdEI7QUFFQTs7QUFFRCxXQUFPeXlCLFVBQVUsQ0FBQ3I0QixNQUFELENBQWpCO0FBQ0E7QUFFRDtBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU25YLE1BQVQsQ0FBZ0JvYyxLQUFoQixFQUF1QjtBQUN0QixRQUFJVyxDQUFKO0FBQUEsUUFDSSt5QixLQURKO0FBQUEsUUFFSVEsY0FGSjtBQUFBLFFBR0lDLFdBSEo7QUFBQSxRQUlJTCxJQUpKO0FBQUEsUUFLSTdyQixDQUxKO0FBQUEsUUFNSXhHLENBTko7QUFBQSxRQU9JMnlCLENBUEo7QUFBQSxRQVFJbGQsQ0FSSjtBQUFBLFFBU0k1VSxDQVRKO0FBQUEsUUFVSSt4QixZQVZKO0FBQUEsUUFXSXQ1QixNQUFNLEdBQUcsRUFYYjs7QUFZSTtBQUNBODRCLElBQUFBLFdBYko7O0FBY0k7QUFDQVMsSUFBQUEscUJBZko7QUFBQSxRQWdCSUwsVUFoQko7QUFBQSxRQWlCSU0sT0FqQkosQ0FEc0IsQ0FvQnRCOztBQUNBdjBCLElBQUFBLEtBQUssR0FBR2l6QixVQUFVLENBQUNqekIsS0FBRCxDQUFsQixDQXJCc0IsQ0F1QnRCOztBQUNBNnpCLElBQUFBLFdBQVcsR0FBRzd6QixLQUFLLENBQUNyUyxNQUFwQixDQXhCc0IsQ0EwQnRCOztBQUNBZ1QsSUFBQUEsQ0FBQyxHQUFHNHhCLFFBQUo7QUFDQW1CLElBQUFBLEtBQUssR0FBRyxDQUFSO0FBQ0FJLElBQUFBLElBQUksR0FBR3hCLFdBQVAsQ0E3QnNCLENBK0J0Qjs7QUFDQSxTQUFLcnFCLENBQUMsR0FBRyxDQUFULEVBQVlBLENBQUMsR0FBRzRyQixXQUFoQixFQUE2QixFQUFFNXJCLENBQS9CLEVBQWtDO0FBQ2pDb3NCLE1BQUFBLFlBQVksR0FBR3IwQixLQUFLLENBQUNpSSxDQUFELENBQXBCOztBQUNBLFVBQUlvc0IsWUFBWSxHQUFHLElBQW5CLEVBQXlCO0FBQ3hCdDVCLFFBQUFBLE1BQU0sQ0FBQ3pOLElBQVAsQ0FBWXVsQyxrQkFBa0IsQ0FBQ3dCLFlBQUQsQ0FBOUI7QUFDQTtBQUNEOztBQUVESCxJQUFBQSxjQUFjLEdBQUdDLFdBQVcsR0FBR3A1QixNQUFNLENBQUNwTixNQUF0QyxDQXZDc0IsQ0F5Q3RCO0FBQ0E7QUFFQTs7QUFDQSxRQUFJd21DLFdBQUosRUFBaUI7QUFDaEJwNUIsTUFBQUEsTUFBTSxDQUFDek4sSUFBUCxDQUFZa2xDLFNBQVo7QUFDQSxLQS9DcUIsQ0FpRHRCOzs7QUFDQSxXQUFPMEIsY0FBYyxHQUFHTCxXQUF4QixFQUFxQztBQUVwQztBQUNBO0FBQ0EsV0FBS3B5QixDQUFDLEdBQUd1d0IsTUFBSixFQUFZL3BCLENBQUMsR0FBRyxDQUFyQixFQUF3QkEsQ0FBQyxHQUFHNHJCLFdBQTVCLEVBQXlDLEVBQUU1ckIsQ0FBM0MsRUFBOEM7QUFDN0Nvc0IsUUFBQUEsWUFBWSxHQUFHcjBCLEtBQUssQ0FBQ2lJLENBQUQsQ0FBcEI7O0FBQ0EsWUFBSW9zQixZQUFZLElBQUkxekIsQ0FBaEIsSUFBcUIwekIsWUFBWSxHQUFHNXlCLENBQXhDLEVBQTJDO0FBQzFDQSxVQUFBQSxDQUFDLEdBQUc0eUIsWUFBSjtBQUNBO0FBQ0QsT0FUbUMsQ0FXcEM7QUFDQTs7O0FBQ0FDLE1BQUFBLHFCQUFxQixHQUFHSixjQUFjLEdBQUcsQ0FBekM7O0FBQ0EsVUFBSXp5QixDQUFDLEdBQUdkLENBQUosR0FBUXFQLEtBQUssQ0FBQyxDQUFDZ2lCLE1BQU0sR0FBRzBCLEtBQVYsSUFBbUJZLHFCQUFwQixDQUFqQixFQUE2RDtBQUM1RHRtQyxRQUFBQSxLQUFLLENBQUMsVUFBRCxDQUFMO0FBQ0E7O0FBRUQwbEMsTUFBQUEsS0FBSyxJQUFJLENBQUNqeUIsQ0FBQyxHQUFHZCxDQUFMLElBQVUyekIscUJBQW5CO0FBQ0EzekIsTUFBQUEsQ0FBQyxHQUFHYyxDQUFKOztBQUVBLFdBQUt3RyxDQUFDLEdBQUcsQ0FBVCxFQUFZQSxDQUFDLEdBQUc0ckIsV0FBaEIsRUFBNkIsRUFBRTVyQixDQUEvQixFQUFrQztBQUNqQ29zQixRQUFBQSxZQUFZLEdBQUdyMEIsS0FBSyxDQUFDaUksQ0FBRCxDQUFwQjs7QUFFQSxZQUFJb3NCLFlBQVksR0FBRzF6QixDQUFmLElBQW9CLEVBQUUreUIsS0FBRixHQUFVMUIsTUFBbEMsRUFBMEM7QUFDekNoa0MsVUFBQUEsS0FBSyxDQUFDLFVBQUQsQ0FBTDtBQUNBOztBQUVELFlBQUlxbUMsWUFBWSxJQUFJMXpCLENBQXBCLEVBQXVCO0FBQ3RCO0FBQ0EsZUFBS3l6QixDQUFDLEdBQUdWLEtBQUosRUFBV3hjLENBQUMsR0FBRythLElBQXBCLEdBQThDL2EsQ0FBQyxJQUFJK2EsSUFBbkQsRUFBeUQ7QUFDeEQzdkIsWUFBQUEsQ0FBQyxHQUFHNFUsQ0FBQyxJQUFJNGMsSUFBTCxHQUFZNUIsSUFBWixHQUFvQmhiLENBQUMsSUFBSTRjLElBQUksR0FBRzNCLElBQVosR0FBbUJBLElBQW5CLEdBQTBCamIsQ0FBQyxHQUFHNGMsSUFBdEQ7O0FBQ0EsZ0JBQUlNLENBQUMsR0FBRzl4QixDQUFSLEVBQVc7QUFDVjtBQUNBOztBQUNEaXlCLFlBQUFBLE9BQU8sR0FBR0gsQ0FBQyxHQUFHOXhCLENBQWQ7QUFDQTJ4QixZQUFBQSxVQUFVLEdBQUdoQyxJQUFJLEdBQUczdkIsQ0FBcEI7QUFDQXZILFlBQUFBLE1BQU0sQ0FBQ3pOLElBQVAsQ0FDQ3VsQyxrQkFBa0IsQ0FBQ1MsWUFBWSxDQUFDaHhCLENBQUMsR0FBR2l5QixPQUFPLEdBQUdOLFVBQWYsRUFBMkIsQ0FBM0IsQ0FBYixDQURuQjtBQUdBRyxZQUFBQSxDQUFDLEdBQUdwa0IsS0FBSyxDQUFDdWtCLE9BQU8sR0FBR04sVUFBWCxDQUFUO0FBQ0E7O0FBRURsNUIsVUFBQUEsTUFBTSxDQUFDek4sSUFBUCxDQUFZdWxDLGtCQUFrQixDQUFDUyxZQUFZLENBQUNjLENBQUQsRUFBSSxDQUFKLENBQWIsQ0FBOUI7QUFDQU4sVUFBQUEsSUFBSSxHQUFHTCxLQUFLLENBQUNDLEtBQUQsRUFBUVkscUJBQVIsRUFBK0JKLGNBQWMsSUFBSUMsV0FBakQsQ0FBWjtBQUNBVCxVQUFBQSxLQUFLLEdBQUcsQ0FBUjtBQUNBLFlBQUVRLGNBQUY7QUFDQTtBQUNEOztBQUVELFFBQUVSLEtBQUY7QUFDQSxRQUFFL3lCLENBQUY7QUFFQTs7QUFDRCxXQUFPNUYsTUFBTSxDQUFDOUcsSUFBUCxDQUFZLEVBQVosQ0FBUDtBQUNBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3VnQyxTQUFULENBQW1CeDBCLEtBQW5CLEVBQTBCO0FBQ3pCLFdBQU84eUIsU0FBUyxDQUFDOXlCLEtBQUQsRUFBUSxVQUFTa0YsTUFBVCxFQUFpQjtBQUN4QyxhQUFPdXRCLGFBQWEsQ0FBQ3A5QixJQUFkLENBQW1CNlAsTUFBbkIsSUFDSnpnQixNQUFNLENBQUN5Z0IsTUFBTSxDQUFDamhCLEtBQVAsQ0FBYSxDQUFiLEVBQWdCcUYsV0FBaEIsRUFBRCxDQURGLEdBRUo0YixNQUZIO0FBR0EsS0FKZSxDQUFoQjtBQUtBO0FBRUQ7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBQ0MsV0FBU3V2QixPQUFULENBQWlCejBCLEtBQWpCLEVBQXdCO0FBQ3ZCLFdBQU84eUIsU0FBUyxDQUFDOXlCLEtBQUQsRUFBUSxVQUFTa0YsTUFBVCxFQUFpQjtBQUN4QyxhQUFPd3RCLGFBQWEsQ0FBQ3I5QixJQUFkLENBQW1CNlAsTUFBbkIsSUFDSixTQUFTdGhCLE1BQU0sQ0FBQ3NoQixNQUFELENBRFgsR0FFSkEsTUFGSDtBQUdBLEtBSmUsQ0FBaEI7QUFLQTtBQUVEOztBQUVBOzs7QUFDQTZzQixFQUFBQSxRQUFRLEdBQUc7QUFDVjtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsZUFBVyxPQU5EOztBQU9WO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0UsWUFBUTtBQUNQLGdCQUFVa0IsVUFESDtBQUVQLGdCQUFVRztBQUZILEtBZEU7QUFrQlYsY0FBVTN1QyxNQWxCQTtBQW1CVixjQUFVYixNQW5CQTtBQW9CVixlQUFXNndDLE9BcEJEO0FBcUJWLGlCQUFhRDtBQXJCSCxHQUFYO0FBd0JBO0FBQ0E7QUFDQTs7QUFDQSxNQUNDLFNBQ0EsUUFBT0Usd0JBQVAsS0FBcUIsUUFEckIsSUFFQUEsd0JBSEQsRUFJRTtBQUNEQSxJQUFBQSxtQ0FBbUIsWUFBVztBQUM3QixhQUFPM0MsUUFBUDtBQUNBLEtBRks7QUFBQSxrR0FBTjtBQUdBLEdBUkQsTUFRTyxJQUFJSixXQUFXLElBQUlFLFVBQW5CLEVBQStCO0FBQ3JDLFFBQUlodEMsTUFBTSxDQUFDNUIsT0FBUCxJQUFrQjB1QyxXQUF0QixFQUFtQztBQUFFO0FBQ3BDRSxNQUFBQSxVQUFVLENBQUM1dUMsT0FBWCxHQUFxQjh1QyxRQUFyQjtBQUNBLEtBRkQsTUFFTztBQUFFO0FBQ1IsV0FBSzFvQyxHQUFMLElBQVkwb0MsUUFBWixFQUFzQjtBQUNyQkEsUUFBQUEsUUFBUSxDQUFDNTRCLGNBQVQsQ0FBd0I5UCxHQUF4QixNQUFpQ3NvQyxXQUFXLENBQUN0b0MsR0FBRCxDQUFYLEdBQW1CMG9DLFFBQVEsQ0FBQzFvQyxHQUFELENBQTVEO0FBQ0E7QUFDRDtBQUNELEdBUk0sTUFRQTtBQUFFO0FBQ1Jxb0MsSUFBQUEsSUFBSSxDQUFDSyxRQUFMLEdBQWdCQSxRQUFoQjtBQUNBO0FBRUQsQ0FoaEJDLEVBZ2hCQSxJQWhoQkEsQ0FBRDs7Ozs7Ozs7OztBQ0REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFYTs7OztBQUViLElBQUlBLFFBQVEsR0FBRzN1QyxtQkFBTyxDQUFDLHNFQUFELENBQXRCOztBQUNBLElBQUl3eEMsSUFBSSxHQUFHeHhDLG1CQUFPLENBQUMsMENBQUQsQ0FBbEI7O0FBRUFILGFBQUEsR0FBZ0I0eEMsUUFBaEI7QUFDQTV4QyxlQUFBLEdBQWtCNnhDLFVBQWxCO0FBQ0E3eEMscUJBQUEsR0FBd0IreEMsZ0JBQXhCO0FBQ0EveEMsY0FBQSxHQUFpQml5QyxTQUFqQjtBQUVBanlDLFdBQUEsR0FBY2t5QyxHQUFkOztBQUVBLFNBQVNBLEdBQVQsR0FBZTtBQUNiLE9BQUtuL0IsUUFBTCxHQUFnQixJQUFoQjtBQUNBLE9BQUtvL0IsT0FBTCxHQUFlLElBQWY7QUFDQSxPQUFLaHZDLElBQUwsR0FBWSxJQUFaO0FBQ0EsT0FBSzZQLElBQUwsR0FBWSxJQUFaO0FBQ0EsT0FBS0csSUFBTCxHQUFZLElBQVo7QUFDQSxPQUFLRCxRQUFMLEdBQWdCLElBQWhCO0FBQ0EsT0FBS2pTLElBQUwsR0FBWSxJQUFaO0FBQ0EsT0FBS2dTLE1BQUwsR0FBYyxJQUFkO0FBQ0EsT0FBS20vQixLQUFMLEdBQWEsSUFBYjtBQUNBLE9BQUtoL0IsUUFBTCxHQUFnQixJQUFoQjtBQUNBLE9BQUs5QixJQUFMLEdBQVksSUFBWjtBQUNBLE9BQUt1QixJQUFMLEdBQVksSUFBWjtBQUNELEVBRUQ7QUFFQTtBQUNBOzs7QUFDQSxJQUFJdy9CLGVBQWUsR0FBRyxtQkFBdEI7QUFBQSxJQUNJQyxXQUFXLEdBQUcsVUFEbEI7QUFBQSxJQUdJO0FBQ0FDLGlCQUFpQixHQUFHLG9DQUp4QjtBQUFBLElBTUk7QUFDQTtBQUNBQyxNQUFNLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsRUFBZ0IsR0FBaEIsRUFBcUIsR0FBckIsRUFBMEIsSUFBMUIsRUFBZ0MsSUFBaEMsRUFBc0MsSUFBdEMsQ0FSYjtBQUFBLElBVUk7QUFDQUMsTUFBTSxHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLElBQWhCLEVBQXNCLEdBQXRCLEVBQTJCLEdBQTNCLEVBQWdDaG9DLE1BQWhDLENBQXVDK25DLE1BQXZDLENBWGI7QUFBQSxJQWFJO0FBQ0FFLFVBQVUsR0FBRyxDQUFDLElBQUQsRUFBT2pvQyxNQUFQLENBQWNnb0MsTUFBZCxDQWRqQjtBQUFBLElBZUk7QUFDQTtBQUNBO0FBQ0E7QUFDQUUsWUFBWSxHQUFHLENBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxHQUFYLEVBQWdCLEdBQWhCLEVBQXFCLEdBQXJCLEVBQTBCbG9DLE1BQTFCLENBQWlDaW9DLFVBQWpDLENBbkJuQjtBQUFBLElBb0JJRSxlQUFlLEdBQUcsQ0FBQyxHQUFELEVBQU0sR0FBTixFQUFXLEdBQVgsQ0FwQnRCO0FBQUEsSUFxQklDLGNBQWMsR0FBRyxHQXJCckI7QUFBQSxJQXNCSUMsbUJBQW1CLEdBQUcsd0JBdEIxQjtBQUFBLElBdUJJQyxpQkFBaUIsR0FBRyw4QkF2QnhCO0FBQUEsSUF3Qkk7QUFDQUMsY0FBYyxHQUFHO0FBQ2YsZ0JBQWMsSUFEQztBQUVmLGlCQUFlO0FBRkEsQ0F6QnJCO0FBQUEsSUE2Qkk7QUFDQUMsZ0JBQWdCLEdBQUc7QUFDakIsZ0JBQWMsSUFERztBQUVqQixpQkFBZTtBQUZFLENBOUJ2QjtBQUFBLElBa0NJO0FBQ0FDLGVBQWUsR0FBRztBQUNoQixVQUFRLElBRFE7QUFFaEIsV0FBUyxJQUZPO0FBR2hCLFNBQU8sSUFIUztBQUloQixZQUFVLElBSk07QUFLaEIsVUFBUSxJQUxRO0FBTWhCLFdBQVMsSUFOTztBQU9oQixZQUFVLElBUE07QUFRaEIsVUFBUSxJQVJRO0FBU2hCLGFBQVcsSUFUSztBQVVoQixXQUFTO0FBVk8sQ0FuQ3RCO0FBQUEsSUErQ0lDLFdBQVcsR0FBR2h6QyxtQkFBTyxDQUFDLHdEQUFELENBL0N6Qjs7QUFpREEsU0FBU3l4QyxRQUFULENBQWtCaHVDLEdBQWxCLEVBQXVCd3ZDLGdCQUF2QixFQUF5Q0MsaUJBQXpDLEVBQTREO0FBQzFELE1BQUl6dkMsR0FBRyxJQUFJK3RDLElBQUksQ0FBQzFoQyxRQUFMLENBQWNyTSxHQUFkLENBQVAsSUFBNkJBLEdBQUcsWUFBWXN1QyxHQUFoRCxFQUFxRCxPQUFPdHVDLEdBQVA7QUFFckQsTUFBSTB2QyxDQUFDLEdBQUcsSUFBSXBCLEdBQUosRUFBUjtBQUNBb0IsRUFBQUEsQ0FBQyxDQUFDamtDLEtBQUYsQ0FBUXpMLEdBQVIsRUFBYXd2QyxnQkFBYixFQUErQkMsaUJBQS9CO0FBQ0EsU0FBT0MsQ0FBUDtBQUNEOztBQUVEcEIsR0FBRyxDQUFDeHFDLFNBQUosQ0FBYzJILEtBQWQsR0FBc0IsVUFBU3pMLEdBQVQsRUFBY3d2QyxnQkFBZCxFQUFnQ0MsaUJBQWhDLEVBQW1EO0FBQ3ZFLE1BQUksQ0FBQzFCLElBQUksQ0FBQ3hpQyxRQUFMLENBQWN2TCxHQUFkLENBQUwsRUFBeUI7QUFDdkIsVUFBTSxJQUFJNkUsU0FBSixDQUFjLG1EQUFrRDdFLEdBQWxELENBQWQsQ0FBTjtBQUNELEdBSHNFLENBS3ZFO0FBQ0E7QUFDQTs7O0FBQ0EsTUFBSTJ2QyxVQUFVLEdBQUczdkMsR0FBRyxDQUFDbUIsT0FBSixDQUFZLEdBQVosQ0FBakI7QUFBQSxNQUNJeXVDLFFBQVEsR0FDSEQsVUFBVSxLQUFLLENBQUMsQ0FBaEIsSUFBcUJBLFVBQVUsR0FBRzN2QyxHQUFHLENBQUNtQixPQUFKLENBQVksR0FBWixDQUFuQyxHQUF1RCxHQUF2RCxHQUE2RCxHQUZyRTtBQUFBLE1BR0kwdUMsTUFBTSxHQUFHN3ZDLEdBQUcsQ0FBQ2lRLEtBQUosQ0FBVTIvQixRQUFWLENBSGI7QUFBQSxNQUlJRSxVQUFVLEdBQUcsS0FKakI7QUFLQUQsRUFBQUEsTUFBTSxDQUFDLENBQUQsQ0FBTixHQUFZQSxNQUFNLENBQUMsQ0FBRCxDQUFOLENBQVV4b0MsT0FBVixDQUFrQnlvQyxVQUFsQixFQUE4QixHQUE5QixDQUFaO0FBQ0E5dkMsRUFBQUEsR0FBRyxHQUFHNnZDLE1BQU0sQ0FBQ3ppQyxJQUFQLENBQVl3aUMsUUFBWixDQUFOO0FBRUEsTUFBSUcsSUFBSSxHQUFHL3ZDLEdBQVgsQ0FoQnVFLENBa0J2RTtBQUNBOztBQUNBK3ZDLEVBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDcmtDLElBQUwsRUFBUDs7QUFFQSxNQUFJLENBQUMrakMsaUJBQUQsSUFBc0J6dkMsR0FBRyxDQUFDaVEsS0FBSixDQUFVLEdBQVYsRUFBZW5KLE1BQWYsS0FBMEIsQ0FBcEQsRUFBdUQ7QUFDckQ7QUFDQSxRQUFJa3BDLFVBQVUsR0FBR3JCLGlCQUFpQixDQUFDc0IsSUFBbEIsQ0FBdUJGLElBQXZCLENBQWpCOztBQUNBLFFBQUlDLFVBQUosRUFBZ0I7QUFDZCxXQUFLdGlDLElBQUwsR0FBWXFpQyxJQUFaO0FBQ0EsV0FBSzlnQyxJQUFMLEdBQVk4Z0MsSUFBWjtBQUNBLFdBQUt2Z0MsUUFBTCxHQUFnQndnQyxVQUFVLENBQUMsQ0FBRCxDQUExQjs7QUFDQSxVQUFJQSxVQUFVLENBQUMsQ0FBRCxDQUFkLEVBQW1CO0FBQ2pCLGFBQUszZ0MsTUFBTCxHQUFjMmdDLFVBQVUsQ0FBQyxDQUFELENBQXhCOztBQUNBLFlBQUlSLGdCQUFKLEVBQXNCO0FBQ3BCLGVBQUtoQixLQUFMLEdBQWFlLFdBQVcsQ0FBQzlqQyxLQUFaLENBQWtCLEtBQUs0RCxNQUFMLENBQVljLE1BQVosQ0FBbUIsQ0FBbkIsQ0FBbEIsQ0FBYjtBQUNELFNBRkQsTUFFTztBQUNMLGVBQUtxK0IsS0FBTCxHQUFhLEtBQUtuL0IsTUFBTCxDQUFZYyxNQUFaLENBQW1CLENBQW5CLENBQWI7QUFDRDtBQUNGLE9BUEQsTUFPTyxJQUFJcS9CLGdCQUFKLEVBQXNCO0FBQzNCLGFBQUtuZ0MsTUFBTCxHQUFjLEVBQWQ7QUFDQSxhQUFLbS9CLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7O0FBQ0QsYUFBTyxJQUFQO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJM3hCLEtBQUssR0FBRzR4QixlQUFlLENBQUN3QixJQUFoQixDQUFxQkYsSUFBckIsQ0FBWjs7QUFDQSxNQUFJbHpCLEtBQUosRUFBVztBQUNUQSxJQUFBQSxLQUFLLEdBQUdBLEtBQUssQ0FBQyxDQUFELENBQWI7QUFDQSxRQUFJcXpCLFVBQVUsR0FBR3J6QixLQUFLLENBQUNwYSxXQUFOLEVBQWpCO0FBQ0EsU0FBSzBNLFFBQUwsR0FBZ0IrZ0MsVUFBaEI7QUFDQUgsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUM1L0IsTUFBTCxDQUFZME0sS0FBSyxDQUFDL1YsTUFBbEIsQ0FBUDtBQUNELEdBbERzRSxDQW9EdkU7QUFDQTtBQUNBO0FBQ0E7OztBQUNBLE1BQUkyb0MsaUJBQWlCLElBQUk1eUIsS0FBckIsSUFBOEJrekIsSUFBSSxDQUFDN2hDLEtBQUwsQ0FBVyxzQkFBWCxDQUFsQyxFQUFzRTtBQUNwRSxRQUFJcWdDLE9BQU8sR0FBR3dCLElBQUksQ0FBQzUvQixNQUFMLENBQVksQ0FBWixFQUFlLENBQWYsTUFBc0IsSUFBcEM7O0FBQ0EsUUFBSW8rQixPQUFPLElBQUksRUFBRTF4QixLQUFLLElBQUl3eUIsZ0JBQWdCLENBQUN4eUIsS0FBRCxDQUEzQixDQUFmLEVBQW9EO0FBQ2xEa3pCLE1BQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDNS9CLE1BQUwsQ0FBWSxDQUFaLENBQVA7QUFDQSxXQUFLbytCLE9BQUwsR0FBZSxJQUFmO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJLENBQUNjLGdCQUFnQixDQUFDeHlCLEtBQUQsQ0FBakIsS0FDQzB4QixPQUFPLElBQUsxeEIsS0FBSyxJQUFJLENBQUN5eUIsZUFBZSxDQUFDenlCLEtBQUQsQ0FEdEMsQ0FBSixFQUNxRDtBQUVuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUVBO0FBQ0EsUUFBSXN6QixPQUFPLEdBQUcsQ0FBQyxDQUFmOztBQUNBLFNBQUssSUFBSXZqQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHb2lDLGVBQWUsQ0FBQ2xvQyxNQUFwQyxFQUE0QzhGLENBQUMsRUFBN0MsRUFBaUQ7QUFDL0MsVUFBSXdqQyxHQUFHLEdBQUdMLElBQUksQ0FBQzV1QyxPQUFMLENBQWE2dEMsZUFBZSxDQUFDcGlDLENBQUQsQ0FBNUIsQ0FBVjtBQUNBLFVBQUl3akMsR0FBRyxLQUFLLENBQUMsQ0FBVCxLQUFlRCxPQUFPLEtBQUssQ0FBQyxDQUFiLElBQWtCQyxHQUFHLEdBQUdELE9BQXZDLENBQUosRUFDRUEsT0FBTyxHQUFHQyxHQUFWO0FBQ0gsS0F2QmtELENBeUJuRDtBQUNBOzs7QUFDQSxRQUFJN3dDLElBQUosRUFBVTh3QyxNQUFWOztBQUNBLFFBQUlGLE9BQU8sS0FBSyxDQUFDLENBQWpCLEVBQW9CO0FBQ2xCO0FBQ0FFLE1BQUFBLE1BQU0sR0FBR04sSUFBSSxDQUFDaDZCLFdBQUwsQ0FBaUIsR0FBakIsQ0FBVDtBQUNELEtBSEQsTUFHTztBQUNMO0FBQ0E7QUFDQXM2QixNQUFBQSxNQUFNLEdBQUdOLElBQUksQ0FBQ2g2QixXQUFMLENBQWlCLEdBQWpCLEVBQXNCbzZCLE9BQXRCLENBQVQ7QUFDRCxLQW5Da0QsQ0FxQ25EO0FBQ0E7OztBQUNBLFFBQUlFLE1BQU0sS0FBSyxDQUFDLENBQWhCLEVBQW1CO0FBQ2pCOXdDLE1BQUFBLElBQUksR0FBR3d3QyxJQUFJLENBQUMzeUMsS0FBTCxDQUFXLENBQVgsRUFBY2l6QyxNQUFkLENBQVA7QUFDQU4sTUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUMzeUMsS0FBTCxDQUFXaXpDLE1BQU0sR0FBRyxDQUFwQixDQUFQO0FBQ0EsV0FBSzl3QyxJQUFMLEdBQVk2TyxrQkFBa0IsQ0FBQzdPLElBQUQsQ0FBOUI7QUFDRCxLQTNDa0QsQ0E2Q25EOzs7QUFDQTR3QyxJQUFBQSxPQUFPLEdBQUcsQ0FBQyxDQUFYOztBQUNBLFNBQUssSUFBSXZqQyxDQUFDLEdBQUcsQ0FBYixFQUFnQkEsQ0FBQyxHQUFHbWlDLFlBQVksQ0FBQ2pvQyxNQUFqQyxFQUF5QzhGLENBQUMsRUFBMUMsRUFBOEM7QUFDNUMsVUFBSXdqQyxHQUFHLEdBQUdMLElBQUksQ0FBQzV1QyxPQUFMLENBQWE0dEMsWUFBWSxDQUFDbmlDLENBQUQsQ0FBekIsQ0FBVjtBQUNBLFVBQUl3akMsR0FBRyxLQUFLLENBQUMsQ0FBVCxLQUFlRCxPQUFPLEtBQUssQ0FBQyxDQUFiLElBQWtCQyxHQUFHLEdBQUdELE9BQXZDLENBQUosRUFDRUEsT0FBTyxHQUFHQyxHQUFWO0FBQ0gsS0FuRGtELENBb0RuRDs7O0FBQ0EsUUFBSUQsT0FBTyxLQUFLLENBQUMsQ0FBakIsRUFDRUEsT0FBTyxHQUFHSixJQUFJLENBQUNqcEMsTUFBZjtBQUVGLFNBQUtzSSxJQUFMLEdBQVkyZ0MsSUFBSSxDQUFDM3lDLEtBQUwsQ0FBVyxDQUFYLEVBQWMreUMsT0FBZCxDQUFaO0FBQ0FKLElBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDM3lDLEtBQUwsQ0FBVyt5QyxPQUFYLENBQVAsQ0F6RG1ELENBMkRuRDs7QUFDQSxTQUFLRyxTQUFMLEdBNURtRCxDQThEbkQ7QUFDQTs7QUFDQSxTQUFLaGhDLFFBQUwsR0FBZ0IsS0FBS0EsUUFBTCxJQUFpQixFQUFqQyxDQWhFbUQsQ0FrRW5EO0FBQ0E7O0FBQ0EsUUFBSWloQyxZQUFZLEdBQUcsS0FBS2poQyxRQUFMLENBQWMsQ0FBZCxNQUFxQixHQUFyQixJQUNmLEtBQUtBLFFBQUwsQ0FBYyxLQUFLQSxRQUFMLENBQWN4SSxNQUFkLEdBQXVCLENBQXJDLE1BQTRDLEdBRGhELENBcEVtRCxDQXVFbkQ7O0FBQ0EsUUFBSSxDQUFDeXBDLFlBQUwsRUFBbUI7QUFDakIsVUFBSUMsU0FBUyxHQUFHLEtBQUtsaEMsUUFBTCxDQUFjVyxLQUFkLENBQW9CLElBQXBCLENBQWhCOztBQUNBLFdBQUssSUFBSXJELENBQUMsR0FBRyxDQUFSLEVBQVd5RixDQUFDLEdBQUdtK0IsU0FBUyxDQUFDMXBDLE1BQTlCLEVBQXNDOEYsQ0FBQyxHQUFHeUYsQ0FBMUMsRUFBNkN6RixDQUFDLEVBQTlDLEVBQWtEO0FBQ2hELFlBQUk2akMsSUFBSSxHQUFHRCxTQUFTLENBQUM1akMsQ0FBRCxDQUFwQjtBQUNBLFlBQUksQ0FBQzZqQyxJQUFMLEVBQVc7O0FBQ1gsWUFBSSxDQUFDQSxJQUFJLENBQUN2aUMsS0FBTCxDQUFXZ2hDLG1CQUFYLENBQUwsRUFBc0M7QUFDcEMsY0FBSXdCLE9BQU8sR0FBRyxFQUFkOztBQUNBLGVBQUssSUFBSXR2QixDQUFDLEdBQUcsQ0FBUixFQUFXaVAsQ0FBQyxHQUFHb2dCLElBQUksQ0FBQzNwQyxNQUF6QixFQUFpQ3NhLENBQUMsR0FBR2lQLENBQXJDLEVBQXdDalAsQ0FBQyxFQUF6QyxFQUE2QztBQUMzQyxnQkFBSXF2QixJQUFJLENBQUM3OUIsVUFBTCxDQUFnQndPLENBQWhCLElBQXFCLEdBQXpCLEVBQThCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBc3ZCLGNBQUFBLE9BQU8sSUFBSSxHQUFYO0FBQ0QsYUFMRCxNQUtPO0FBQ0xBLGNBQUFBLE9BQU8sSUFBSUQsSUFBSSxDQUFDcnZCLENBQUQsQ0FBZjtBQUNEO0FBQ0YsV0FYbUMsQ0FZcEM7OztBQUNBLGNBQUksQ0FBQ3N2QixPQUFPLENBQUN4aUMsS0FBUixDQUFjZ2hDLG1CQUFkLENBQUwsRUFBeUM7QUFDdkMsZ0JBQUl5QixVQUFVLEdBQUdILFNBQVMsQ0FBQ3B6QyxLQUFWLENBQWdCLENBQWhCLEVBQW1Cd1AsQ0FBbkIsQ0FBakI7QUFDQSxnQkFBSWdrQyxPQUFPLEdBQUdKLFNBQVMsQ0FBQ3B6QyxLQUFWLENBQWdCd1AsQ0FBQyxHQUFHLENBQXBCLENBQWQ7QUFDQSxnQkFBSWlrQyxHQUFHLEdBQUdKLElBQUksQ0FBQ3ZpQyxLQUFMLENBQVdpaEMsaUJBQVgsQ0FBVjs7QUFDQSxnQkFBSTBCLEdBQUosRUFBUztBQUNQRixjQUFBQSxVQUFVLENBQUNscUMsSUFBWCxDQUFnQm9xQyxHQUFHLENBQUMsQ0FBRCxDQUFuQjtBQUNBRCxjQUFBQSxPQUFPLENBQUN4cUMsT0FBUixDQUFnQnlxQyxHQUFHLENBQUMsQ0FBRCxDQUFuQjtBQUNEOztBQUNELGdCQUFJRCxPQUFPLENBQUM5cEMsTUFBWixFQUFvQjtBQUNsQmlwQyxjQUFBQSxJQUFJLEdBQUcsTUFBTWEsT0FBTyxDQUFDeGpDLElBQVIsQ0FBYSxHQUFiLENBQU4sR0FBMEIyaUMsSUFBakM7QUFDRDs7QUFDRCxpQkFBS3pnQyxRQUFMLEdBQWdCcWhDLFVBQVUsQ0FBQ3ZqQyxJQUFYLENBQWdCLEdBQWhCLENBQWhCO0FBQ0E7QUFDRDtBQUNGO0FBQ0Y7QUFDRjs7QUFFRCxRQUFJLEtBQUtrQyxRQUFMLENBQWN4SSxNQUFkLEdBQXVCbW9DLGNBQTNCLEVBQTJDO0FBQ3pDLFdBQUszL0IsUUFBTCxHQUFnQixFQUFoQjtBQUNELEtBRkQsTUFFTztBQUNMO0FBQ0EsV0FBS0EsUUFBTCxHQUFnQixLQUFLQSxRQUFMLENBQWM3TSxXQUFkLEVBQWhCO0FBQ0Q7O0FBRUQsUUFBSSxDQUFDOHRDLFlBQUwsRUFBbUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFLamhDLFFBQUwsR0FBZ0I0N0IsUUFBUSxDQUFDMEMsT0FBVCxDQUFpQixLQUFLdCtCLFFBQXRCLENBQWhCO0FBQ0Q7O0FBRUQsUUFBSXFLLENBQUMsR0FBRyxLQUFLcEssSUFBTCxHQUFZLE1BQU0sS0FBS0EsSUFBdkIsR0FBOEIsRUFBdEM7QUFDQSxRQUFJeEgsQ0FBQyxHQUFHLEtBQUt1SCxRQUFMLElBQWlCLEVBQXpCO0FBQ0EsU0FBS0YsSUFBTCxHQUFZckgsQ0FBQyxHQUFHNFIsQ0FBaEI7QUFDQSxTQUFLMUssSUFBTCxJQUFhLEtBQUtHLElBQWxCLENBOUhtRCxDQWdJbkQ7QUFDQTs7QUFDQSxRQUFJbWhDLFlBQUosRUFBa0I7QUFDaEIsV0FBS2poQyxRQUFMLEdBQWdCLEtBQUtBLFFBQUwsQ0FBY2EsTUFBZCxDQUFxQixDQUFyQixFQUF3QixLQUFLYixRQUFMLENBQWN4SSxNQUFkLEdBQXVCLENBQS9DLENBQWhCOztBQUNBLFVBQUlpcEMsSUFBSSxDQUFDLENBQUQsQ0FBSixLQUFZLEdBQWhCLEVBQXFCO0FBQ25CQSxRQUFBQSxJQUFJLEdBQUcsTUFBTUEsSUFBYjtBQUNEO0FBQ0Y7QUFDRixHQXpNc0UsQ0EyTXZFO0FBQ0E7OztBQUNBLE1BQUksQ0FBQ1gsY0FBYyxDQUFDYyxVQUFELENBQW5CLEVBQWlDO0FBRS9CO0FBQ0E7QUFDQTtBQUNBLFNBQUssSUFBSXRqQyxDQUFDLEdBQUcsQ0FBUixFQUFXeUYsQ0FBQyxHQUFHeThCLFVBQVUsQ0FBQ2hvQyxNQUEvQixFQUF1QzhGLENBQUMsR0FBR3lGLENBQTNDLEVBQThDekYsQ0FBQyxFQUEvQyxFQUFtRDtBQUNqRCxVQUFJa2tDLEVBQUUsR0FBR2hDLFVBQVUsQ0FBQ2xpQyxDQUFELENBQW5CO0FBQ0EsVUFBSW1qQyxJQUFJLENBQUM1dUMsT0FBTCxDQUFhMnZDLEVBQWIsTUFBcUIsQ0FBQyxDQUExQixFQUNFO0FBQ0YsVUFBSUMsR0FBRyxHQUFHcHhDLGtCQUFrQixDQUFDbXhDLEVBQUQsQ0FBNUI7O0FBQ0EsVUFBSUMsR0FBRyxLQUFLRCxFQUFaLEVBQWdCO0FBQ2RDLFFBQUFBLEdBQUcsR0FBR0MsTUFBTSxDQUFDRixFQUFELENBQVo7QUFDRDs7QUFDRGYsTUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUM5L0IsS0FBTCxDQUFXNmdDLEVBQVgsRUFBZTFqQyxJQUFmLENBQW9CMmpDLEdBQXBCLENBQVA7QUFDRDtBQUNGLEdBNU5zRSxDQStOdkU7OztBQUNBLE1BQUkxekMsSUFBSSxHQUFHMHlDLElBQUksQ0FBQzV1QyxPQUFMLENBQWEsR0FBYixDQUFYOztBQUNBLE1BQUk5RCxJQUFJLEtBQUssQ0FBQyxDQUFkLEVBQWlCO0FBQ2Y7QUFDQSxTQUFLQSxJQUFMLEdBQVkweUMsSUFBSSxDQUFDNS9CLE1BQUwsQ0FBWTlTLElBQVosQ0FBWjtBQUNBMHlDLElBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDM3lDLEtBQUwsQ0FBVyxDQUFYLEVBQWNDLElBQWQsQ0FBUDtBQUNEOztBQUNELE1BQUk0ekMsRUFBRSxHQUFHbEIsSUFBSSxDQUFDNXVDLE9BQUwsQ0FBYSxHQUFiLENBQVQ7O0FBQ0EsTUFBSTh2QyxFQUFFLEtBQUssQ0FBQyxDQUFaLEVBQWU7QUFDYixTQUFLNWhDLE1BQUwsR0FBYzBnQyxJQUFJLENBQUM1L0IsTUFBTCxDQUFZOGdDLEVBQVosQ0FBZDtBQUNBLFNBQUt6QyxLQUFMLEdBQWF1QixJQUFJLENBQUM1L0IsTUFBTCxDQUFZOGdDLEVBQUUsR0FBRyxDQUFqQixDQUFiOztBQUNBLFFBQUl6QixnQkFBSixFQUFzQjtBQUNwQixXQUFLaEIsS0FBTCxHQUFhZSxXQUFXLENBQUM5akMsS0FBWixDQUFrQixLQUFLK2lDLEtBQXZCLENBQWI7QUFDRDs7QUFDRHVCLElBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDM3lDLEtBQUwsQ0FBVyxDQUFYLEVBQWM2ekMsRUFBZCxDQUFQO0FBQ0QsR0FQRCxNQU9PLElBQUl6QixnQkFBSixFQUFzQjtBQUMzQjtBQUNBLFNBQUtuZ0MsTUFBTCxHQUFjLEVBQWQ7QUFDQSxTQUFLbS9CLEtBQUwsR0FBYSxFQUFiO0FBQ0Q7O0FBQ0QsTUFBSXVCLElBQUosRUFBVSxLQUFLdmdDLFFBQUwsR0FBZ0J1Z0MsSUFBaEI7O0FBQ1YsTUFBSVQsZUFBZSxDQUFDWSxVQUFELENBQWYsSUFDQSxLQUFLNWdDLFFBREwsSUFDaUIsQ0FBQyxLQUFLRSxRQUQzQixFQUNxQztBQUNuQyxTQUFLQSxRQUFMLEdBQWdCLEdBQWhCO0FBQ0QsR0F2UHNFLENBeVB2RTs7O0FBQ0EsTUFBSSxLQUFLQSxRQUFMLElBQWlCLEtBQUtILE1BQTFCLEVBQWtDO0FBQ2hDLFFBQUlzSyxDQUFDLEdBQUcsS0FBS25LLFFBQUwsSUFBaUIsRUFBekI7QUFDQSxRQUFJa0ksQ0FBQyxHQUFHLEtBQUtySSxNQUFMLElBQWUsRUFBdkI7QUFDQSxTQUFLM0IsSUFBTCxHQUFZaU0sQ0FBQyxHQUFHakMsQ0FBaEI7QUFDRCxHQTlQc0UsQ0FnUXZFOzs7QUFDQSxPQUFLekksSUFBTCxHQUFZLEtBQUttL0IsTUFBTCxFQUFaO0FBQ0EsU0FBTyxJQUFQO0FBQ0QsQ0FuUUQsRUFxUUE7OztBQUNBLFNBQVNDLFNBQVQsQ0FBbUJqOEIsR0FBbkIsRUFBd0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFJMjdCLElBQUksQ0FBQ3hpQyxRQUFMLENBQWM2RyxHQUFkLENBQUosRUFBd0JBLEdBQUcsR0FBRzQ3QixRQUFRLENBQUM1N0IsR0FBRCxDQUFkO0FBQ3hCLE1BQUksRUFBRUEsR0FBRyxZQUFZazhCLEdBQWpCLENBQUosRUFBMkIsT0FBT0EsR0FBRyxDQUFDeHFDLFNBQUosQ0FBY3NxQyxNQUFkLENBQXFCN2xDLElBQXJCLENBQTBCNkosR0FBMUIsQ0FBUDtBQUMzQixTQUFPQSxHQUFHLENBQUNnOEIsTUFBSixFQUFQO0FBQ0Q7O0FBRURFLEdBQUcsQ0FBQ3hxQyxTQUFKLENBQWNzcUMsTUFBZCxHQUF1QixZQUFXO0FBQ2hDLE1BQUk3dUMsSUFBSSxHQUFHLEtBQUtBLElBQUwsSUFBYSxFQUF4Qjs7QUFDQSxNQUFJQSxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxHQUFHSSxrQkFBa0IsQ0FBQ0osSUFBRCxDQUF6QjtBQUNBQSxJQUFBQSxJQUFJLEdBQUdBLElBQUksQ0FBQzhILE9BQUwsQ0FBYSxNQUFiLEVBQXFCLEdBQXJCLENBQVA7QUFDQTlILElBQUFBLElBQUksSUFBSSxHQUFSO0FBQ0Q7O0FBRUQsTUFBSTRQLFFBQVEsR0FBRyxLQUFLQSxRQUFMLElBQWlCLEVBQWhDO0FBQUEsTUFDSUssUUFBUSxHQUFHLEtBQUtBLFFBQUwsSUFBaUIsRUFEaEM7QUFBQSxNQUVJblMsSUFBSSxHQUFHLEtBQUtBLElBQUwsSUFBYSxFQUZ4QjtBQUFBLE1BR0krUixJQUFJLEdBQUcsS0FIWDtBQUFBLE1BSUlvL0IsS0FBSyxHQUFHLEVBSlo7O0FBTUEsTUFBSSxLQUFLcC9CLElBQVQsRUFBZTtBQUNiQSxJQUFBQSxJQUFJLEdBQUc3UCxJQUFJLEdBQUcsS0FBSzZQLElBQW5CO0FBQ0QsR0FGRCxNQUVPLElBQUksS0FBS0UsUUFBVCxFQUFtQjtBQUN4QkYsSUFBQUEsSUFBSSxHQUFHN1AsSUFBSSxJQUFJLEtBQUsrUCxRQUFMLENBQWNuTyxPQUFkLENBQXNCLEdBQXRCLE1BQStCLENBQUMsQ0FBaEMsR0FDWCxLQUFLbU8sUUFETSxHQUVYLE1BQU0sS0FBS0EsUUFBWCxHQUFzQixHQUZmLENBQVg7O0FBR0EsUUFBSSxLQUFLQyxJQUFULEVBQWU7QUFDYkgsTUFBQUEsSUFBSSxJQUFJLE1BQU0sS0FBS0csSUFBbkI7QUFDRDtBQUNGOztBQUVELE1BQUksS0FBS2kvQixLQUFMLElBQ0FULElBQUksQ0FBQzFoQyxRQUFMLENBQWMsS0FBS21pQyxLQUFuQixDQURBLElBRUF0eUMsTUFBTSxDQUFDc08sSUFBUCxDQUFZLEtBQUtna0MsS0FBakIsRUFBd0IxbkMsTUFGNUIsRUFFb0M7QUFDbEMwbkMsSUFBQUEsS0FBSyxHQUFHZSxXQUFXLENBQUMzakMsU0FBWixDQUFzQixLQUFLNGlDLEtBQTNCLENBQVI7QUFDRDs7QUFFRCxNQUFJbi9CLE1BQU0sR0FBRyxLQUFLQSxNQUFMLElBQWdCbS9CLEtBQUssSUFBSyxNQUFNQSxLQUFoQyxJQUEyQyxFQUF4RDtBQUVBLE1BQUlyL0IsUUFBUSxJQUFJQSxRQUFRLENBQUNnQixNQUFULENBQWdCLENBQUMsQ0FBakIsTUFBd0IsR0FBeEMsRUFBNkNoQixRQUFRLElBQUksR0FBWixDQWpDYixDQW1DaEM7QUFDQTs7QUFDQSxNQUFJLEtBQUtvL0IsT0FBTCxJQUNBLENBQUMsQ0FBQ3AvQixRQUFELElBQWFtZ0MsZUFBZSxDQUFDbmdDLFFBQUQsQ0FBN0IsS0FBNENDLElBQUksS0FBSyxLQUR6RCxFQUNnRTtBQUM5REEsSUFBQUEsSUFBSSxHQUFHLFFBQVFBLElBQUksSUFBSSxFQUFoQixDQUFQO0FBQ0EsUUFBSUksUUFBUSxJQUFJQSxRQUFRLENBQUNDLE1BQVQsQ0FBZ0IsQ0FBaEIsTUFBdUIsR0FBdkMsRUFBNENELFFBQVEsR0FBRyxNQUFNQSxRQUFqQjtBQUM3QyxHQUpELE1BSU8sSUFBSSxDQUFDSixJQUFMLEVBQVc7QUFDaEJBLElBQUFBLElBQUksR0FBRyxFQUFQO0FBQ0Q7O0FBRUQsTUFBSS9SLElBQUksSUFBSUEsSUFBSSxDQUFDb1MsTUFBTCxDQUFZLENBQVosTUFBbUIsR0FBL0IsRUFBb0NwUyxJQUFJLEdBQUcsTUFBTUEsSUFBYjtBQUNwQyxNQUFJZ1MsTUFBTSxJQUFJQSxNQUFNLENBQUNJLE1BQVAsQ0FBYyxDQUFkLE1BQXFCLEdBQW5DLEVBQXdDSixNQUFNLEdBQUcsTUFBTUEsTUFBZjtBQUV4Q0csRUFBQUEsUUFBUSxHQUFHQSxRQUFRLENBQUNuSSxPQUFULENBQWlCLE9BQWpCLEVBQTBCLFVBQVM2RyxLQUFULEVBQWdCO0FBQ25ELFdBQU92TyxrQkFBa0IsQ0FBQ3VPLEtBQUQsQ0FBekI7QUFDRCxHQUZVLENBQVg7QUFHQW1CLEVBQUFBLE1BQU0sR0FBR0EsTUFBTSxDQUFDaEksT0FBUCxDQUFlLEdBQWYsRUFBb0IsS0FBcEIsQ0FBVDtBQUVBLFNBQU84SCxRQUFRLEdBQUdDLElBQVgsR0FBa0JJLFFBQWxCLEdBQTZCSCxNQUE3QixHQUFzQ2hTLElBQTdDO0FBQ0QsQ0F0REQ7O0FBd0RBLFNBQVM0d0MsVUFBVCxDQUFvQjlvQyxNQUFwQixFQUE0QityQyxRQUE1QixFQUFzQztBQUNwQyxTQUFPbEQsUUFBUSxDQUFDN29DLE1BQUQsRUFBUyxLQUFULEVBQWdCLElBQWhCLENBQVIsQ0FBOEJ0RyxPQUE5QixDQUFzQ3F5QyxRQUF0QyxDQUFQO0FBQ0Q7O0FBRUQ1QyxHQUFHLENBQUN4cUMsU0FBSixDQUFjakYsT0FBZCxHQUF3QixVQUFTcXlDLFFBQVQsRUFBbUI7QUFDekMsU0FBTyxLQUFLaEQsYUFBTCxDQUFtQkYsUUFBUSxDQUFDa0QsUUFBRCxFQUFXLEtBQVgsRUFBa0IsSUFBbEIsQ0FBM0IsRUFBb0Q5QyxNQUFwRCxFQUFQO0FBQ0QsQ0FGRDs7QUFJQSxTQUFTRCxnQkFBVCxDQUEwQmhwQyxNQUExQixFQUFrQytyQyxRQUFsQyxFQUE0QztBQUMxQyxNQUFJLENBQUMvckMsTUFBTCxFQUFhLE9BQU8rckMsUUFBUDtBQUNiLFNBQU9sRCxRQUFRLENBQUM3b0MsTUFBRCxFQUFTLEtBQVQsRUFBZ0IsSUFBaEIsQ0FBUixDQUE4QitvQyxhQUE5QixDQUE0Q2dELFFBQTVDLENBQVA7QUFDRDs7QUFFRDVDLEdBQUcsQ0FBQ3hxQyxTQUFKLENBQWNvcUMsYUFBZCxHQUE4QixVQUFTZ0QsUUFBVCxFQUFtQjtBQUMvQyxNQUFJbkQsSUFBSSxDQUFDeGlDLFFBQUwsQ0FBYzJsQyxRQUFkLENBQUosRUFBNkI7QUFDM0IsUUFBSUMsR0FBRyxHQUFHLElBQUk3QyxHQUFKLEVBQVY7QUFDQTZDLElBQUFBLEdBQUcsQ0FBQzFsQyxLQUFKLENBQVV5bEMsUUFBVixFQUFvQixLQUFwQixFQUEyQixJQUEzQjtBQUNBQSxJQUFBQSxRQUFRLEdBQUdDLEdBQVg7QUFDRDs7QUFFRCxNQUFJMS9CLE1BQU0sR0FBRyxJQUFJNjhCLEdBQUosRUFBYjtBQUNBLE1BQUk4QyxLQUFLLEdBQUdsMUMsTUFBTSxDQUFDc08sSUFBUCxDQUFZLElBQVosQ0FBWjs7QUFDQSxPQUFLLElBQUk2bUMsRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR0QsS0FBSyxDQUFDdHFDLE1BQTVCLEVBQW9DdXFDLEVBQUUsRUFBdEMsRUFBMEM7QUFDeEMsUUFBSUMsSUFBSSxHQUFHRixLQUFLLENBQUNDLEVBQUQsQ0FBaEI7QUFDQTUvQixJQUFBQSxNQUFNLENBQUM2L0IsSUFBRCxDQUFOLEdBQWUsS0FBS0EsSUFBTCxDQUFmO0FBQ0QsR0FaOEMsQ0FjL0M7QUFDQTs7O0FBQ0E3L0IsRUFBQUEsTUFBTSxDQUFDcFUsSUFBUCxHQUFjNnpDLFFBQVEsQ0FBQzd6QyxJQUF2QixDQWhCK0MsQ0FrQi9DOztBQUNBLE1BQUk2ekMsUUFBUSxDQUFDamlDLElBQVQsS0FBa0IsRUFBdEIsRUFBMEI7QUFDeEJ3QyxJQUFBQSxNQUFNLENBQUN4QyxJQUFQLEdBQWN3QyxNQUFNLENBQUMyOEIsTUFBUCxFQUFkO0FBQ0EsV0FBTzM4QixNQUFQO0FBQ0QsR0F0QjhDLENBd0IvQzs7O0FBQ0EsTUFBSXkvQixRQUFRLENBQUMzQyxPQUFULElBQW9CLENBQUMyQyxRQUFRLENBQUMvaEMsUUFBbEMsRUFBNEM7QUFDMUM7QUFDQSxRQUFJb2lDLEtBQUssR0FBR3IxQyxNQUFNLENBQUNzTyxJQUFQLENBQVkwbUMsUUFBWixDQUFaOztBQUNBLFNBQUssSUFBSU0sRUFBRSxHQUFHLENBQWQsRUFBaUJBLEVBQUUsR0FBR0QsS0FBSyxDQUFDenFDLE1BQTVCLEVBQW9DMHFDLEVBQUUsRUFBdEMsRUFBMEM7QUFDeEMsVUFBSUMsSUFBSSxHQUFHRixLQUFLLENBQUNDLEVBQUQsQ0FBaEI7QUFDQSxVQUFJQyxJQUFJLEtBQUssVUFBYixFQUNFaGdDLE1BQU0sQ0FBQ2dnQyxJQUFELENBQU4sR0FBZVAsUUFBUSxDQUFDTyxJQUFELENBQXZCO0FBQ0gsS0FQeUMsQ0FTMUM7OztBQUNBLFFBQUluQyxlQUFlLENBQUM3OUIsTUFBTSxDQUFDdEMsUUFBUixDQUFmLElBQ0FzQyxNQUFNLENBQUNuQyxRQURQLElBQ21CLENBQUNtQyxNQUFNLENBQUNqQyxRQUQvQixFQUN5QztBQUN2Q2lDLE1BQUFBLE1BQU0sQ0FBQy9ELElBQVAsR0FBYytELE1BQU0sQ0FBQ2pDLFFBQVAsR0FBa0IsR0FBaEM7QUFDRDs7QUFFRGlDLElBQUFBLE1BQU0sQ0FBQ3hDLElBQVAsR0FBY3dDLE1BQU0sQ0FBQzI4QixNQUFQLEVBQWQ7QUFDQSxXQUFPMzhCLE1BQVA7QUFDRDs7QUFFRCxNQUFJeS9CLFFBQVEsQ0FBQy9oQyxRQUFULElBQXFCK2hDLFFBQVEsQ0FBQy9oQyxRQUFULEtBQXNCc0MsTUFBTSxDQUFDdEMsUUFBdEQsRUFBZ0U7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQUksQ0FBQ21nQyxlQUFlLENBQUM0QixRQUFRLENBQUMvaEMsUUFBVixDQUFwQixFQUF5QztBQUN2QyxVQUFJM0UsSUFBSSxHQUFHdE8sTUFBTSxDQUFDc08sSUFBUCxDQUFZMG1DLFFBQVosQ0FBWDs7QUFDQSxXQUFLLElBQUlqa0MsQ0FBQyxHQUFHLENBQWIsRUFBZ0JBLENBQUMsR0FBR3pDLElBQUksQ0FBQzFELE1BQXpCLEVBQWlDbUcsQ0FBQyxFQUFsQyxFQUFzQztBQUNwQyxZQUFJb2pCLENBQUMsR0FBRzdsQixJQUFJLENBQUN5QyxDQUFELENBQVo7QUFDQXdFLFFBQUFBLE1BQU0sQ0FBQzRlLENBQUQsQ0FBTixHQUFZNmdCLFFBQVEsQ0FBQzdnQixDQUFELENBQXBCO0FBQ0Q7O0FBQ0Q1ZSxNQUFBQSxNQUFNLENBQUN4QyxJQUFQLEdBQWN3QyxNQUFNLENBQUMyOEIsTUFBUCxFQUFkO0FBQ0EsYUFBTzM4QixNQUFQO0FBQ0Q7O0FBRURBLElBQUFBLE1BQU0sQ0FBQ3RDLFFBQVAsR0FBa0IraEMsUUFBUSxDQUFDL2hDLFFBQTNCOztBQUNBLFFBQUksQ0FBQytoQyxRQUFRLENBQUM5aEMsSUFBVixJQUFrQixDQUFDaWdDLGdCQUFnQixDQUFDNkIsUUFBUSxDQUFDL2hDLFFBQVYsQ0FBdkMsRUFBNEQ7QUFDMUQsVUFBSXVpQyxPQUFPLEdBQUcsQ0FBQ1IsUUFBUSxDQUFDMWhDLFFBQVQsSUFBcUIsRUFBdEIsRUFBMEJTLEtBQTFCLENBQWdDLEdBQWhDLENBQWQ7O0FBQ0EsYUFBT3loQyxPQUFPLENBQUM1cUMsTUFBUixJQUFrQixFQUFFb3FDLFFBQVEsQ0FBQzloQyxJQUFULEdBQWdCc2lDLE9BQU8sQ0FBQzNxQyxLQUFSLEVBQWxCLENBQXpCO0FBQTREO0FBQTVEOztBQUNBLFVBQUksQ0FBQ21xQyxRQUFRLENBQUM5aEMsSUFBZCxFQUFvQjhoQyxRQUFRLENBQUM5aEMsSUFBVCxHQUFnQixFQUFoQjtBQUNwQixVQUFJLENBQUM4aEMsUUFBUSxDQUFDNWhDLFFBQWQsRUFBd0I0aEMsUUFBUSxDQUFDNWhDLFFBQVQsR0FBb0IsRUFBcEI7QUFDeEIsVUFBSW9pQyxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsRUFBbkIsRUFBdUJBLE9BQU8sQ0FBQ3RyQyxPQUFSLENBQWdCLEVBQWhCO0FBQ3ZCLFVBQUlzckMsT0FBTyxDQUFDNXFDLE1BQVIsR0FBaUIsQ0FBckIsRUFBd0I0cUMsT0FBTyxDQUFDdHJDLE9BQVIsQ0FBZ0IsRUFBaEI7QUFDeEJxTCxNQUFBQSxNQUFNLENBQUNqQyxRQUFQLEdBQWtCa2lDLE9BQU8sQ0FBQ3RrQyxJQUFSLENBQWEsR0FBYixDQUFsQjtBQUNELEtBUkQsTUFRTztBQUNMcUUsTUFBQUEsTUFBTSxDQUFDakMsUUFBUCxHQUFrQjBoQyxRQUFRLENBQUMxaEMsUUFBM0I7QUFDRDs7QUFDRGlDLElBQUFBLE1BQU0sQ0FBQ3BDLE1BQVAsR0FBZ0I2aEMsUUFBUSxDQUFDN2hDLE1BQXpCO0FBQ0FvQyxJQUFBQSxNQUFNLENBQUMrOEIsS0FBUCxHQUFlMEMsUUFBUSxDQUFDMUMsS0FBeEI7QUFDQS84QixJQUFBQSxNQUFNLENBQUNyQyxJQUFQLEdBQWM4aEMsUUFBUSxDQUFDOWhDLElBQVQsSUFBaUIsRUFBL0I7QUFDQXFDLElBQUFBLE1BQU0sQ0FBQ2xTLElBQVAsR0FBYzJ4QyxRQUFRLENBQUMzeEMsSUFBdkI7QUFDQWtTLElBQUFBLE1BQU0sQ0FBQ25DLFFBQVAsR0FBa0I0aEMsUUFBUSxDQUFDNWhDLFFBQVQsSUFBcUI0aEMsUUFBUSxDQUFDOWhDLElBQWhEO0FBQ0FxQyxJQUFBQSxNQUFNLENBQUNsQyxJQUFQLEdBQWMyaEMsUUFBUSxDQUFDM2hDLElBQXZCLENBcEM4RCxDQXFDOUQ7O0FBQ0EsUUFBSWtDLE1BQU0sQ0FBQ2pDLFFBQVAsSUFBbUJpQyxNQUFNLENBQUNwQyxNQUE5QixFQUFzQztBQUNwQyxVQUFJc0ssQ0FBQyxHQUFHbEksTUFBTSxDQUFDakMsUUFBUCxJQUFtQixFQUEzQjtBQUNBLFVBQUlrSSxDQUFDLEdBQUdqRyxNQUFNLENBQUNwQyxNQUFQLElBQWlCLEVBQXpCO0FBQ0FvQyxNQUFBQSxNQUFNLENBQUMvRCxJQUFQLEdBQWNpTSxDQUFDLEdBQUdqQyxDQUFsQjtBQUNEOztBQUNEakcsSUFBQUEsTUFBTSxDQUFDODhCLE9BQVAsR0FBaUI5OEIsTUFBTSxDQUFDODhCLE9BQVAsSUFBa0IyQyxRQUFRLENBQUMzQyxPQUE1QztBQUNBOThCLElBQUFBLE1BQU0sQ0FBQ3hDLElBQVAsR0FBY3dDLE1BQU0sQ0FBQzI4QixNQUFQLEVBQWQ7QUFDQSxXQUFPMzhCLE1BQVA7QUFDRDs7QUFFRCxNQUFJa2dDLFdBQVcsR0FBSWxnQyxNQUFNLENBQUNqQyxRQUFQLElBQW1CaUMsTUFBTSxDQUFDakMsUUFBUCxDQUFnQkMsTUFBaEIsQ0FBdUIsQ0FBdkIsTUFBOEIsR0FBcEU7QUFBQSxNQUNJbWlDLFFBQVEsR0FDSlYsUUFBUSxDQUFDOWhDLElBQVQsSUFDQThoQyxRQUFRLENBQUMxaEMsUUFBVCxJQUFxQjBoQyxRQUFRLENBQUMxaEMsUUFBVCxDQUFrQkMsTUFBbEIsQ0FBeUIsQ0FBekIsTUFBZ0MsR0FIN0Q7QUFBQSxNQUtJb2lDLFVBQVUsR0FBSUQsUUFBUSxJQUFJRCxXQUFaLElBQ0NsZ0MsTUFBTSxDQUFDckMsSUFBUCxJQUFlOGhDLFFBQVEsQ0FBQzFoQyxRQU4zQztBQUFBLE1BT0lzaUMsYUFBYSxHQUFHRCxVQVBwQjtBQUFBLE1BUUlFLE9BQU8sR0FBR3RnQyxNQUFNLENBQUNqQyxRQUFQLElBQW1CaUMsTUFBTSxDQUFDakMsUUFBUCxDQUFnQlMsS0FBaEIsQ0FBc0IsR0FBdEIsQ0FBbkIsSUFBaUQsRUFSL0Q7QUFBQSxNQVNJeWhDLE9BQU8sR0FBR1IsUUFBUSxDQUFDMWhDLFFBQVQsSUFBcUIwaEMsUUFBUSxDQUFDMWhDLFFBQVQsQ0FBa0JTLEtBQWxCLENBQXdCLEdBQXhCLENBQXJCLElBQXFELEVBVG5FO0FBQUEsTUFVSStoQyxTQUFTLEdBQUd2Z0MsTUFBTSxDQUFDdEMsUUFBUCxJQUFtQixDQUFDbWdDLGVBQWUsQ0FBQzc5QixNQUFNLENBQUN0QyxRQUFSLENBVm5ELENBNUYrQyxDQXdHL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFDQSxNQUFJNmlDLFNBQUosRUFBZTtBQUNidmdDLElBQUFBLE1BQU0sQ0FBQ25DLFFBQVAsR0FBa0IsRUFBbEI7QUFDQW1DLElBQUFBLE1BQU0sQ0FBQ2xDLElBQVAsR0FBYyxJQUFkOztBQUNBLFFBQUlrQyxNQUFNLENBQUNyQyxJQUFYLEVBQWlCO0FBQ2YsVUFBSTJpQyxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsRUFBbkIsRUFBdUJBLE9BQU8sQ0FBQyxDQUFELENBQVAsR0FBYXRnQyxNQUFNLENBQUNyQyxJQUFwQixDQUF2QixLQUNLMmlDLE9BQU8sQ0FBQzNyQyxPQUFSLENBQWdCcUwsTUFBTSxDQUFDckMsSUFBdkI7QUFDTjs7QUFDRHFDLElBQUFBLE1BQU0sQ0FBQ3JDLElBQVAsR0FBYyxFQUFkOztBQUNBLFFBQUk4aEMsUUFBUSxDQUFDL2hDLFFBQWIsRUFBdUI7QUFDckIraEMsTUFBQUEsUUFBUSxDQUFDNWhDLFFBQVQsR0FBb0IsSUFBcEI7QUFDQTRoQyxNQUFBQSxRQUFRLENBQUMzaEMsSUFBVCxHQUFnQixJQUFoQjs7QUFDQSxVQUFJMmhDLFFBQVEsQ0FBQzloQyxJQUFiLEVBQW1CO0FBQ2pCLFlBQUlzaUMsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQW5CLEVBQXVCQSxPQUFPLENBQUMsQ0FBRCxDQUFQLEdBQWFSLFFBQVEsQ0FBQzloQyxJQUF0QixDQUF2QixLQUNLc2lDLE9BQU8sQ0FBQ3RyQyxPQUFSLENBQWdCOHFDLFFBQVEsQ0FBQzloQyxJQUF6QjtBQUNOOztBQUNEOGhDLE1BQUFBLFFBQVEsQ0FBQzloQyxJQUFULEdBQWdCLElBQWhCO0FBQ0Q7O0FBQ0R5aUMsSUFBQUEsVUFBVSxHQUFHQSxVQUFVLEtBQUtILE9BQU8sQ0FBQyxDQUFELENBQVAsS0FBZSxFQUFmLElBQXFCSyxPQUFPLENBQUMsQ0FBRCxDQUFQLEtBQWUsRUFBekMsQ0FBdkI7QUFDRDs7QUFFRCxNQUFJSCxRQUFKLEVBQWM7QUFDWjtBQUNBbmdDLElBQUFBLE1BQU0sQ0FBQ3JDLElBQVAsR0FBZThoQyxRQUFRLENBQUM5aEMsSUFBVCxJQUFpQjhoQyxRQUFRLENBQUM5aEMsSUFBVCxLQUFrQixFQUFwQyxHQUNBOGhDLFFBQVEsQ0FBQzloQyxJQURULEdBQ2dCcUMsTUFBTSxDQUFDckMsSUFEckM7QUFFQXFDLElBQUFBLE1BQU0sQ0FBQ25DLFFBQVAsR0FBbUI0aEMsUUFBUSxDQUFDNWhDLFFBQVQsSUFBcUI0aEMsUUFBUSxDQUFDNWhDLFFBQVQsS0FBc0IsRUFBNUMsR0FDQTRoQyxRQUFRLENBQUM1aEMsUUFEVCxHQUNvQm1DLE1BQU0sQ0FBQ25DLFFBRDdDO0FBRUFtQyxJQUFBQSxNQUFNLENBQUNwQyxNQUFQLEdBQWdCNmhDLFFBQVEsQ0FBQzdoQyxNQUF6QjtBQUNBb0MsSUFBQUEsTUFBTSxDQUFDKzhCLEtBQVAsR0FBZTBDLFFBQVEsQ0FBQzFDLEtBQXhCO0FBQ0F1RCxJQUFBQSxPQUFPLEdBQUdMLE9BQVYsQ0FSWSxDQVNaO0FBQ0QsR0FWRCxNQVVPLElBQUlBLE9BQU8sQ0FBQzVxQyxNQUFaLEVBQW9CO0FBQ3pCO0FBQ0E7QUFDQSxRQUFJLENBQUNpckMsT0FBTCxFQUFjQSxPQUFPLEdBQUcsRUFBVjtBQUNkQSxJQUFBQSxPQUFPLENBQUNoNUIsR0FBUjtBQUNBZzVCLElBQUFBLE9BQU8sR0FBR0EsT0FBTyxDQUFDbHJDLE1BQVIsQ0FBZTZxQyxPQUFmLENBQVY7QUFDQWpnQyxJQUFBQSxNQUFNLENBQUNwQyxNQUFQLEdBQWdCNmhDLFFBQVEsQ0FBQzdoQyxNQUF6QjtBQUNBb0MsSUFBQUEsTUFBTSxDQUFDKzhCLEtBQVAsR0FBZTBDLFFBQVEsQ0FBQzFDLEtBQXhCO0FBQ0QsR0FSTSxNQVFBLElBQUksQ0FBQ1QsSUFBSSxDQUFDa0UsaUJBQUwsQ0FBdUJmLFFBQVEsQ0FBQzdoQyxNQUFoQyxDQUFMLEVBQThDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFFBQUkyaUMsU0FBSixFQUFlO0FBQ2J2Z0MsTUFBQUEsTUFBTSxDQUFDbkMsUUFBUCxHQUFrQm1DLE1BQU0sQ0FBQ3JDLElBQVAsR0FBYzJpQyxPQUFPLENBQUNockMsS0FBUixFQUFoQyxDQURhLENBRWI7QUFDQTtBQUNBOztBQUNBLFVBQUltckMsVUFBVSxHQUFHemdDLE1BQU0sQ0FBQ3JDLElBQVAsSUFBZXFDLE1BQU0sQ0FBQ3JDLElBQVAsQ0FBWWpPLE9BQVosQ0FBb0IsR0FBcEIsSUFBMkIsQ0FBMUMsR0FDQXNRLE1BQU0sQ0FBQ3JDLElBQVAsQ0FBWWEsS0FBWixDQUFrQixHQUFsQixDQURBLEdBQ3lCLEtBRDFDOztBQUVBLFVBQUlpaUMsVUFBSixFQUFnQjtBQUNkemdDLFFBQUFBLE1BQU0sQ0FBQ2xTLElBQVAsR0FBYzJ5QyxVQUFVLENBQUNuckMsS0FBWCxFQUFkO0FBQ0EwSyxRQUFBQSxNQUFNLENBQUNyQyxJQUFQLEdBQWNxQyxNQUFNLENBQUNuQyxRQUFQLEdBQWtCNGlDLFVBQVUsQ0FBQ25yQyxLQUFYLEVBQWhDO0FBQ0Q7QUFDRjs7QUFDRDBLLElBQUFBLE1BQU0sQ0FBQ3BDLE1BQVAsR0FBZ0I2aEMsUUFBUSxDQUFDN2hDLE1BQXpCO0FBQ0FvQyxJQUFBQSxNQUFNLENBQUMrOEIsS0FBUCxHQUFlMEMsUUFBUSxDQUFDMUMsS0FBeEIsQ0FqQm1ELENBa0JuRDs7QUFDQSxRQUFJLENBQUNULElBQUksQ0FBQ29FLE1BQUwsQ0FBWTFnQyxNQUFNLENBQUNqQyxRQUFuQixDQUFELElBQWlDLENBQUN1K0IsSUFBSSxDQUFDb0UsTUFBTCxDQUFZMWdDLE1BQU0sQ0FBQ3BDLE1BQW5CLENBQXRDLEVBQWtFO0FBQ2hFb0MsTUFBQUEsTUFBTSxDQUFDL0QsSUFBUCxHQUFjLENBQUMrRCxNQUFNLENBQUNqQyxRQUFQLEdBQWtCaUMsTUFBTSxDQUFDakMsUUFBekIsR0FBb0MsRUFBckMsS0FDQ2lDLE1BQU0sQ0FBQ3BDLE1BQVAsR0FBZ0JvQyxNQUFNLENBQUNwQyxNQUF2QixHQUFnQyxFQURqQyxDQUFkO0FBRUQ7O0FBQ0RvQyxJQUFBQSxNQUFNLENBQUN4QyxJQUFQLEdBQWN3QyxNQUFNLENBQUMyOEIsTUFBUCxFQUFkO0FBQ0EsV0FBTzM4QixNQUFQO0FBQ0Q7O0FBRUQsTUFBSSxDQUFDc2dDLE9BQU8sQ0FBQ2pyQyxNQUFiLEVBQXFCO0FBQ25CO0FBQ0E7QUFDQTJLLElBQUFBLE1BQU0sQ0FBQ2pDLFFBQVAsR0FBa0IsSUFBbEIsQ0FIbUIsQ0FJbkI7O0FBQ0EsUUFBSWlDLE1BQU0sQ0FBQ3BDLE1BQVgsRUFBbUI7QUFDakJvQyxNQUFBQSxNQUFNLENBQUMvRCxJQUFQLEdBQWMsTUFBTStELE1BQU0sQ0FBQ3BDLE1BQTNCO0FBQ0QsS0FGRCxNQUVPO0FBQ0xvQyxNQUFBQSxNQUFNLENBQUMvRCxJQUFQLEdBQWMsSUFBZDtBQUNEOztBQUNEK0QsSUFBQUEsTUFBTSxDQUFDeEMsSUFBUCxHQUFjd0MsTUFBTSxDQUFDMjhCLE1BQVAsRUFBZDtBQUNBLFdBQU8zOEIsTUFBUDtBQUNELEdBMUw4QyxDQTRML0M7QUFDQTtBQUNBOzs7QUFDQSxNQUFJK0osSUFBSSxHQUFHdTJCLE9BQU8sQ0FBQzMwQyxLQUFSLENBQWMsQ0FBQyxDQUFmLEVBQWtCLENBQWxCLENBQVg7QUFDQSxNQUFJZzFDLGdCQUFnQixHQUNoQixDQUFDM2dDLE1BQU0sQ0FBQ3JDLElBQVAsSUFBZThoQyxRQUFRLENBQUM5aEMsSUFBeEIsSUFBZ0MyaUMsT0FBTyxDQUFDanJDLE1BQVIsR0FBaUIsQ0FBbEQsTUFDQzBVLElBQUksS0FBSyxHQUFULElBQWdCQSxJQUFJLEtBQUssSUFEMUIsS0FDbUNBLElBQUksS0FBSyxFQUZoRCxDQWhNK0MsQ0FvTS9DO0FBQ0E7O0FBQ0EsTUFBSTYyQixFQUFFLEdBQUcsQ0FBVDs7QUFDQSxPQUFLLElBQUl6bEMsQ0FBQyxHQUFHbWxDLE9BQU8sQ0FBQ2pyQyxNQUFyQixFQUE2QjhGLENBQUMsSUFBSSxDQUFsQyxFQUFxQ0EsQ0FBQyxFQUF0QyxFQUEwQztBQUN4QzRPLElBQUFBLElBQUksR0FBR3UyQixPQUFPLENBQUNubEMsQ0FBRCxDQUFkOztBQUNBLFFBQUk0TyxJQUFJLEtBQUssR0FBYixFQUFrQjtBQUNoQnUyQixNQUFBQSxPQUFPLENBQUNwWixNQUFSLENBQWUvckIsQ0FBZixFQUFrQixDQUFsQjtBQUNELEtBRkQsTUFFTyxJQUFJNE8sSUFBSSxLQUFLLElBQWIsRUFBbUI7QUFDeEJ1MkIsTUFBQUEsT0FBTyxDQUFDcFosTUFBUixDQUFlL3JCLENBQWYsRUFBa0IsQ0FBbEI7QUFDQXlsQyxNQUFBQSxFQUFFO0FBQ0gsS0FITSxNQUdBLElBQUlBLEVBQUosRUFBUTtBQUNiTixNQUFBQSxPQUFPLENBQUNwWixNQUFSLENBQWUvckIsQ0FBZixFQUFrQixDQUFsQjtBQUNBeWxDLE1BQUFBLEVBQUU7QUFDSDtBQUNGLEdBbE44QyxDQW9OL0M7OztBQUNBLE1BQUksQ0FBQ1IsVUFBRCxJQUFlLENBQUNDLGFBQXBCLEVBQW1DO0FBQ2pDLFdBQU9PLEVBQUUsRUFBVCxFQUFhQSxFQUFiLEVBQWlCO0FBQ2ZOLE1BQUFBLE9BQU8sQ0FBQzNyQyxPQUFSLENBQWdCLElBQWhCO0FBQ0Q7QUFDRjs7QUFFRCxNQUFJeXJDLFVBQVUsSUFBSUUsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQTdCLEtBQ0MsQ0FBQ0EsT0FBTyxDQUFDLENBQUQsQ0FBUixJQUFlQSxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVd0aUMsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUR6QyxDQUFKLEVBQ21EO0FBQ2pEc2lDLElBQUFBLE9BQU8sQ0FBQzNyQyxPQUFSLENBQWdCLEVBQWhCO0FBQ0Q7O0FBRUQsTUFBSWdzQyxnQkFBZ0IsSUFBS0wsT0FBTyxDQUFDM2tDLElBQVIsQ0FBYSxHQUFiLEVBQWtCK0MsTUFBbEIsQ0FBeUIsQ0FBQyxDQUExQixNQUFpQyxHQUExRCxFQUFnRTtBQUM5RDRoQyxJQUFBQSxPQUFPLENBQUN0ckMsSUFBUixDQUFhLEVBQWI7QUFDRDs7QUFFRCxNQUFJNnJDLFVBQVUsR0FBR1AsT0FBTyxDQUFDLENBQUQsQ0FBUCxLQUFlLEVBQWYsSUFDWkEsT0FBTyxDQUFDLENBQUQsQ0FBUCxJQUFjQSxPQUFPLENBQUMsQ0FBRCxDQUFQLENBQVd0aUMsTUFBWCxDQUFrQixDQUFsQixNQUF5QixHQUQ1QyxDQXBPK0MsQ0F1Ty9DOztBQUNBLE1BQUl1aUMsU0FBSixFQUFlO0FBQ2J2Z0MsSUFBQUEsTUFBTSxDQUFDbkMsUUFBUCxHQUFrQm1DLE1BQU0sQ0FBQ3JDLElBQVAsR0FBY2tqQyxVQUFVLEdBQUcsRUFBSCxHQUNWUCxPQUFPLENBQUNqckMsTUFBUixHQUFpQmlyQyxPQUFPLENBQUNockMsS0FBUixFQUFqQixHQUFtQyxFQURuRSxDQURhLENBR2I7QUFDQTtBQUNBOztBQUNBLFFBQUltckMsVUFBVSxHQUFHemdDLE1BQU0sQ0FBQ3JDLElBQVAsSUFBZXFDLE1BQU0sQ0FBQ3JDLElBQVAsQ0FBWWpPLE9BQVosQ0FBb0IsR0FBcEIsSUFBMkIsQ0FBMUMsR0FDQXNRLE1BQU0sQ0FBQ3JDLElBQVAsQ0FBWWEsS0FBWixDQUFrQixHQUFsQixDQURBLEdBQ3lCLEtBRDFDOztBQUVBLFFBQUlpaUMsVUFBSixFQUFnQjtBQUNkemdDLE1BQUFBLE1BQU0sQ0FBQ2xTLElBQVAsR0FBYzJ5QyxVQUFVLENBQUNuckMsS0FBWCxFQUFkO0FBQ0EwSyxNQUFBQSxNQUFNLENBQUNyQyxJQUFQLEdBQWNxQyxNQUFNLENBQUNuQyxRQUFQLEdBQWtCNGlDLFVBQVUsQ0FBQ25yQyxLQUFYLEVBQWhDO0FBQ0Q7QUFDRjs7QUFFRDhxQyxFQUFBQSxVQUFVLEdBQUdBLFVBQVUsSUFBS3BnQyxNQUFNLENBQUNyQyxJQUFQLElBQWUyaUMsT0FBTyxDQUFDanJDLE1BQW5EOztBQUVBLE1BQUkrcUMsVUFBVSxJQUFJLENBQUNTLFVBQW5CLEVBQStCO0FBQzdCUCxJQUFBQSxPQUFPLENBQUMzckMsT0FBUixDQUFnQixFQUFoQjtBQUNEOztBQUVELE1BQUksQ0FBQzJyQyxPQUFPLENBQUNqckMsTUFBYixFQUFxQjtBQUNuQjJLLElBQUFBLE1BQU0sQ0FBQ2pDLFFBQVAsR0FBa0IsSUFBbEI7QUFDQWlDLElBQUFBLE1BQU0sQ0FBQy9ELElBQVAsR0FBYyxJQUFkO0FBQ0QsR0FIRCxNQUdPO0FBQ0wrRCxJQUFBQSxNQUFNLENBQUNqQyxRQUFQLEdBQWtCdWlDLE9BQU8sQ0FBQzNrQyxJQUFSLENBQWEsR0FBYixDQUFsQjtBQUNELEdBalE4QyxDQW1RL0M7OztBQUNBLE1BQUksQ0FBQzJnQyxJQUFJLENBQUNvRSxNQUFMLENBQVkxZ0MsTUFBTSxDQUFDakMsUUFBbkIsQ0FBRCxJQUFpQyxDQUFDdStCLElBQUksQ0FBQ29FLE1BQUwsQ0FBWTFnQyxNQUFNLENBQUNwQyxNQUFuQixDQUF0QyxFQUFrRTtBQUNoRW9DLElBQUFBLE1BQU0sQ0FBQy9ELElBQVAsR0FBYyxDQUFDK0QsTUFBTSxDQUFDakMsUUFBUCxHQUFrQmlDLE1BQU0sQ0FBQ2pDLFFBQXpCLEdBQW9DLEVBQXJDLEtBQ0NpQyxNQUFNLENBQUNwQyxNQUFQLEdBQWdCb0MsTUFBTSxDQUFDcEMsTUFBdkIsR0FBZ0MsRUFEakMsQ0FBZDtBQUVEOztBQUNEb0MsRUFBQUEsTUFBTSxDQUFDbFMsSUFBUCxHQUFjMnhDLFFBQVEsQ0FBQzN4QyxJQUFULElBQWlCa1MsTUFBTSxDQUFDbFMsSUFBdEM7QUFDQWtTLEVBQUFBLE1BQU0sQ0FBQzg4QixPQUFQLEdBQWlCOThCLE1BQU0sQ0FBQzg4QixPQUFQLElBQWtCMkMsUUFBUSxDQUFDM0MsT0FBNUM7QUFDQTk4QixFQUFBQSxNQUFNLENBQUN4QyxJQUFQLEdBQWN3QyxNQUFNLENBQUMyOEIsTUFBUCxFQUFkO0FBQ0EsU0FBTzM4QixNQUFQO0FBQ0QsQ0E1UUQ7O0FBOFFBNjhCLEdBQUcsQ0FBQ3hxQyxTQUFKLENBQWN3c0MsU0FBZCxHQUEwQixZQUFXO0FBQ25DLE1BQUlsaEMsSUFBSSxHQUFHLEtBQUtBLElBQWhCO0FBQ0EsTUFBSUcsSUFBSSxHQUFHbS9CLFdBQVcsQ0FBQ3VCLElBQVosQ0FBaUI3Z0MsSUFBakIsQ0FBWDs7QUFDQSxNQUFJRyxJQUFKLEVBQVU7QUFDUkEsSUFBQUEsSUFBSSxHQUFHQSxJQUFJLENBQUMsQ0FBRCxDQUFYOztBQUNBLFFBQUlBLElBQUksS0FBSyxHQUFiLEVBQWtCO0FBQ2hCLFdBQUtBLElBQUwsR0FBWUEsSUFBSSxDQUFDWSxNQUFMLENBQVksQ0FBWixDQUFaO0FBQ0Q7O0FBQ0RmLElBQUFBLElBQUksR0FBR0EsSUFBSSxDQUFDZSxNQUFMLENBQVksQ0FBWixFQUFlZixJQUFJLENBQUN0SSxNQUFMLEdBQWN5SSxJQUFJLENBQUN6SSxNQUFsQyxDQUFQO0FBQ0Q7O0FBQ0QsTUFBSXNJLElBQUosRUFBVSxLQUFLRSxRQUFMLEdBQWdCRixJQUFoQjtBQUNYLENBWEQ7Ozs7Ozs7Ozs7QUNodEJhOzs7O0FBRWJwUixNQUFNLENBQUM1QixPQUFQLEdBQWlCO0FBQ2ZtUCxFQUFBQSxRQUFRLEVBQUUsa0JBQVM4UixHQUFULEVBQWM7QUFDdEIsV0FBTyxPQUFPQSxHQUFQLEtBQWdCLFFBQXZCO0FBQ0QsR0FIYztBQUlmaFIsRUFBQUEsUUFBUSxFQUFFLGtCQUFTZ1IsR0FBVCxFQUFjO0FBQ3RCLFdBQU8sUUFBT0EsR0FBUCxNQUFnQixRQUFoQixJQUE0QkEsR0FBRyxLQUFLLElBQTNDO0FBQ0QsR0FOYztBQU9mODBCLEVBQUFBLE1BQU0sRUFBRSxnQkFBUzkwQixHQUFULEVBQWM7QUFDcEIsV0FBT0EsR0FBRyxLQUFLLElBQWY7QUFDRCxHQVRjO0FBVWY0MEIsRUFBQUEsaUJBQWlCLEVBQUUsMkJBQVM1MEIsR0FBVCxFQUFjO0FBQy9CLFdBQU9BLEdBQUcsSUFBSSxJQUFkO0FBQ0Q7QUFaYyxDQUFqQjs7Ozs7Ozs7OztBQ0RBO0FBQ0E7QUFDQTtBQUVBcmYsTUFBTSxDQUFDNUIsT0FBUCxHQUFpQmcvQixTQUFqQjtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBU0EsU0FBVCxDQUFvQnZ6QixFQUFwQixFQUF3QitnQixHQUF4QixFQUE2QjtBQUMzQixNQUFJbHFCLE1BQU0sQ0FBQyxlQUFELENBQVYsRUFBNkI7QUFDM0IsV0FBT21KLEVBQVA7QUFDRDs7QUFFRCxNQUFJeWtCLE1BQU0sR0FBRyxLQUFiOztBQUNBLFdBQVNpbUIsVUFBVCxHQUFzQjtBQUNwQixRQUFJLENBQUNqbUIsTUFBTCxFQUFhO0FBQ1gsVUFBSTV0QixNQUFNLENBQUMsa0JBQUQsQ0FBVixFQUFnQztBQUM5QixjQUFNLElBQUlaLEtBQUosQ0FBVThxQixHQUFWLENBQU47QUFDRCxPQUZELE1BRU8sSUFBSWxxQixNQUFNLENBQUMsa0JBQUQsQ0FBVixFQUFnQztBQUNyQzJTLFFBQUFBLE9BQU8sQ0FBQ21oQyxLQUFSLENBQWM1cEIsR0FBZDtBQUNELE9BRk0sTUFFQTtBQUNMdlgsUUFBQUEsT0FBTyxDQUFDQyxJQUFSLENBQWFzWCxHQUFiO0FBQ0Q7O0FBQ0QwRCxNQUFBQSxNQUFNLEdBQUcsSUFBVDtBQUNEOztBQUNELFdBQU96a0IsRUFBRSxDQUFDakIsS0FBSCxDQUFTLElBQVQsRUFBZWxCLFNBQWYsQ0FBUDtBQUNEOztBQUVELFNBQU82c0MsVUFBUDtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLFNBQVM3ekMsTUFBVCxDQUFpQnVLLElBQWpCLEVBQXVCO0FBQ3JCO0FBQ0EsTUFBSTtBQUNGLFFBQUksQ0FBQ2lxQixxQkFBTSxDQUFDdWYsWUFBWixFQUEwQixPQUFPLEtBQVA7QUFDM0IsR0FGRCxDQUVFLE9BQU8zVixDQUFQLEVBQVU7QUFDVixXQUFPLEtBQVA7QUFDRDs7QUFDRCxNQUFJdjZCLEdBQUcsR0FBRzJ3QixxQkFBTSxDQUFDdWYsWUFBUCxDQUFvQnhwQyxJQUFwQixDQUFWO0FBQ0EsTUFBSSxRQUFRMUcsR0FBWixFQUFpQixPQUFPLEtBQVA7QUFDakIsU0FBTzJjLE1BQU0sQ0FBQzNjLEdBQUQsQ0FBTixDQUFZRSxXQUFaLE9BQThCLE1BQXJDO0FBQ0Q7Ozs7Ozs7Ozs7QUNsRUR6RSxNQUFNLENBQUM1QixPQUFQLEdBQWlCMkgsTUFBakI7QUFFQSxJQUFJdU8sY0FBYyxHQUFHcFcsTUFBTSxDQUFDNEgsU0FBUCxDQUFpQndPLGNBQXRDOztBQUVBLFNBQVN2TyxNQUFULEdBQWtCO0FBQ2QsTUFBSWdHLE1BQU0sR0FBRyxFQUFiOztBQUVBLE9BQUssSUFBSTZDLENBQUMsR0FBRyxDQUFiLEVBQWdCQSxDQUFDLEdBQUdsSCxTQUFTLENBQUNvQixNQUE5QixFQUFzQzhGLENBQUMsRUFBdkMsRUFBMkM7QUFDdkMsUUFBSXpILE1BQU0sR0FBR08sU0FBUyxDQUFDa0gsQ0FBRCxDQUF0Qjs7QUFFQSxTQUFLLElBQUlwSyxHQUFULElBQWdCMkMsTUFBaEIsRUFBd0I7QUFDcEIsVUFBSW1OLGNBQWMsQ0FBQy9KLElBQWYsQ0FBb0JwRCxNQUFwQixFQUE0QjNDLEdBQTVCLENBQUosRUFBc0M7QUFDbEN1SCxRQUFBQSxNQUFNLENBQUN2SCxHQUFELENBQU4sR0FBYzJDLE1BQU0sQ0FBQzNDLEdBQUQsQ0FBcEI7QUFDSDtBQUNKO0FBQ0o7O0FBRUQsU0FBT3VILE1BQVA7QUFDSCIsInNvdXJjZXMiOlsid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL0BlbXVyZ28vY2lwMTQtanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWxUb2tlbi5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9idWlsZEZ1bGxQYXRoLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29va2llcy5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc1VSTFNhbWVPcmlnaW4uanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2JlY2gzMi9kaXN0L2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2JsYWtlMmItd2FzbS9ibGFrZTJiLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2JsYWtlMmItd2FzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9ibGFrZTJiL2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9idWlsdGluLXN0YXR1cy1jb2Rlcy9icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvZm9ybS1kYXRhL2xpYi9icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL2llZWU3NTQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9uYW5vYXNzZXJ0L2luZGV4LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nL2RlY29kZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy9lbmNvZGUuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcXVlcnlzdHJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2Vycm9ycy1icm93c2VyLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9kdXBsZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvYXN5bmNfaXRlcmF0b3IuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2J1ZmZlcl9saXN0LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9mcm9tLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL3BpcGVsaW5lLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZS5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc2FmZS1idWZmZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvaW5kZXguanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL2NhcGFiaWxpdHkuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3JlcXVlc3QuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvc3RyZWFtLWh0dHAvbGliL3Jlc3BvbnNlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy91cmwvbm9kZV9tb2R1bGVzL3B1bnljb2RlL3B1bnljb2RlLmpzIiwid2VicGFjazovL3dhbGxldF90ZXN0Ly4vbm9kZV9tb2R1bGVzL3VybC91cmwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXJsL3V0aWwuanMiLCJ3ZWJwYWNrOi8vd2FsbGV0X3Rlc3QvLi9ub2RlX21vZHVsZXMvdXRpbC1kZXByZWNhdGUvYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly93YWxsZXRfdGVzdC8uL25vZGVfbW9kdWxlcy94dGVuZC9pbW11dGFibGUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBibGFrZTJiXzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcImJsYWtlMmJcIikpO1xuY29uc3QgYmVjaDMyXzEgPSByZXF1aXJlKFwiYmVjaDMyXCIpO1xuLy8vIG5vdGU6IHRoaXMgZnVuY3Rpb24gY2FuJ3QgYmUgaW52ZXJ0ZWQgZHVlIHRvIHRoZSBoYXNoXG5jb25zdCBEQVRBID0gXCJhc3NldFwiO1xuY2xhc3MgQXNzZXRGaW5nZXJwcmludCB7XG4gICAgY29uc3RydWN0b3IoaGFzaEJ1Zikge1xuICAgICAgICB0aGlzLmhhc2hCdWYgPSBoYXNoQnVmO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUhhc2goaGFzaCkge1xuICAgICAgICByZXR1cm4gbmV3IEFzc2V0RmluZ2VycHJpbnQoaGFzaCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tUGFydHMocG9saWN5SWQsIGFzc2V0TmFtZSkge1xuICAgICAgICAvLyBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2NhcmRhbm8tZm91bmRhdGlvbi9DSVBzL3B1bGwvNjRcbiAgICAgICAgY29uc3QgaGFzaEJ1ZiA9ICgwLCBibGFrZTJiXzEuZGVmYXVsdCkoMjApXG4gICAgICAgICAgICAudXBkYXRlKG5ldyBVaW50OEFycmF5KFsuLi5wb2xpY3lJZCwgLi4uYXNzZXROYW1lXSkpXG4gICAgICAgICAgICAuZGlnZXN0KFwiYmluYXJ5XCIpO1xuICAgICAgICByZXR1cm4gQXNzZXRGaW5nZXJwcmludC5mcm9tSGFzaChoYXNoQnVmKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21CZWNoMzIoZmluZ2VycHJpbnQpIHtcbiAgICAgICAgY29uc3QgeyBwcmVmaXgsIHdvcmRzIH0gPSBiZWNoMzJfMS5iZWNoMzIuZGVjb2RlKGZpbmdlcnByaW50KTtcbiAgICAgICAgaWYgKHByZWZpeCAhPT0gREFUQSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhc3NldCBmaW5nZXJwcmludFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBoYXNoQnVmID0gQnVmZmVyLmZyb20oYmVjaDMyXzEuYmVjaDMyLmZyb21Xb3Jkcyh3b3JkcykpO1xuICAgICAgICByZXR1cm4gQXNzZXRGaW5nZXJwcmludC5mcm9tSGFzaChoYXNoQnVmKTtcbiAgICB9XG4gICAgZmluZ2VycHJpbnQoKSB7XG4gICAgICAgIGNvbnN0IHdvcmRzID0gYmVjaDMyXzEuYmVjaDMyLnRvV29yZHModGhpcy5oYXNoQnVmKTtcbiAgICAgICAgcmV0dXJuIGJlY2gzMl8xLmJlY2gzMi5lbmNvZGUoREFUQSwgd29yZHMpO1xuICAgIH1cbiAgICBoYXNoKCkge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20odGhpcy5oYXNoQnVmKS50b1N0cmluZyhcImhleFwiKTtcbiAgICB9XG4gICAgcHJlZml4KCkge1xuICAgICAgICByZXR1cm4gREFUQTtcbiAgICB9XG4gICAgLy8gVGhlIGxhc3Qgc2l4IGNoYXJhY3RlcnMgb2YgdGhlIGRhdGEgcGFydCBmb3JtIGEgY2hlY2tzdW0gYW5kIGNvbnRhaW4gbm8gaW5mb3JtYXRpb25cbiAgICBjaGVja3N1bSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZmluZ2VycHJpbnQoKS5zbGljZSgtNik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQXNzZXRGaW5nZXJwcmludDtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvYXhpb3MnKTsiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBzZXR0bGUgPSByZXF1aXJlKCcuLy4uL2NvcmUvc2V0dGxlJyk7XG52YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG52YXIgYnVpbGRVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBidWlsZEZ1bGxQYXRoID0gcmVxdWlyZSgnLi4vY29yZS9idWlsZEZ1bGxQYXRoJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblxuICAgIC8vIEhUVFAgYmFzaWMgYXV0aGVudGljYXRpb25cbiAgICBpZiAoY29uZmlnLmF1dGgpIHtcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgdmFyIHBhc3N3b3JkID0gY29uZmlnLmF1dGgucGFzc3dvcmQgPyB1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoY29uZmlnLmF1dGgucGFzc3dvcmQpKSA6ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICB2YXIgZnVsbFBhdGggPSBidWlsZEZ1bGxQYXRoKGNvbmZpZy5iYXNlVVJMLCBjb25maWcudXJsKTtcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcblxuICAgIC8vIFNldCB0aGUgcmVxdWVzdCB0aW1lb3V0IGluIE1TXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XG5cbiAgICBmdW5jdGlvbiBvbmxvYWRlbmQoKSB7XG4gICAgICBpZiAoIXJlcXVlc3QpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcbiAgICAgIHZhciByZXNwb25zZUhlYWRlcnMgPSAnZ2V0QWxsUmVzcG9uc2VIZWFkZXJzJyBpbiByZXF1ZXN0ID8gcGFyc2VIZWFkZXJzKHJlcXVlc3QuZ2V0QWxsUmVzcG9uc2VIZWFkZXJzKCkpIDogbnVsbDtcbiAgICAgIHZhciByZXNwb25zZURhdGEgPSAhcmVzcG9uc2VUeXBlIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnIHx8ICByZXNwb25zZVR5cGUgPT09ICdqc29uJyA/XG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcbiAgICAgIHZhciByZXNwb25zZSA9IHtcbiAgICAgICAgZGF0YTogcmVzcG9uc2VEYXRhLFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXF1ZXN0LnN0YXR1c1RleHQsXG4gICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXG4gICAgICAgIHJlcXVlc3Q6IHJlcXVlc3RcbiAgICAgIH07XG5cbiAgICAgIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHJlc3BvbnNlKTtcblxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxuICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKCdvbmxvYWRlbmQnIGluIHJlcXVlc3QpIHtcbiAgICAgIC8vIFVzZSBvbmxvYWRlbmQgaWYgYXZhaWxhYmxlXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGlzdGVuIGZvciByZWFkeSBzdGF0ZSB0byBlbXVsYXRlIG9ubG9hZGVuZFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgICBpZiAoIXJlcXVlc3QgfHwgcmVxdWVzdC5yZWFkeVN0YXRlICE9PSA0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXG4gICAgICAgIC8vIFdpdGggb25lIGV4Y2VwdGlvbjogcmVxdWVzdCB0aGF0IHVzaW5nIGZpbGU6IHByb3RvY29sLCBtb3N0IGJyb3dzZXJzXG4gICAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcbiAgICAgICAgLy8gc28gd2Ugc2hvdWxkIGNhbGwgb25sb2FkZW5kIG9uIHRoZSBuZXh0ICd0aWNrJ1xuICAgICAgICBzZXRUaW1lb3V0KG9ubG9hZGVuZCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcbiAgICByZXF1ZXN0Lm9uYWJvcnQgPSBmdW5jdGlvbiBoYW5kbGVBYm9ydCgpIHtcbiAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xuICAgIHJlcXVlc3Qub25lcnJvciA9IGZ1bmN0aW9uIGhhbmRsZUVycm9yKCkge1xuICAgICAgLy8gUmVhbCBlcnJvcnMgYXJlIGhpZGRlbiBmcm9tIHVzIGJ5IHRoZSBicm93c2VyXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignTmV0d29yayBFcnJvcicsIGNvbmZpZywgbnVsbCwgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gSGFuZGxlIHRpbWVvdXRcbiAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7XG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9ICd0aW1lb3V0IG9mICcgKyBjb25maWcudGltZW91dCArICdtcyBleGNlZWRlZCc7XG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0RXJyb3JNZXNzYWdlO1xuICAgICAgfVxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgICB0aW1lb3V0RXJyb3JNZXNzYWdlLFxuICAgICAgICBjb25maWcsXG4gICAgICAgIGNvbmZpZy50cmFuc2l0aW9uYWwgJiYgY29uZmlnLnRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcbiAgICAgICAgcmVxdWVzdCkpO1xuXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XG4gICAgICByZXF1ZXN0ID0gbnVsbDtcbiAgICB9O1xuXG4gICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgLy8gVGhpcyBpcyBvbmx5IGRvbmUgaWYgcnVubmluZyBpbiBhIHN0YW5kYXJkIGJyb3dzZXIgZW52aXJvbm1lbnQuXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cbiAgICBpZiAodXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSkge1xuICAgICAgLy8gQWRkIHhzcmYgaGVhZGVyXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgY29va2llcy5yZWFkKGNvbmZpZy54c3JmQ29va2llTmFtZSkgOlxuICAgICAgICB1bmRlZmluZWQ7XG5cbiAgICAgIGlmICh4c3JmVmFsdWUpIHtcbiAgICAgICAgcmVxdWVzdEhlYWRlcnNbY29uZmlnLnhzcmZIZWFkZXJOYW1lXSA9IHhzcmZWYWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxuICAgIGlmICgnc2V0UmVxdWVzdEhlYWRlcicgaW4gcmVxdWVzdCkge1xuICAgICAgdXRpbHMuZm9yRWFjaChyZXF1ZXN0SGVhZGVycywgZnVuY3Rpb24gc2V0UmVxdWVzdEhlYWRlcih2YWwsIGtleSkge1xuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcbiAgICAgICAgICAvLyBSZW1vdmUgQ29udGVudC1UeXBlIGlmIGRhdGEgaXMgdW5kZWZpbmVkXG4gICAgICAgICAgZGVsZXRlIHJlcXVlc3RIZWFkZXJzW2tleV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gT3RoZXJ3aXNlIGFkZCBoZWFkZXIgdG8gdGhlIHJlcXVlc3RcbiAgICAgICAgICByZXF1ZXN0LnNldFJlcXVlc3RIZWFkZXIoa2V5LCB2YWwpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBBZGQgd2l0aENyZWRlbnRpYWxzIHRvIHJlcXVlc3QgaWYgbmVlZGVkXG4gICAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcud2l0aENyZWRlbnRpYWxzKSkge1xuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChyZXNwb25zZVR5cGUgJiYgcmVzcG9uc2VUeXBlICE9PSAnanNvbicpIHtcbiAgICAgIHJlcXVlc3QucmVzcG9uc2VUeXBlID0gY29uZmlnLnJlc3BvbnNlVHlwZTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAoIXJlcXVlc3REYXRhKSB7XG4gICAgICByZXF1ZXN0RGF0YSA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gU2VuZCB0aGUgcmVxdWVzdFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XG4gIH0pO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL2NvcmUvbWVyZ2VDb25maWcnKTtcbnZhciBkZWZhdWx0cyA9IHJlcXVpcmUoJy4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gaW5zdGFuY2Ugb2YgQXhpb3NcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVmYXVsdENvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICogQHJldHVybiB7QXhpb3N9IEEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRDb25maWcpIHtcbiAgdmFyIGNvbnRleHQgPSBuZXcgQXhpb3MoZGVmYXVsdENvbmZpZyk7XG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xuXG4gIC8vIENvcHkgYXhpb3MucHJvdG90eXBlIHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGNvbnRleHQgdG8gaW5zdGFuY2VcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcblxuICByZXR1cm4gaW5zdGFuY2U7XG59XG5cbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxudmFyIGF4aW9zID0gY3JlYXRlSW5zdGFuY2UoZGVmYXVsdHMpO1xuXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcbmF4aW9zLkF4aW9zID0gQXhpb3M7XG5cbi8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcbmF4aW9zLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xuICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoYXhpb3MuZGVmYXVsdHMsIGluc3RhbmNlQ29uZmlnKSk7XG59O1xuXG4vLyBFeHBvc2UgQ2FuY2VsICYgQ2FuY2VsVG9rZW5cbmF4aW9zLkNhbmNlbCA9IHJlcXVpcmUoJy4vY2FuY2VsL0NhbmNlbCcpO1xuYXhpb3MuQ2FuY2VsVG9rZW4gPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWxUb2tlbicpO1xuYXhpb3MuaXNDYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9pc0NhbmNlbCcpO1xuXG4vLyBFeHBvc2UgYWxsL3NwcmVhZFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XG4gIHJldHVybiBQcm9taXNlLmFsbChwcm9taXNlcyk7XG59O1xuYXhpb3Muc3ByZWFkID0gcmVxdWlyZSgnLi9oZWxwZXJzL3NwcmVhZCcpO1xuXG4vLyBFeHBvc2UgaXNBeGlvc0Vycm9yXG5heGlvcy5pc0F4aW9zRXJyb3IgPSByZXF1aXJlKCcuL2hlbHBlcnMvaXNBeGlvc0Vycm9yJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gYXhpb3M7XG5cbi8vIEFsbG93IHVzZSBvZiBkZWZhdWx0IGltcG9ydCBzeW50YXggaW4gVHlwZVNjcmlwdFxubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IGF4aW9zO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQ2FuY2VsKHZhbHVlKSB7XG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcbnZhciBidWlsZFVSTCA9IHJlcXVpcmUoJy4uL2hlbHBlcnMvYnVpbGRVUkwnKTtcbnZhciBJbnRlcmNlcHRvck1hbmFnZXIgPSByZXF1aXJlKCcuL0ludGVyY2VwdG9yTWFuYWdlcicpO1xudmFyIGRpc3BhdGNoUmVxdWVzdCA9IHJlcXVpcmUoJy4vZGlzcGF0Y2hSZXF1ZXN0Jyk7XG52YXIgbWVyZ2VDb25maWcgPSByZXF1aXJlKCcuL21lcmdlQ29uZmlnJyk7XG52YXIgdmFsaWRhdG9yID0gcmVxdWlyZSgnLi4vaGVscGVycy92YWxpZGF0b3InKTtcblxudmFyIHZhbGlkYXRvcnMgPSB2YWxpZGF0b3IudmFsaWRhdG9ycztcbi8qKlxuICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIEF4aW9zKGluc3RhbmNlQ29uZmlnKSB7XG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcbiAgdGhpcy5pbnRlcmNlcHRvcnMgPSB7XG4gICAgcmVxdWVzdDogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpLFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcbiAgfTtcbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcgc3BlY2lmaWMgZm9yIHRoaXMgcmVxdWVzdCAobWVyZ2VkIHdpdGggdGhpcy5kZWZhdWx0cylcbiAqL1xuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxuICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25maWcgPSBhcmd1bWVudHNbMV0gfHwge307XG4gICAgY29uZmlnLnVybCA9IGFyZ3VtZW50c1swXTtcbiAgfSBlbHNlIHtcbiAgICBjb25maWcgPSBjb25maWcgfHwge307XG4gIH1cblxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuXG4gIC8vIFNldCBjb25maWcubWV0aG9kXG4gIGlmIChjb25maWcubWV0aG9kKSB7XG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcbiAgfSBlbHNlIGlmICh0aGlzLmRlZmF1bHRzLm1ldGhvZCkge1xuICAgIGNvbmZpZy5tZXRob2QgPSB0aGlzLmRlZmF1bHRzLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICB9IGVsc2Uge1xuICAgIGNvbmZpZy5tZXRob2QgPSAnZ2V0JztcbiAgfVxuXG4gIHZhciB0cmFuc2l0aW9uYWwgPSBjb25maWcudHJhbnNpdGlvbmFsO1xuXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xuICAgIHZhbGlkYXRvci5hc3NlcnRPcHRpb25zKHRyYW5zaXRpb25hbCwge1xuICAgICAgc2lsZW50SlNPTlBhcnNpbmc6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJyksXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuLCAnMS4wLjAnKSxcbiAgICAgIGNsYXJpZnlUaW1lb3V0RXJyb3I6IHZhbGlkYXRvcnMudHJhbnNpdGlvbmFsKHZhbGlkYXRvcnMuYm9vbGVhbiwgJzEuMC4wJylcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvLyBmaWx0ZXIgb3V0IHNraXBwZWQgaW50ZXJjZXB0b3JzXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xuICB2YXIgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gdHJ1ZTtcbiAgdGhpcy5pbnRlcmNlcHRvcnMucmVxdWVzdC5mb3JFYWNoKGZ1bmN0aW9uIHVuc2hpZnRSZXF1ZXN0SW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgPSBzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMgJiYgaW50ZXJjZXB0b3Iuc3luY2hyb25vdXM7XG5cbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XG4gIHRoaXMuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLmZvckVhY2goZnVuY3Rpb24gcHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzKGludGVyY2VwdG9yKSB7XG4gICAgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHZhciBwcm9taXNlO1xuXG4gIGlmICghc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzKSB7XG4gICAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcblxuICAgIEFycmF5LnByb3RvdHlwZS51bnNoaWZ0LmFwcGx5KGNoYWluLCByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbik7XG4gICAgY2hhaW4gPSBjaGFpbi5jb25jYXQocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluKTtcblxuICAgIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcbiAgICB3aGlsZSAoY2hhaW4ubGVuZ3RoKSB7XG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICAgIH1cblxuICAgIHJldHVybiBwcm9taXNlO1xuICB9XG5cblxuICB2YXIgbmV3Q29uZmlnID0gY29uZmlnO1xuICB3aGlsZSAocmVxdWVzdEludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcbiAgICB2YXIgb25SZWplY3RlZCA9IHJlcXVlc3RJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCk7XG4gICAgdHJ5IHtcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIG9uUmVqZWN0ZWQoZXJyb3IpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdHJ5IHtcbiAgICBwcm9taXNlID0gZGlzcGF0Y2hSZXF1ZXN0KG5ld0NvbmZpZyk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgfVxuXG4gIHdoaWxlIChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ubGVuZ3RoKSB7XG4gICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSwgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG5BeGlvcy5wcm90b3R5cGUuZ2V0VXJpID0gZnVuY3Rpb24gZ2V0VXJpKGNvbmZpZykge1xuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xuICByZXR1cm4gYnVpbGRVUkwoY29uZmlnLnVybCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLnJlcGxhY2UoL15cXD8vLCAnJyk7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChtZXJnZUNvbmZpZyhjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmwsXG4gICAgICBkYXRhOiAoY29uZmlnIHx8IHt9KS5kYXRhXG4gICAgfSkpO1xuICB9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXG4gIEF4aW9zLnByb3RvdHlwZVttZXRob2RdID0gZnVuY3Rpb24odXJsLCBkYXRhLCBjb25maWcpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xuICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICB1cmw6IHVybCxcbiAgICAgIGRhdGE6IGRhdGFcbiAgICB9KSk7XG4gIH07XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBBeGlvcztcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5mdW5jdGlvbiBJbnRlcmNlcHRvck1hbmFnZXIoKSB7XG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcbn1cblxuLyoqXG4gKiBBZGQgYSBuZXcgaW50ZXJjZXB0b3IgdG8gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0ZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgcmVqZWN0YCBmb3IgYSBgUHJvbWlzZWBcbiAqXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUudXNlID0gZnVuY3Rpb24gdXNlKGZ1bGZpbGxlZCwgcmVqZWN0ZWQsIG9wdGlvbnMpIHtcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcbiAgICBmdWxmaWxsZWQ6IGZ1bGZpbGxlZCxcbiAgICByZWplY3RlZDogcmVqZWN0ZWQsXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXG4gICAgcnVuV2hlbjogb3B0aW9ucyA/IG9wdGlvbnMucnVuV2hlbiA6IG51bGxcbiAgfSk7XG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbiBpbnRlcmNlcHRvciBmcm9tIHRoZSBzdGFja1xuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5lamVjdCA9IGZ1bmN0aW9uIGVqZWN0KGlkKSB7XG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xuICAgIHRoaXMuaGFuZGxlcnNbaWRdID0gbnVsbDtcbiAgfVxufTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHBhcnRpY3VsYXJseSB1c2VmdWwgZm9yIHNraXBwaW5nIG92ZXIgYW55XG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiBUaGUgZnVuY3Rpb24gdG8gY2FsbCBmb3IgZWFjaCBpbnRlcmNlcHRvclxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiBmb3JFYWNoKGZuKSB7XG4gIHV0aWxzLmZvckVhY2godGhpcy5oYW5kbGVycywgZnVuY3Rpb24gZm9yRWFjaEhhbmRsZXIoaCkge1xuICAgIGlmIChoICE9PSBudWxsKSB7XG4gICAgICBmbihoKTtcbiAgICB9XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBpc0Fic29sdXRlVVJMID0gcmVxdWlyZSgnLi4vaGVscGVycy9pc0Fic29sdXRlVVJMJyk7XG52YXIgY29tYmluZVVSTHMgPSByZXF1aXJlKCcuLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogQ3JlYXRlcyBhIG5ldyBVUkwgYnkgY29tYmluaW5nIHRoZSBiYXNlVVJMIHdpdGggdGhlIHJlcXVlc3RlZFVSTCxcbiAqIG9ubHkgd2hlbiB0aGUgcmVxdWVzdGVkVVJMIGlzIG5vdCBhbHJlYWR5IGFuIGFic29sdXRlIFVSTC5cbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgZnVsbCBwYXRoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcbiAgaWYgKGJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwocmVxdWVzdGVkVVJMKSkge1xuICAgIHJldHVybiBjb21iaW5lVVJMcyhiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpO1xuICB9XG4gIHJldHVybiByZXF1ZXN0ZWRVUkw7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW5oYW5jZUVycm9yID0gcmVxdWlyZSgnLi9lbmhhbmNlRXJyb3InKTtcblxuLyoqXG4gKiBDcmVhdGUgYW4gRXJyb3Igd2l0aCB0aGUgc3BlY2lmaWVkIG1lc3NhZ2UsIGNvbmZpZywgZXJyb3IgY29kZSwgcmVxdWVzdCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIFRoZSBjb25maWcuXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVzcG9uc2VdIFRoZSByZXNwb25zZS5cbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGNyZWF0ZWQgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlRXJyb3IobWVzc2FnZSwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSkge1xuICB2YXIgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIHRyYW5zZm9ybURhdGEgPSByZXF1aXJlKCcuL3RyYW5zZm9ybURhdGEnKTtcbnZhciBpc0NhbmNlbCA9IHJlcXVpcmUoJy4uL2NhbmNlbC9pc0NhbmNlbCcpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi4vZGVmYXVsdHMnKTtcblxuLyoqXG4gKiBUaHJvd3MgYSBgQ2FuY2VsYCBpZiBjYW5jZWxsYXRpb24gaGFzIGJlZW4gcmVxdWVzdGVkLlxuICovXG5mdW5jdGlvbiB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZykge1xuICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcbiAgfVxufVxuXG4vKipcbiAqIERpc3BhdGNoIGEgcmVxdWVzdCB0byB0aGUgc2VydmVyIHVzaW5nIHRoZSBjb25maWd1cmVkIGFkYXB0ZXIuXG4gKlxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcbiAqIEByZXR1cm5zIHtQcm9taXNlfSBUaGUgUHJvbWlzZSB0byBiZSBmdWxmaWxsZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XG4gIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxuICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xuXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcbiAgY29uZmlnLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgY29uZmlnLFxuICAgIGNvbmZpZy5kYXRhLFxuICAgIGNvbmZpZy5oZWFkZXJzLFxuICAgIGNvbmZpZy50cmFuc2Zvcm1SZXF1ZXN0XG4gICk7XG5cbiAgLy8gRmxhdHRlbiBoZWFkZXJzXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXG4gICAgY29uZmlnLmhlYWRlcnMuY29tbW9uIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzW2NvbmZpZy5tZXRob2RdIHx8IHt9LFxuICAgIGNvbmZpZy5oZWFkZXJzXG4gICk7XG5cbiAgdXRpbHMuZm9yRWFjaChcbiAgICBbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCcsICdwb3N0JywgJ3B1dCcsICdwYXRjaCcsICdjb21tb24nXSxcbiAgICBmdW5jdGlvbiBjbGVhbkhlYWRlckNvbmZpZyhtZXRob2QpIHtcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xuICAgIH1cbiAgKTtcblxuICB2YXIgYWRhcHRlciA9IGNvbmZpZy5hZGFwdGVyIHx8IGRlZmF1bHRzLmFkYXB0ZXI7XG5cbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcbiAgICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgIHJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhLmNhbGwoXG4gICAgICBjb25maWcsXG4gICAgICByZXNwb25zZS5kYXRhLFxuICAgICAgcmVzcG9uc2UuaGVhZGVycyxcbiAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICk7XG5cbiAgICByZXR1cm4gcmVzcG9uc2U7XG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcbiAgICBpZiAoIWlzQ2FuY2VsKHJlYXNvbikpIHtcbiAgICAgIHRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQoY29uZmlnKTtcblxuICAgICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICAgIGlmIChyZWFzb24gJiYgcmVhc29uLnJlc3BvbnNlKSB7XG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxuICAgICAgICAgIGNvbmZpZyxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuZGF0YSxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICBjb25maWcudHJhbnNmb3JtUmVzcG9uc2VcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xuICBlcnJvci5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICBlcnJvci5pc0F4aW9zRXJyb3IgPSB0cnVlO1xuXG4gIGVycm9yLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgLy8gU3RhbmRhcmRcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIC8vIE1pY3Jvc29mdFxuICAgICAgZGVzY3JpcHRpb246IHRoaXMuZGVzY3JpcHRpb24sXG4gICAgICBudW1iZXI6IHRoaXMubnVtYmVyLFxuICAgICAgLy8gTW96aWxsYVxuICAgICAgZmlsZU5hbWU6IHRoaXMuZmlsZU5hbWUsXG4gICAgICBsaW5lTnVtYmVyOiB0aGlzLmxpbmVOdW1iZXIsXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICAvLyBBeGlvc1xuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcbiAgICAgIGNvZGU6IHRoaXMuY29kZVxuICAgIH07XG4gIH07XG4gIHJldHVybiBlcnJvcjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbi8qKlxuICogQ29uZmlnLXNwZWNpZmljIG1lcmdlLWZ1bmN0aW9uIHdoaWNoIGNyZWF0ZXMgYSBuZXcgY29uZmlnLW9iamVjdFxuICogYnkgbWVyZ2luZyB0d28gY29uZmlndXJhdGlvbiBvYmplY3RzIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcxXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMlxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1lcmdlQ29uZmlnKGNvbmZpZzEsIGNvbmZpZzIpIHtcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXG4gIGNvbmZpZzIgPSBjb25maWcyIHx8IHt9O1xuICB2YXIgY29uZmlnID0ge307XG5cbiAgdmFyIHZhbHVlRnJvbUNvbmZpZzJLZXlzID0gWyd1cmwnLCAnbWV0aG9kJywgJ2RhdGEnXTtcbiAgdmFyIG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzID0gWydoZWFkZXJzJywgJ2F1dGgnLCAncHJveHknLCAncGFyYW1zJ107XG4gIHZhciBkZWZhdWx0VG9Db25maWcyS2V5cyA9IFtcbiAgICAnYmFzZVVSTCcsICd0cmFuc2Zvcm1SZXF1ZXN0JywgJ3RyYW5zZm9ybVJlc3BvbnNlJywgJ3BhcmFtc1NlcmlhbGl6ZXInLFxuICAgICd0aW1lb3V0JywgJ3RpbWVvdXRNZXNzYWdlJywgJ3dpdGhDcmVkZW50aWFscycsICdhZGFwdGVyJywgJ3Jlc3BvbnNlVHlwZScsICd4c3JmQ29va2llTmFtZScsXG4gICAgJ3hzcmZIZWFkZXJOYW1lJywgJ29uVXBsb2FkUHJvZ3Jlc3MnLCAnb25Eb3dubG9hZFByb2dyZXNzJywgJ2RlY29tcHJlc3MnLFxuICAgICdtYXhDb250ZW50TGVuZ3RoJywgJ21heEJvZHlMZW5ndGgnLCAnbWF4UmVkaXJlY3RzJywgJ3RyYW5zcG9ydCcsICdodHRwQWdlbnQnLFxuICAgICdodHRwc0FnZW50JywgJ2NhbmNlbFRva2VuJywgJ3NvY2tldFBhdGgnLCAncmVzcG9uc2VFbmNvZGluZydcbiAgXTtcbiAgdmFyIGRpcmVjdE1lcmdlS2V5cyA9IFsndmFsaWRhdGVTdGF0dXMnXTtcblxuICBmdW5jdGlvbiBnZXRNZXJnZWRWYWx1ZSh0YXJnZXQsIHNvdXJjZSkge1xuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2UodGFyZ2V0LCBzb3VyY2UpO1xuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XG4gICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KHNvdXJjZSkpIHtcbiAgICAgIHJldHVybiBzb3VyY2Uuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIHNvdXJjZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfVxuXG4gIHV0aWxzLmZvckVhY2godmFsdWVGcm9tQ29uZmlnMktleXMsIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcbiAgICAgIGNvbmZpZ1twcm9wXSA9IGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XG4gICAgfVxuICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG1lcmdlRGVlcFByb3BlcnRpZXNLZXlzLCBtZXJnZURlZXBQcm9wZXJ0aWVzKTtcblxuICB1dGlscy5mb3JFYWNoKGRlZmF1bHRUb0NvbmZpZzJLZXlzLCBmdW5jdGlvbiBkZWZhdWx0VG9Db25maWcyKHByb3ApIHtcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzJbcHJvcF0pO1xuICAgIH0gZWxzZSBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzFbcHJvcF0pKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xuICAgIH1cbiAgfSk7XG5cbiAgdXRpbHMuZm9yRWFjaChkaXJlY3RNZXJnZUtleXMsIGZ1bmN0aW9uIG1lcmdlKHByb3ApIHtcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XG4gICAgICBjb25maWdbcHJvcF0gPSBnZXRNZXJnZWRWYWx1ZShjb25maWcxW3Byb3BdLCBjb25maWcyW3Byb3BdKTtcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xuICAgICAgY29uZmlnW3Byb3BdID0gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcbiAgICB9XG4gIH0pO1xuXG4gIHZhciBheGlvc0tleXMgPSB2YWx1ZUZyb21Db25maWcyS2V5c1xuICAgIC5jb25jYXQobWVyZ2VEZWVwUHJvcGVydGllc0tleXMpXG4gICAgLmNvbmNhdChkZWZhdWx0VG9Db25maWcyS2V5cylcbiAgICAuY29uY2F0KGRpcmVjdE1lcmdlS2V5cyk7XG5cbiAgdmFyIG90aGVyS2V5cyA9IE9iamVjdFxuICAgIC5rZXlzKGNvbmZpZzEpXG4gICAgLmNvbmNhdChPYmplY3Qua2V5cyhjb25maWcyKSlcbiAgICAuZmlsdGVyKGZ1bmN0aW9uIGZpbHRlckF4aW9zS2V5cyhrZXkpIHtcbiAgICAgIHJldHVybiBheGlvc0tleXMuaW5kZXhPZihrZXkpID09PSAtMTtcbiAgICB9KTtcblxuICB1dGlscy5mb3JFYWNoKG90aGVyS2V5cywgbWVyZ2VEZWVwUHJvcGVydGllcyk7XG5cbiAgcmV0dXJuIGNvbmZpZztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgcmVzb2x2ZShyZXNwb25zZSk7XG4gIH0gZWxzZSB7XG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxuICAgICAgJ1JlcXVlc3QgZmFpbGVkIHdpdGggc3RhdHVzIGNvZGUgJyArIHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgIHJlc3BvbnNlLmNvbmZpZyxcbiAgICAgIG51bGwsXG4gICAgICByZXNwb25zZS5yZXF1ZXN0LFxuICAgICAgcmVzcG9uc2VcbiAgICApKTtcbiAgfVxufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xudmFyIGRlZmF1bHRzID0gcmVxdWlyZSgnLi8uLi9kZWZhdWx0cycpO1xuXG4vKipcbiAqIFRyYW5zZm9ybSB0aGUgZGF0YSBmb3IgYSByZXF1ZXN0IG9yIGEgcmVzcG9uc2VcbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcbiAqIEBwYXJhbSB7QXJyYXl9IGhlYWRlcnMgVGhlIGhlYWRlcnMgZm9yIHRoZSByZXF1ZXN0IG9yIHJlc3BvbnNlXG4gKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufSBmbnMgQSBzaW5nbGUgZnVuY3Rpb24gb3IgQXJyYXkgb2YgZnVuY3Rpb25zXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gdHJhbnNmb3JtRGF0YShkYXRhLCBoZWFkZXJzLCBmbnMpIHtcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2NvcmUvZW5oYW5jZUVycm9yJyk7XG5cbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcbiAgJ0NvbnRlbnQtVHlwZSc6ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnXG59O1xuXG5mdW5jdGlvbiBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgdmFsdWUpIHtcbiAgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzKSAmJiB1dGlscy5pc1VuZGVmaW5lZChoZWFkZXJzWydDb250ZW50LVR5cGUnXSkpIHtcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRBZGFwdGVyKCkge1xuICB2YXIgYWRhcHRlcjtcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3IgYnJvd3NlcnMgdXNlIFhIUiBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMveGhyJyk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChwcm9jZXNzKSA9PT0gJ1tvYmplY3QgcHJvY2Vzc10nKSB7XG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxuICAgIGFkYXB0ZXIgPSByZXF1aXJlKCcuL2FkYXB0ZXJzL2h0dHAnKTtcbiAgfVxuICByZXR1cm4gYWRhcHRlcjtcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5U2FmZWx5KHJhd1ZhbHVlLCBwYXJzZXIsIGVuY29kZXIpIHtcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xuICAgIHRyeSB7XG4gICAgICAocGFyc2VyIHx8IEpTT04ucGFyc2UpKHJhd1ZhbHVlKTtcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBpZiAoZS5uYW1lICE9PSAnU3ludGF4RXJyb3InKSB7XG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIChlbmNvZGVyIHx8IEpTT04uc3RyaW5naWZ5KShyYXdWYWx1ZSk7XG59XG5cbnZhciBkZWZhdWx0cyA9IHtcblxuICB0cmFuc2l0aW9uYWw6IHtcbiAgICBzaWxlbnRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBmb3JjZWRKU09OUGFyc2luZzogdHJ1ZSxcbiAgICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxuICB9LFxuXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQXJyYXlCdWZmZXIoZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzQnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNGaWxlKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0Jsb2IoZGF0YSlcbiAgICApIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcbiAgICAgIHJldHVybiBkYXRhLmJ1ZmZlcjtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDtjaGFyc2V0PXV0Zi04Jyk7XG4gICAgICByZXR1cm4gZGF0YS50b1N0cmluZygpO1xuICAgIH1cbiAgICBpZiAodXRpbHMuaXNPYmplY3QoZGF0YSkgfHwgKGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPT09ICdhcHBsaWNhdGlvbi9qc29uJykpIHtcbiAgICAgIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCAnYXBwbGljYXRpb24vanNvbicpO1xuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1dLFxuXG4gIHRyYW5zZm9ybVJlc3BvbnNlOiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVzcG9uc2UoZGF0YSkge1xuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbDtcbiAgICB2YXIgc2lsZW50SlNPTlBhcnNpbmcgPSB0cmFuc2l0aW9uYWwgJiYgdHJhbnNpdGlvbmFsLnNpbGVudEpTT05QYXJzaW5nO1xuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XG4gICAgdmFyIHN0cmljdEpTT05QYXJzaW5nID0gIXNpbGVudEpTT05QYXJzaW5nICYmIHRoaXMucmVzcG9uc2VUeXBlID09PSAnanNvbic7XG5cbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChzdHJpY3RKU09OUGFyc2luZykge1xuICAgICAgICAgIGlmIChlLm5hbWUgPT09ICdTeW50YXhFcnJvcicpIHtcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgLyoqXG4gICAqIEEgdGltZW91dCBpbiBtaWxsaXNlY29uZHMgdG8gYWJvcnQgYSByZXF1ZXN0LiBJZiBzZXQgdG8gMCAoZGVmYXVsdCkgYVxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxuICAgKi9cbiAgdGltZW91dDogMCxcblxuICB4c3JmQ29va2llTmFtZTogJ1hTUkYtVE9LRU4nLFxuICB4c3JmSGVhZGVyTmFtZTogJ1gtWFNSRi1UT0tFTicsXG5cbiAgbWF4Q29udGVudExlbmd0aDogLTEsXG4gIG1heEJvZHlMZW5ndGg6IC0xLFxuXG4gIHZhbGlkYXRlU3RhdHVzOiBmdW5jdGlvbiB2YWxpZGF0ZVN0YXR1cyhzdGF0dXMpIHtcbiAgICByZXR1cm4gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDA7XG4gIH1cbn07XG5cbmRlZmF1bHRzLmhlYWRlcnMgPSB7XG4gIGNvbW1vbjoge1xuICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xuICB9XG59O1xuXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHt9O1xufSk7XG5cbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XG4gIGRlZmF1bHRzLmhlYWRlcnNbbWV0aG9kXSA9IHV0aWxzLm1lcmdlKERFRkFVTFRfQ09OVEVOVF9UWVBFKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlZmF1bHRzO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQoZm4sIHRoaXNBcmcpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpc0FyZywgYXJncyk7XG4gIH07XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyUzQS9naSwgJzonKS5cbiAgICByZXBsYWNlKC8lMjQvZywgJyQnKS5cbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXG4gICAgcmVwbGFjZSgvJTIwL2csICcrJykuXG4gICAgcmVwbGFjZSgvJTVCL2dpLCAnWycpLlxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcbn1cblxuLyoqXG4gKiBCdWlsZCBhIFVSTCBieSBhcHBlbmRpbmcgcGFyYW1zIHRvIHRoZSBlbmRcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcbiAqIEBwYXJhbSB7b2JqZWN0fSBbcGFyYW1zXSBUaGUgcGFyYW1zIHRvIGJlIGFwcGVuZGVkXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgZm9ybWF0dGVkIHVybFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJ1aWxkVVJMKHVybCwgcGFyYW1zLCBwYXJhbXNTZXJpYWxpemVyKSB7XG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xuICBpZiAoIXBhcmFtcykge1xuICAgIHJldHVybiB1cmw7XG4gIH1cblxuICB2YXIgc2VyaWFsaXplZFBhcmFtcztcbiAgaWYgKHBhcmFtc1NlcmlhbGl6ZXIpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xuICB9IGVsc2UgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKHBhcmFtcykpIHtcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zLnRvU3RyaW5nKCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHBhcnRzID0gW107XG5cbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XG4gICAgICBpZiAodmFsID09PSBudWxsIHx8IHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHV0aWxzLmlzQXJyYXkodmFsKSkge1xuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHZhciBoYXNobWFya0luZGV4ID0gdXJsLmluZGV4T2YoJyMnKTtcbiAgICBpZiAoaGFzaG1hcmtJbmRleCAhPT0gLTEpIHtcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcbiAgICB9XG5cbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIH1cblxuICByZXR1cm4gdXJsO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGJhc2VVUkwgVGhlIGJhc2UgVVJMXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIFVSTFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XG4gIHJldHVybiByZWxhdGl2ZVVSTFxuICAgID8gYmFzZVVSTC5yZXBsYWNlKC9cXC8rJC8sICcnKSArICcvJyArIHJlbGF0aXZlVVJMLnJlcGxhY2UoL15cXC8rLywgJycpXG4gICAgOiBiYXNlVVJMO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXG4gICAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcbiAgICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgICAgY29va2llLnB1c2gobmFtZSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzTnVtYmVyKGV4cGlyZXMpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKHBhdGgpKSB7XG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKHNlY3VyZSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZS5qb2luKCc7ICcpO1xuICAgICAgICB9LFxuXG4gICAgICAgIHJlYWQ6IGZ1bmN0aW9uIHJlYWQobmFtZSkge1xuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXHMqKSgnICsgbmFtZSArICcpPShbXjtdKiknKSk7XG4gICAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgICAgfSxcblxuICAgICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZShuYW1lKSB7XG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICAgICAgcmVtb3ZlOiBmdW5jdGlvbiByZW1vdmUoKSB7fVxuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbi8qKlxuICogRGV0ZXJtaW5lcyB3aGV0aGVyIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvc1xuICpcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHBheWxvYWQgaXMgYW4gZXJyb3IgdGhyb3duIGJ5IEF4aW9zLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xuICByZXR1cm4gKHR5cGVvZiBwYXlsb2FkID09PSAnb2JqZWN0JykgJiYgKHBheWxvYWQuaXNBeGlvc0Vycm9yID09PSB0cnVlKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSAoXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xuXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxuICAvLyB3aGV0aGVyIHRoZSByZXF1ZXN0IFVSTCBpcyBvZiB0aGUgc2FtZSBvcmlnaW4gYXMgY3VycmVudCBsb2NhdGlvbi5cbiAgICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xuICAgICAgdmFyIHVybFBhcnNpbmdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xuICAgICAgdmFyIG9yaWdpblVSTDtcblxuICAgICAgLyoqXG4gICAgKiBQYXJzZSBhIFVSTCB0byBkaXNjb3ZlciBpdCdzIGNvbXBvbmVudHNcbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gdXJsIFRoZSBVUkwgdG8gYmUgcGFyc2VkXG4gICAgKiBAcmV0dXJucyB7T2JqZWN0fVxuICAgICovXG4gICAgICBmdW5jdGlvbiByZXNvbHZlVVJMKHVybCkge1xuICAgICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgICBpZiAobXNpZSkge1xuICAgICAgICAvLyBJRSBuZWVkcyBhdHRyaWJ1dGUgc2V0IHR3aWNlIHRvIG5vcm1hbGl6ZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XG4gICAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICAgIH1cblxuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcblxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaHJlZjogdXJsUGFyc2luZ05vZGUuaHJlZixcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICAgIGhvc3Q6IHVybFBhcnNpbmdOb2RlLmhvc3QsXG4gICAgICAgICAgc2VhcmNoOiB1cmxQYXJzaW5nTm9kZS5zZWFyY2ggPyB1cmxQYXJzaW5nTm9kZS5zZWFyY2gucmVwbGFjZSgvXlxcPy8sICcnKSA6ICcnLFxuICAgICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxuICAgICAgICAgIHBvcnQ6IHVybFBhcnNpbmdOb2RlLnBvcnQsXG4gICAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAgIC8qKlxuICAgICogRGV0ZXJtaW5lIGlmIGEgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4gYXMgdGhlIGN1cnJlbnQgbG9jYXRpb25cbiAgICAqXG4gICAgKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdFVSTCBUaGUgVVJMIHRvIHRlc3RcbiAgICAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luLCBvdGhlcndpc2UgZmFsc2VcbiAgICAqL1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbihyZXF1ZXN0VVJMKSB7XG4gICAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcbiAgICAgICAgICAgIHBhcnNlZC5ob3N0ID09PSBvcmlnaW5VUkwuaG9zdCk7XG4gICAgICB9O1xuICAgIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4oKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfTtcbiAgICB9KSgpXG4pO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8vIEhlYWRlcnMgd2hvc2UgZHVwbGljYXRlcyBhcmUgaWdub3JlZCBieSBub2RlXG4vLyBjLmYuIGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvaHR0cC5odG1sI2h0dHBfbWVzc2FnZV9oZWFkZXJzXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXG4gICdhZ2UnLCAnYXV0aG9yaXphdGlvbicsICdjb250ZW50LWxlbmd0aCcsICdjb250ZW50LXR5cGUnLCAnZXRhZycsXG4gICdleHBpcmVzJywgJ2Zyb20nLCAnaG9zdCcsICdpZi1tb2RpZmllZC1zaW5jZScsICdpZi11bm1vZGlmaWVkLXNpbmNlJyxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxuICAncmVmZXJlcicsICdyZXRyeS1hZnRlcicsICd1c2VyLWFnZW50J1xuXTtcblxuLyoqXG4gKiBQYXJzZSBoZWFkZXJzIGludG8gYW4gb2JqZWN0XG4gKlxuICogYGBgXG4gKiBEYXRlOiBXZWQsIDI3IEF1ZyAyMDE0IDA4OjU4OjQ5IEdNVFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXG4gKiBDb25uZWN0aW9uOiBrZWVwLWFsaXZlXG4gKiBUcmFuc2Zlci1FbmNvZGluZzogY2h1bmtlZFxuICogYGBgXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlcnMgSGVhZGVycyBuZWVkaW5nIHRvIGJlIHBhcnNlZFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBwYXJzZUhlYWRlcnMoaGVhZGVycykge1xuICB2YXIgcGFyc2VkID0ge307XG4gIHZhciBrZXk7XG4gIHZhciB2YWw7XG4gIHZhciBpO1xuXG4gIGlmICghaGVhZGVycykgeyByZXR1cm4gcGFyc2VkOyB9XG5cbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLnNwbGl0KCdcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcbiAgICBpID0gbGluZS5pbmRleE9mKCc6Jyk7XG4gICAga2V5ID0gdXRpbHMudHJpbShsaW5lLnN1YnN0cigwLCBpKSkudG9Mb3dlckNhc2UoKTtcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XG5cbiAgICBpZiAoa2V5KSB7XG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gKHBhcnNlZFtrZXldID8gcGFyc2VkW2tleV0gOiBbXSkuY29uY2F0KFt2YWxdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gcGFyc2VkO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHBrZyA9IHJlcXVpcmUoJy4vLi4vLi4vcGFja2FnZS5qc29uJyk7XG5cbnZhciB2YWxpZGF0b3JzID0ge307XG5cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XG4gIHZhbGlkYXRvcnNbdHlwZV0gPSBmdW5jdGlvbiB2YWxpZGF0b3IodGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSB0eXBlIHx8ICdhJyArIChpIDwgMSA/ICduICcgOiAnICcpICsgdHlwZTtcbiAgfTtcbn0pO1xuXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XG52YXIgY3VycmVudFZlckFyciA9IHBrZy52ZXJzaW9uLnNwbGl0KCcuJyk7XG5cbi8qKlxuICogQ29tcGFyZSBwYWNrYWdlIHZlcnNpb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gdmVyc2lvblxuICogQHBhcmFtIHtzdHJpbmc/fSB0aGFuVmVyc2lvblxuICogQHJldHVybnMge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzT2xkZXJWZXJzaW9uKHZlcnNpb24sIHRoYW5WZXJzaW9uKSB7XG4gIHZhciBwa2dWZXJzaW9uQXJyID0gdGhhblZlcnNpb24gPyB0aGFuVmVyc2lvbi5zcGxpdCgnLicpIDogY3VycmVudFZlckFycjtcbiAgdmFyIGRlc3RWZXIgPSB2ZXJzaW9uLnNwbGl0KCcuJyk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG4gICAgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPiBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKHBrZ1ZlcnNpb25BcnJbaV0gPCBkZXN0VmVyW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBUcmFuc2l0aW9uYWwgb3B0aW9uIHZhbGlkYXRvclxuICogQHBhcmFtIHtmdW5jdGlvbnxib29sZWFuP30gdmFsaWRhdG9yXG4gKiBAcGFyYW0ge3N0cmluZz99IHZlcnNpb25cbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb259XG4gKi9cbnZhbGlkYXRvcnMudHJhbnNpdGlvbmFsID0gZnVuY3Rpb24gdHJhbnNpdGlvbmFsKHZhbGlkYXRvciwgdmVyc2lvbiwgbWVzc2FnZSkge1xuICB2YXIgaXNEZXByZWNhdGVkID0gdmVyc2lvbiAmJiBpc09sZGVyVmVyc2lvbih2ZXJzaW9uKTtcblxuICBmdW5jdGlvbiBmb3JtYXRNZXNzYWdlKG9wdCwgZGVzYykge1xuICAgIHJldHVybiAnW0F4aW9zIHYnICsgcGtnLnZlcnNpb24gKyAnXSBUcmFuc2l0aW9uYWwgb3B0aW9uIFxcJycgKyBvcHQgKyAnXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xuICB9XG5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcbiAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvcHQsIG9wdHMpIHtcbiAgICBpZiAodmFsaWRhdG9yID09PSBmYWxzZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQgaW4gJyArIHZlcnNpb24pKTtcbiAgICB9XG5cbiAgICBpZiAoaXNEZXByZWNhdGVkICYmICFkZXByZWNhdGVkV2FybmluZ3Nbb3B0XSkge1xuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcbiAgICAgICAgICBvcHQsXG4gICAgICAgICAgJyBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIHYnICsgdmVyc2lvbiArICcgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmVhciBmdXR1cmUnXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHZhbGlkYXRvciA/IHZhbGlkYXRvcih2YWx1ZSwgb3B0LCBvcHRzKSA6IHRydWU7XG4gIH07XG59O1xuXG4vKipcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcbiAqIEBwYXJhbSB7b2JqZWN0fSBvcHRpb25zXG4gKiBAcGFyYW0ge29iamVjdH0gc2NoZW1hXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cbiAqL1xuXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XG4gIGlmICh0eXBlb2Ygb3B0aW9ucyAhPT0gJ29iamVjdCcpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb25zIG11c3QgYmUgYW4gb2JqZWN0Jyk7XG4gIH1cbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvcHRpb25zKTtcbiAgdmFyIGkgPSBrZXlzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSA+IDApIHtcbiAgICB2YXIgb3B0ID0ga2V5c1tpXTtcbiAgICB2YXIgdmFsaWRhdG9yID0gc2NoZW1hW29wdF07XG4gICAgaWYgKHZhbGlkYXRvcikge1xuICAgICAgdmFyIHZhbHVlID0gb3B0aW9uc1tvcHRdO1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsaWRhdG9yKHZhbHVlLCBvcHQsIG9wdGlvbnMpO1xuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gJyArIG9wdCArICcgbXVzdCBiZSAnICsgcmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAoYWxsb3dVbmtub3duICE9PSB0cnVlKSB7XG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc09sZGVyVmVyc2lvbjogaXNPbGRlclZlcnNpb24sXG4gIGFzc2VydE9wdGlvbnM6IGFzc2VydE9wdGlvbnMsXG4gIHZhbGlkYXRvcnM6IHZhbGlkYXRvcnNcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCdWZmZXIodmFsKSB7XG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXG4gICAgJiYgdHlwZW9mIHZhbC5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIodmFsKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHBsYWluIE9iamVjdFxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xuICBpZiAodG9TdHJpbmcuY2FsbCh2YWwpICE9PSAnW29iamVjdCBPYmplY3RdJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHZhciBwcm90b3R5cGUgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodmFsKTtcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBEYXRlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBEYXRlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGaWxlXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGaWxlLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNGaWxlKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGaWxlXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBGdW5jdGlvblxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRnVuY3Rpb24sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgU3RyZWFtXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBTdHJlYW0sIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1N0cmVhbSh2YWwpIHtcbiAgcmV0dXJuIGlzT2JqZWN0KHZhbCkgJiYgaXNGdW5jdGlvbih2YWwucGlwZSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVUkxTZWFyY2hQYXJhbXModmFsKSB7XG4gIHJldHVybiB0eXBlb2YgVVJMU2VhcmNoUGFyYW1zICE9PSAndW5kZWZpbmVkJyAmJiB2YWwgaW5zdGFuY2VvZiBVUkxTZWFyY2hQYXJhbXM7XG59XG5cbi8qKlxuICogVHJpbSBleGNlc3Mgd2hpdGVzcGFjZSBvZmYgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIGEgc3RyaW5nXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciBUaGUgU3RyaW5nIHRvIHRyaW1cbiAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBTdHJpbmcgZnJlZWQgb2YgZXhjZXNzIHdoaXRlc3BhY2VcbiAqL1xuZnVuY3Rpb24gdHJpbShzdHIpIHtcbiAgcmV0dXJuIHN0ci50cmltID8gc3RyLnRyaW0oKSA6IHN0ci5yZXBsYWNlKC9eXFxzK3xcXHMrJC9nLCAnJyk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIHdlJ3JlIHJ1bm5pbmcgaW4gYSBzdGFuZGFyZCBicm93c2VyIGVudmlyb25tZW50XG4gKlxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cbiAqIEJvdGggZW52aXJvbm1lbnRzIHN1cHBvcnQgWE1MSHR0cFJlcXVlc3QsIGJ1dCBub3QgZnVsbHkgc3RhbmRhcmQgZ2xvYmFscy5cbiAqXG4gKiB3ZWIgd29ya2VyczpcbiAqICB0eXBlb2Ygd2luZG93IC0+IHVuZGVmaW5lZFxuICogIHR5cGVvZiBkb2N1bWVudCAtPiB1bmRlZmluZWRcbiAqXG4gKiByZWFjdC1uYXRpdmU6XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ1JlYWN0TmF0aXZlJ1xuICogbmF0aXZlc2NyaXB0XG4gKiAgbmF2aWdhdG9yLnByb2R1Y3QgLT4gJ05hdGl2ZVNjcmlwdCcgb3IgJ05TJ1xuICovXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIChuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTmF0aXZlU2NyaXB0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmIChpc1BsYWluT2JqZWN0KHJlc3VsdFtrZXldKSAmJiBpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2Uoe30sIHZhbCk7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xuICAgIH1cbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGZvckVhY2goYXJndW1lbnRzW2ldLCBhc3NpZ25WYWx1ZSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBFeHRlbmRzIG9iamVjdCBhIGJ5IG11dGFibHkgYWRkaW5nIHRvIGl0IHRoZSBwcm9wZXJ0aWVzIG9mIG9iamVjdCBiLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBhIFRoZSBvYmplY3QgdG8gYmUgZXh0ZW5kZWRcbiAqIEBwYXJhbSB7T2JqZWN0fSBiIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb21cbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcmVzdWx0aW5nIHZhbHVlIG9mIG9iamVjdCBhXG4gKi9cbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XG4gIGZvckVhY2goYiwgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcbiAgICBpZiAodGhpc0FyZyAmJiB0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGFba2V5XSA9IHZhbDtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gYTtcbn1cblxuLyoqXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29udGVudCB3aXRoIEJPTVxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXG4gKi9cbmZ1bmN0aW9uIHN0cmlwQk9NKGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XG4gICAgY29udGVudCA9IGNvbnRlbnQuc2xpY2UoMSk7XG4gIH1cbiAgcmV0dXJuIGNvbnRlbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltLFxuICBzdHJpcEJPTTogc3RyaXBCT01cbn07XG4iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG4vLyBTdXBwb3J0IGRlY29kaW5nIFVSTC1zYWZlIGJhc2U2NCBzdHJpbmdzLCBhcyBOb2RlLmpzIGRvZXMuXG4vLyBTZWU6IGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Jhc2U2NCNVUkxfYXBwbGljYXRpb25zXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBnZXRMZW5zIChiNjQpIHtcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcblxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gVHJpbSBvZmYgZXh0cmEgYnl0ZXMgYWZ0ZXIgcGxhY2Vob2xkZXIgYnl0ZXMgYXJlIGZvdW5kXG4gIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2JlYXRnYW1taXQvYmFzZTY0LWpzL2lzc3Vlcy80MlxuICB2YXIgdmFsaWRMZW4gPSBiNjQuaW5kZXhPZignPScpXG4gIGlmICh2YWxpZExlbiA9PT0gLTEpIHZhbGlkTGVuID0gbGVuXG5cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IHZhbGlkTGVuID09PSBsZW5cbiAgICA/IDBcbiAgICA6IDQgLSAodmFsaWRMZW4gJSA0KVxuXG4gIHJldHVybiBbdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbl1cbn1cblxuLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgdmFyIGxlbnMgPSBnZXRMZW5zKGI2NClcbiAgdmFyIHZhbGlkTGVuID0gbGVuc1swXVxuICB2YXIgcGxhY2VIb2xkZXJzTGVuID0gbGVuc1sxXVxuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gX2J5dGVMZW5ndGggKGI2NCwgdmFsaWRMZW4sIHBsYWNlSG9sZGVyc0xlbikge1xuICByZXR1cm4gKCh2YWxpZExlbiArIHBsYWNlSG9sZGVyc0xlbikgKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNMZW5cbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW5zID0gZ2V0TGVucyhiNjQpXG4gIHZhciB2YWxpZExlbiA9IGxlbnNbMF1cbiAgdmFyIHBsYWNlSG9sZGVyc0xlbiA9IGxlbnNbMV1cblxuICB2YXIgYXJyID0gbmV3IEFycihfYnl0ZUxlbmd0aChiNjQsIHZhbGlkTGVuLCBwbGFjZUhvbGRlcnNMZW4pKVxuXG4gIHZhciBjdXJCeXRlID0gMFxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgdmFyIGxlbiA9IHBsYWNlSG9sZGVyc0xlbiA+IDBcbiAgICA/IHZhbGlkTGVuIC0gNFxuICAgIDogdmFsaWRMZW5cblxuICB2YXIgaVxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICB0bXAgPVxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTgpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHxcbiAgICAgIHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMyldXG4gICAgYXJyW2N1ckJ5dGUrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9ICh0bXAgPj4gOCkgJiAweEZGXG4gICAgYXJyW2N1ckJ5dGUrK10gPSB0bXAgJiAweEZGXG4gIH1cblxuICBpZiAocGxhY2VIb2xkZXJzTGVuID09PSAyKSB7XG4gICAgdG1wID1cbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltjdXJCeXRlKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVyc0xlbiA9PT0gMSkge1xuICAgIHRtcCA9XG4gICAgICAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfFxuICAgICAgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHxcbiAgICAgIChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltjdXJCeXRlKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbY3VyQnl0ZSsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArXG4gICAgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICtcbiAgICBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArXG4gICAgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9XG4gICAgICAoKHVpbnQ4W2ldIDw8IDE2KSAmIDB4RkYwMDAwKSArXG4gICAgICAoKHVpbnQ4W2kgKyAxXSA8PCA4KSAmIDB4RkYwMCkgK1xuICAgICAgKHVpbnQ4W2kgKyAyXSAmIDB4RkYpXG4gICAgb3V0cHV0LnB1c2godHJpcGxldFRvQmFzZTY0KHRtcCkpXG4gIH1cbiAgcmV0dXJuIG91dHB1dC5qb2luKCcnKVxufVxuXG5mdW5jdGlvbiBmcm9tQnl0ZUFycmF5ICh1aW50OCkge1xuICB2YXIgdG1wXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcbiAgdmFyIGV4dHJhQnl0ZXMgPSBsZW4gJSAzIC8vIGlmIHdlIGhhdmUgMSBieXRlIGxlZnQsIHBhZCAyIGJ5dGVzXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBwYXJ0cy5wdXNoKFxuICAgICAgbG9va3VwW3RtcCA+PiAyXSArXG4gICAgICBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdICtcbiAgICAgICc9PSdcbiAgICApXG4gIH0gZWxzZSBpZiAoZXh0cmFCeXRlcyA9PT0gMikge1xuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArIHVpbnQ4W2xlbiAtIDFdXG4gICAgcGFydHMucHVzaChcbiAgICAgIGxvb2t1cFt0bXAgPj4gMTBdICtcbiAgICAgIGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl0gK1xuICAgICAgbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXSArXG4gICAgICAnPSdcbiAgICApXG4gIH1cblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIid1c2Ugc3RyaWN0Jztcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuYmVjaDMybSA9IGV4cG9ydHMuYmVjaDMyID0gdm9pZCAwO1xuY29uc3QgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnO1xuY29uc3QgQUxQSEFCRVRfTUFQID0ge307XG5mb3IgKGxldCB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gICAgY29uc3QgeCA9IEFMUEhBQkVULmNoYXJBdCh6KTtcbiAgICBBTFBIQUJFVF9NQVBbeF0gPSB6O1xufVxuZnVuY3Rpb24gcG9seW1vZFN0ZXAocHJlKSB7XG4gICAgY29uc3QgYiA9IHByZSA+PiAyNTtcbiAgICByZXR1cm4gKCgocHJlICYgMHgxZmZmZmZmKSA8PCA1KSBeXG4gICAgICAgICgtKChiID4+IDApICYgMSkgJiAweDNiNmE1N2IyKSBeXG4gICAgICAgICgtKChiID4+IDEpICYgMSkgJiAweDI2NTA4ZTZkKSBeXG4gICAgICAgICgtKChiID4+IDIpICYgMSkgJiAweDFlYTExOWZhKSBeXG4gICAgICAgICgtKChiID4+IDMpICYgMSkgJiAweDNkNDIzM2RkKSBeXG4gICAgICAgICgtKChiID4+IDQpICYgMSkgJiAweDJhMTQ2MmIzKSk7XG59XG5mdW5jdGlvbiBwcmVmaXhDaGsocHJlZml4KSB7XG4gICAgbGV0IGNoayA9IDE7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgYyA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpXG4gICAgICAgICAgICByZXR1cm4gJ0ludmFsaWQgcHJlZml4ICgnICsgcHJlZml4ICsgJyknO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKGMgPj4gNSk7XG4gICAgfVxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoayk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmVmaXgubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgdiA9IHByZWZpeC5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspIF4gKHYgJiAweDFmKTtcbiAgICB9XG4gICAgcmV0dXJuIGNoaztcbn1cbmZ1bmN0aW9uIGNvbnZlcnQoZGF0YSwgaW5CaXRzLCBvdXRCaXRzLCBwYWQpIHtcbiAgICBsZXQgdmFsdWUgPSAwO1xuICAgIGxldCBiaXRzID0gMDtcbiAgICBjb25zdCBtYXhWID0gKDEgPDwgb3V0Qml0cykgLSAxO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YWx1ZSA9ICh2YWx1ZSA8PCBpbkJpdHMpIHwgZGF0YVtpXTtcbiAgICAgICAgYml0cyArPSBpbkJpdHM7XG4gICAgICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcbiAgICAgICAgICAgIGJpdHMgLT0gb3V0Qml0cztcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCh2YWx1ZSA+PiBiaXRzKSAmIG1heFYpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChwYWQpIHtcbiAgICAgICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKGJpdHMgPj0gaW5CaXRzKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlc3MgcGFkZGluZyc7XG4gICAgICAgIGlmICgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKVxuICAgICAgICAgICAgcmV0dXJuICdOb24temVybyBwYWRkaW5nJztcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIHRvV29yZHMoYnl0ZXMpIHtcbiAgICByZXR1cm4gY29udmVydChieXRlcywgOCwgNSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUod29yZHMpIHtcbiAgICBjb25zdCByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSlcbiAgICAgICAgcmV0dXJuIHJlcztcbn1cbmZ1bmN0aW9uIGZyb21Xb3Jkcyh3b3Jkcykge1xuICAgIGNvbnN0IHJlcyA9IGNvbnZlcnQod29yZHMsIDUsIDgsIGZhbHNlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXMpKVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xufVxuZnVuY3Rpb24gZ2V0TGlicmFyeUZyb21FbmNvZGluZyhlbmNvZGluZykge1xuICAgIGxldCBFTkNPRElOR19DT05TVDtcbiAgICBpZiAoZW5jb2RpbmcgPT09ICdiZWNoMzInKSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIEVOQ09ESU5HX0NPTlNUID0gMHgyYmM4MzBhMztcbiAgICB9XG4gICAgZnVuY3Rpb24gZW5jb2RlKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG4gICAgICAgIExJTUlUID0gTElNSVQgfHwgOTA7XG4gICAgICAgIGlmIChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKTtcbiAgICAgICAgcHJlZml4ID0gcHJlZml4LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIGRldGVybWluZSBjaGsgbW9kXG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGNoayk7XG4gICAgICAgIGxldCByZXN1bHQgPSBwcmVmaXggKyAnMSc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHggPSB3b3Jkc1tpXTtcbiAgICAgICAgICAgIGlmICh4ID4+IDUgIT09IDApXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOb24gNS1iaXQgd29yZCcpO1xuICAgICAgICAgICAgY2hrID0gcG9seW1vZFN0ZXAoY2hrKSBeIHg7XG4gICAgICAgICAgICByZXN1bHQgKz0gQUxQSEFCRVQuY2hhckF0KHgpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgKytpKSB7XG4gICAgICAgICAgICBjaGsgPSBwb2x5bW9kU3RlcChjaGspO1xuICAgICAgICB9XG4gICAgICAgIGNoayBePSBFTkNPRElOR19DT05TVDtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IHYgPSAoY2hrID4+ICgoNSAtIGkpICogNSkpICYgMHgxZjtcbiAgICAgICAgICAgIHJlc3VsdCArPSBBTFBIQUJFVC5jaGFyQXQodik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZnVuY3Rpb24gX19kZWNvZGUoc3RyLCBMSU1JVCkge1xuICAgICAgICBMSU1JVCA9IExJTUlUIHx8IDkwO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA8IDgpXG4gICAgICAgICAgICByZXR1cm4gc3RyICsgJyB0b28gc2hvcnQnO1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKVxuICAgICAgICAgICAgcmV0dXJuICdFeGNlZWRzIGxlbmd0aCBsaW1pdCc7XG4gICAgICAgIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgICAgICAgY29uc3QgbG93ZXJlZCA9IHN0ci50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBjb25zdCB1cHBlcmVkID0gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKVxuICAgICAgICAgICAgcmV0dXJuICdNaXhlZC1jYXNlIHN0cmluZyAnICsgc3RyO1xuICAgICAgICBzdHIgPSBsb3dlcmVkO1xuICAgICAgICBjb25zdCBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpO1xuICAgICAgICBpZiAoc3BsaXQgPT09IC0xKVxuICAgICAgICAgICAgcmV0dXJuICdObyBzZXBhcmF0b3IgY2hhcmFjdGVyIGZvciAnICsgc3RyO1xuICAgICAgICBpZiAoc3BsaXQgPT09IDApXG4gICAgICAgICAgICByZXR1cm4gJ01pc3NpbmcgcHJlZml4IGZvciAnICsgc3RyO1xuICAgICAgICBjb25zdCBwcmVmaXggPSBzdHIuc2xpY2UoMCwgc3BsaXQpO1xuICAgICAgICBjb25zdCB3b3JkQ2hhcnMgPSBzdHIuc2xpY2Uoc3BsaXQgKyAxKTtcbiAgICAgICAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KVxuICAgICAgICAgICAgcmV0dXJuICdEYXRhIHRvbyBzaG9ydCc7XG4gICAgICAgIGxldCBjaGsgPSBwcmVmaXhDaGsocHJlZml4KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGsgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIGNoaztcbiAgICAgICAgY29uc3Qgd29yZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3JkQ2hhcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbnN0IGMgPSB3b3JkQ2hhcnMuY2hhckF0KGkpO1xuICAgICAgICAgICAgY29uc3QgdiA9IEFMUEhBQkVUX01BUFtjXTtcbiAgICAgICAgICAgIGlmICh2ID09PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuICdVbmtub3duIGNoYXJhY3RlciAnICsgYztcbiAgICAgICAgICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2O1xuICAgICAgICAgICAgLy8gbm90IGluIHRoZSBjaGVja3N1bT9cbiAgICAgICAgICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgd29yZHMucHVzaCh2KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hrICE9PSBFTkNPRElOR19DT05TVClcbiAgICAgICAgICAgIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0cjtcbiAgICAgICAgcmV0dXJuIHsgcHJlZml4LCB3b3JkcyB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBkZWNvZGVVbnNhZmUoc3RyLCBMSU1JVCkge1xuICAgICAgICBjb25zdCByZXMgPSBfX2RlY29kZShzdHIsIExJTUlUKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKVxuICAgICAgICAgICAgcmV0dXJuIHJlcztcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVjb2RlKHN0ciwgTElNSVQpIHtcbiAgICAgICAgY29uc3QgcmVzID0gX19kZWNvZGUoc3RyLCBMSU1JVCk7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHJldHVybiByZXM7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihyZXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWNvZGVVbnNhZmUsXG4gICAgICAgIGRlY29kZSxcbiAgICAgICAgZW5jb2RlLFxuICAgICAgICB0b1dvcmRzLFxuICAgICAgICBmcm9tV29yZHNVbnNhZmUsXG4gICAgICAgIGZyb21Xb3JkcyxcbiAgICB9O1xufVxuZXhwb3J0cy5iZWNoMzIgPSBnZXRMaWJyYXJ5RnJvbUVuY29kaW5nKCdiZWNoMzInKTtcbmV4cG9ydHMuYmVjaDMybSA9IGdldExpYnJhcnlGcm9tRW5jb2RpbmcoJ2JlY2gzMm0nKTtcbiIsIlxubW9kdWxlLmV4cG9ydHMgPSBsb2FkV2ViQXNzZW1ibHlcblxubG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCA9IHR5cGVvZiBXZWJBc3NlbWJseSAhPT0gJ3VuZGVmaW5lZCdcblxuZnVuY3Rpb24gbG9hZFdlYkFzc2VtYmx5IChvcHRzKSB7XG4gIGlmICghbG9hZFdlYkFzc2VtYmx5LnN1cHBvcnRlZCkgcmV0dXJuIG51bGxcblxuICB2YXIgaW1wID0gb3B0cyAmJiBvcHRzLmltcG9ydHNcbiAgdmFyIHdhc20gPSB0b1VpbnQ4QXJyYXkoJ0FHRnpiUUVBQUFBQkVBTmdBbjkvQUdBRGYzOS9BR0FCZndBREJRUUFBUUlDQlFVQkFRcm9Cd2ROQlFadFpXMXZjbmtDQUF4aWJHRnJaVEppWDJsdWFYUUFBQTVpYkdGclpUSmlYM1Z3WkdGMFpRQUJEV0pzWVd0bE1tSmZabWx1WVd3QUFoQmliR0ZyWlRKaVgyTnZiWEJ5WlhOekFBTUswMEFFbGdNQUlBQkNBRGNEQUNBQVFRaHFRZ0EzQXdBZ0FFRVFha0lBTndNQUlBQkJHR3BDQURjREFDQUFRU0JxUWdBM0F3QWdBRUVvYWtJQU53TUFJQUJCTUdwQ0FEY0RBQ0FBUVRocVFnQTNBd0FnQUVIQUFHcENBRGNEQUNBQVFjZ0Fha0lBTndNQUlBQkIwQUJxUWdBM0F3QWdBRUhZQUdwQ0FEY0RBQ0FBUWVBQWFrSUFOd01BSUFCQjZBQnFRZ0EzQXdBZ0FFSHdBR3BDQURjREFDQUFRZmdBYWtJQU53TUFJQUJCZ0FGcVFvaVM4NTMvelBtRTZnQkJBQ2tEQUlVM0F3QWdBRUdJQVdwQ3U4NnFwdGpRNjdPN2YwRUlLUU1BaFRjREFDQUFRWkFCYWtLcjhOUDByKzY4dHp4QkVDa0RBSVUzQXdBZ0FFR1lBV3BDOGUzMCtLV24vYWVsZjBFWUtRTUFoVGNEQUNBQVFhQUJha0xSaFpyditzK1VoOUVBUVNBcEF3Q0ZOd01BSUFCQnFBRnFRcC9ZK2RuQ2tkcUNtMzlCS0NrREFJVTNBd0FnQUVHd0FXcEM2L3FHMnIrMTlzRWZRVEFwQXdDRk53TUFJQUJCdUFGcVF2bkMrSnVSbzdQdzJ3QkJPQ2tEQUlVM0F3QWdBRUhBQVdwQ0FEY0RBQ0FBUWNnQmFrSUFOd01BSUFCQjBBRnFRZ0EzQXdBTGJRRURmeUFBUWNBQmFpRURJQUJCeUFGcUlRUWdCQ2tEQUtjaEJRSkFBMEFnQVNBQ1JnMEJJQVZCZ0FGR0JFQWdBeUFES1FNQUlBV3RmRGNEQUVFQUlRVWdBQkFEQ3lBQUlBVnFJQUV0QUFBNkFBQWdCVUVCYWlFRklBRkJBV29oQVF3QUN3c2dCQ0FGclRjREFBdGtBUU4vSUFCQndBRnFJUUVnQUVISUFXb2hBaUFCSUFFcEF3QWdBaWtEQUh3M0F3QWdBRUhRQVdwQ2Z6Y0RBQ0FDS1FNQXB5RURBa0FEUUNBRFFZQUJSZzBCSUFBZ0EycEJBRG9BQUNBRFFRRnFJUU1NQUFzTElBSWdBNjAzQXdBZ0FCQURDK1U3QWlCK0NYOGdBRUdBQVdvaElTQUFRWWdCYWlFaUlBQkJrQUZxSVNNZ0FFR1lBV29oSkNBQVFhQUJhaUVsSUFCQnFBRnFJU1lnQUVHd0FXb2hKeUFBUWJnQmFpRW9JQ0VwQXdBaEFTQWlLUU1BSVFJZ0l5a0RBQ0VESUNRcEF3QWhCQ0FsS1FNQUlRVWdKaWtEQUNFR0lDY3BBd0FoQnlBb0tRTUFJUWhDaUpMem5mL00rWVRxQUNFSlFydk9xcWJZME91enUzOGhDa0tyOE5QMHIrNjh0endoQzBMeDdmVDRwYWY5cDZWL0lReEMwWVdhNy9yUGxJZlJBQ0VOUXAvWStkbkNrZHFDbTM4aERrTHIrb2JhdjdYMndSOGhEMEw1d3ZpYmthT3o4TnNBSVJBZ0FDa0RBQ0VSSUFCQkNHb3BBd0FoRWlBQVFSQnFLUU1BSVJNZ0FFRVlhaWtEQUNFVUlBQkJJR29wQXdBaEZTQUFRU2hxS1FNQUlSWWdBRUV3YWlrREFDRVhJQUJCT0dvcEF3QWhHQ0FBUWNBQWFpa0RBQ0VaSUFCQnlBQnFLUU1BSVJvZ0FFSFFBR29wQXdBaEd5QUFRZGdBYWlrREFDRWNJQUJCNEFCcUtRTUFJUjBnQUVIb0FHb3BBd0FoSGlBQVFmQUFhaWtEQUNFZklBQkIrQUJxS1FNQUlTQWdEU0FBUWNBQmFpa0RBSVVoRFNBUElBQkIwQUZxS1FNQWhTRVBJQUVnQlNBUmZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0VueDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCTjhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQVVmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dGWHg4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQlo4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FYZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnR0h4OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUJsOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBYWZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0czeDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCeDhmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQWRmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dIbng4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQjk4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FnZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnSDN4OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJ0OGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBVmZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0dYeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCcDhmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QWdmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dIbng4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQmQ4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFTZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnSFh4OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUJGOGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBVGZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0hIeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCaDhmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQVdmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdGSHg4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQng4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FaZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnSFh4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJGOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBV2ZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0UzeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlDQjhmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQWVmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdHM3g4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQjk4ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFVZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnRjN4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJoOGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBU2ZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0dueDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCVjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUFFZ0JTQVlmSHdoQVNBTklBR0ZRaUNLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNHSW9oQlNBQklBVWdHbng4SVFFZ0RTQUJoVUlRaWlFTklBa2dEWHdoQ1NBRklBbUZRaitLSVFVZ0FpQUdJQlI4ZkNFQ0lBNGdBb1ZDSUlvaERpQUtJQTU4SVFvZ0JpQUtoVUlZaWlFR0lBSWdCaUFTZkh3aEFpQU9JQUtGUWhDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDUDRvaEJpQURJQWNnSG54OElRTWdEeUFEaFVJZ2lpRVBJQXNnRDN3aEN5QUhJQXVGUWhpS0lRY2dBeUFISUIxOGZDRURJQThnQTRWQ0VJb2hEeUFMSUE5OElRc2dCeUFMaFVJL2lpRUhJQVFnQ0NBY2ZId2hCQ0FRSUFTRlFpQ0tJUkFnRENBUWZDRU1JQWdnRElWQ0dJb2hDQ0FFSUFnZ0gzeDhJUVFnRUNBRWhVSVFpaUVRSUF3Z0VId2hEQ0FJSUF5RlFqK0tJUWdnQVNBR0lCTjhmQ0VCSUJBZ0FZVkNJSW9oRUNBTElCQjhJUXNnQmlBTGhVSVlpaUVHSUFFZ0JpQVhmSHdoQVNBUUlBR0ZRaENLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNQNG9oQmlBQ0lBY2dGbng4SVFJZ0RTQUNoVUlnaWlFTklBd2dEWHdoRENBSElBeUZRaGlLSVFjZ0FpQUhJQnQ4ZkNFQ0lBMGdBb1ZDRUlvaERTQU1JQTE4SVF3Z0J5QU1oVUkvaWlFSElBTWdDQ0FWZkh3aEF5QU9JQU9GUWlDS0lRNGdDU0FPZkNFSklBZ2dDWVZDR0lvaENDQURJQWdnRVh4OElRTWdEaUFEaFVJUWlpRU9JQWtnRG53aENTQUlJQW1GUWorS0lRZ2dCQ0FGSUNCOGZDRUVJQThnQklWQ0lJb2hEeUFLSUE5OElRb2dCU0FLaFVJWWlpRUZJQVFnQlNBWmZId2hCQ0FQSUFTRlFoQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ1A0b2hCU0FCSUFVZ0dueDhJUUVnRFNBQmhVSWdpaUVOSUFrZ0RYd2hDU0FGSUFtRlFoaUtJUVVnQVNBRklCRjhmQ0VCSUEwZ0FZVkNFSW9oRFNBSklBMThJUWtnQlNBSmhVSS9paUVGSUFJZ0JpQVdmSHdoQWlBT0lBS0ZRaUNLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNHSW9oQmlBQ0lBWWdHSHg4SVFJZ0RpQUNoVUlRaWlFT0lBb2dEbndoQ2lBR0lBcUZRaitLSVFZZ0F5QUhJQk44ZkNFRElBOGdBNFZDSUlvaER5QUxJQTk4SVFzZ0J5QUxoVUlZaWlFSElBTWdCeUFWZkh3aEF5QVBJQU9GUWhDS0lROGdDeUFQZkNFTElBY2dDNFZDUDRvaEJ5QUVJQWdnRzN4OElRUWdFQ0FFaFVJZ2lpRVFJQXdnRUh3aERDQUlJQXlGUWhpS0lRZ2dCQ0FJSUNCOGZDRUVJQkFnQklWQ0VJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJL2lpRUlJQUVnQmlBZmZId2hBU0FRSUFHRlFpQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ0dJb2hCaUFCSUFZZ0VueDhJUUVnRUNBQmhVSVFpaUVRSUFzZ0VId2hDeUFHSUF1RlFqK0tJUVlnQWlBSElCeDhmQ0VDSUEwZ0FvVkNJSW9oRFNBTUlBMThJUXdnQnlBTWhVSVlpaUVISUFJZ0J5QWRmSHdoQWlBTklBS0ZRaENLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNQNG9oQnlBRElBZ2dGM3g4SVFNZ0RpQURoVUlnaWlFT0lBa2dEbndoQ1NBSUlBbUZRaGlLSVFnZ0F5QUlJQmw4ZkNFRElBNGdBNFZDRUlvaERpQUpJQTU4SVFrZ0NDQUpoVUkvaWlFSUlBUWdCU0FVZkh3aEJDQVBJQVNGUWlDS0lROGdDaUFQZkNFS0lBVWdDb1ZDR0lvaEJTQUVJQVVnSG54OElRUWdEeUFFaFVJUWlpRVBJQW9nRDN3aENpQUZJQXFGUWorS0lRVWdBU0FGSUJOOGZDRUJJQTBnQVlWQ0lJb2hEU0FKSUExOElRa2dCU0FKaFVJWWlpRUZJQUVnQlNBZGZId2hBU0FOSUFHRlFoQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ1A0b2hCU0FDSUFZZ0YzeDhJUUlnRGlBQ2hVSWdpaUVPSUFvZ0Rud2hDaUFHSUFxRlFoaUtJUVlnQWlBR0lCdDhmQ0VDSUE0Z0FvVkNFSW9oRGlBS0lBNThJUW9nQmlBS2hVSS9paUVHSUFNZ0J5QVJmSHdoQXlBUElBT0ZRaUNLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNHSW9oQnlBRElBY2dISHg4SVFNZ0R5QURoVUlRaWlFUElBc2dEM3doQ3lBSElBdUZRaitLSVFjZ0JDQUlJQmw4ZkNFRUlCQWdCSVZDSUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUlZaWlFSUlBUWdDQ0FVZkh3aEJDQVFJQVNGUWhDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDUDRvaENDQUJJQVlnRlh4OElRRWdFQ0FCaFVJZ2lpRVFJQXNnRUh3aEN5QUdJQXVGUWhpS0lRWWdBU0FHSUI1OGZDRUJJQkFnQVlWQ0VJb2hFQ0FMSUJCOElRc2dCaUFMaFVJL2lpRUdJQUlnQnlBWWZId2hBaUFOSUFLRlFpQ0tJUTBnRENBTmZDRU1JQWNnRElWQ0dJb2hCeUFDSUFjZ0ZueDhJUUlnRFNBQ2hVSVFpaUVOSUF3Z0RYd2hEQ0FISUF5RlFqK0tJUWNnQXlBSUlDQjhmQ0VESUE0Z0E0VkNJSW9oRGlBSklBNThJUWtnQ0NBSmhVSVlpaUVJSUFNZ0NDQWZmSHdoQXlBT0lBT0ZRaENLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNQNG9oQ0NBRUlBVWdFbng4SVFRZ0R5QUVoVUlnaWlFUElBb2dEM3doQ2lBRklBcUZRaGlLSVFVZ0JDQUZJQnA4ZkNFRUlBOGdCSVZDRUlvaER5QUtJQTk4SVFvZ0JTQUtoVUkvaWlFRklBRWdCU0FkZkh3aEFTQU5JQUdGUWlDS0lRMGdDU0FOZkNFSklBVWdDWVZDR0lvaEJTQUJJQVVnRm54OElRRWdEU0FCaFVJUWlpRU5JQWtnRFh3aENTQUZJQW1GUWorS0lRVWdBaUFHSUJKOGZDRUNJQTRnQW9WQ0lJb2hEaUFLSUE1OElRb2dCaUFLaFVJWWlpRUdJQUlnQmlBZ2ZId2hBaUFPSUFLRlFoQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ1A0b2hCaUFESUFjZ0gzeDhJUU1nRHlBRGhVSWdpaUVQSUFzZ0Qzd2hDeUFISUF1RlFoaUtJUWNnQXlBSElCNThmQ0VESUE4Z0E0VkNFSW9oRHlBTElBOThJUXNnQnlBTGhVSS9paUVISUFRZ0NDQVZmSHdoQkNBUUlBU0ZRaUNLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNHSW9oQ0NBRUlBZ2dHM3g4SVFRZ0VDQUVoVUlRaWlFUUlBd2dFSHdoRENBSUlBeUZRaitLSVFnZ0FTQUdJQkY4ZkNFQklCQWdBWVZDSUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUlZaWlFR0lBRWdCaUFZZkh3aEFTQVFJQUdGUWhDS0lSQWdDeUFRZkNFTElBWWdDNFZDUDRvaEJpQUNJQWNnRjN4OElRSWdEU0FDaFVJZ2lpRU5JQXdnRFh3aERDQUhJQXlGUWhpS0lRY2dBaUFISUJSOGZDRUNJQTBnQW9WQ0VJb2hEU0FNSUExOElRd2dCeUFNaFVJL2lpRUhJQU1nQ0NBYWZId2hBeUFPSUFPRlFpQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ0dJb2hDQ0FESUFnZ0UzeDhJUU1nRGlBRGhVSVFpaUVPSUFrZ0Rud2hDU0FJSUFtRlFqK0tJUWdnQkNBRklCbDhmQ0VFSUE4Z0JJVkNJSW9oRHlBS0lBOThJUW9nQlNBS2hVSVlpaUVGSUFRZ0JTQWNmSHdoQkNBUElBU0ZRaENLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNQNG9oQlNBQklBVWdIbng4SVFFZ0RTQUJoVUlnaWlFTklBa2dEWHdoQ1NBRklBbUZRaGlLSVFVZ0FTQUZJQng4ZkNFQklBMGdBWVZDRUlvaERTQUpJQTE4SVFrZ0JTQUpoVUkvaWlFRklBSWdCaUFZZkh3aEFpQU9JQUtGUWlDS0lRNGdDaUFPZkNFS0lBWWdDb1ZDR0lvaEJpQUNJQVlnSDN4OElRSWdEaUFDaFVJUWlpRU9JQW9nRG53aENpQUdJQXFGUWorS0lRWWdBeUFISUIxOGZDRURJQThnQTRWQ0lJb2hEeUFMSUE5OElRc2dCeUFMaFVJWWlpRUhJQU1nQnlBU2ZId2hBeUFQSUFPRlFoQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ1A0b2hCeUFFSUFnZ0ZIeDhJUVFnRUNBRWhVSWdpaUVRSUF3Z0VId2hEQ0FJSUF5RlFoaUtJUWdnQkNBSUlCcDhmQ0VFSUJBZ0JJVkNFSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSS9paUVJSUFFZ0JpQVdmSHdoQVNBUUlBR0ZRaUNLSVJBZ0N5QVFmQ0VMSUFZZ0M0VkNHSW9oQmlBQklBWWdFWHg4SVFFZ0VDQUJoVUlRaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaitLSVFZZ0FpQUhJQ0I4ZkNFQ0lBMGdBb1ZDSUlvaERTQU1JQTE4SVF3Z0J5QU1oVUlZaWlFSElBSWdCeUFWZkh3aEFpQU5JQUtGUWhDS0lRMGdEQ0FOZkNFTUlBY2dESVZDUDRvaEJ5QURJQWdnR1h4OElRTWdEaUFEaFVJZ2lpRU9JQWtnRG53aENTQUlJQW1GUWhpS0lRZ2dBeUFJSUJkOGZDRURJQTRnQTRWQ0VJb2hEaUFKSUE1OElRa2dDQ0FKaFVJL2lpRUlJQVFnQlNBVGZId2hCQ0FQSUFTRlFpQ0tJUThnQ2lBUGZDRUtJQVVnQ29WQ0dJb2hCU0FFSUFVZ0czeDhJUVFnRHlBRWhVSVFpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFqK0tJUVVnQVNBRklCZDhmQ0VCSUEwZ0FZVkNJSW9oRFNBSklBMThJUWtnQlNBSmhVSVlpaUVGSUFFZ0JTQWdmSHdoQVNBTklBR0ZRaENLSVEwZ0NTQU5mQ0VKSUFVZ0NZVkNQNG9oQlNBQ0lBWWdIM3g4SVFJZ0RpQUNoVUlnaWlFT0lBb2dEbndoQ2lBR0lBcUZRaGlLSVFZZ0FpQUdJQnA4ZkNFQ0lBNGdBb1ZDRUlvaERpQUtJQTU4SVFvZ0JpQUtoVUkvaWlFR0lBTWdCeUFjZkh3aEF5QVBJQU9GUWlDS0lROGdDeUFQZkNFTElBY2dDNFZDR0lvaEJ5QURJQWNnRkh4OElRTWdEeUFEaFVJUWlpRVBJQXNnRDN3aEN5QUhJQXVGUWorS0lRY2dCQ0FJSUJGOGZDRUVJQkFnQklWQ0lJb2hFQ0FNSUJCOElRd2dDQ0FNaFVJWWlpRUlJQVFnQ0NBWmZId2hCQ0FRSUFTRlFoQ0tJUkFnRENBUWZDRU1JQWdnRElWQ1A0b2hDQ0FCSUFZZ0hYeDhJUUVnRUNBQmhVSWdpaUVRSUFzZ0VId2hDeUFHSUF1RlFoaUtJUVlnQVNBR0lCTjhmQ0VCSUJBZ0FZVkNFSW9oRUNBTElCQjhJUXNnQmlBTGhVSS9paUVHSUFJZ0J5QWVmSHdoQWlBTklBS0ZRaUNLSVEwZ0RDQU5mQ0VNSUFjZ0RJVkNHSW9oQnlBQ0lBY2dHSHg4SVFJZ0RTQUNoVUlRaWlFTklBd2dEWHdoRENBSElBeUZRaitLSVFjZ0F5QUlJQko4ZkNFRElBNGdBNFZDSUlvaERpQUpJQTU4SVFrZ0NDQUpoVUlZaWlFSUlBTWdDQ0FWZkh3aEF5QU9JQU9GUWhDS0lRNGdDU0FPZkNFSklBZ2dDWVZDUDRvaENDQUVJQVVnRzN4OElRUWdEeUFFaFVJZ2lpRVBJQW9nRDN3aENpQUZJQXFGUWhpS0lRVWdCQ0FGSUJaOGZDRUVJQThnQklWQ0VJb2hEeUFLSUE5OElRb2dCU0FLaFVJL2lpRUZJQUVnQlNBYmZId2hBU0FOSUFHRlFpQ0tJUTBnQ1NBTmZDRUpJQVVnQ1lWQ0dJb2hCU0FCSUFVZ0UzeDhJUUVnRFNBQmhVSVFpaUVOSUFrZ0RYd2hDU0FGSUFtRlFqK0tJUVVnQWlBR0lCbDhmQ0VDSUE0Z0FvVkNJSW9oRGlBS0lBNThJUW9nQmlBS2hVSVlpaUVHSUFJZ0JpQVZmSHdoQWlBT0lBS0ZRaENLSVE0Z0NpQU9mQ0VLSUFZZ0NvVkNQNG9oQmlBRElBY2dHSHg4SVFNZ0R5QURoVUlnaWlFUElBc2dEM3doQ3lBSElBdUZRaGlLSVFjZ0F5QUhJQmQ4ZkNFRElBOGdBNFZDRUlvaER5QUxJQTk4SVFzZ0J5QUxoVUkvaWlFSElBUWdDQ0FTZkh3aEJDQVFJQVNGUWlDS0lSQWdEQ0FRZkNFTUlBZ2dESVZDR0lvaENDQUVJQWdnRm54OElRUWdFQ0FFaFVJUWlpRVFJQXdnRUh3aERDQUlJQXlGUWorS0lRZ2dBU0FHSUNCOGZDRUJJQkFnQVlWQ0lJb2hFQ0FMSUJCOElRc2dCaUFMaFVJWWlpRUdJQUVnQmlBY2ZId2hBU0FRSUFHRlFoQ0tJUkFnQ3lBUWZDRUxJQVlnQzRWQ1A0b2hCaUFDSUFjZ0dueDhJUUlnRFNBQ2hVSWdpaUVOSUF3Z0RYd2hEQ0FISUF5RlFoaUtJUWNnQWlBSElCOThmQ0VDSUEwZ0FvVkNFSW9oRFNBTUlBMThJUXdnQnlBTWhVSS9paUVISUFNZ0NDQVVmSHdoQXlBT0lBT0ZRaUNLSVE0Z0NTQU9mQ0VKSUFnZ0NZVkNHSW9oQ0NBRElBZ2dIWHg4SVFNZ0RpQURoVUlRaWlFT0lBa2dEbndoQ1NBSUlBbUZRaitLSVFnZ0JDQUZJQjU4ZkNFRUlBOGdCSVZDSUlvaER5QUtJQTk4SVFvZ0JTQUtoVUlZaWlFRklBUWdCU0FSZkh3aEJDQVBJQVNGUWhDS0lROGdDaUFQZkNFS0lBVWdDb1ZDUDRvaEJTQUJJQVVnRVh4OElRRWdEU0FCaFVJZ2lpRU5JQWtnRFh3aENTQUZJQW1GUWhpS0lRVWdBU0FGSUJKOGZDRUJJQTBnQVlWQ0VJb2hEU0FKSUExOElRa2dCU0FKaFVJL2lpRUZJQUlnQmlBVGZId2hBaUFPSUFLRlFpQ0tJUTRnQ2lBT2ZDRUtJQVlnQ29WQ0dJb2hCaUFDSUFZZ0ZIeDhJUUlnRGlBQ2hVSVFpaUVPSUFvZ0Rud2hDaUFHSUFxRlFqK0tJUVlnQXlBSElCVjhmQ0VESUE4Z0E0VkNJSW9oRHlBTElBOThJUXNnQnlBTGhVSVlpaUVISUFNZ0J5QVdmSHdoQXlBUElBT0ZRaENLSVE4Z0N5QVBmQ0VMSUFjZ0M0VkNQNG9oQnlBRUlBZ2dGM3g4SVFRZ0VDQUVoVUlnaWlFUUlBd2dFSHdoRENBSUlBeUZRaGlLSVFnZ0JDQUlJQmg4ZkNFRUlCQWdCSVZDRUlvaEVDQU1JQkI4SVF3Z0NDQU1oVUkvaWlFSUlBRWdCaUFaZkh3aEFTQVFJQUdGUWlDS0lSQWdDeUFRZkNFTElBWWdDNFZDR0lvaEJpQUJJQVlnR254OElRRWdFQ0FCaFVJUWlpRVFJQXNnRUh3aEN5QUdJQXVGUWorS0lRWWdBaUFISUJ0OGZDRUNJQTBnQW9WQ0lJb2hEU0FNSUExOElRd2dCeUFNaFVJWWlpRUhJQUlnQnlBY2ZId2hBaUFOSUFLRlFoQ0tJUTBnRENBTmZDRU1JQWNnRElWQ1A0b2hCeUFESUFnZ0hYeDhJUU1nRGlBRGhVSWdpaUVPSUFrZ0Rud2hDU0FJSUFtRlFoaUtJUWdnQXlBSUlCNThmQ0VESUE0Z0E0VkNFSW9oRGlBSklBNThJUWtnQ0NBSmhVSS9paUVJSUFRZ0JTQWZmSHdoQkNBUElBU0ZRaUNLSVE4Z0NpQVBmQ0VLSUFVZ0NvVkNHSW9oQlNBRUlBVWdJSHg4SVFRZ0R5QUVoVUlRaWlFUElBb2dEM3doQ2lBRklBcUZRaitLSVFVZ0FTQUZJQjk4ZkNFQklBMGdBWVZDSUlvaERTQUpJQTE4SVFrZ0JTQUpoVUlZaWlFRklBRWdCU0FiZkh3aEFTQU5JQUdGUWhDS0lRMGdDU0FOZkNFSklBVWdDWVZDUDRvaEJTQUNJQVlnRlh4OElRSWdEaUFDaFVJZ2lpRU9JQW9nRG53aENpQUdJQXFGUWhpS0lRWWdBaUFHSUJsOGZDRUNJQTRnQW9WQ0VJb2hEaUFLSUE1OElRb2dCaUFLaFVJL2lpRUdJQU1nQnlBYWZId2hBeUFQSUFPRlFpQ0tJUThnQ3lBUGZDRUxJQWNnQzRWQ0dJb2hCeUFESUFjZ0lIeDhJUU1nRHlBRGhVSVFpaUVQSUFzZ0Qzd2hDeUFISUF1RlFqK0tJUWNnQkNBSUlCNThmQ0VFSUJBZ0JJVkNJSW9oRUNBTUlCQjhJUXdnQ0NBTWhVSVlpaUVJSUFRZ0NDQVhmSHdoQkNBUUlBU0ZRaENLSVJBZ0RDQVFmQ0VNSUFnZ0RJVkNQNG9oQ0NBQklBWWdFbng4SVFFZ0VDQUJoVUlnaWlFUUlBc2dFSHdoQ3lBR0lBdUZRaGlLSVFZZ0FTQUdJQjE4ZkNFQklCQWdBWVZDRUlvaEVDQUxJQkI4SVFzZ0JpQUxoVUkvaWlFR0lBSWdCeUFSZkh3aEFpQU5JQUtGUWlDS0lRMGdEQ0FOZkNFTUlBY2dESVZDR0lvaEJ5QUNJQWNnRTN4OElRSWdEU0FDaFVJUWlpRU5JQXdnRFh3aERDQUhJQXlGUWorS0lRY2dBeUFJSUJ4OGZDRURJQTRnQTRWQ0lJb2hEaUFKSUE1OElRa2dDQ0FKaFVJWWlpRUlJQU1nQ0NBWWZId2hBeUFPSUFPRlFoQ0tJUTRnQ1NBT2ZDRUpJQWdnQ1lWQ1A0b2hDQ0FFSUFVZ0ZueDhJUVFnRHlBRWhVSWdpaUVQSUFvZ0Qzd2hDaUFGSUFxRlFoaUtJUVVnQkNBRklCUjhmQ0VFSUE4Z0JJVkNFSW9oRHlBS0lBOThJUW9nQlNBS2hVSS9paUVGSUNFZ0lTa0RBQ0FCSUFtRmhUY0RBQ0FpSUNJcEF3QWdBaUFLaFlVM0F3QWdJeUFqS1FNQUlBTWdDNFdGTndNQUlDUWdKQ2tEQUNBRUlBeUZoVGNEQUNBbElDVXBBd0FnQlNBTmhZVTNBd0FnSmlBbUtRTUFJQVlnRG9XRk53TUFJQ2NnSnlrREFDQUhJQStGaFRjREFDQW9JQ2dwQXdBZ0NDQVFoWVUzQXdBTCcpXG4gIHZhciByZWFkeSA9IG51bGxcblxuICB2YXIgbW9kID0ge1xuICAgIGJ1ZmZlcjogd2FzbSxcbiAgICBtZW1vcnk6IG51bGwsXG4gICAgZXhwb3J0czogbnVsbCxcbiAgICByZWFsbG9jOiByZWFsbG9jLFxuICAgIG9ubG9hZDogb25sb2FkXG4gIH1cblxuICBvbmxvYWQoZnVuY3Rpb24gKCkge30pXG5cbiAgcmV0dXJuIG1vZFxuXG4gIGZ1bmN0aW9uIHJlYWxsb2MgKHNpemUpIHtcbiAgICBtb2QuZXhwb3J0cy5tZW1vcnkuZ3JvdyhNYXRoLmNlaWwoTWF0aC5hYnMoc2l6ZSAtIG1vZC5tZW1vcnkubGVuZ3RoKSAvIDY1NTM2KSlcbiAgICBtb2QubWVtb3J5ID0gbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxuXG4gIGZ1bmN0aW9uIG9ubG9hZCAoY2IpIHtcbiAgICBpZiAobW9kLmV4cG9ydHMpIHJldHVybiBjYigpXG5cbiAgICBpZiAocmVhZHkpIHtcbiAgICAgIHJlYWR5LnRoZW4oY2IuYmluZChudWxsLCBudWxsKSkuY2F0Y2goY2IpXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB0cnkge1xuICAgICAgaWYgKG9wdHMgJiYgb3B0cy5hc3luYykgdGhyb3cgbmV3IEVycm9yKCdhc3luYycpXG4gICAgICBzZXR1cCh7aW5zdGFuY2U6IG5ldyBXZWJBc3NlbWJseS5JbnN0YW5jZShuZXcgV2ViQXNzZW1ibHkuTW9kdWxlKHdhc20pLCBpbXApfSlcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJlYWR5ID0gV2ViQXNzZW1ibHkuaW5zdGFudGlhdGUod2FzbSwgaW1wKS50aGVuKHNldHVwKVxuICAgIH1cblxuICAgIG9ubG9hZChjYilcbiAgfVxuXG4gIGZ1bmN0aW9uIHNldHVwICh3KSB7XG4gICAgbW9kLmV4cG9ydHMgPSB3Lmluc3RhbmNlLmV4cG9ydHNcbiAgICBtb2QubWVtb3J5ID0gbW9kLmV4cG9ydHMubWVtb3J5ICYmIG1vZC5leHBvcnRzLm1lbW9yeS5idWZmZXIgJiYgbmV3IFVpbnQ4QXJyYXkobW9kLmV4cG9ydHMubWVtb3J5LmJ1ZmZlcilcbiAgfVxufVxuXG5mdW5jdGlvbiB0b1VpbnQ4QXJyYXkgKHMpIHtcbiAgaWYgKHR5cGVvZiBhdG9iID09PSAnZnVuY3Rpb24nKSByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXRvYihzKS5zcGxpdCgnJykubWFwKGNoYXJDb2RlQXQpKVxuICByZXR1cm4gbmV3IChyZXF1aXJlKCdidWYnICsgJ2ZlcicpLkJ1ZmZlcikocywgJ2Jhc2U2NCcpXG59XG5cbmZ1bmN0aW9uIGNoYXJDb2RlQXQgKGMpIHtcbiAgcmV0dXJuIGMuY2hhckNvZGVBdCgwKVxufVxuIiwidmFyIGFzc2VydCA9IHJlcXVpcmUoJ25hbm9hc3NlcnQnKVxudmFyIHdhc20gPSByZXF1aXJlKCcuL2JsYWtlMmInKSgpXG5cbnZhciBoZWFkID0gNjRcbnZhciBmcmVlTGlzdCA9IFtdXG5cbm1vZHVsZS5leHBvcnRzID0gQmxha2UyYlxudmFyIEJZVEVTX01JTiA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01JTiA9IDE2XG52YXIgQllURVNfTUFYID0gbW9kdWxlLmV4cG9ydHMuQllURVNfTUFYID0gNjRcbnZhciBCWVRFUyA9IG1vZHVsZS5leHBvcnRzLkJZVEVTID0gMzJcbnZhciBLRVlCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NSU4gPSAxNlxudmFyIEtFWUJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLktFWUJZVEVTX01BWCA9IDY0XG52YXIgS0VZQllURVMgPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFUyA9IDMyXG52YXIgU0FMVEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuU0FMVEJZVEVTID0gMTZcbnZhciBQRVJTT05BTEJZVEVTID0gbW9kdWxlLmV4cG9ydHMuUEVSU09OQUxCWVRFUyA9IDE2XG5cbmZ1bmN0aW9uIEJsYWtlMmIgKGRpZ2VzdExlbmd0aCwga2V5LCBzYWx0LCBwZXJzb25hbCwgbm9Bc3NlcnQpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJsYWtlMmIpKSByZXR1cm4gbmV3IEJsYWtlMmIoZGlnZXN0TGVuZ3RoLCBrZXksIHNhbHQsIHBlcnNvbmFsLCBub0Fzc2VydClcbiAgaWYgKCEod2FzbSAmJiB3YXNtLmV4cG9ydHMpKSB0aHJvdyBuZXcgRXJyb3IoJ1dBU00gbm90IGxvYWRlZC4gV2FpdCBmb3IgQmxha2UyYi5yZWFkeShjYiknKVxuICBpZiAoIWRpZ2VzdExlbmd0aCkgZGlnZXN0TGVuZ3RoID0gMzJcblxuICBpZiAobm9Bc3NlcnQgIT09IHRydWUpIHtcbiAgICBhc3NlcnQoZGlnZXN0TGVuZ3RoID49IEJZVEVTX01JTiwgJ2RpZ2VzdExlbmd0aCBtdXN0IGJlIGF0IGxlYXN0ICcgKyBCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIGRpZ2VzdExlbmd0aClcbiAgICBhc3NlcnQoZGlnZXN0TGVuZ3RoIDw9IEJZVEVTX01BWCwgJ2RpZ2VzdExlbmd0aCBtdXN0IGJlIGF0IG1vc3QgJyArIEJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsgZGlnZXN0TGVuZ3RoKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPj0gS0VZQllURVNfTUlOLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoIDw9IEtFWUJZVEVTX01BWCwgJ2tleSBtdXN0IGJlIGF0IGxlYXN0ICcgKyBLRVlCWVRFU19NQVggKyAnLCB3YXMgZ2l2ZW4gJyArIGtleS5sZW5ndGgpXG4gICAgaWYgKHNhbHQgIT0gbnVsbCkgYXNzZXJ0KHNhbHQubGVuZ3RoID09PSBTQUxUQllURVMsICdzYWx0IG11c3QgYmUgZXhhY3RseSAnICsgU0FMVEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBzYWx0Lmxlbmd0aClcbiAgICBpZiAocGVyc29uYWwgIT0gbnVsbCkgYXNzZXJ0KHBlcnNvbmFsLmxlbmd0aCA9PT0gUEVSU09OQUxCWVRFUywgJ3BlcnNvbmFsIG11c3QgYmUgZXhhY3RseSAnICsgUEVSU09OQUxCWVRFUyArICcsIHdhcyBnaXZlbiAnICsgcGVyc29uYWwubGVuZ3RoKVxuICB9XG5cbiAgaWYgKCFmcmVlTGlzdC5sZW5ndGgpIHtcbiAgICBmcmVlTGlzdC5wdXNoKGhlYWQpXG4gICAgaGVhZCArPSAyMTZcbiAgfVxuXG4gIHRoaXMuZGlnZXN0TGVuZ3RoID0gZGlnZXN0TGVuZ3RoXG4gIHRoaXMuZmluYWxpemVkID0gZmFsc2VcbiAgdGhpcy5wb2ludGVyID0gZnJlZUxpc3QucG9wKClcblxuICB3YXNtLm1lbW9yeS5maWxsKDAsIDAsIDY0KVxuICB3YXNtLm1lbW9yeVswXSA9IHRoaXMuZGlnZXN0TGVuZ3RoXG4gIHdhc20ubWVtb3J5WzFdID0ga2V5ID8ga2V5Lmxlbmd0aCA6IDBcbiAgd2FzbS5tZW1vcnlbMl0gPSAxIC8vIGZhbm91dFxuICB3YXNtLm1lbW9yeVszXSA9IDEgLy8gZGVwdGhcblxuICBpZiAoc2FsdCkgd2FzbS5tZW1vcnkuc2V0KHNhbHQsIDMyKVxuICBpZiAocGVyc29uYWwpIHdhc20ubWVtb3J5LnNldChwZXJzb25hbCwgNDgpXG5cbiAgaWYgKHRoaXMucG9pbnRlciArIDIxNiA+IHdhc20ubWVtb3J5Lmxlbmd0aCkgd2FzbS5yZWFsbG9jKHRoaXMucG9pbnRlciArIDIxNikgLy8gd2UgbmVlZCAyMTYgYnl0ZXMgZm9yIHRoZSBzdGF0ZVxuICB3YXNtLmV4cG9ydHMuYmxha2UyYl9pbml0KHRoaXMucG9pbnRlciwgdGhpcy5kaWdlc3RMZW5ndGgpXG5cbiAgaWYgKGtleSkge1xuICAgIHRoaXMudXBkYXRlKGtleSlcbiAgICB3YXNtLm1lbW9yeS5maWxsKDAsIGhlYWQsIGhlYWQgKyBrZXkubGVuZ3RoKSAvLyB3aGl0ZW91dCBrZXlcbiAgICB3YXNtLm1lbW9yeVt0aGlzLnBvaW50ZXIgKyAyMDBdID0gMTI4XG4gIH1cbn1cblxuXG5CbGFrZTJiLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoaW5wdXQpIHtcbiAgYXNzZXJ0KHRoaXMuZmluYWxpemVkID09PSBmYWxzZSwgJ0hhc2ggaW5zdGFuY2UgZmluYWxpemVkJylcbiAgYXNzZXJ0KGlucHV0LCAnaW5wdXQgbXVzdCBiZSBUeXBlZEFycmF5IG9yIEJ1ZmZlcicpXG5cbiAgaWYgKGhlYWQgKyBpbnB1dC5sZW5ndGggPiB3YXNtLm1lbW9yeS5sZW5ndGgpIHdhc20ucmVhbGxvYyhoZWFkICsgaW5wdXQubGVuZ3RoKVxuICB3YXNtLm1lbW9yeS5zZXQoaW5wdXQsIGhlYWQpXG4gIHdhc20uZXhwb3J0cy5ibGFrZTJiX3VwZGF0ZSh0aGlzLnBvaW50ZXIsIGhlYWQsIGhlYWQgKyBpbnB1dC5sZW5ndGgpXG4gIHJldHVybiB0aGlzXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgYXNzZXJ0KHRoaXMuZmluYWxpemVkID09PSBmYWxzZSwgJ0hhc2ggaW5zdGFuY2UgZmluYWxpemVkJylcbiAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlXG5cbiAgZnJlZUxpc3QucHVzaCh0aGlzLnBvaW50ZXIpXG4gIHdhc20uZXhwb3J0cy5ibGFrZTJiX2ZpbmFsKHRoaXMucG9pbnRlcilcblxuICBpZiAoIWVuYyB8fCBlbmMgPT09ICdiaW5hcnknKSB7XG4gICAgcmV0dXJuIHdhc20ubWVtb3J5LnNsaWNlKHRoaXMucG9pbnRlciArIDEyOCwgdGhpcy5wb2ludGVyICsgMTI4ICsgdGhpcy5kaWdlc3RMZW5ndGgpXG4gIH1cblxuICBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgIHJldHVybiBoZXhTbGljZSh3YXNtLm1lbW9yeSwgdGhpcy5wb2ludGVyICsgMTI4LCB0aGlzLmRpZ2VzdExlbmd0aClcbiAgfVxuXG4gIGFzc2VydChlbmMubGVuZ3RoID49IHRoaXMuZGlnZXN0TGVuZ3RoLCAnaW5wdXQgbXVzdCBiZSBUeXBlZEFycmF5IG9yIEJ1ZmZlcicpXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5kaWdlc3RMZW5ndGg7IGkrKykge1xuICAgIGVuY1tpXSA9IHdhc20ubWVtb3J5W3RoaXMucG9pbnRlciArIDEyOCArIGldXG4gIH1cblxuICByZXR1cm4gZW5jXG59XG5cbi8vIGxpYnNvZGl1bSBjb21wYXRcbkJsYWtlMmIucHJvdG90eXBlLmZpbmFsID0gQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0XG5cbkJsYWtlMmIuV0FTTSA9IHdhc20gJiYgd2FzbS5idWZmZXJcbkJsYWtlMmIuU1VQUE9SVEVEID0gdHlwZW9mIFdlYkFzc2VtYmx5ICE9PSAndW5kZWZpbmVkJ1xuXG5CbGFrZTJiLnJlYWR5ID0gZnVuY3Rpb24gKGNiKSB7XG4gIGlmICghY2IpIGNiID0gbm9vcFxuICBpZiAoIXdhc20pIHJldHVybiBjYihuZXcgRXJyb3IoJ1dlYkFzc2VtYmx5IG5vdCBzdXBwb3J0ZWQnKSlcblxuICAvLyBiYWNrd2FyZHMgY29tcGF0LCBjYW4gYmUgcmVtb3ZlZCBpbiBhIG5ldyBtYWpvclxuICB2YXIgcCA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZWplY3QsIHJlc29sdmUpIHtcbiAgICB3YXNtLm9ubG9hZChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSByZXNvbHZlKClcbiAgICAgIGVsc2UgcmVqZWN0KClcbiAgICAgIGNiKGVycilcbiAgICB9KVxuICB9KVxuXG4gIHJldHVybiBwXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLnJlYWR5ID0gQmxha2UyYi5yZWFkeVxuXG5mdW5jdGlvbiBub29wICgpIHt9XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBsZW4pIHtcbiAgdmFyIHN0ciA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHN0ciArPSB0b0hleChidWZbc3RhcnQgKyBpXSlcbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG4iLCJ2YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbmFub2Fzc2VydCcpXG52YXIgYjJ3YXNtID0gcmVxdWlyZSgnYmxha2UyYi13YXNtJylcblxuLy8gNjQtYml0IHVuc2lnbmVkIGFkZGl0aW9uXG4vLyBTZXRzIHZbYSxhKzFdICs9IHZbYixiKzFdXG4vLyB2IHNob3VsZCBiZSBhIFVpbnQzMkFycmF5XG5mdW5jdGlvbiBBREQ2NEFBICh2LCBhLCBiKSB7XG4gIHZhciBvMCA9IHZbYV0gKyB2W2JdXG4gIHZhciBvMSA9IHZbYSArIDFdICsgdltiICsgMV1cbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIDY0LWJpdCB1bnNpZ25lZCBhZGRpdGlvblxuLy8gU2V0cyB2W2EsYSsxXSArPSBiXG4vLyBiMCBpcyB0aGUgbG93IDMyIGJpdHMgb2YgYiwgYjEgcmVwcmVzZW50cyB0aGUgaGlnaCAzMiBiaXRzXG5mdW5jdGlvbiBBREQ2NEFDICh2LCBhLCBiMCwgYjEpIHtcbiAgdmFyIG8wID0gdlthXSArIGIwXG4gIGlmIChiMCA8IDApIHtcbiAgICBvMCArPSAweDEwMDAwMDAwMFxuICB9XG4gIHZhciBvMSA9IHZbYSArIDFdICsgYjFcbiAgaWYgKG8wID49IDB4MTAwMDAwMDAwKSB7XG4gICAgbzErK1xuICB9XG4gIHZbYV0gPSBvMFxuICB2W2EgKyAxXSA9IG8xXG59XG5cbi8vIExpdHRsZS1lbmRpYW4gYnl0ZSBhY2Nlc3NcbmZ1bmN0aW9uIEIyQl9HRVQzMiAoYXJyLCBpKSB7XG4gIHJldHVybiAoYXJyW2ldIF5cbiAgKGFycltpICsgMV0gPDwgOCkgXlxuICAoYXJyW2kgKyAyXSA8PCAxNikgXlxuICAoYXJyW2kgKyAzXSA8PCAyNCkpXG59XG5cbi8vIEcgTWl4aW5nIGZ1bmN0aW9uXG4vLyBUaGUgUk9UUnMgYXJlIGlubGluZWQgZm9yIHNwZWVkXG5mdW5jdGlvbiBCMkJfRyAoYSwgYiwgYywgZCwgaXgsIGl5KSB7XG4gIHZhciB4MCA9IG1baXhdXG4gIHZhciB4MSA9IG1baXggKyAxXVxuICB2YXIgeTAgPSBtW2l5XVxuICB2YXIgeTEgPSBtW2l5ICsgMV1cblxuICBBREQ2NEFBKHYsIGEsIGIpIC8vIHZbYSxhKzFdICs9IHZbYixiKzFdIC4uLiBpbiBKUyB3ZSBtdXN0IHN0b3JlIGEgdWludDY0IGFzIHR3byB1aW50MzJzXG4gIEFERDY0QUModiwgYSwgeDAsIHgxKSAvLyB2W2EsIGErMV0gKz0geCAuLi4geDAgaXMgdGhlIGxvdyAzMiBiaXRzIG9mIHgsIHgxIGlzIHRoZSBoaWdoIDMyIGJpdHNcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgdG8gdGhlIHJpZ2h0IGJ5IDMyIGJpdHNcbiAgdmFyIHhvcjAgPSB2W2RdIF4gdlthXVxuICB2YXIgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9IHhvcjFcbiAgdltkICsgMV0gPSB4b3IwXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSAyNCBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjAgPj4+IDI0KSBeICh4b3IxIDw8IDgpXG4gIHZbYiArIDFdID0gKHhvcjEgPj4+IDI0KSBeICh4b3IwIDw8IDgpXG5cbiAgQURENjRBQSh2LCBhLCBiKVxuICBBREQ2NEFDKHYsIGEsIHkwLCB5MSlcblxuICAvLyB2W2QsZCsxXSA9ICh2W2QsZCsxXSB4b3IgdlthLGErMV0pIHJvdGF0ZWQgcmlnaHQgYnkgMTYgYml0c1xuICB4b3IwID0gdltkXSBeIHZbYV1cbiAgeG9yMSA9IHZbZCArIDFdIF4gdlthICsgMV1cbiAgdltkXSA9ICh4b3IwID4+PiAxNikgXiAoeG9yMSA8PCAxNilcbiAgdltkICsgMV0gPSAoeG9yMSA+Pj4gMTYpIF4gKHhvcjAgPDwgMTYpXG5cbiAgQURENjRBQSh2LCBjLCBkKVxuXG4gIC8vIHZbYixiKzFdID0gKHZbYixiKzFdIHhvciB2W2MsYysxXSkgcm90YXRlZCByaWdodCBieSA2MyBiaXRzXG4gIHhvcjAgPSB2W2JdIF4gdltjXVxuICB4b3IxID0gdltiICsgMV0gXiB2W2MgKyAxXVxuICB2W2JdID0gKHhvcjEgPj4+IDMxKSBeICh4b3IwIDw8IDEpXG4gIHZbYiArIDFdID0gKHhvcjAgPj4+IDMxKSBeICh4b3IxIDw8IDEpXG59XG5cbi8vIEluaXRpYWxpemF0aW9uIFZlY3RvclxudmFyIEJMQUtFMkJfSVYzMiA9IG5ldyBVaW50MzJBcnJheShbXG4gIDB4RjNCQ0M5MDgsIDB4NkEwOUU2NjcsIDB4ODRDQUE3M0IsIDB4QkI2N0FFODUsXG4gIDB4RkU5NEY4MkIsIDB4M0M2RUYzNzIsIDB4NUYxRDM2RjEsIDB4QTU0RkY1M0EsXG4gIDB4QURFNjgyRDEsIDB4NTEwRTUyN0YsIDB4MkIzRTZDMUYsIDB4OUIwNTY4OEMsXG4gIDB4RkI0MUJENkIsIDB4MUY4M0Q5QUIsIDB4MTM3RTIxNzksIDB4NUJFMENEMTlcbl0pXG5cbnZhciBTSUdNQTggPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDMsXG4gIDExLCA4LCAxMiwgMCwgNSwgMiwgMTUsIDEzLCAxMCwgMTQsIDMsIDYsIDcsIDEsIDksIDQsXG4gIDcsIDksIDMsIDEsIDEzLCAxMiwgMTEsIDE0LCAyLCA2LCA1LCAxMCwgNCwgMCwgMTUsIDgsXG4gIDksIDAsIDUsIDcsIDIsIDQsIDEwLCAxNSwgMTQsIDEsIDExLCAxMiwgNiwgOCwgMywgMTMsXG4gIDIsIDEyLCA2LCAxMCwgMCwgMTEsIDgsIDMsIDQsIDEzLCA3LCA1LCAxNSwgMTQsIDEsIDksXG4gIDEyLCA1LCAxLCAxNSwgMTQsIDEzLCA0LCAxMCwgMCwgNywgNiwgMywgOSwgMiwgOCwgMTEsXG4gIDEzLCAxMSwgNywgMTQsIDEyLCAxLCAzLCA5LCA1LCAwLCAxNSwgNCwgOCwgNiwgMiwgMTAsXG4gIDYsIDE1LCAxNCwgOSwgMTEsIDMsIDAsIDgsIDEyLCAyLCAxMywgNywgMSwgNCwgMTAsIDUsXG4gIDEwLCAyLCA4LCA0LCA3LCA2LCAxLCA1LCAxNSwgMTEsIDksIDE0LCAzLCAxMiwgMTMsIDAsXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDE0LCAxMCwgNCwgOCwgOSwgMTUsIDEzLCA2LCAxLCAxMiwgMCwgMiwgMTEsIDcsIDUsIDNcbl1cblxuLy8gVGhlc2UgYXJlIG9mZnNldHMgaW50byBhIHVpbnQ2NCBidWZmZXIuXG4vLyBNdWx0aXBseSB0aGVtIGFsbCBieSAyIHRvIG1ha2UgdGhlbSBvZmZzZXRzIGludG8gYSB1aW50MzIgYnVmZmVyLFxuLy8gYmVjYXVzZSB0aGlzIGlzIEphdmFzY3JpcHQgYW5kIHdlIGRvbid0IGhhdmUgdWludDY0c1xudmFyIFNJR01BODIgPSBuZXcgVWludDhBcnJheShTSUdNQTgubWFwKGZ1bmN0aW9uICh4KSB7IHJldHVybiB4ICogMiB9KSlcblxuLy8gQ29tcHJlc3Npb24gZnVuY3Rpb24uICdsYXN0JyBmbGFnIGluZGljYXRlcyBsYXN0IGJsb2NrLlxuLy8gTm90ZSB3ZSdyZSByZXByZXNlbnRpbmcgMTYgdWludDY0cyBhcyAzMiB1aW50MzJzXG52YXIgdiA9IG5ldyBVaW50MzJBcnJheSgzMilcbnZhciBtID0gbmV3IFVpbnQzMkFycmF5KDMyKVxuZnVuY3Rpb24gYmxha2UyYkNvbXByZXNzIChjdHgsIGxhc3QpIHtcbiAgdmFyIGkgPSAwXG5cbiAgLy8gaW5pdCB3b3JrIHZhcmlhYmxlc1xuICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHZbaV0gPSBjdHguaFtpXVxuICAgIHZbaSArIDE2XSA9IEJMQUtFMkJfSVYzMltpXVxuICB9XG5cbiAgLy8gbG93IDY0IGJpdHMgb2Ygb2Zmc2V0XG4gIHZbMjRdID0gdlsyNF0gXiBjdHgudFxuICB2WzI1XSA9IHZbMjVdIF4gKGN0eC50IC8gMHgxMDAwMDAwMDApXG4gIC8vIGhpZ2ggNjQgYml0cyBub3Qgc3VwcG9ydGVkLCBvZmZzZXQgbWF5IG5vdCBiZSBoaWdoZXIgdGhhbiAyKio1My0xXG5cbiAgLy8gbGFzdCBibG9jayBmbGFnIHNldCA/XG4gIGlmIChsYXN0KSB7XG4gICAgdlsyOF0gPSB+dlsyOF1cbiAgICB2WzI5XSA9IH52WzI5XVxuICB9XG5cbiAgLy8gZ2V0IGxpdHRsZS1lbmRpYW4gd29yZHNcbiAgZm9yIChpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICBtW2ldID0gQjJCX0dFVDMyKGN0eC5iLCA0ICogaSlcbiAgfVxuXG4gIC8vIHR3ZWx2ZSByb3VuZHMgb2YgbWl4aW5nXG4gIGZvciAoaSA9IDA7IGkgPCAxMjsgaSsrKSB7XG4gICAgQjJCX0coMCwgOCwgMTYsIDI0LCBTSUdNQTgyW2kgKiAxNiArIDBdLCBTSUdNQTgyW2kgKiAxNiArIDFdKVxuICAgIEIyQl9HKDIsIDEwLCAxOCwgMjYsIFNJR01BODJbaSAqIDE2ICsgMl0sIFNJR01BODJbaSAqIDE2ICsgM10pXG4gICAgQjJCX0coNCwgMTIsIDIwLCAyOCwgU0lHTUE4MltpICogMTYgKyA0XSwgU0lHTUE4MltpICogMTYgKyA1XSlcbiAgICBCMkJfRyg2LCAxNCwgMjIsIDMwLCBTSUdNQTgyW2kgKiAxNiArIDZdLCBTSUdNQTgyW2kgKiAxNiArIDddKVxuICAgIEIyQl9HKDAsIDEwLCAyMCwgMzAsIFNJR01BODJbaSAqIDE2ICsgOF0sIFNJR01BODJbaSAqIDE2ICsgOV0pXG4gICAgQjJCX0coMiwgMTIsIDIyLCAyNCwgU0lHTUE4MltpICogMTYgKyAxMF0sIFNJR01BODJbaSAqIDE2ICsgMTFdKVxuICAgIEIyQl9HKDQsIDE0LCAxNiwgMjYsIFNJR01BODJbaSAqIDE2ICsgMTJdLCBTSUdNQTgyW2kgKiAxNiArIDEzXSlcbiAgICBCMkJfRyg2LCA4LCAxOCwgMjgsIFNJR01BODJbaSAqIDE2ICsgMTRdLCBTSUdNQTgyW2kgKiAxNiArIDE1XSlcbiAgfVxuXG4gIGZvciAoaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgY3R4LmhbaV0gPSBjdHguaFtpXSBeIHZbaV0gXiB2W2kgKyAxNl1cbiAgfVxufVxuXG4vLyByZXVzYWJsZSBwYXJhbWV0ZXJfYmxvY2tcbnZhciBwYXJhbWV0ZXJfYmxvY2sgPSBuZXcgVWludDhBcnJheShbXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDA6IG91dGxlbiwga2V5bGVuLCBmYW5vdXQsIGRlcHRoXG4gIDAsIDAsIDAsIDAsICAgICAgLy8gIDQ6IGxlYWYgbGVuZ3RoLCBzZXF1ZW50aWFsIG1vZGVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAgODogbm9kZSBvZmZzZXRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAxMjogbm9kZSBvZmZzZXRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAxNjogbm9kZSBkZXB0aCwgaW5uZXIgbGVuZ3RoLCByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAyMDogcmZ1XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gMjQ6IHJmdVxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDI4OiByZnVcbiAgMCwgMCwgMCwgMCwgICAgICAvLyAzMjogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDM2OiBzYWx0XG4gIDAsIDAsIDAsIDAsICAgICAgLy8gNDA6IHNhbHRcbiAgMCwgMCwgMCwgMCwgICAgICAvLyA0NDogc2FsdFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDQ4OiBwZXJzb25hbFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDUyOiBwZXJzb25hbFxuICAwLCAwLCAwLCAwLCAgICAgIC8vIDU2OiBwZXJzb25hbFxuICAwLCAwLCAwLCAwICAgICAgIC8vIDYwOiBwZXJzb25hbFxuXSlcblxuLy8gQ3JlYXRlcyBhIEJMQUtFMmIgaGFzaGluZyBjb250ZXh0XG4vLyBSZXF1aXJlcyBhbiBvdXRwdXQgbGVuZ3RoIGJldHdlZW4gMSBhbmQgNjQgYnl0ZXNcbi8vIFRha2VzIGFuIG9wdGlvbmFsIFVpbnQ4QXJyYXkga2V5XG5mdW5jdGlvbiBCbGFrZTJiIChvdXRsZW4sIGtleSwgc2FsdCwgcGVyc29uYWwpIHtcbiAgLy8gemVybyBvdXQgcGFyYW1ldGVyX2Jsb2NrIGJlZm9yZSB1c2FnZVxuICBwYXJhbWV0ZXJfYmxvY2suZmlsbCgwKVxuICAvLyBzdGF0ZSwgJ3BhcmFtIGJsb2NrJ1xuXG4gIHRoaXMuYiA9IG5ldyBVaW50OEFycmF5KDEyOClcbiAgdGhpcy5oID0gbmV3IFVpbnQzMkFycmF5KDE2KVxuICB0aGlzLnQgPSAwIC8vIGlucHV0IGNvdW50XG4gIHRoaXMuYyA9IDAgLy8gcG9pbnRlciB3aXRoaW4gYnVmZmVyXG4gIHRoaXMub3V0bGVuID0gb3V0bGVuIC8vIG91dHB1dCBsZW5ndGggaW4gYnl0ZXNcblxuICBwYXJhbWV0ZXJfYmxvY2tbMF0gPSBvdXRsZW5cbiAgaWYgKGtleSkgcGFyYW1ldGVyX2Jsb2NrWzFdID0ga2V5Lmxlbmd0aFxuICBwYXJhbWV0ZXJfYmxvY2tbMl0gPSAxIC8vIGZhbm91dFxuICBwYXJhbWV0ZXJfYmxvY2tbM10gPSAxIC8vIGRlcHRoXG5cbiAgaWYgKHNhbHQpIHBhcmFtZXRlcl9ibG9jay5zZXQoc2FsdCwgMzIpXG4gIGlmIChwZXJzb25hbCkgcGFyYW1ldGVyX2Jsb2NrLnNldChwZXJzb25hbCwgNDgpXG5cbiAgLy8gaW5pdGlhbGl6ZSBoYXNoIHN0YXRlXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgIHRoaXMuaFtpXSA9IEJMQUtFMkJfSVYzMltpXSBeIEIyQl9HRVQzMihwYXJhbWV0ZXJfYmxvY2ssIGkgKiA0KVxuICB9XG5cbiAgLy8ga2V5IHRoZSBoYXNoLCBpZiBhcHBsaWNhYmxlXG4gIGlmIChrZXkpIHtcbiAgICBibGFrZTJiVXBkYXRlKHRoaXMsIGtleSlcbiAgICAvLyBhdCB0aGUgZW5kXG4gICAgdGhpcy5jID0gMTI4XG4gIH1cbn1cblxuQmxha2UyYi5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKGlucHV0KSB7XG4gIGFzc2VydChpbnB1dCAhPSBudWxsLCAnaW5wdXQgbXVzdCBiZSBVaW50OEFycmF5IG9yIEJ1ZmZlcicpXG4gIGJsYWtlMmJVcGRhdGUodGhpcywgaW5wdXQpXG4gIHJldHVybiB0aGlzXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmRpZ2VzdCA9IGZ1bmN0aW9uIChvdXQpIHtcbiAgdmFyIGJ1ZiA9ICghb3V0IHx8IG91dCA9PT0gJ2JpbmFyeScgfHwgb3V0ID09PSAnaGV4JykgPyBuZXcgVWludDhBcnJheSh0aGlzLm91dGxlbikgOiBvdXRcbiAgYXNzZXJ0KGJ1Zi5sZW5ndGggPj0gdGhpcy5vdXRsZW4sICdvdXQgbXVzdCBoYXZlIGF0IGxlYXN0IG91dGxlbiBieXRlcyBvZiBzcGFjZScpXG4gIGJsYWtlMmJGaW5hbCh0aGlzLCBidWYpXG4gIGlmIChvdXQgPT09ICdoZXgnKSByZXR1cm4gaGV4U2xpY2UoYnVmKVxuICByZXR1cm4gYnVmXG59XG5cbkJsYWtlMmIucHJvdG90eXBlLmZpbmFsID0gQmxha2UyYi5wcm90b3R5cGUuZGlnZXN0XG5cbkJsYWtlMmIucmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICBjYigpIC8vIGlnbm9yZSB0aGUgZXJyb3JcbiAgfSlcbn1cblxuLy8gVXBkYXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbi8vIFJlcXVpcmVzIGhhc2ggY29udGV4dCBhbmQgVWludDhBcnJheSAoYnl0ZSBhcnJheSlcbmZ1bmN0aW9uIGJsYWtlMmJVcGRhdGUgKGN0eCwgaW5wdXQpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjdHguYyA9PT0gMTI4KSB7IC8vIGJ1ZmZlciBmdWxsID9cbiAgICAgIGN0eC50ICs9IGN0eC5jIC8vIGFkZCBjb3VudGVyc1xuICAgICAgYmxha2UyYkNvbXByZXNzKGN0eCwgZmFsc2UpIC8vIGNvbXByZXNzIChub3QgbGFzdClcbiAgICAgIGN0eC5jID0gMCAvLyBjb3VudGVyIHRvIHplcm9cbiAgICB9XG4gICAgY3R4LmJbY3R4LmMrK10gPSBpbnB1dFtpXVxuICB9XG59XG5cbi8vIENvbXBsZXRlcyBhIEJMQUtFMmIgc3RyZWFtaW5nIGhhc2hcbi8vIFJldHVybnMgYSBVaW50OEFycmF5IGNvbnRhaW5pbmcgdGhlIG1lc3NhZ2UgZGlnZXN0XG5mdW5jdGlvbiBibGFrZTJiRmluYWwgKGN0eCwgb3V0KSB7XG4gIGN0eC50ICs9IGN0eC5jIC8vIG1hcmsgbGFzdCBibG9jayBvZmZzZXRcblxuICB3aGlsZSAoY3R4LmMgPCAxMjgpIHsgLy8gZmlsbCB1cCB3aXRoIHplcm9zXG4gICAgY3R4LmJbY3R4LmMrK10gPSAwXG4gIH1cbiAgYmxha2UyYkNvbXByZXNzKGN0eCwgdHJ1ZSkgLy8gZmluYWwgYmxvY2sgZmxhZyA9IDFcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGN0eC5vdXRsZW47IGkrKykge1xuICAgIG91dFtpXSA9IGN0eC5oW2kgPj4gMl0gPj4gKDggKiAoaSAmIDMpKVxuICB9XG4gIHJldHVybiBvdXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Zikge1xuICB2YXIgc3RyID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHN0ciArPSB0b0hleChidWZbaV0pXG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdG9IZXggKG4pIHtcbiAgaWYgKG4gPCAxNikgcmV0dXJuICcwJyArIG4udG9TdHJpbmcoMTYpXG4gIHJldHVybiBuLnRvU3RyaW5nKDE2KVxufVxuXG52YXIgUHJvdG8gPSBCbGFrZTJiXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY3JlYXRlSGFzaCAob3V0bGVuLCBrZXksIHNhbHQsIHBlcnNvbmFsLCBub0Fzc2VydCkge1xuICBpZiAobm9Bc3NlcnQgIT09IHRydWUpIHtcbiAgICBhc3NlcnQob3V0bGVuID49IEJZVEVTX01JTiwgJ291dGxlbiBtdXN0IGJlIGF0IGxlYXN0ICcgKyBCWVRFU19NSU4gKyAnLCB3YXMgZ2l2ZW4gJyArIG91dGxlbilcbiAgICBhc3NlcnQob3V0bGVuIDw9IEJZVEVTX01BWCwgJ291dGxlbiBtdXN0IGJlIGF0IG1vc3QgJyArIEJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsgb3V0bGVuKVxuICAgIGlmIChrZXkgIT0gbnVsbCkgYXNzZXJ0KGtleS5sZW5ndGggPj0gS0VZQllURVNfTUlOLCAna2V5IG11c3QgYmUgYXQgbGVhc3QgJyArIEtFWUJZVEVTX01JTiArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoa2V5ICE9IG51bGwpIGFzc2VydChrZXkubGVuZ3RoIDw9IEtFWUJZVEVTX01BWCwgJ2tleSBtdXN0IGJlIGF0IG1vc3QgJyArIEtFWUJZVEVTX01BWCArICcsIHdhcyBnaXZlbiAnICsga2V5Lmxlbmd0aClcbiAgICBpZiAoc2FsdCAhPSBudWxsKSBhc3NlcnQoc2FsdC5sZW5ndGggPT09IFNBTFRCWVRFUywgJ3NhbHQgbXVzdCBiZSBleGFjdGx5ICcgKyBTQUxUQllURVMgKyAnLCB3YXMgZ2l2ZW4gJyArIHNhbHQubGVuZ3RoKVxuICAgIGlmIChwZXJzb25hbCAhPSBudWxsKSBhc3NlcnQocGVyc29uYWwubGVuZ3RoID09PSBQRVJTT05BTEJZVEVTLCAncGVyc29uYWwgbXVzdCBiZSBleGFjdGx5ICcgKyBQRVJTT05BTEJZVEVTICsgJywgd2FzIGdpdmVuICcgKyBwZXJzb25hbC5sZW5ndGgpXG4gIH1cblxuICByZXR1cm4gbmV3IFByb3RvKG91dGxlbiwga2V5LCBzYWx0LCBwZXJzb25hbClcbn1cblxubW9kdWxlLmV4cG9ydHMucmVhZHkgPSBmdW5jdGlvbiAoY2IpIHtcbiAgYjJ3YXNtLnJlYWR5KGZ1bmN0aW9uICgpIHsgLy8gaWdub3JlIGVycm9yc1xuICAgIGNiKClcbiAgfSlcbn1cblxubW9kdWxlLmV4cG9ydHMuV0FTTV9TVVBQT1JURUQgPSBiMndhc20uU1VQUE9SVEVEXG5tb2R1bGUuZXhwb3J0cy5XQVNNX0xPQURFRCA9IGZhbHNlXG5cbnZhciBCWVRFU19NSU4gPSBtb2R1bGUuZXhwb3J0cy5CWVRFU19NSU4gPSAxNlxudmFyIEJZVEVTX01BWCA9IG1vZHVsZS5leHBvcnRzLkJZVEVTX01BWCA9IDY0XG52YXIgQllURVMgPSBtb2R1bGUuZXhwb3J0cy5CWVRFUyA9IDMyXG52YXIgS0VZQllURVNfTUlOID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVNfTUlOID0gMTZcbnZhciBLRVlCWVRFU19NQVggPSBtb2R1bGUuZXhwb3J0cy5LRVlCWVRFU19NQVggPSA2NFxudmFyIEtFWUJZVEVTID0gbW9kdWxlLmV4cG9ydHMuS0VZQllURVMgPSAzMlxudmFyIFNBTFRCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlNBTFRCWVRFUyA9IDE2XG52YXIgUEVSU09OQUxCWVRFUyA9IG1vZHVsZS5leHBvcnRzLlBFUlNPTkFMQllURVMgPSAxNlxuXG5iMndhc20ucmVhZHkoZnVuY3Rpb24gKGVycikge1xuICBpZiAoIWVycikge1xuICAgIG1vZHVsZS5leHBvcnRzLldBU01fTE9BREVEID0gdHJ1ZVxuICAgIFByb3RvID0gYjJ3YXNtXG4gIH1cbn0pXG4iLCIvKiFcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxuICpcbiAqIEBhdXRob3IgICBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXG5cbid1c2Ugc3RyaWN0J1xuXG5jb25zdCBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxuY29uc3QgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuY29uc3QgY3VzdG9tSW5zcGVjdFN5bWJvbCA9XG4gICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2xbJ2ZvciddID09PSAnZnVuY3Rpb24nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgID8gU3ltYm9sWydmb3InXSgnbm9kZWpzLnV0aWwuaW5zcGVjdC5jdXN0b20nKSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGRvdC1ub3RhdGlvblxuICAgIDogbnVsbFxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbmNvbnN0IEtfTUFYX0xFTkdUSCA9IDB4N2ZmZmZmZmZcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxuXG4vKipcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XG4gKiAgID09PSB0cnVlICAgIFVzZSBVaW50OEFycmF5IGltcGxlbWVudGF0aW9uIChmYXN0ZXN0KVxuICogICA9PT0gZmFsc2UgICBQcmludCB3YXJuaW5nIGFuZCByZWNvbW1lbmQgdXNpbmcgYGJ1ZmZlcmAgdjQueCB3aGljaCBoYXMgYW4gT2JqZWN0XG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxuICpcbiAqIEJyb3dzZXJzIHRoYXQgc3VwcG9ydCB0eXBlZCBhcnJheXMgYXJlIElFIDEwKywgRmlyZWZveCA0KywgQ2hyb21lIDcrLCBTYWZhcmkgNS4xKyxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cbiAqXG4gKiBXZSByZXBvcnQgdGhhdCB0aGUgYnJvd3NlciBkb2VzIG5vdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBpZiB0aGUgYXJlIG5vdCBzdWJjbGFzc2FibGVcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcbiAqIChTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NTQzOCkuIElFIDEwIGxhY2tzIHN1cHBvcnRcbiAqIGZvciBfX3Byb3RvX18gYW5kIGhhcyBhIGJ1Z2d5IHR5cGVkIGFycmF5IGltcGxlbWVudGF0aW9uLlxuICovXG5CdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCA9IHR5cGVkQXJyYXlTdXBwb3J0KClcblxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcbiAgICB0eXBlb2YgY29uc29sZS5lcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xuICBjb25zb2xlLmVycm9yKFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXG4gICAgJ2BidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuJ1xuICApXG59XG5cbmZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0ICgpIHtcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xuICB0cnkge1xuICAgIGNvbnN0IGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgY29uc3QgcHJvdG8gPSB7IGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfSB9XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHByb3RvLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYXJyLCBwcm90bylcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEJ1ZmZlci5wcm90b3R5cGUsICdwYXJlbnQnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKHRoaXMpKSByZXR1cm4gdW5kZWZpbmVkXG4gICAgcmV0dXJuIHRoaXMuYnVmZmVyXG4gIH1cbn0pXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLCAnb2Zmc2V0Jywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0aGlzKSkgcmV0dXJuIHVuZGVmaW5lZFxuICAgIHJldHVybiB0aGlzLmJ5dGVPZmZzZXRcbiAgfVxufSlcblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgXCInICsgbGVuZ3RoICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxuICBPYmplY3Quc2V0UHJvdG90eXBlT2YoYnVmLCBCdWZmZXIucHJvdG90eXBlKVxuICByZXR1cm4gYnVmXG59XG5cbi8qKlxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXG4gKiBwcm90b3R5cGUgY2hhbmdlZCB0byBgQnVmZmVyLnByb3RvdHlwZWAuIEZ1cnRoZXJtb3JlLCBgQnVmZmVyYCBpcyBhIHN1YmNsYXNzIG9mXG4gKiBgVWludDhBcnJheWAsIHNvIHRoZSByZXR1cm5lZCBpbnN0YW5jZXMgd2lsbCBoYXZlIGFsbCB0aGUgbm9kZSBgQnVmZmVyYCBtZXRob2RzXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxuICogcmV0dXJucyBhIHNpbmdsZSBvY3RldC5cbiAqXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXG4gKi9cblxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICAvLyBDb21tb24gY2FzZS5cbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBzdHJpbmcuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5Vmlldyh2YWx1ZSlcbiAgfVxuXG4gIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCAnICtcbiAgICAgICdvciBBcnJheS1saWtlIE9iamVjdC4gUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB2YWx1ZSlcbiAgICApXG4gIH1cblxuICBpZiAoaXNJbnN0YW5jZSh2YWx1ZSwgQXJyYXlCdWZmZXIpIHx8XG4gICAgICAodmFsdWUgJiYgaXNJbnN0YW5jZSh2YWx1ZS5idWZmZXIsIEFycmF5QnVmZmVyKSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIFNoYXJlZEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgKGlzSW5zdGFuY2UodmFsdWUsIFNoYXJlZEFycmF5QnVmZmVyKSB8fFxuICAgICAgKHZhbHVlICYmIGlzSW5zdGFuY2UodmFsdWUuYnVmZmVyLCBTaGFyZWRBcnJheUJ1ZmZlcikpKSkge1xuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICdUaGUgXCJ2YWx1ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlIG51bWJlcidcbiAgICApXG4gIH1cblxuICBjb25zdCB2YWx1ZU9mID0gdmFsdWUudmFsdWVPZiAmJiB2YWx1ZS52YWx1ZU9mKClcbiAgaWYgKHZhbHVlT2YgIT0gbnVsbCAmJiB2YWx1ZU9mICE9PSB2YWx1ZSkge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZU9mLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBjb25zdCBiID0gZnJvbU9iamVjdCh2YWx1ZSlcbiAgaWYgKGIpIHJldHVybiBiXG5cbiAgaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1ByaW1pdGl2ZSAhPSBudWxsICYmXG4gICAgICB0eXBlb2YgdmFsdWVbU3ltYm9sLnRvUHJpbWl0aXZlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbSh2YWx1ZVtTeW1ib2wudG9QcmltaXRpdmVdKCdzdHJpbmcnKSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAnVGhlIGZpcnN0IGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIEFycmF5QnVmZmVyLCBBcnJheSwgJyArXG4gICAgJ29yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlICcgKyAodHlwZW9mIHZhbHVlKVxuICApXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIucHJvdG90eXBlLCBVaW50OEFycmF5LnByb3RvdHlwZSlcbk9iamVjdC5zZXRQcm90b3R5cGVPZihCdWZmZXIsIFVpbnQ4QXJyYXkpXG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgb2YgdHlwZSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyBzaXplICsgJ1wiIGlzIGludmFsaWQgZm9yIG9wdGlvbiBcInNpemVcIicpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgfVxuXG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVMZW5ndGgoc3RyaW5nLCBlbmNvZGluZykgfCAwXG4gIGxldCBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuXG4gIGNvbnN0IGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIGNvbnN0IGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5VmlldyAoYXJyYXlWaWV3KSB7XG4gIGlmIChpc0luc3RhbmNlKGFycmF5VmlldywgVWludDhBcnJheSkpIHtcbiAgICBjb25zdCBjb3B5ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlWaWV3KVxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIoY29weS5idWZmZXIsIGNvcHkuYnl0ZU9mZnNldCwgY29weS5ieXRlTGVuZ3RoKVxuICB9XG4gIHJldHVybiBmcm9tQXJyYXlMaWtlKGFycmF5Vmlldylcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5QnVmZmVyIChhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKSB7XG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQgKyAobGVuZ3RoIHx8IDApKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGxldCBidWZcbiAgaWYgKGJ5dGVPZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQpXG4gIH0gZWxzZSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aClcbiAgfVxuXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZihidWYsIEJ1ZmZlci5wcm90b3R5cGUpXG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgY29uc3QgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICBjb25zdCBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxuXG4gICAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBidWZcbiAgICB9XG5cbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcbiAgICByZXR1cm4gYnVmXG4gIH1cblxuICBpZiAob2JqLmxlbmd0aCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgIH1cbiAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gIH1cblxuICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tlZCAobGVuZ3RoKSB7XG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxuICAvLyBsZW5ndGggaXMgTmFOICh3aGljaCBpcyBvdGhlcndpc2UgY29lcmNlZCB0byB6ZXJvLilcbiAgaWYgKGxlbmd0aCA+PSBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTogMHgnICsgS19NQVhfTEVOR1RILnRvU3RyaW5nKDE2KSArICcgYnl0ZXMnKVxuICB9XG4gIHJldHVybiBsZW5ndGggfCAwXG59XG5cbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xuICBpZiAoK2xlbmd0aCAhPSBsZW5ndGgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBlcWVxZXFcbiAgICBsZW5ndGggPSAwXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlci5hbGxvYygrbGVuZ3RoKVxufVxuXG5CdWZmZXIuaXNCdWZmZXIgPSBmdW5jdGlvbiBpc0J1ZmZlciAoYikge1xuICByZXR1cm4gYiAhPSBudWxsICYmIGIuX2lzQnVmZmVyID09PSB0cnVlICYmXG4gICAgYiAhPT0gQnVmZmVyLnByb3RvdHlwZSAvLyBzbyBCdWZmZXIuaXNCdWZmZXIoQnVmZmVyLnByb3RvdHlwZSkgd2lsbCBiZSBmYWxzZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKGlzSW5zdGFuY2UoYSwgVWludDhBcnJheSkpIGEgPSBCdWZmZXIuZnJvbShhLCBhLm9mZnNldCwgYS5ieXRlTGVuZ3RoKVxuICBpZiAoaXNJbnN0YW5jZShiLCBVaW50OEFycmF5KSkgYiA9IEJ1ZmZlci5mcm9tKGIsIGIub2Zmc2V0LCBiLmJ5dGVMZW5ndGgpXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcImJ1ZjFcIiwgXCJidWYyXCIgYXJndW1lbnRzIG11c3QgYmUgb25lIG9mIHR5cGUgQnVmZmVyIG9yIFVpbnQ4QXJyYXknXG4gICAgKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgbGV0IHggPSBhLmxlbmd0aFxuICBsZXQgeSA9IGIubGVuZ3RoXG5cbiAgZm9yIChsZXQgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICBsZXQgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGJ1ZmZlciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShsZW5ndGgpXG4gIGxldCBwb3MgPSAwXG4gIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgbGV0IGJ1ZiA9IGxpc3RbaV1cbiAgICBpZiAoaXNJbnN0YW5jZShidWYsIFVpbnQ4QXJyYXkpKSB7XG4gICAgICBpZiAocG9zICsgYnVmLmxlbmd0aCA+IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgYnVmID0gQnVmZmVyLmZyb20oYnVmKVxuICAgICAgICBidWYuY29weShidWZmZXIsIHBvcylcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIFVpbnQ4QXJyYXkucHJvdG90eXBlLnNldC5jYWxsKFxuICAgICAgICAgIGJ1ZmZlcixcbiAgICAgICAgICBidWYsXG4gICAgICAgICAgcG9zXG4gICAgICAgIClcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgfVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhzdHJpbmcpIHx8IGlzSW5zdGFuY2Uoc3RyaW5nLCBBcnJheUJ1ZmZlcikpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnICtcbiAgICAgICdSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2Ygc3RyaW5nXG4gICAgKVxuICB9XG5cbiAgY29uc3QgbGVuID0gc3RyaW5nLmxlbmd0aFxuICBjb25zdCBtdXN0TWF0Y2ggPSAoYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdID09PSB0cnVlKVxuICBpZiAoIW11c3RNYXRjaCAmJiBsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIGxldCBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIGxlbiAqIDJcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHtcbiAgICAgICAgICByZXR1cm4gbXVzdE1hdGNoID8gLTEgOiB1dGY4VG9CeXRlcyhzdHJpbmcpLmxlbmd0aCAvLyBhc3N1bWUgdXRmOFxuICAgICAgICB9XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICBsZXQgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcmNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICBjb25zdCBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAxNi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMSlcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIGNvbnN0IGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICBjb25zdCBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuZ3RoID09PSAwKSByZXR1cm4gJydcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHJldHVybiB1dGY4U2xpY2UodGhpcywgMCwgbGVuZ3RoKVxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZyA9IEJ1ZmZlci5wcm90b3R5cGUudG9TdHJpbmdcblxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICBpZiAodGhpcyA9PT0gYikgcmV0dXJuIHRydWVcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICBsZXQgc3RyID0gJydcbiAgY29uc3QgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLnJlcGxhY2UoLyguezJ9KS9nLCAnJDEgJykudHJpbSgpXG4gIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cbmlmIChjdXN0b21JbnNwZWN0U3ltYm9sKSB7XG4gIEJ1ZmZlci5wcm90b3R5cGVbY3VzdG9tSW5zcGVjdFN5bWJvbF0gPSBCdWZmZXIucHJvdG90eXBlLmluc3BlY3Rcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKGlzSW5zdGFuY2UodGFyZ2V0LCBVaW50OEFycmF5KSkge1xuICAgIHRhcmdldCA9IEJ1ZmZlci5mcm9tKHRhcmdldCwgdGFyZ2V0Lm9mZnNldCwgdGFyZ2V0LmJ5dGVMZW5ndGgpXG4gIH1cbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAnVGhlIFwidGFyZ2V0XCIgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheS4gJyArXG4gICAgICAnUmVjZWl2ZWQgdHlwZSAnICsgKHR5cGVvZiB0YXJnZXQpXG4gICAgKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgbGV0IHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIGxldCB5ID0gZW5kIC0gc3RhcnRcbiAgY29uc3QgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICBjb25zdCB0aGlzQ29weSA9IHRoaXMuc2xpY2UodGhpc1N0YXJ0LCB0aGlzRW5kKVxuICBjb25zdCB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbdmFsXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgbGV0IGluZGV4U2l6ZSA9IDFcbiAgbGV0IGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgbGV0IHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgbGV0IGlcbiAgaWYgKGRpcikge1xuICAgIGxldCBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIGxldCBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgY29uc3QgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgY29uc3Qgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGxldCBpXG4gIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IHBhcnNlZCA9IHBhcnNlSW50KHN0cmluZy5zdWJzdHIoaSAqIDIsIDIpLCAxNilcbiAgICBpZiAobnVtYmVySXNOYU4ocGFyc2VkKSkgcmV0dXJuIGlcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcbiAgfVxuICByZXR1cm4gaVxufVxuXG5mdW5jdGlvbiB1dGY4V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYXNjaWlUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIGNvbnN0IHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgbGV0IGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICBjb25zdCByZXMgPSBbXVxuXG4gIGxldCBpID0gc3RhcnRcbiAgd2hpbGUgKGkgPCBlbmQpIHtcbiAgICBjb25zdCBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICBsZXQgY29kZVBvaW50ID0gbnVsbFxuICAgIGxldCBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpXG4gICAgICA/IDRcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpXG4gICAgICAgICAgPyAzXG4gICAgICAgICAgOiAoZmlyc3RCeXRlID4gMHhCRilcbiAgICAgICAgICAgICAgPyAyXG4gICAgICAgICAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgbGV0IHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxuY29uc3QgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIGNvbnN0IGxlbiA9IGNvZGVQb2ludHMubGVuZ3RoXG4gIGlmIChsZW4gPD0gTUFYX0FSR1VNRU5UU19MRU5HVEgpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcbiAgfVxuXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXCJjYWxsIHN0YWNrIHNpemUgZXhjZWVkZWRcIi5cbiAgbGV0IHJlcyA9ICcnXG4gIGxldCBpID0gMFxuICB3aGlsZSAoaSA8IGxlbikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFxuICAgICAgU3RyaW5nLFxuICAgICAgY29kZVBvaW50cy5zbGljZShpLCBpICs9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKVxuICAgIClcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGFzY2lpU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBsZXQgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGxhdGluMVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgbGV0IHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gcmV0XG59XG5cbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgY29uc3QgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIGxldCBvdXQgPSAnJ1xuICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSBoZXhTbGljZUxvb2t1cFRhYmxlW2J1ZltpXV1cbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGNvbnN0IGJ5dGVzID0gYnVmLnNsaWNlKHN0YXJ0LCBlbmQpXG4gIGxldCByZXMgPSAnJ1xuICAvLyBJZiBieXRlcy5sZW5ndGggaXMgb2RkLCB0aGUgbGFzdCA4IGJpdHMgbXVzdCBiZSBpZ25vcmVkIChzYW1lIGFzIG5vZGUuanMpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoIC0gMTsgaSArPSAyKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnl0ZXNbaV0gKyAoYnl0ZXNbaSArIDFdICogMjU2KSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc2xpY2UgPSBmdW5jdGlvbiBzbGljZSAoc3RhcnQsIGVuZCkge1xuICBjb25zdCBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIGNvbnN0IG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgT2JqZWN0LnNldFByb3RvdHlwZU9mKG5ld0J1ZiwgQnVmZmVyLnByb3RvdHlwZSlcblxuICByZXR1cm4gbmV3QnVmXG59XG5cbi8qXG4gKiBOZWVkIHRvIG1ha2Ugc3VyZSB0aGF0IGJ1ZmZlciBpc24ndCB0cnlpbmcgdG8gd3JpdGUgb3V0IG9mIGJvdW5kcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tPZmZzZXQgKG9mZnNldCwgZXh0LCBsZW5ndGgpIHtcbiAgaWYgKChvZmZzZXQgJSAxKSAhPT0gMCB8fCBvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb2Zmc2V0IGlzIG5vdCB1aW50JylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50TEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXRdXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnRCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIGxldCB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgbGV0IG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50OCA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MTZMRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVWludDMyTEUgPVxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVaW50MzJCRSA9XG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdVSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnVUludDY0TEUgKG9mZnNldCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgY29uc3QgZmlyc3QgPSB0aGlzW29mZnNldF1cbiAgY29uc3QgbGFzdCA9IHRoaXNbb2Zmc2V0ICsgN11cbiAgaWYgKGZpcnN0ID09PSB1bmRlZmluZWQgfHwgbGFzdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYm91bmRzRXJyb3Iob2Zmc2V0LCB0aGlzLmxlbmd0aCAtIDgpXG4gIH1cblxuICBjb25zdCBsbyA9IGZpcnN0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMjRcblxuICBjb25zdCBoaSA9IHRoaXNbKytvZmZzZXRdICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICBsYXN0ICogMiAqKiAyNFxuXG4gIHJldHVybiBCaWdJbnQobG8pICsgKEJpZ0ludChoaSkgPDwgQmlnSW50KDMyKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEJpZ1VJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdVSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IGhpID0gZmlyc3QgKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICB0aGlzWysrb2Zmc2V0XVxuXG4gIGNvbnN0IGxvID0gdGhpc1srK29mZnNldF0gKiAyICoqIDI0ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogMTYgK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiA4ICtcbiAgICBsYXN0XG5cbiAgcmV0dXJuIChCaWdJbnQoaGkpIDw8IEJpZ0ludCgzMikpICsgQmlnSW50KGxvKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgbGV0IHZhbCA9IHRoaXNbb2Zmc2V0XVxuICBsZXQgbXVsID0gMVxuICBsZXQgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIGxldCBpID0gYnl0ZUxlbmd0aFxuICBsZXQgbXVsID0gMVxuICBsZXQgdmFsID0gdGhpc1tvZmZzZXQgKyAtLWldXG4gIHdoaWxlIChpID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcbiAgcmV0dXJuICgoMHhmZiAtIHRoaXNbb2Zmc2V0XSArIDEpICogLTEpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEUgPSBmdW5jdGlvbiByZWFkSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIGNvbnN0IHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRCaWdJbnQ2NExFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHJlYWRCaWdJbnQ2NExFIChvZmZzZXQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIHZhbGlkYXRlTnVtYmVyKG9mZnNldCwgJ29mZnNldCcpXG4gIGNvbnN0IGZpcnN0ID0gdGhpc1tvZmZzZXRdXG4gIGNvbnN0IGxhc3QgPSB0aGlzW29mZnNldCArIDddXG4gIGlmIChmaXJzdCA9PT0gdW5kZWZpbmVkIHx8IGxhc3QgPT09IHVuZGVmaW5lZCkge1xuICAgIGJvdW5kc0Vycm9yKG9mZnNldCwgdGhpcy5sZW5ndGggLSA4KVxuICB9XG5cbiAgY29uc3QgdmFsID0gdGhpc1tvZmZzZXQgKyA0XSArXG4gICAgdGhpc1tvZmZzZXQgKyA1XSAqIDIgKiogOCArXG4gICAgdGhpc1tvZmZzZXQgKyA2XSAqIDIgKiogMTYgK1xuICAgIChsYXN0IDw8IDI0KSAvLyBPdmVyZmxvd1xuXG4gIHJldHVybiAoQmlnSW50KHZhbCkgPDwgQmlnSW50KDMyKSkgK1xuICAgIEJpZ0ludChmaXJzdCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDI0KVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkQmlnSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiByZWFkQmlnSW50NjRCRSAob2Zmc2V0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICB2YWxpZGF0ZU51bWJlcihvZmZzZXQsICdvZmZzZXQnKVxuICBjb25zdCBmaXJzdCA9IHRoaXNbb2Zmc2V0XVxuICBjb25zdCBsYXN0ID0gdGhpc1tvZmZzZXQgKyA3XVxuICBpZiAoZmlyc3QgPT09IHVuZGVmaW5lZCB8fCBsYXN0ID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIHRoaXMubGVuZ3RoIC0gOClcbiAgfVxuXG4gIGNvbnN0IHZhbCA9IChmaXJzdCA8PCAyNCkgKyAvLyBPdmVyZmxvd1xuICAgIHRoaXNbKytvZmZzZXRdICogMiAqKiAxNiArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDggK1xuICAgIHRoaXNbKytvZmZzZXRdXG5cbiAgcmV0dXJuIChCaWdJbnQodmFsKSA8PCBCaWdJbnQoMzIpKSArXG4gICAgQmlnSW50KHRoaXNbKytvZmZzZXRdICogMiAqKiAyNCArXG4gICAgdGhpc1srK29mZnNldF0gKiAyICoqIDE2ICtcbiAgICB0aGlzWysrb2Zmc2V0XSAqIDIgKiogOCArXG4gICAgbGFzdClcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0TEUgPSBmdW5jdGlvbiByZWFkRmxvYXRMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdEJFID0gZnVuY3Rpb24gcmVhZEZsb2F0QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFID0gZnVuY3Rpb24gcmVhZERvdWJsZUxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgNTIsIDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUJFID0gZnVuY3Rpb24gcmVhZERvdWJsZUJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDgsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDUyLCA4KVxufVxuXG5mdW5jdGlvbiBjaGVja0ludCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpXG4gIGlmICh2YWx1ZSA+IG1heCB8fCB2YWx1ZSA8IG1pbikgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludExFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIGxldCBtdWwgPSAxXG4gIGxldCBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50QkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlVUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNvbnN0IG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgbGV0IGkgPSBieXRlTGVuZ3RoIC0gMVxuICBsZXQgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQ4ID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDE2TEUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVpbnQxNkJFID1cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVaW50MzJMRSA9XG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZVVJbnQzMkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHhmZmZmZmZmZiwgMClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVWludDMyQkUgPVxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuZnVuY3Rpb24gd3J0QmlnVUludDY0TEUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbWluLCBtYXgpIHtcbiAgY2hlY2tJbnRCSSh2YWx1ZSwgbWluLCBtYXgsIGJ1Ziwgb2Zmc2V0LCA3KVxuXG4gIGxldCBsbyA9IE51bWJlcih2YWx1ZSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0KytdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGxvXG4gIGxldCBoaSA9IE51bWJlcih2YWx1ZSA+PiBCaWdJbnQoMzIpICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQrK10gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldCsrXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0KytdID0gaGlcbiAgcmV0dXJuIG9mZnNldFxufVxuXG5mdW5jdGlvbiB3cnRCaWdVSW50NjRCRSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBtaW4sIG1heCkge1xuICBjaGVja0ludEJJKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIDcpXG5cbiAgbGV0IGxvID0gTnVtYmVyKHZhbHVlICYgQmlnSW50KDB4ZmZmZmZmZmYpKVxuICBidWZbb2Zmc2V0ICsgN10gPSBsb1xuICBsbyA9IGxvID4+IDhcbiAgYnVmW29mZnNldCArIDZdID0gbG9cbiAgbG8gPSBsbyA+PiA4XG4gIGJ1ZltvZmZzZXQgKyA1XSA9IGxvXG4gIGxvID0gbG8gPj4gOFxuICBidWZbb2Zmc2V0ICsgNF0gPSBsb1xuICBsZXQgaGkgPSBOdW1iZXIodmFsdWUgPj4gQmlnSW50KDMyKSAmIEJpZ0ludCgweGZmZmZmZmZmKSlcbiAgYnVmW29mZnNldCArIDNdID0gaGlcbiAgaGkgPSBoaSA+PiA4XG4gIGJ1ZltvZmZzZXQgKyAyXSA9IGhpXG4gIGhpID0gaGkgPj4gOFxuICBidWZbb2Zmc2V0ICsgMV0gPSBoaVxuICBoaSA9IGhpID4+IDhcbiAgYnVmW29mZnNldF0gPSBoaVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnVUludDY0TEUgPSBkZWZpbmVCaWdJbnRNZXRob2QoZnVuY3Rpb24gd3JpdGVCaWdVSW50NjRMRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NExFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIEJpZ0ludCgwKSwgQmlnSW50KCcweGZmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdVSW50NjRCRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ1VJbnQ2NEJFICh2YWx1ZSwgb2Zmc2V0ID0gMCkge1xuICByZXR1cm4gd3J0QmlnVUludDY0QkUodGhpcywgdmFsdWUsIG9mZnNldCwgQmlnSW50KDApLCBCaWdJbnQoJzB4ZmZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IDBcbiAgbGV0IG11bCA9IDFcbiAgbGV0IHN1YiA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpIC0gMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludEJFID0gZnVuY3Rpb24gd3JpdGVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjb25zdCBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICBsZXQgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIGxldCBtdWwgPSAxXG4gIGxldCBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlQmlnSW50NjRMRSA9IGRlZmluZUJpZ0ludE1ldGhvZChmdW5jdGlvbiB3cml0ZUJpZ0ludDY0TEUgKHZhbHVlLCBvZmZzZXQgPSAwKSB7XG4gIHJldHVybiB3cnRCaWdVSW50NjRMRSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAtQmlnSW50KCcweDgwMDAwMDAwMDAwMDAwMDAnKSwgQmlnSW50KCcweDdmZmZmZmZmZmZmZmZmZmYnKSlcbn0pXG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVCaWdJbnQ2NEJFID0gZGVmaW5lQmlnSW50TWV0aG9kKGZ1bmN0aW9uIHdyaXRlQmlnSW50NjRCRSAodmFsdWUsIG9mZnNldCA9IDApIHtcbiAgcmV0dXJuIHdydEJpZ1VJbnQ2NEJFKHRoaXMsIHZhbHVlLCBvZmZzZXQsIC1CaWdJbnQoJzB4ODAwMDAwMDAwMDAwMDAwMCcpLCBCaWdJbnQoJzB4N2ZmZmZmZmZmZmZmZmZmZicpKVxufSlcblxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKG9mZnNldCArIGV4dCA+IGJ1Zi5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxuICBpZiAob2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDIzLCA0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdEJFID0gZnVuY3Rpb24gd3JpdGVGbG9hdEJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbmZ1bmN0aW9uIHdyaXRlRG91YmxlIChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxuICB9XG4gIGllZWU3NTQud3JpdGUoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIDUyLCA4KVxuICByZXR1cm4gb2Zmc2V0ICsgOFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgdHJ1ZSwgbm9Bc3NlcnQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVCRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBmYWxzZSwgbm9Bc3NlcnQpXG59XG5cbi8vIGNvcHkodGFyZ2V0QnVmZmVyLCB0YXJnZXRTdGFydD0wLCBzb3VyY2VTdGFydD0wLCBzb3VyY2VFbmQ9YnVmZmVyLmxlbmd0aClcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkgdGhyb3cgbmV3IFR5cGVFcnJvcignYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyJylcbiAgaWYgKCFzdGFydCkgc3RhcnQgPSAwXG4gIGlmICghZW5kICYmIGVuZCAhPT0gMCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxuICBpZiAoIXRhcmdldFN0YXJ0KSB0YXJnZXRTdGFydCA9IDBcbiAgaWYgKGVuZCA+IDAgJiYgZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgLy8gQ29weSAwIGJ5dGVzOyB3ZSdyZSBkb25lXG4gIGlmIChlbmQgPT09IHN0YXJ0KSByZXR1cm4gMFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBGYXRhbCBlcnJvciBjb25kaXRpb25zXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcigndGFyZ2V0U3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIH1cbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIGNvbnN0IGxlbiA9IGVuZCAtIHN0YXJ0XG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiB0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuY29weVdpdGhpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIC8vIFVzZSBidWlsdC1pbiB3aGVuIGF2YWlsYWJsZSwgbWlzc2luZyBmcm9tIElFMTFcbiAgICB0aGlzLmNvcHlXaXRoaW4odGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpXG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpLFxuICAgICAgdGFyZ2V0U3RhcnRcbiAgICApXG4gIH1cblxuICByZXR1cm4gbGVuXG59XG5cbi8vIFVzYWdlOlxuLy8gICAgYnVmZmVyLmZpbGwobnVtYmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChidWZmZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxuQnVmZmVyLnByb3RvdHlwZS5maWxsID0gZnVuY3Rpb24gZmlsbCAodmFsLCBzdGFydCwgZW5kLCBlbmNvZGluZykge1xuICAvLyBIYW5kbGUgc3RyaW5nIGNhc2VzOlxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICBpZiAodHlwZW9mIHN0YXJ0ID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBzdGFydFxuICAgICAgc3RhcnQgPSAwXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVuZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5kXG4gICAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdlbmNvZGluZyBtdXN0IGJlIGEgc3RyaW5nJylcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgIH1cbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoKGVuY29kaW5nID09PSAndXRmOCcgJiYgY29kZSA8IDEyOCkgfHxcbiAgICAgICAgICBlbmNvZGluZyA9PT0gJ2xhdGluMScpIHtcbiAgICAgICAgLy8gRmFzdCBwYXRoOiBJZiBgdmFsYCBmaXRzIGludG8gYSBzaW5nbGUgYnl0ZSwgdXNlIHRoYXQgbnVtZXJpYyB2YWx1ZS5cbiAgICAgICAgdmFsID0gY29kZVxuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDI1NVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgIHZhbCA9IE51bWJlcih2YWwpXG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgbGV0IGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICAgIGNvbnN0IGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGlmIChsZW4gPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicgKyB2YWwgK1xuICAgICAgICAnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJylcbiAgICB9XG4gICAgZm9yIChpID0gMDsgaSA8IGVuZCAtIHN0YXJ0OyArK2kpIHtcbiAgICAgIHRoaXNbaSArIHN0YXJ0XSA9IGJ5dGVzW2kgJSBsZW5dXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRoaXNcbn1cblxuLy8gQ1VTVE9NIEVSUk9SU1xuLy8gPT09PT09PT09PT09PVxuXG4vLyBTaW1wbGlmaWVkIHZlcnNpb25zIGZyb20gTm9kZSwgY2hhbmdlZCBmb3IgQnVmZmVyLW9ubHkgdXNhZ2VcbmNvbnN0IGVycm9ycyA9IHt9XG5mdW5jdGlvbiBFIChzeW0sIGdldE1lc3NhZ2UsIEJhc2UpIHtcbiAgZXJyb3JzW3N5bV0gPSBjbGFzcyBOb2RlRXJyb3IgZXh0ZW5kcyBCYXNlIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICBzdXBlcigpXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbWVzc2FnZScsIHtcbiAgICAgICAgdmFsdWU6IGdldE1lc3NhZ2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfSlcblxuICAgICAgLy8gQWRkIHRoZSBlcnJvciBjb2RlIHRvIHRoZSBuYW1lIHRvIGluY2x1ZGUgaXQgaW4gdGhlIHN0YWNrIHRyYWNlLlxuICAgICAgdGhpcy5uYW1lID0gYCR7dGhpcy5uYW1lfSBbJHtzeW19XWBcbiAgICAgIC8vIEFjY2VzcyB0aGUgc3RhY2sgdG8gZ2VuZXJhdGUgdGhlIGVycm9yIG1lc3NhZ2UgaW5jbHVkaW5nIHRoZSBlcnJvciBjb2RlXG4gICAgICAvLyBmcm9tIHRoZSBuYW1lLlxuICAgICAgdGhpcy5zdGFjayAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuICAgICAgLy8gUmVzZXQgdGhlIG5hbWUgdG8gdGhlIGFjdHVhbCBuYW1lLlxuICAgICAgZGVsZXRlIHRoaXMubmFtZVxuICAgIH1cblxuICAgIGdldCBjb2RlICgpIHtcbiAgICAgIHJldHVybiBzeW1cbiAgICB9XG5cbiAgICBzZXQgY29kZSAodmFsdWUpIHtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnY29kZScsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH0pXG4gICAgfVxuXG4gICAgdG9TdHJpbmcgKCkge1xuICAgICAgcmV0dXJuIGAke3RoaXMubmFtZX0gWyR7c3ltfV06ICR7dGhpcy5tZXNzYWdlfWBcbiAgICB9XG4gIH1cbn1cblxuRSgnRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTJyxcbiAgZnVuY3Rpb24gKG5hbWUpIHtcbiAgICBpZiAobmFtZSkge1xuICAgICAgcmV0dXJuIGAke25hbWV9IGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kc2BcbiAgICB9XG5cbiAgICByZXR1cm4gJ0F0dGVtcHQgdG8gYWNjZXNzIG1lbW9yeSBvdXRzaWRlIGJ1ZmZlciBib3VuZHMnXG4gIH0sIFJhbmdlRXJyb3IpXG5FKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsXG4gIGZ1bmN0aW9uIChuYW1lLCBhY3R1YWwpIHtcbiAgICByZXR1cm4gYFRoZSBcIiR7bmFtZX1cIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgbnVtYmVyLiBSZWNlaXZlZCB0eXBlICR7dHlwZW9mIGFjdHVhbH1gXG4gIH0sIFR5cGVFcnJvcilcbkUoJ0VSUl9PVVRfT0ZfUkFOR0UnLFxuICBmdW5jdGlvbiAoc3RyLCByYW5nZSwgaW5wdXQpIHtcbiAgICBsZXQgbXNnID0gYFRoZSB2YWx1ZSBvZiBcIiR7c3RyfVwiIGlzIG91dCBvZiByYW5nZS5gXG4gICAgbGV0IHJlY2VpdmVkID0gaW5wdXRcbiAgICBpZiAoTnVtYmVyLmlzSW50ZWdlcihpbnB1dCkgJiYgTWF0aC5hYnMoaW5wdXQpID4gMiAqKiAzMikge1xuICAgICAgcmVjZWl2ZWQgPSBhZGROdW1lcmljYWxTZXBhcmF0b3IoU3RyaW5nKGlucHV0KSlcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBpbnB1dCA9PT0gJ2JpZ2ludCcpIHtcbiAgICAgIHJlY2VpdmVkID0gU3RyaW5nKGlucHV0KVxuICAgICAgaWYgKGlucHV0ID4gQmlnSW50KDIpICoqIEJpZ0ludCgzMikgfHwgaW5wdXQgPCAtKEJpZ0ludCgyKSAqKiBCaWdJbnQoMzIpKSkge1xuICAgICAgICByZWNlaXZlZCA9IGFkZE51bWVyaWNhbFNlcGFyYXRvcihyZWNlaXZlZClcbiAgICAgIH1cbiAgICAgIHJlY2VpdmVkICs9ICduJ1xuICAgIH1cbiAgICBtc2cgKz0gYCBJdCBtdXN0IGJlICR7cmFuZ2V9LiBSZWNlaXZlZCAke3JlY2VpdmVkfWBcbiAgICByZXR1cm4gbXNnXG4gIH0sIFJhbmdlRXJyb3IpXG5cbmZ1bmN0aW9uIGFkZE51bWVyaWNhbFNlcGFyYXRvciAodmFsKSB7XG4gIGxldCByZXMgPSAnJ1xuICBsZXQgaSA9IHZhbC5sZW5ndGhcbiAgY29uc3Qgc3RhcnQgPSB2YWxbMF0gPT09ICctJyA/IDEgOiAwXG4gIGZvciAoOyBpID49IHN0YXJ0ICsgNDsgaSAtPSAzKSB7XG4gICAgcmVzID0gYF8ke3ZhbC5zbGljZShpIC0gMywgaSl9JHtyZXN9YFxuICB9XG4gIHJldHVybiBgJHt2YWwuc2xpY2UoMCwgaSl9JHtyZXN9YFxufVxuXG4vLyBDSEVDSyBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PVxuXG5mdW5jdGlvbiBjaGVja0JvdW5kcyAoYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgdmFsaWRhdGVOdW1iZXIob2Zmc2V0LCAnb2Zmc2V0JylcbiAgaWYgKGJ1ZltvZmZzZXRdID09PSB1bmRlZmluZWQgfHwgYnVmW29mZnNldCArIGJ5dGVMZW5ndGhdID09PSB1bmRlZmluZWQpIHtcbiAgICBib3VuZHNFcnJvcihvZmZzZXQsIGJ1Zi5sZW5ndGggLSAoYnl0ZUxlbmd0aCArIDEpKVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50QkkgKHZhbHVlLCBtaW4sIG1heCwgYnVmLCBvZmZzZXQsIGJ5dGVMZW5ndGgpIHtcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB7XG4gICAgY29uc3QgbiA9IHR5cGVvZiBtaW4gPT09ICdiaWdpbnQnID8gJ24nIDogJydcbiAgICBsZXQgcmFuZ2VcbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDMpIHtcbiAgICAgIGlmIChtaW4gPT09IDAgfHwgbWluID09PSBCaWdJbnQoMCkpIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gMCR7bn0gYW5kIDwgMiR7bn0gKiogJHsoYnl0ZUxlbmd0aCArIDEpICogOH0ke259YFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmFuZ2UgPSBgPj0gLSgyJHtufSAqKiAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259KSBhbmQgPCAyICoqIGAgK1xuICAgICAgICAgICAgICAgIGAkeyhieXRlTGVuZ3RoICsgMSkgKiA4IC0gMX0ke259YFxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByYW5nZSA9IGA+PSAke21pbn0ke259IGFuZCA8PSAke21heH0ke259YFxuICAgIH1cbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9PVVRfT0ZfUkFOR0UoJ3ZhbHVlJywgcmFuZ2UsIHZhbHVlKVxuICB9XG4gIGNoZWNrQm91bmRzKGJ1Ziwgb2Zmc2V0LCBieXRlTGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU51bWJlciAodmFsdWUsIG5hbWUpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgZXJyb3JzLkVSUl9JTlZBTElEX0FSR19UWVBFKG5hbWUsICdudW1iZXInLCB2YWx1ZSlcbiAgfVxufVxuXG5mdW5jdGlvbiBib3VuZHNFcnJvciAodmFsdWUsIGxlbmd0aCwgdHlwZSkge1xuICBpZiAoTWF0aC5mbG9vcih2YWx1ZSkgIT09IHZhbHVlKSB7XG4gICAgdmFsaWRhdGVOdW1iZXIodmFsdWUsIHR5cGUpXG4gICAgdGhyb3cgbmV3IGVycm9ycy5FUlJfT1VUX09GX1JBTkdFKHR5cGUgfHwgJ29mZnNldCcsICdhbiBpbnRlZ2VyJywgdmFsdWUpXG4gIH1cblxuICBpZiAobGVuZ3RoIDwgMCkge1xuICAgIHRocm93IG5ldyBlcnJvcnMuRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTKClcbiAgfVxuXG4gIHRocm93IG5ldyBlcnJvcnMuRVJSX09VVF9PRl9SQU5HRSh0eXBlIHx8ICdvZmZzZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYD49ICR7dHlwZSA/IDEgOiAwfSBhbmQgPD0gJHtsZW5ndGh9YCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlKVxufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbmNvbnN0IElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgdGFrZXMgZXF1YWwgc2lnbnMgYXMgZW5kIG9mIHRoZSBCYXNlNjQgZW5jb2RpbmdcbiAgc3RyID0gc3RyLnNwbGl0KCc9JylbMF1cbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcbiBhbmQgXFx0IGZyb20gdGhlIHN0cmluZywgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHN0ciA9IHN0ci50cmltKCkucmVwbGFjZShJTlZBTElEX0JBU0U2NF9SRSwgJycpXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcbiAgaWYgKHN0ci5sZW5ndGggPCAyKSByZXR1cm4gJydcbiAgLy8gTm9kZSBhbGxvd3MgZm9yIG5vbi1wYWRkZWQgYmFzZTY0IHN0cmluZ3MgKG1pc3NpbmcgdHJhaWxpbmcgPT09KSwgYmFzZTY0LWpzIGRvZXMgbm90XG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xuICAgIHN0ciA9IHN0ciArICc9J1xuICB9XG4gIHJldHVybiBzdHJcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICBsZXQgY29kZVBvaW50XG4gIGNvbnN0IGxlbmd0aCA9IHN0cmluZy5sZW5ndGhcbiAgbGV0IGxlYWRTdXJyb2dhdGUgPSBudWxsXG4gIGNvbnN0IGJ5dGVzID0gW11cblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgY29uc3QgYnl0ZUFycmF5ID0gW11cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICBsZXQgYywgaGksIGxvXG4gIGNvbnN0IGJ5dGVBcnJheSA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG5cbiAgICBjID0gc3RyLmNoYXJDb2RlQXQoaSlcbiAgICBoaSA9IGMgPj4gOFxuICAgIGxvID0gYyAlIDI1NlxuICAgIGJ5dGVBcnJheS5wdXNoKGxvKVxuICAgIGJ5dGVBcnJheS5wdXNoKGhpKVxuICB9XG5cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiBiYXNlNjRUb0J5dGVzIChzdHIpIHtcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxufVxuXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgbGV0IGlcbiAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVyIG9yIFVpbnQ4QXJyYXkgb2JqZWN0cyBmcm9tIG90aGVyIGNvbnRleHRzIChpLmUuIGlmcmFtZXMpIGRvIG5vdCBwYXNzXG4vLyB0aGUgYGluc3RhbmNlb2ZgIGNoZWNrIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIG9mIHRoYXQgdHlwZS5cbi8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNJbnN0YW5jZSAob2JqLCB0eXBlKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiB0eXBlIHx8XG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lICE9IG51bGwgJiZcbiAgICAgIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSB0eXBlLm5hbWUpXG59XG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XG4gIC8vIEZvciBJRTExIHN1cHBvcnRcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG5cbi8vIENyZWF0ZSBsb29rdXAgdGFibGUgZm9yIGB0b1N0cmluZygnaGV4JylgXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8yMTlcbmNvbnN0IGhleFNsaWNlTG9va3VwVGFibGUgPSAoZnVuY3Rpb24gKCkge1xuICBjb25zdCBhbHBoYWJldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJ1xuICBjb25zdCB0YWJsZSA9IG5ldyBBcnJheSgyNTYpXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgIGNvbnN0IGkxNiA9IGkgKiAxNlxuICAgIGZvciAobGV0IGogPSAwOyBqIDwgMTY7ICsraikge1xuICAgICAgdGFibGVbaTE2ICsgal0gPSBhbHBoYWJldFtpXSArIGFscGhhYmV0W2pdXG4gICAgfVxuICB9XG4gIHJldHVybiB0YWJsZVxufSkoKVxuXG4vLyBSZXR1cm4gbm90IGZ1bmN0aW9uIHdpdGggRXJyb3IgaWYgQmlnSW50IG5vdCBzdXBwb3J0ZWRcbmZ1bmN0aW9uIGRlZmluZUJpZ0ludE1ldGhvZCAoZm4pIHtcbiAgcmV0dXJuIHR5cGVvZiBCaWdJbnQgPT09ICd1bmRlZmluZWQnID8gQnVmZmVyQmlnSW50Tm90RGVmaW5lZCA6IGZuXG59XG5cbmZ1bmN0aW9uIEJ1ZmZlckJpZ0ludE5vdERlZmluZWQgKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ0JpZ0ludCBub3Qgc3VwcG9ydGVkJylcbn1cbiIsIm1vZHVsZS5leHBvcnRzID0ge1xuICBcIjEwMFwiOiBcIkNvbnRpbnVlXCIsXG4gIFwiMTAxXCI6IFwiU3dpdGNoaW5nIFByb3RvY29sc1wiLFxuICBcIjEwMlwiOiBcIlByb2Nlc3NpbmdcIixcbiAgXCIyMDBcIjogXCJPS1wiLFxuICBcIjIwMVwiOiBcIkNyZWF0ZWRcIixcbiAgXCIyMDJcIjogXCJBY2NlcHRlZFwiLFxuICBcIjIwM1wiOiBcIk5vbi1BdXRob3JpdGF0aXZlIEluZm9ybWF0aW9uXCIsXG4gIFwiMjA0XCI6IFwiTm8gQ29udGVudFwiLFxuICBcIjIwNVwiOiBcIlJlc2V0IENvbnRlbnRcIixcbiAgXCIyMDZcIjogXCJQYXJ0aWFsIENvbnRlbnRcIixcbiAgXCIyMDdcIjogXCJNdWx0aS1TdGF0dXNcIixcbiAgXCIyMDhcIjogXCJBbHJlYWR5IFJlcG9ydGVkXCIsXG4gIFwiMjI2XCI6IFwiSU0gVXNlZFwiLFxuICBcIjMwMFwiOiBcIk11bHRpcGxlIENob2ljZXNcIixcbiAgXCIzMDFcIjogXCJNb3ZlZCBQZXJtYW5lbnRseVwiLFxuICBcIjMwMlwiOiBcIkZvdW5kXCIsXG4gIFwiMzAzXCI6IFwiU2VlIE90aGVyXCIsXG4gIFwiMzA0XCI6IFwiTm90IE1vZGlmaWVkXCIsXG4gIFwiMzA1XCI6IFwiVXNlIFByb3h5XCIsXG4gIFwiMzA3XCI6IFwiVGVtcG9yYXJ5IFJlZGlyZWN0XCIsXG4gIFwiMzA4XCI6IFwiUGVybWFuZW50IFJlZGlyZWN0XCIsXG4gIFwiNDAwXCI6IFwiQmFkIFJlcXVlc3RcIixcbiAgXCI0MDFcIjogXCJVbmF1dGhvcml6ZWRcIixcbiAgXCI0MDJcIjogXCJQYXltZW50IFJlcXVpcmVkXCIsXG4gIFwiNDAzXCI6IFwiRm9yYmlkZGVuXCIsXG4gIFwiNDA0XCI6IFwiTm90IEZvdW5kXCIsXG4gIFwiNDA1XCI6IFwiTWV0aG9kIE5vdCBBbGxvd2VkXCIsXG4gIFwiNDA2XCI6IFwiTm90IEFjY2VwdGFibGVcIixcbiAgXCI0MDdcIjogXCJQcm94eSBBdXRoZW50aWNhdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQwOFwiOiBcIlJlcXVlc3QgVGltZW91dFwiLFxuICBcIjQwOVwiOiBcIkNvbmZsaWN0XCIsXG4gIFwiNDEwXCI6IFwiR29uZVwiLFxuICBcIjQxMVwiOiBcIkxlbmd0aCBSZXF1aXJlZFwiLFxuICBcIjQxMlwiOiBcIlByZWNvbmRpdGlvbiBGYWlsZWRcIixcbiAgXCI0MTNcIjogXCJQYXlsb2FkIFRvbyBMYXJnZVwiLFxuICBcIjQxNFwiOiBcIlVSSSBUb28gTG9uZ1wiLFxuICBcIjQxNVwiOiBcIlVuc3VwcG9ydGVkIE1lZGlhIFR5cGVcIixcbiAgXCI0MTZcIjogXCJSYW5nZSBOb3QgU2F0aXNmaWFibGVcIixcbiAgXCI0MTdcIjogXCJFeHBlY3RhdGlvbiBGYWlsZWRcIixcbiAgXCI0MThcIjogXCJJJ20gYSB0ZWFwb3RcIixcbiAgXCI0MjFcIjogXCJNaXNkaXJlY3RlZCBSZXF1ZXN0XCIsXG4gIFwiNDIyXCI6IFwiVW5wcm9jZXNzYWJsZSBFbnRpdHlcIixcbiAgXCI0MjNcIjogXCJMb2NrZWRcIixcbiAgXCI0MjRcIjogXCJGYWlsZWQgRGVwZW5kZW5jeVwiLFxuICBcIjQyNVwiOiBcIlVub3JkZXJlZCBDb2xsZWN0aW9uXCIsXG4gIFwiNDI2XCI6IFwiVXBncmFkZSBSZXF1aXJlZFwiLFxuICBcIjQyOFwiOiBcIlByZWNvbmRpdGlvbiBSZXF1aXJlZFwiLFxuICBcIjQyOVwiOiBcIlRvbyBNYW55IFJlcXVlc3RzXCIsXG4gIFwiNDMxXCI6IFwiUmVxdWVzdCBIZWFkZXIgRmllbGRzIFRvbyBMYXJnZVwiLFxuICBcIjQ1MVwiOiBcIlVuYXZhaWxhYmxlIEZvciBMZWdhbCBSZWFzb25zXCIsXG4gIFwiNTAwXCI6IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yXCIsXG4gIFwiNTAxXCI6IFwiTm90IEltcGxlbWVudGVkXCIsXG4gIFwiNTAyXCI6IFwiQmFkIEdhdGV3YXlcIixcbiAgXCI1MDNcIjogXCJTZXJ2aWNlIFVuYXZhaWxhYmxlXCIsXG4gIFwiNTA0XCI6IFwiR2F0ZXdheSBUaW1lb3V0XCIsXG4gIFwiNTA1XCI6IFwiSFRUUCBWZXJzaW9uIE5vdCBTdXBwb3J0ZWRcIixcbiAgXCI1MDZcIjogXCJWYXJpYW50IEFsc28gTmVnb3RpYXRlc1wiLFxuICBcIjUwN1wiOiBcIkluc3VmZmljaWVudCBTdG9yYWdlXCIsXG4gIFwiNTA4XCI6IFwiTG9vcCBEZXRlY3RlZFwiLFxuICBcIjUwOVwiOiBcIkJhbmR3aWR0aCBMaW1pdCBFeGNlZWRlZFwiLFxuICBcIjUxMFwiOiBcIk5vdCBFeHRlbmRlZFwiLFxuICBcIjUxMVwiOiBcIk5ldHdvcmsgQXV0aGVudGljYXRpb24gUmVxdWlyZWRcIlxufVxuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFIgPSB0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgPyBSZWZsZWN0IDogbnVsbFxudmFyIFJlZmxlY3RBcHBseSA9IFIgJiYgdHlwZW9mIFIuYXBwbHkgPT09ICdmdW5jdGlvbidcbiAgPyBSLmFwcGx5XG4gIDogZnVuY3Rpb24gUmVmbGVjdEFwcGx5KHRhcmdldCwgcmVjZWl2ZXIsIGFyZ3MpIHtcbiAgICByZXR1cm4gRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwodGFyZ2V0LCByZWNlaXZlciwgYXJncyk7XG4gIH1cblxudmFyIFJlZmxlY3RPd25LZXlzXG5pZiAoUiAmJiB0eXBlb2YgUi5vd25LZXlzID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlZmxlY3RPd25LZXlzID0gUi5vd25LZXlzXG59IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KVxuICAgICAgLmNvbmNhdChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHRhcmdldCkpO1xuICB9O1xufSBlbHNlIHtcbiAgUmVmbGVjdE93bktleXMgPSBmdW5jdGlvbiBSZWZsZWN0T3duS2V5cyh0YXJnZXQpIHtcbiAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGFyZ2V0KTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gUHJvY2Vzc0VtaXRXYXJuaW5nKHdhcm5pbmcpIHtcbiAgaWYgKGNvbnNvbGUgJiYgY29uc29sZS53YXJuKSBjb25zb2xlLndhcm4od2FybmluZyk7XG59XG5cbnZhciBOdW1iZXJJc05hTiA9IE51bWJlci5pc05hTiB8fCBmdW5jdGlvbiBOdW1iZXJJc05hTih2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgIT09IHZhbHVlO1xufVxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIEV2ZW50RW1pdHRlci5pbml0LmNhbGwodGhpcyk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcbm1vZHVsZS5leHBvcnRzLm9uY2UgPSBvbmNlO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50c0NvdW50ID0gMDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxudmFyIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuZnVuY3Rpb24gY2hlY2tMaXN0ZW5lcihsaXN0ZW5lcikge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwibGlzdGVuZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRnVuY3Rpb24uIFJlY2VpdmVkIHR5cGUgJyArIHR5cGVvZiBsaXN0ZW5lcik7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50RW1pdHRlciwgJ2RlZmF1bHRNYXhMaXN0ZW5lcnMnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIGRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24oYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgTnVtYmVySXNOYU4oYXJnKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSB2YWx1ZSBvZiBcImRlZmF1bHRNYXhMaXN0ZW5lcnNcIiBpcyBvdXQgb2YgcmFuZ2UuIEl0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgbnVtYmVyLiBSZWNlaXZlZCAnICsgYXJnICsgJy4nKTtcbiAgICB9XG4gICAgZGVmYXVsdE1heExpc3RlbmVycyA9IGFyZztcbiAgfVxufSk7XG5cbkV2ZW50RW1pdHRlci5pbml0ID0gZnVuY3Rpb24oKSB7XG5cbiAgaWYgKHRoaXMuX2V2ZW50cyA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICB0aGlzLl9ldmVudHMgPT09IE9iamVjdC5nZXRQcm90b3R5cGVPZih0aGlzKS5fZXZlbnRzKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9ldmVudHNDb3VudCA9IDA7XG4gIH1cblxuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSB0aGlzLl9tYXhMaXN0ZW5lcnMgfHwgdW5kZWZpbmVkO1xufTtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBOdW1iZXJJc05hTihuKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgdmFsdWUgb2YgXCJuXCIgaXMgb3V0IG9mIHJhbmdlLiBJdCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlci4gUmVjZWl2ZWQgJyArIG4gKyAnLicpO1xuICB9XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gX2dldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gX2dldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgYXJncyA9IFtdO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgYXJncy5wdXNoKGFyZ3VtZW50c1tpXSk7XG4gIHZhciBkb0Vycm9yID0gKHR5cGUgPT09ICdlcnJvcicpO1xuXG4gIHZhciBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMgIT09IHVuZGVmaW5lZClcbiAgICBkb0Vycm9yID0gKGRvRXJyb3IgJiYgZXZlbnRzLmVycm9yID09PSB1bmRlZmluZWQpO1xuICBlbHNlIGlmICghZG9FcnJvcilcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgLy8gSWYgdGhlcmUgaXMgbm8gJ2Vycm9yJyBldmVudCBsaXN0ZW5lciB0aGVuIHRocm93LlxuICBpZiAoZG9FcnJvcikge1xuICAgIHZhciBlcjtcbiAgICBpZiAoYXJncy5sZW5ndGggPiAwKVxuICAgICAgZXIgPSBhcmdzWzBdO1xuICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAvLyBOb3RlOiBUaGUgY29tbWVudHMgb24gdGhlIGB0aHJvd2AgbGluZXMgYXJlIGludGVudGlvbmFsLCB0aGV5IHNob3dcbiAgICAgIC8vIHVwIGluIE5vZGUncyBvdXRwdXQgaWYgdGhpcyByZXN1bHRzIGluIGFuIHVuaGFuZGxlZCBleGNlcHRpb24uXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkICdlcnJvcicgZXZlbnRcbiAgICB9XG4gICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBlcnJvci4nICsgKGVyID8gJyAoJyArIGVyLm1lc3NhZ2UgKyAnKScgOiAnJykpO1xuICAgIGVyci5jb250ZXh0ID0gZXI7XG4gICAgdGhyb3cgZXJyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICB9XG5cbiAgdmFyIGhhbmRsZXIgPSBldmVudHNbdHlwZV07XG5cbiAgaWYgKGhhbmRsZXIgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKHR5cGVvZiBoYW5kbGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgUmVmbGVjdEFwcGx5KGhhbmRsZXIsIHRoaXMsIGFyZ3MpO1xuICB9IGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBSZWZsZWN0QXBwbHkobGlzdGVuZXJzW2ldLCB0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gX2FkZExpc3RlbmVyKHRhcmdldCwgdHlwZSwgbGlzdGVuZXIsIHByZXBlbmQpIHtcbiAgdmFyIG07XG4gIHZhciBldmVudHM7XG4gIHZhciBleGlzdGluZztcblxuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRhcmdldC5fZXZlbnRzQ291bnQgPSAwO1xuICB9IGVsc2Uge1xuICAgIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFwibmV3TGlzdGVuZXJcIiEgQmVmb3JlXG4gICAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICAgIGlmIChldmVudHMubmV3TGlzdGVuZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyID8gbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgICAgIC8vIFJlLWFzc2lnbiBgZXZlbnRzYCBiZWNhdXNlIGEgbmV3TGlzdGVuZXIgaGFuZGxlciBjb3VsZCBoYXZlIGNhdXNlZCB0aGVcbiAgICAgIC8vIHRoaXMuX2V2ZW50cyB0byBiZSBhc3NpZ25lZCB0byBhIG5ldyBvYmplY3RcbiAgICAgIGV2ZW50cyA9IHRhcmdldC5fZXZlbnRzO1xuICAgIH1cbiAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXTtcbiAgfVxuXG4gIGlmIChleGlzdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgIHByZXBlbmQgPyBbbGlzdGVuZXIsIGV4aXN0aW5nXSA6IFtleGlzdGluZywgbGlzdGVuZXJdO1xuICAgICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIH0gZWxzZSBpZiAocHJlcGVuZCkge1xuICAgICAgZXhpc3RpbmcudW5zaGlmdChsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGV4aXN0aW5nLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciBsaXN0ZW5lciBsZWFrXG4gICAgbSA9IF9nZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICBpZiAobSA+IDAgJiYgZXhpc3RpbmcubGVuZ3RoID4gbSAmJiAhZXhpc3Rpbmcud2FybmVkKSB7XG4gICAgICBleGlzdGluZy53YXJuZWQgPSB0cnVlO1xuICAgICAgLy8gTm8gZXJyb3IgY29kZSBmb3IgdGhpcyBzaW5jZSBpdCBpcyBhIFdhcm5pbmdcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZXN0cmljdGVkLXN5bnRheFxuICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGV4aXN0aW5nLmxlbmd0aCArICcgJyArIFN0cmluZyh0eXBlKSArICcgbGlzdGVuZXJzICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaW5jcmVhc2UgbGltaXQnKTtcbiAgICAgIHcubmFtZSA9ICdNYXhMaXN0ZW5lcnNFeGNlZWRlZFdhcm5pbmcnO1xuICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgdy50eXBlID0gdHlwZTtcbiAgICAgIHcuY291bnQgPSBleGlzdGluZy5sZW5ndGg7XG4gICAgICBQcm9jZXNzRW1pdFdhcm5pbmcodyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0KTtcbiAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJndW1lbnRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfb25jZVdyYXAodGFyZ2V0LCB0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgc3RhdGUgPSB7IGZpcmVkOiBmYWxzZSwgd3JhcEZuOiB1bmRlZmluZWQsIHRhcmdldDogdGFyZ2V0LCB0eXBlOiB0eXBlLCBsaXN0ZW5lcjogbGlzdGVuZXIgfTtcbiAgdmFyIHdyYXBwZWQgPSBvbmNlV3JhcHBlci5iaW5kKHN0YXRlKTtcbiAgd3JhcHBlZC5saXN0ZW5lciA9IGxpc3RlbmVyO1xuICBzdGF0ZS53cmFwRm4gPSB3cmFwcGVkO1xuICByZXR1cm4gd3JhcHBlZDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gb25jZSh0eXBlLCBsaXN0ZW5lcikge1xuICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcbiAgdGhpcy5vbih0eXBlLCBfb25jZVdyYXAodGhpcywgdHlwZSwgbGlzdGVuZXIpKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRPbmNlTGlzdGVuZXIgPVxuICAgIGZ1bmN0aW9uIHByZXBlbmRPbmNlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIGNoZWNrTGlzdGVuZXIobGlzdGVuZXIpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBjaGVja0xpc3RlbmVyKGxpc3RlbmVyKTtcblxuICAgICAgZXZlbnRzID0gdGhpcy5fZXZlbnRzO1xuICAgICAgaWYgKGV2ZW50cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmIChsaXN0ID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICBpZiAobGlzdCA9PT0gbGlzdGVuZXIgfHwgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKC0tdGhpcy5fZXZlbnRzQ291bnQgPT09IDApXG4gICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgZGVsZXRlIGV2ZW50c1t0eXBlXTtcbiAgICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3QubGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBsaXN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHBvc2l0aW9uID0gLTE7XG5cbiAgICAgICAgZm9yIChpID0gbGlzdC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIGlmIChsaXN0W2ldID09PSBsaXN0ZW5lciB8fCBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICAgICAgb3JpZ2luYWxMaXN0ZW5lciA9IGxpc3RbaV0ubGlzdGVuZXI7XG4gICAgICAgICAgICBwb3NpdGlvbiA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChwb3NpdGlvbiA9PT0gMClcbiAgICAgICAgICBsaXN0LnNoaWZ0KCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHNwbGljZU9uZShsaXN0LCBwb3NpdGlvbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIG9yaWdpbmFsTGlzdGVuZXIgfHwgbGlzdGVuZXIpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID1cbiAgICBmdW5jdGlvbiByZW1vdmVBbGxMaXN0ZW5lcnModHlwZSkge1xuICAgICAgdmFyIGxpc3RlbmVycywgZXZlbnRzLCBpO1xuXG4gICAgICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gICAgICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgfSBlbHNlIGlmIChldmVudHNbdHlwZV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBkZWxldGUgZXZlbnRzW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgfVxuXG4gICAgICAvLyBlbWl0IHJlbW92ZUxpc3RlbmVyIGZvciBhbGwgbGlzdGVuZXJzIG9uIGFsbCBldmVudHNcbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZXZlbnRzKTtcbiAgICAgICAgdmFyIGtleTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGtleXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmIChrZXkgPT09ICdyZW1vdmVMaXN0ZW5lcicpIGNvbnRpbnVlO1xuICAgICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3JlbW92ZUxpc3RlbmVyJyk7XG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAvLyBMSUZPIG9yZGVyXG4gICAgICAgIGZvciAoaSA9IGxpc3RlbmVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG5mdW5jdGlvbiBfbGlzdGVuZXJzKHRhcmdldCwgdHlwZSwgdW53cmFwKSB7XG4gIHZhciBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzID09PSB1bmRlZmluZWQpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoZXZsaXN0ZW5lciA9PT0gdW5kZWZpbmVkKVxuICAgIHJldHVybiBbXTtcblxuICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpXG4gICAgcmV0dXJuIHVud3JhcCA/IFtldmxpc3RlbmVyLmxpc3RlbmVyIHx8IGV2bGlzdGVuZXJdIDogW2V2bGlzdGVuZXJdO1xuXG4gIHJldHVybiB1bndyYXAgP1xuICAgIHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzICE9PSB1bmRlZmluZWQpIHtcbiAgICB2YXIgZXZsaXN0ZW5lciA9IGV2ZW50c1t0eXBlXTtcblxuICAgIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIDE7XG4gICAgfSBlbHNlIGlmIChldmxpc3RlbmVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBldmxpc3RlbmVyLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gMDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgcmV0dXJuIHRoaXMuX2V2ZW50c0NvdW50ID4gMCA/IFJlZmxlY3RPd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlT25lKGxpc3QsIGluZGV4KSB7XG4gIGZvciAoOyBpbmRleCArIDEgPCBsaXN0Lmxlbmd0aDsgaW5kZXgrKylcbiAgICBsaXN0W2luZGV4XSA9IGxpc3RbaW5kZXggKyAxXTtcbiAgbGlzdC5wb3AoKTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb25jZShlbWl0dGVyLCBuYW1lKSB7XG4gIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgZnVuY3Rpb24gZXJyb3JMaXN0ZW5lcihlcnIpIHtcbiAgICAgIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIobmFtZSwgcmVzb2x2ZXIpO1xuICAgICAgcmVqZWN0KGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzb2x2ZXIoKSB7XG4gICAgICBpZiAodHlwZW9mIGVtaXR0ZXIucmVtb3ZlTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBlcnJvckxpc3RlbmVyKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB9O1xuXG4gICAgZXZlbnRUYXJnZXRBZ25vc3RpY0FkZExpc3RlbmVyKGVtaXR0ZXIsIG5hbWUsIHJlc29sdmVyLCB7IG9uY2U6IHRydWUgfSk7XG4gICAgaWYgKG5hbWUgIT09ICdlcnJvcicpIHtcbiAgICAgIGFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyKGVtaXR0ZXIsIGVycm9yTGlzdGVuZXIsIHsgb25jZTogdHJ1ZSB9KTtcbiAgICB9XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRFcnJvckhhbmRsZXJJZkV2ZW50RW1pdHRlcihlbWl0dGVyLCBoYW5kbGVyLCBmbGFncykge1xuICBpZiAodHlwZW9mIGVtaXR0ZXIub24gPT09ICdmdW5jdGlvbicpIHtcbiAgICBldmVudFRhcmdldEFnbm9zdGljQWRkTGlzdGVuZXIoZW1pdHRlciwgJ2Vycm9yJywgaGFuZGxlciwgZmxhZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lcihlbWl0dGVyLCBuYW1lLCBsaXN0ZW5lciwgZmxhZ3MpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLm9uID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgIGVtaXR0ZXIub25jZShuYW1lLCBsaXN0ZW5lcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXR0ZXIub24obmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgfSBlbHNlIGlmICh0eXBlb2YgZW1pdHRlci5hZGRFdmVudExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgLy8gRXZlbnRUYXJnZXQgZG9lcyBub3QgaGF2ZSBgZXJyb3JgIGV2ZW50IHNlbWFudGljcyBsaWtlIE5vZGVcbiAgICAvLyBFdmVudEVtaXR0ZXJzLCB3ZSBkbyBub3QgbGlzdGVuIGZvciBgZXJyb3JgIGV2ZW50cyBoZXJlLlxuICAgIGVtaXR0ZXIuYWRkRXZlbnRMaXN0ZW5lcihuYW1lLCBmdW5jdGlvbiB3cmFwTGlzdGVuZXIoYXJnKSB7XG4gICAgICAvLyBJRSBkb2VzIG5vdCBoYXZlIGJ1aWx0aW4gYHsgb25jZTogdHJ1ZSB9YCBzdXBwb3J0IHNvIHdlXG4gICAgICAvLyBoYXZlIHRvIGRvIGl0IG1hbnVhbGx5LlxuICAgICAgaWYgKGZsYWdzLm9uY2UpIHtcbiAgICAgICAgZW1pdHRlci5yZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIHdyYXBMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBsaXN0ZW5lcihhcmcpO1xuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcImVtaXR0ZXJcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgRXZlbnRFbWl0dGVyLiBSZWNlaXZlZCB0eXBlICcgKyB0eXBlb2YgZW1pdHRlcik7XG4gIH1cbn1cbiIsIi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyA/IHNlbGYuRm9ybURhdGEgOiB3aW5kb3cuRm9ybURhdGE7XG4iLCIvKiEgaWVlZTc1NC4gQlNELTMtQ2xhdXNlIExpY2Vuc2UuIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZy9vcGVuc291cmNlPiAqL1xuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG1cbiAgdmFyIGVMZW4gPSAobkJ5dGVzICogOCkgLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSAoZSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSAobSAqIDI1NikgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBpZiAoZSA9PT0gMCkge1xuICAgIGUgPSAxIC0gZUJpYXNcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XG4gICAgcmV0dXJuIG0gPyBOYU4gOiAoKHMgPyAtMSA6IDEpICogSW5maW5pdHkpXG4gIH0gZWxzZSB7XG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxuICAgIGUgPSBlIC0gZUJpYXNcbiAgfVxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxufVxuXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtLCBjXG4gIHZhciBlTGVuID0gKG5CeXRlcyAqIDgpIC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICgodmFsdWUgKiBjKSAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiYXNzZXJ0Lm5vdEVxdWFsID0gbm90RXF1YWxcbmFzc2VydC5ub3RPayA9IG5vdE9rXG5hc3NlcnQuZXF1YWwgPSBlcXVhbFxuYXNzZXJ0Lm9rID0gYXNzZXJ0XG5cbm1vZHVsZS5leHBvcnRzID0gYXNzZXJ0XG5cbmZ1bmN0aW9uIGVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhID09IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdEVxdWFsIChhLCBiLCBtKSB7XG4gIGFzc2VydChhICE9IGIsIG0pIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG59XG5cbmZ1bmN0aW9uIG5vdE9rICh0LCBtKSB7XG4gIGFzc2VydCghdCwgbSlcbn1cblxuZnVuY3Rpb24gYXNzZXJ0ICh0LCBtKSB7XG4gIGlmICghdCkgdGhyb3cgbmV3IEVycm9yKG0gfHwgJ0Fzc2VydGlvbkVycm9yJylcbn1cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLm1hcChmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gb2JqW2tdLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZSh2KSk7XG4gICAgICAgIH0pLmpvaW4oc2VwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqW2tdKSk7XG4gICAgICB9XG4gICAgfSkuam9pbihzZXApO1xuXG4gIH1cblxuICBpZiAoIW5hbWUpIHJldHVybiAnJztcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUobmFtZSkpICsgZXEgK1xuICAgICAgICAgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmopKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmV4cG9ydHMuZGVjb2RlID0gZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vZGVjb2RlJyk7XG5leHBvcnRzLmVuY29kZSA9IGV4cG9ydHMuc3RyaW5naWZ5ID0gcmVxdWlyZSgnLi9lbmNvZGUnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gX2luaGVyaXRzTG9vc2Uoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHsgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzLnByb3RvdHlwZSk7IHN1YkNsYXNzLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IHN1YkNsYXNzOyBzdWJDbGFzcy5fX3Byb3RvX18gPSBzdXBlckNsYXNzOyB9XG5cbnZhciBjb2RlcyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVFcnJvclR5cGUoY29kZSwgbWVzc2FnZSwgQmFzZSkge1xuICBpZiAoIUJhc2UpIHtcbiAgICBCYXNlID0gRXJyb3I7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNZXNzYWdlKGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm4gbWVzc2FnZTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG1lc3NhZ2UoYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfVxuICB9XG5cbiAgdmFyIE5vZGVFcnJvciA9XG4gIC8qI19fUFVSRV9fKi9cbiAgZnVuY3Rpb24gKF9CYXNlKSB7XG4gICAgX2luaGVyaXRzTG9vc2UoTm9kZUVycm9yLCBfQmFzZSk7XG5cbiAgICBmdW5jdGlvbiBOb2RlRXJyb3IoYXJnMSwgYXJnMiwgYXJnMykge1xuICAgICAgcmV0dXJuIF9CYXNlLmNhbGwodGhpcywgZ2V0TWVzc2FnZShhcmcxLCBhcmcyLCBhcmczKSkgfHwgdGhpcztcbiAgICB9XG5cbiAgICByZXR1cm4gTm9kZUVycm9yO1xuICB9KEJhc2UpO1xuXG4gIE5vZGVFcnJvci5wcm90b3R5cGUubmFtZSA9IEJhc2UubmFtZTtcbiAgTm9kZUVycm9yLnByb3RvdHlwZS5jb2RlID0gY29kZTtcbiAgY29kZXNbY29kZV0gPSBOb2RlRXJyb3I7XG59IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9ibG9iL3YxMC44LjAvbGliL2ludGVybmFsL2Vycm9ycy5qc1xuXG5cbmZ1bmN0aW9uIG9uZU9mKGV4cGVjdGVkLCB0aGluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheShleHBlY3RlZCkpIHtcbiAgICB2YXIgbGVuID0gZXhwZWN0ZWQubGVuZ3RoO1xuICAgIGV4cGVjdGVkID0gZXhwZWN0ZWQubWFwKGZ1bmN0aW9uIChpKSB7XG4gICAgICByZXR1cm4gU3RyaW5nKGkpO1xuICAgIH0pO1xuXG4gICAgaWYgKGxlbiA+IDIpIHtcbiAgICAgIHJldHVybiBcIm9uZSBvZiBcIi5jb25jYXQodGhpbmcsIFwiIFwiKS5jb25jYXQoZXhwZWN0ZWQuc2xpY2UoMCwgbGVuIC0gMSkuam9pbignLCAnKSwgXCIsIG9yIFwiKSArIGV4cGVjdGVkW2xlbiAtIDFdO1xuICAgIH0gZWxzZSBpZiAobGVuID09PSAyKSB7XG4gICAgICByZXR1cm4gXCJvbmUgb2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdLCBcIiBvciBcIikuY29uY2F0KGV4cGVjdGVkWzFdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KGV4cGVjdGVkWzBdKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib2YgXCIuY29uY2F0KHRoaW5nLCBcIiBcIikuY29uY2F0KFN0cmluZyhleHBlY3RlZCkpO1xuICB9XG59IC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL1N0cmluZy9zdGFydHNXaXRoXG5cblxuZnVuY3Rpb24gc3RhcnRzV2l0aChzdHIsIHNlYXJjaCwgcG9zKSB7XG4gIHJldHVybiBzdHIuc3Vic3RyKCFwb3MgfHwgcG9zIDwgMCA/IDAgOiArcG9zLCBzZWFyY2gubGVuZ3RoKSA9PT0gc2VhcmNoO1xufSAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvZW5kc1dpdGhcblxuXG5mdW5jdGlvbiBlbmRzV2l0aChzdHIsIHNlYXJjaCwgdGhpc19sZW4pIHtcbiAgaWYgKHRoaXNfbGVuID09PSB1bmRlZmluZWQgfHwgdGhpc19sZW4gPiBzdHIubGVuZ3RoKSB7XG4gICAgdGhpc19sZW4gPSBzdHIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIHN0ci5zdWJzdHJpbmcodGhpc19sZW4gLSBzZWFyY2gubGVuZ3RoLCB0aGlzX2xlbikgPT09IHNlYXJjaDtcbn0gLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU3RyaW5nL2luY2x1ZGVzXG5cblxuZnVuY3Rpb24gaW5jbHVkZXMoc3RyLCBzZWFyY2gsIHN0YXJ0KSB7XG4gIGlmICh0eXBlb2Ygc3RhcnQgIT09ICdudW1iZXInKSB7XG4gICAgc3RhcnQgPSAwO1xuICB9XG5cbiAgaWYgKHN0YXJ0ICsgc2VhcmNoLmxlbmd0aCA+IHN0ci5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHN0ci5pbmRleE9mKHNlYXJjaCwgc3RhcnQpICE9PSAtMTtcbiAgfVxufVxuXG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9JTlZBTElEX09QVF9WQUxVRScsIGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICByZXR1cm4gJ1RoZSB2YWx1ZSBcIicgKyB2YWx1ZSArICdcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCInICsgbmFtZSArICdcIic7XG59LCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfSU5WQUxJRF9BUkdfVFlQRScsIGZ1bmN0aW9uIChuYW1lLCBleHBlY3RlZCwgYWN0dWFsKSB7XG4gIC8vIGRldGVybWluZXI6ICdtdXN0IGJlJyBvciAnbXVzdCBub3QgYmUnXG4gIHZhciBkZXRlcm1pbmVyO1xuXG4gIGlmICh0eXBlb2YgZXhwZWN0ZWQgPT09ICdzdHJpbmcnICYmIHN0YXJ0c1dpdGgoZXhwZWN0ZWQsICdub3QgJykpIHtcbiAgICBkZXRlcm1pbmVyID0gJ211c3Qgbm90IGJlJztcbiAgICBleHBlY3RlZCA9IGV4cGVjdGVkLnJlcGxhY2UoL15ub3QgLywgJycpO1xuICB9IGVsc2Uge1xuICAgIGRldGVybWluZXIgPSAnbXVzdCBiZSc7XG4gIH1cblxuICB2YXIgbXNnO1xuXG4gIGlmIChlbmRzV2l0aChuYW1lLCAnIGFyZ3VtZW50JykpIHtcbiAgICAvLyBGb3IgY2FzZXMgbGlrZSAnZmlyc3QgYXJndW1lbnQnXG4gICAgbXNnID0gXCJUaGUgXCIuY29uY2F0KG5hbWUsIFwiIFwiKS5jb25jYXQoZGV0ZXJtaW5lciwgXCIgXCIpLmNvbmNhdChvbmVPZihleHBlY3RlZCwgJ3R5cGUnKSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIHR5cGUgPSBpbmNsdWRlcyhuYW1lLCAnLicpID8gJ3Byb3BlcnR5JyA6ICdhcmd1bWVudCc7XG4gICAgbXNnID0gXCJUaGUgXFxcIlwiLmNvbmNhdChuYW1lLCBcIlxcXCIgXCIpLmNvbmNhdCh0eXBlLCBcIiBcIikuY29uY2F0KGRldGVybWluZXIsIFwiIFwiKS5jb25jYXQob25lT2YoZXhwZWN0ZWQsICd0eXBlJykpO1xuICB9XG5cbiAgbXNnICs9IFwiLiBSZWNlaXZlZCB0eXBlIFwiLmNvbmNhdCh0eXBlb2YgYWN0dWFsKTtcbiAgcmV0dXJuIG1zZztcbn0sIFR5cGVFcnJvcik7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YnLCAnc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQnLCBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gJ1RoZSAnICsgbmFtZSArICcgbWV0aG9kIGlzIG5vdCBpbXBsZW1lbnRlZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UnLCAnUHJlbWF0dXJlIGNsb3NlJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fREVTVFJPWUVEJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgcmV0dXJuICdDYW5ub3QgY2FsbCAnICsgbmFtZSArICcgYWZ0ZXIgYSBzdHJlYW0gd2FzIGRlc3Ryb3llZCc7XG59KTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX01VTFRJUExFX0NBTExCQUNLJywgJ0NhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfU1RSRUFNX0NBTk5PVF9QSVBFJywgJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQnLCAnd3JpdGUgYWZ0ZXIgZW5kJyk7XG5jcmVhdGVFcnJvclR5cGUoJ0VSUl9TVFJFQU1fTlVMTF9WQUxVRVMnLCAnTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nLCBUeXBlRXJyb3IpO1xuY3JlYXRlRXJyb3JUeXBlKCdFUlJfVU5LTk9XTl9FTkNPRElORycsIGZ1bmN0aW9uIChhcmcpIHtcbiAgcmV0dXJuICdVbmtub3duIGVuY29kaW5nOiAnICsgYXJnO1xufSwgVHlwZUVycm9yKTtcbmNyZWF0ZUVycm9yVHlwZSgnRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCcsICdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpO1xubW9kdWxlLmV4cG9ydHMuY29kZXMgPSBjb2RlcztcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cbid1c2Ugc3RyaWN0Jztcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuXG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfVxuXG4gIHJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcblxudmFyIFdyaXRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3dyaXRhYmxlJyk7XG5cbnJlcXVpcmUoJ2luaGVyaXRzJykoRHVwbGV4LCBSZWFkYWJsZSk7XG5cbntcbiAgLy8gQWxsb3cgdGhlIGtleXMgYXJyYXkgdG8gYmUgR0MnZWQuXG4gIHZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xuXG4gIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBtZXRob2QgPSBrZXlzW3ZdO1xuICAgIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcbiAgICBpZiAob3B0aW9ucy53cml0YWJsZSA9PT0gZmFsc2UpIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcblxuICAgIGlmIChvcHRpb25zLmFsbG93SGFsZk9wZW4gPT09IGZhbHNlKSB7XG4gICAgICB0aGlzLmFsbG93SGFsZk9wZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xuICAgIH1cbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ3dyaXRhYmxlQnVmZmVyJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmdldEJ1ZmZlcigpO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShEdXBsZXgucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcblxuZnVuY3Rpb24gb25lbmQoKSB7XG4gIC8vIElmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLCB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRlZCkgcmV0dXJuOyAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuXG4gIHByb2Nlc3MubmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG5cblxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcblxuZnVuY3Rpb24gUGFzc1Rocm91Z2gob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIEVFbGlzdGVuZXJDb3VudChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG5cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBkZWJ1Z1V0aWwgPSByZXF1aXJlKCd1dGlsJyk7XG5cbnZhciBkZWJ1ZztcblxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiBkZWJ1ZygpIHt9O1xufVxuLyo8L3JlcGxhY2VtZW50PiovXG5cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvYnVmZmVyX2xpc3QnKTtcblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudmFyIF9yZXF1aXJlID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0YXRlJyksXG4gICAgZ2V0SGlnaFdhdGVyTWFyayA9IF9yZXF1aXJlLmdldEhpZ2hXYXRlck1hcms7XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9JTlZBTElEX0FSR19UWVBFID0gX3JlcXVpcmUkY29kZXMuRVJSX0lOVkFMSURfQVJHX1RZUEUsXG4gICAgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fUFVTSF9BRlRFUl9FT0YsXG4gICAgRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCxcbiAgICBFUlJfU1RSRUFNX1VOU0hJRlRfQUZURVJfRU5EX0VWRU5UID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVDsgLy8gTGF6eSBsb2FkZWQgdG8gaW1wcm92ZSB0aGUgc3RhcnR1cCBwZXJmb3JtYW5jZS5cblxuXG52YXIgU3RyaW5nRGVjb2RlcjtcbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7XG52YXIgZnJvbTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShSZWFkYWJsZSwgU3RyZWFtKTtcblxudmFyIGVycm9yT3JEZXN0cm95ID0gZGVzdHJveUltcGwuZXJyb3JPckRlc3Ryb3k7XG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTsgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAvLyB1c2VybGFuZCBvbmVzLiAgTkVWRVIgRE8gVEhJUy4gVGhpcyBpcyBoZXJlIG9ubHkgYmVjYXVzZSB0aGlzIGNvZGUgbmVlZHNcbiAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG5cbiAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChBcnJheS5pc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtLCBpc0R1cGxleCkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTsgLy8gRHVwbGV4IHN0cmVhbXMgYXJlIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLCBidXQgc2hhcmVcbiAgLy8gdGhlIHNhbWUgb3B0aW9ucyBvYmplY3QuXG4gIC8vIEhvd2V2ZXIsIHNvbWUgY2FzZXMgcmVxdWlyZSBzZXR0aW5nIG9wdGlvbnMgdG8gZGlmZmVyZW50XG4gIC8vIHZhbHVlcyBmb3IgdGhlIHJlYWRhYmxlIGFuZCB0aGUgd3JpdGFibGUgc2lkZXMgb2YgdGhlIGR1cGxleCBzdHJlYW0uXG4gIC8vIFRoZXNlIG9wdGlvbnMgY2FuIGJlIHByb3ZpZGVkIHNlcGFyYXRlbHkgYXMgcmVhZGFibGVYWFggYW5kIHdyaXRhYmxlWFhYLlxuXG4gIGlmICh0eXBlb2YgaXNEdXBsZXggIT09ICdib29sZWFuJykgaXNEdXBsZXggPSBzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXg7IC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG5cbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XG4gIGlmIChpc0R1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7IC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICdyZWFkYWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcblxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG5cbiAgdGhpcy5zeW5jID0gdHJ1ZTsgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICB0aGlzLnBhdXNlZCA9IHRydWU7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZW5kJyAoYW5kIHBvdGVudGlhbGx5ICdmaW5pc2gnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG5cbiAgdGhpcy5hd2FpdERyYWluID0gMDsgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuXG4gIHRoaXMucmVhZGluZ01vcmUgPSBmYWxzZTtcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG5cbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICAgIHRoaXMuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKG9wdGlvbnMuZW5jb2RpbmcpO1xuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xuICB9XG59XG5cbmZ1bmN0aW9uIFJlYWRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTsgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgUmVhZGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcywgaXNEdXBsZXgpOyAvLyBsZWdhY3lcblxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuXG5cbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblJlYWRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICBjYihlcnIpO1xufTsgLy8gTWFudWFsbHkgc2hvdmUgc29tZXRoaW5nIGludG8gdGhlIHJlYWQoKSBidWZmZXIuXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcbi8vIHNpbWlsYXIgdG8gaG93IFdyaXRhYmxlLndyaXRlKCkgcmV0dXJucyB0cnVlIGlmIHlvdSBzaG91bGRcbi8vIHdyaXRlKCkgc29tZSBtb3JlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gICAgICBpZiAoZW5jb2RpbmcgIT09IHN0YXRlLmVuY29kaW5nKSB7XG4gICAgICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcbiAgICAgIH1cblxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59OyAvLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBudWxsLCB0cnVlLCBmYWxzZSk7XG59O1xuXG5mdW5jdGlvbiByZWFkYWJsZUFkZENodW5rKHN0cmVhbSwgY2h1bmssIGVuY29kaW5nLCBhZGRUb0Zyb250LCBza2lwQ2h1bmtDaGVjaykge1xuICBkZWJ1ZygncmVhZGFibGVBZGRDaHVuaycsIGNodW5rKTtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpO1xuICB9IGVsc2Uge1xuICAgIHZhciBlcjtcbiAgICBpZiAoIXNraXBDaHVua0NoZWNrKSBlciA9IGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspO1xuXG4gICAgaWYgKGVyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCgpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBuZXcgRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRigpKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcblxuICAgICAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhZW5jb2RpbmcpIHtcbiAgICAgICAgICBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoIWFkZFRvRnJvbnQpIHtcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuICB9IC8vIFdlIGNhbiBwdXNoIG1vcmUgZGF0YSBpZiB3ZSBhcmUgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmsuXG4gIC8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lIG1vcmUgYnl0ZXMuXG4gIC8vIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsIHN1Y2ggYXMgdGhlIHJlcGwuXG5cblxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cblxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcblxuICBpZiAoIV9pc1VpbnQ4QXJyYXkoY2h1bmspICYmIHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlcicsICdVaW50OEFycmF5J10sIGNodW5rKTtcbiAgfVxuXG4gIHJldHVybiBlcjtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07IC8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcbiAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgdmFyIGRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBkZWNvZGVyOyAvLyBJZiBzZXRFbmNvZGluZyhudWxsKSwgZGVjb2Rlci5lbmNvZGluZyBlcXVhbHMgdXRmOFxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIuZW5jb2Rpbmc7IC8vIEl0ZXJhdGUgb3ZlciBjdXJyZW50IGJ1ZmZlciB0byBjb252ZXJ0IGFscmVhZHkgc3RvcmVkIEJ1ZmZlcnM6XG5cbiAgdmFyIHAgPSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5oZWFkO1xuICB2YXIgY29udGVudCA9ICcnO1xuXG4gIHdoaWxlIChwICE9PSBudWxsKSB7XG4gICAgY29udGVudCArPSBkZWNvZGVyLndyaXRlKHAuZGF0YSk7XG4gICAgcCA9IHAubmV4dDtcbiAgfVxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyLmNsZWFyKCk7XG5cbiAgaWYgKGNvbnRlbnQgIT09ICcnKSB0aGlzLl9yZWFkYWJsZVN0YXRlLmJ1ZmZlci5wdXNoKGNvbnRlbnQpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aCA9IGNvbnRlbnQubGVuZ3RoO1xuICByZXR1cm4gdGhpcztcbn07IC8vIERvbid0IHJhaXNlIHRoZSBod20gPiAxR0JcblxuXG52YXIgTUFYX0hXTSA9IDB4NDAwMDAwMDA7XG5cbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIC8vIFRPRE8ocm9uYWcpOiBUaHJvdyBFUlJfVkFMVUVfT1VUX09GX1JBTkdFLlxuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cblxuICByZXR1cm4gbjtcbn0gLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXG5cblxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcblxuICBpZiAobiAhPT0gbikge1xuICAgIC8vIE9ubHkgZmxvdyBvbmUgYnVmZmVyIGF0IGEgdGltZVxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbiAgfSAvLyBJZiB3ZSdyZSBhc2tpbmcgZm9yIG1vcmUgdGhhbiB0aGUgY3VycmVudCBod20sIHRoZW4gcmFpc2UgdGhlIGh3bS5cblxuXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuOyAvLyBEb24ndCBoYXZlIGVub3VnaFxuXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIHJldHVybiAwO1xuICB9XG5cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn0gLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblxuXG5SZWFkYWJsZS5wcm90b3R5cGUucmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIGRlYnVnKCdyZWFkJywgbik7XG4gIG4gPSBwYXJzZUludChuLCAxMCk7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBuT3JpZyA9IG47XG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTsgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoKHN0YXRlLmhpZ2hXYXRlck1hcmsgIT09IDAgPyBzdGF0ZS5sZW5ndGggPj0gc3RhdGUuaGlnaFdhdGVyTWFyayA6IHN0YXRlLmxlbmd0aCA+IDApIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTsgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxuICAvLyAqYmVsb3cqIHRoZSBjYWxsIHRvIF9yZWFkLiAgVGhlIHJlYXNvbiBpcyB0aGF0IGluIGNlcnRhaW5cbiAgLy8gc3ludGhldGljIHN0cmVhbSBjYXNlcywgc3VjaCBhcyBwYXNzdGhyb3VnaCBzdHJlYW1zLCBfcmVhZFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXG4gIC8vIHRoZSBzdGF0ZSBvZiB0aGUgcmVhZCBidWZmZXIsIHByb3ZpZGluZyBlbm91Z2ggZGF0YSB3aGVuXG4gIC8vIGJlZm9yZSB0aGVyZSB3YXMgKm5vdCogZW5vdWdoLlxuICAvL1xuICAvLyBTbywgdGhlIHN0ZXBzIGFyZTpcbiAgLy8gMS4gRmlndXJlIG91dCB3aGF0IHRoZSBzdGF0ZSBvZiB0aGluZ3Mgd2lsbCBiZSBhZnRlciB3ZSBkb1xuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxuICAvL1xuICAvLyAyLiBJZiB0aGF0IHJlc3VsdGluZyBzdGF0ZSB3aWxsIHRyaWdnZXIgYSBfcmVhZCwgdGhlbiBjYWxsIF9yZWFkLlxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcbiAgLy8gZGVlcGx5IHVnbHkgdG8gd3JpdGUgQVBJcyB0aGlzIHdheSwgYnV0IHRoYXQgc3RpbGwgZG9lc24ndCBtZWFuXG4gIC8vIHRoYXQgdGhlIFJlYWRhYmxlIGNsYXNzIHNob3VsZCBiZWhhdmUgaW1wcm9wZXJseSwgYXMgc3RyZWFtcyBhcmVcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cbiAgLy8gVGFrZSBub3RlIGlmIHRoZSBfcmVhZCBjYWxsIGlzIHN5bmMgb3IgYXN5bmMgKGllLCBpZiB0aGUgcmVhZCBjYWxsXG4gIC8vIGhhcyByZXR1cm5lZCB5ZXQpLCBzbyB0aGF0IHdlIGtub3cgd2hldGhlciBvciBub3QgaXQncyBzYWZlIHRvIGVtaXRcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXG4gIC8vXG4gIC8vIDMuIEFjdHVhbGx5IHB1bGwgdGhlIHJlcXVlc3RlZCBjaHVua3Mgb3V0IG9mIHRoZSBidWZmZXIgYW5kIHJldHVybi5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuXG5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpOyAvLyBpZiB3ZSBjdXJyZW50bHkgaGF2ZSBsZXNzIHRoYW4gdGhlIGhpZ2hXYXRlck1hcmssIHRoZW4gYWxzbyByZWFkIHNvbWVcblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9IC8vIGhvd2V2ZXIsIGlmIHdlJ3ZlIGVuZGVkLCB0aGVuIHRoZXJlJ3Mgbm8gcG9pbnQsIGFuZCBpZiB3ZSdyZSBhbHJlYWR5XG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cblxuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7IC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlOyAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG5cbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlOyAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cblxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcbiAgfVxuXG4gIHZhciByZXQ7XG4gIGlmIChuID4gMCkgcmV0ID0gZnJvbUxpc3Qobiwgc3RhdGUpO2Vsc2UgcmV0ID0gbnVsbDtcblxuICBpZiAocmV0ID09PSBudWxsKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gc3RhdGUubGVuZ3RoIDw9IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gICAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7IC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cblxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuICByZXR1cm4gcmV0O1xufTtcblxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XG4gIGRlYnVnKCdvbkVvZkNodW5rJyk7XG4gIGlmIChzdGF0ZS5lbmRlZCkgcmV0dXJuO1xuXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcblxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cblxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLnN5bmMpIHtcbiAgICAvLyBpZiB3ZSBhcmUgc3luYywgd2FpdCB1bnRpbCBuZXh0IHRpY2sgdG8gZW1pdCB0aGUgZGF0YS5cbiAgICAvLyBPdGhlcndpc2Ugd2UgcmlzayBlbWl0dGluZyBkYXRhIGluIHRoZSBmbG93KClcbiAgICAvLyB0aGUgcmVhZGFibGUgY29kZSB0cmlnZ2VycyBkdXJpbmcgYSByZWFkKCkgY2FsbFxuICAgIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xuICB9IGVsc2Uge1xuICAgIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gICAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gICAgfVxuICB9XG59IC8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbWl0UmVhZGFibGUnLCBzdGF0ZS5uZWVkUmVhZGFibGUsIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSk7XG4gIHN0YXRlLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2VtaXRSZWFkYWJsZV8nLCBzdGF0ZS5kZXN0cm95ZWQsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuXG4gIGlmICghc3RhdGUuZGVzdHJveWVkICYmIChzdGF0ZS5sZW5ndGggfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIH0gLy8gVGhlIHN0cmVhbSBuZWVkcyBhbm90aGVyIHJlYWRhYmxlIGV2ZW50IGlmXG4gIC8vIDEuIEl0IGlzIG5vdCBmbG93aW5nLCBhcyB0aGUgZmxvdyBtZWNoYW5pc20gd2lsbCB0YWtlXG4gIC8vICAgIGNhcmUgb2YgaXQuXG4gIC8vIDIuIEl0IGlzIG5vdCBlbmRlZC5cbiAgLy8gMy4gSXQgaXMgYmVsb3cgdGhlIGhpZ2hXYXRlck1hcmssIHNvIHdlIGNhbiBzY2hlZHVsZVxuICAvLyAgICBhbm90aGVyIHJlYWRhYmxlIGxhdGVyLlxuXG5cbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gIXN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLmVuZGVkICYmIHN0YXRlLmxlbmd0aCA8PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICBmbG93KHN0cmVhbSk7XG59IC8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuXG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmdNb3JlKSB7XG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xuICAgIHByb2Nlc3MubmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgLy8gQXR0ZW1wdCB0byByZWFkIG1vcmUgZGF0YSBpZiB3ZSBzaG91bGQuXG4gIC8vXG4gIC8vIFRoZSBjb25kaXRpb25zIGZvciByZWFkaW5nIG1vcmUgZGF0YSBhcmUgKG9uZSBvZik6XG4gIC8vIC0gTm90IGVub3VnaCBkYXRhIGJ1ZmZlcmVkIChzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKS4gVGhlIGxvb3BcbiAgLy8gICBpcyByZXNwb25zaWJsZSBmb3IgZmlsbGluZyB0aGUgYnVmZmVyIHdpdGggZW5vdWdoIGRhdGEgaWYgc3VjaCBkYXRhXG4gIC8vICAgaXMgYXZhaWxhYmxlLiBJZiBoaWdoV2F0ZXJNYXJrIGlzIDAgYW5kIHdlIGFyZSBub3QgaW4gdGhlIGZsb3dpbmcgbW9kZVxuICAvLyAgIHdlIHNob3VsZCBfbm90XyBhdHRlbXB0IHRvIGJ1ZmZlciBhbnkgZXh0cmEgZGF0YS4gV2UnbGwgZ2V0IG1vcmUgZGF0YVxuICAvLyAgIHdoZW4gdGhlIHN0cmVhbSBjb25zdW1lciBjYWxscyByZWFkKCkgaW5zdGVhZC5cbiAgLy8gLSBObyBkYXRhIGluIHRoZSBidWZmZXIsIGFuZCB0aGUgc3RyZWFtIGlzIGluIGZsb3dpbmcgbW9kZS4gSW4gdGhpcyBtb2RlXG4gIC8vICAgdGhlIGxvb3AgYmVsb3cgaXMgcmVzcG9uc2libGUgZm9yIGVuc3VyaW5nIHJlYWQoKSBpcyBjYWxsZWQuIEZhaWxpbmcgdG9cbiAgLy8gICBjYWxsIHJlYWQgaGVyZSB3b3VsZCBhYm9ydCB0aGUgZmxvdyBhbmQgdGhlcmUncyBubyBvdGhlciBtZWNoYW5pc20gZm9yXG4gIC8vICAgY29udGludWluZyB0aGUgZmxvdyBpZiB0aGUgc3RyZWFtIGNvbnN1bWVyIGhhcyBqdXN0IHN1YnNjcmliZWQgdG8gdGhlXG4gIC8vICAgJ2RhdGEnIGV2ZW50LlxuICAvL1xuICAvLyBJbiBhZGRpdGlvbiB0byB0aGUgYWJvdmUgY29uZGl0aW9ucyB0byBrZWVwIHJlYWRpbmcgZGF0YSwgdGhlIGZvbGxvd2luZ1xuICAvLyBjb25kaXRpb25zIHByZXZlbnQgdGhlIGRhdGEgZnJvbSBiZWluZyByZWFkOlxuICAvLyAtIFRoZSBzdHJlYW0gaGFzIGVuZGVkIChzdGF0ZS5lbmRlZCkuXG4gIC8vIC0gVGhlcmUgaXMgYWxyZWFkeSBhIHBlbmRpbmcgJ3JlYWQnIG9wZXJhdGlvbiAoc3RhdGUucmVhZGluZykuIFRoaXMgaXMgYVxuICAvLyAgIGNhc2Ugd2hlcmUgdGhlIHRoZSBzdHJlYW0gaGFzIGNhbGxlZCB0aGUgaW1wbGVtZW50YXRpb24gZGVmaW5lZCBfcmVhZCgpXG4gIC8vICAgbWV0aG9kLCBidXQgdGhleSBhcmUgcHJvY2Vzc2luZyB0aGUgY2FsbCBhc3luY2hyb25vdXNseSBhbmQgaGF2ZSBfbm90X1xuICAvLyAgIGNhbGxlZCBwdXNoKCkgd2l0aCBuZXcgZGF0YS4gSW4gdGhpcyBjYXNlIHdlIHNraXAgcGVyZm9ybWluZyBtb3JlXG4gIC8vICAgcmVhZCgpcy4gVGhlIGV4ZWN1dGlvbiBlbmRzIGluIHRoaXMgbWV0aG9kIGFnYWluIGFmdGVyIHRoZSBfcmVhZCgpIGVuZHNcbiAgLy8gICB1cCBjYWxsaW5nIHB1c2goKSB3aXRoIG1vcmUgZGF0YS5cbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkpIHtcbiAgICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aCkgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgc3RhdGUucmVhZGluZ01vcmUgPSBmYWxzZTtcbn0gLy8gYWJzdHJhY3QgbWV0aG9kLiAgdG8gYmUgb3ZlcnJpZGRlbiBpbiBzcGVjaWZpYyBpbXBsZW1lbnRhdGlvbiBjbGFzc2VzLlxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cbi8vIGZvciB2aXJ0dWFsIChub24tc3RyaW5nLCBub24tYnVmZmVyKSBzdHJlYW1zLCBcImxlbmd0aFwiIGlzIHNvbWV3aGF0XG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXG5cblxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfcmVhZCgpJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBzdGF0ZS5waXBlcy5wdXNoKGRlc3QpO1xuICAgICAgYnJlYWs7XG4gIH1cblxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG4gIHZhciBkb0VuZCA9ICghcGlwZU9wdHMgfHwgcGlwZU9wdHMuZW5kICE9PSBmYWxzZSkgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRvdXQgJiYgZGVzdCAhPT0gcHJvY2Vzcy5zdGRlcnI7XG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzLm5leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG4gIGRlc3Qub24oJ3VucGlwZScsIG9udW5waXBlKTtcblxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH0gLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG5cblxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XG4gIGRlc3Qub24oJ2RyYWluJywgb25kcmFpbik7XG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBjbGVhbnVwKCkge1xuICAgIGRlYnVnKCdjbGVhbnVwJyk7IC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCB1bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XG4gICAgY2xlYW5lZFVwID0gdHJ1ZTsgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xuICAgIC8vIHNwZWNpZmljIHdyaXRlciwgdGhlbiBpdCB3b3VsZCBjYXVzZSBpdCB0byBuZXZlciBzdGFydFxuICAgIC8vIGZsb3dpbmcgYWdhaW4uXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxuICAgIC8vIElmIHdlIGRvbid0IGtub3csIHRoZW4gYXNzdW1lIHRoYXQgd2UgYXJlIHdhaXRpbmcgZm9yIG9uZS5cblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIHNyYy5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBkZWJ1ZygnZGVzdC53cml0ZScsIHJldCk7XG5cbiAgICBpZiAocmV0ID09PSBmYWxzZSkge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgICAgIHN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgIH1cblxuICAgICAgc3JjLnBhdXNlKCk7XG4gICAgfVxuICB9IC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG5cblxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBlcnJvck9yRGVzdHJveShkZXN0LCBlcik7XG4gIH0gLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuXG5cbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpOyAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHVucGlwZSgpO1xuICB9XG5cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cblxuICBkZXN0Lm9uY2UoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcblxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XG4gICAgZGVidWcoJ3VucGlwZScpO1xuICAgIHNyYy51bnBpcGUoZGVzdCk7XG4gIH0gLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cblxuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7IC8vIHN0YXJ0IHRoZSBmbG93IGlmIGl0IGhhc24ndCBiZWVuIHN0YXJ0ZWQgYWxyZWFkeS5cblxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gcGlwZU9uRHJhaW5GdW5jdGlvblJlc3VsdCgpIHtcbiAgICB2YXIgc3RhdGUgPSBzcmMuX3JlYWRhYmxlU3RhdGU7XG4gICAgZGVidWcoJ3BpcGVPbkRyYWluJywgc3RhdGUuYXdhaXREcmFpbik7XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcblxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0ge1xuICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gIH07IC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7IC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cblxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlczsgLy8gZ290IGEgbWF0Y2guXG5cbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIGlmIChkZXN0KSBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIHJldHVybiB0aGlzO1xuICB9IC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cblxuICBpZiAoIWRlc3QpIHtcbiAgICAvLyByZW1vdmUgYWxsLlxuICAgIHZhciBkZXN0cyA9IHN0YXRlLnBpcGVzO1xuICAgIHZhciBsZW4gPSBzdGF0ZS5waXBlc0NvdW50O1xuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBkZXN0c1tpXS5lbWl0KCd1bnBpcGUnLCB0aGlzLCB7XG4gICAgICAgIGhhc1VucGlwZWQ6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxuXG5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuICBkZXN0LmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICByZXR1cm4gdGhpcztcbn07IC8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5cblxuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyB1cGRhdGUgcmVhZGFibGVMaXN0ZW5pbmcgc28gdGhhdCByZXN1bWUoKSBtYXkgYmUgYSBuby1vcFxuICAgIC8vIGEgZmV3IGxpbmVzIGRvd24uIFRoaXMgaXMgbmVlZGVkIHRvIHN1cHBvcnQgb25jZSgncmVhZGFibGUnKS5cbiAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHRoaXMubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7IC8vIFRyeSBzdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcblxuICAgIGlmIChzdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiAhc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcpIHtcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgZGVidWcoJ29uIHJlYWRhYmxlJywgc3RhdGUubGVuZ3RoLCBzdGF0ZS5yZWFkaW5nKTtcblxuICAgICAgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcblxuUmVhZGFibGUucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lci5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgLy8gV2UgbmVlZCB0byBjaGVjayBpZiB0aGVyZSBpcyBzb21lb25lIHN0aWxsIGxpc3RlbmluZyB0b1xuICAgIC8vIHJlYWRhYmxlIGFuZCByZXNldCB0aGUgc3RhdGUuIEhvd2V2ZXIgdGhpcyBuZWVkcyB0byBoYXBwZW5cbiAgICAvLyBhZnRlciByZWFkYWJsZSBoYXMgYmVlbiBlbWl0dGVkIGJ1dCBiZWZvcmUgSS9PIChuZXh0VGljaykgdG9cbiAgICAvLyBzdXBwb3J0IG9uY2UoJ3JlYWRhYmxlJywgZm4pIGN5Y2xlcy4gVGhpcyBtZWFucyB0aGF0IGNhbGxpbmdcbiAgICAvLyByZXN1bWUgd2l0aGluIHRoZSBzYW1lIHRpY2sgd2lsbCBoYXZlIG5vXG4gICAgLy8gZWZmZWN0LlxuICAgIHByb2Nlc3MubmV4dFRpY2sodXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcsIHRoaXMpO1xuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXYpIHtcbiAgdmFyIHJlcyA9IFN0cmVhbS5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cbiAgaWYgKGV2ID09PSAncmVhZGFibGUnIHx8IGV2ID09PSB1bmRlZmluZWQpIHtcbiAgICAvLyBXZSBuZWVkIHRvIGNoZWNrIGlmIHRoZXJlIGlzIHNvbWVvbmUgc3RpbGwgbGlzdGVuaW5nIHRvXG4gICAgLy8gcmVhZGFibGUgYW5kIHJlc2V0IHRoZSBzdGF0ZS4gSG93ZXZlciB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgIC8vIGFmdGVyIHJlYWRhYmxlIGhhcyBiZWVuIGVtaXR0ZWQgYnV0IGJlZm9yZSBJL08gKG5leHRUaWNrKSB0b1xuICAgIC8vIHN1cHBvcnQgb25jZSgncmVhZGFibGUnLCBmbikgY3ljbGVzLiBUaGlzIG1lYW5zIHRoYXQgY2FsbGluZ1xuICAgIC8vIHJlc3VtZSB3aXRoaW4gdGhlIHNhbWUgdGljayB3aWxsIGhhdmUgbm9cbiAgICAvLyBlZmZlY3QuXG4gICAgcHJvY2Vzcy5uZXh0VGljayh1cGRhdGVSZWFkYWJsZUxpc3RlbmluZywgdGhpcyk7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdXBkYXRlUmVhZGFibGVMaXN0ZW5pbmcoc2VsZikge1xuICB2YXIgc3RhdGUgPSBzZWxmLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHNlbGYubGlzdGVuZXJDb3VudCgncmVhZGFibGUnKSA+IDA7XG5cbiAgaWYgKHN0YXRlLnJlc3VtZVNjaGVkdWxlZCAmJiAhc3RhdGUucGF1c2VkKSB7XG4gICAgLy8gZmxvd2luZyBuZWVkcyB0byBiZSBzZXQgdG8gdHJ1ZSBub3csIG90aGVyd2lzZVxuICAgIC8vIHRoZSB1cGNvbWluZyByZXN1bWUgd2lsbCBub3QgZmxvdy5cbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTsgLy8gY3J1ZGUgd2F5IHRvIGNoZWNrIGlmIHdlIHNob3VsZCByZXN1bWVcbiAgfSBlbHNlIGlmIChzZWxmLmxpc3RlbmVyQ291bnQoJ2RhdGEnKSA+IDApIHtcbiAgICBzZWxmLnJlc3VtZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn0gLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpOyAvLyB3ZSBmbG93IG9ubHkgaWYgdGhlcmUgaXMgbm8gb25lIGxpc3RlbmluZ1xuICAgIC8vIGZvciByZWFkYWJsZSwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gY2FsbFxuICAgIC8vIHJlc3VtZSgpXG5cbiAgICBzdGF0ZS5mbG93aW5nID0gIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cblxuICBzdGF0ZS5wYXVzZWQgPSBmYWxzZTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgZGVidWcoJ3Jlc3VtZScsIHN0YXRlLnJlYWRpbmcpO1xuXG4gIGlmICghc3RhdGUucmVhZGluZykge1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0cmVhbS5lbWl0KCdyZXN1bWUnKTtcbiAgZmxvdyhzdHJlYW0pO1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XG59XG5cblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcbiAgZGVidWcoJ2NhbGwgcGF1c2UgZmxvd2luZz0laicsIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyk7XG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyAhPT0gZmFsc2UpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnBhdXNlZCA9IHRydWU7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZmxvdyhzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xuXG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHtcbiAgICA7XG4gIH1cbn0gLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuXG5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBfdGhpcy5wdXNoKGNodW5rKTtcbiAgICB9XG5cbiAgICBfdGhpcy5wdXNoKG51bGwpO1xuICB9KTtcbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspOyAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcblxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcblxuICAgIHZhciByZXQgPSBfdGhpcy5wdXNoKGNodW5rKTtcblxuICAgIGlmICghcmV0KSB7XG4gICAgICBwYXVzZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLnBhdXNlKCk7XG4gICAgfVxuICB9KTsgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cblxuICBmb3IgKHZhciBpIGluIHN0cmVhbSkge1xuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc1tpXSA9IGZ1bmN0aW9uIG1ldGhvZFdyYXAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBtZXRob2RXcmFwUmV0dXJuRnVuY3Rpb24oKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9IC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cblxuXG4gIGZvciAodmFyIG4gPSAwOyBuIDwga1Byb3h5RXZlbnRzLmxlbmd0aDsgbisrKSB7XG4gICAgc3RyZWFtLm9uKGtQcm94eUV2ZW50c1tuXSwgdGhpcy5lbWl0LmJpbmQodGhpcywga1Byb3h5RXZlbnRzW25dKSk7XG4gIH0gLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cblxuXG4gIHRoaXMuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG5cbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5pZiAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJykge1xuICBSZWFkYWJsZS5wcm90b3R5cGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkge1xuICAgIGlmIChjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgY3JlYXRlUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2FzeW5jX2l0ZXJhdG9yJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNyZWF0ZVJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvcih0aGlzKTtcbiAgfTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ3JlYWRhYmxlSGlnaFdhdGVyTWFyaycsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuaGlnaFdhdGVyTWFyaztcbiAgfVxufSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVCdWZmZXInLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuYnVmZmVyO1xuICB9XG59KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShSZWFkYWJsZS5wcm90b3R5cGUsICdyZWFkYWJsZUZsb3dpbmcnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmc7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gc2V0KHN0YXRlKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IHN0YXRlO1xuICAgIH1cbiAgfVxufSk7IC8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cblxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAncmVhZGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7IC8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cblxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuZmlyc3QoKTtlbHNlIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25jYXQoc3RhdGUubGVuZ3RoKTtcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZWFkIHBhcnQgb2YgbGlzdFxuICAgIHJldCA9IHN0YXRlLmJ1ZmZlci5jb25zdW1lKG4sIHN0YXRlLmRlY29kZXIpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdlbmRSZWFkYWJsZScsIHN0YXRlLmVuZEVtaXR0ZWQpO1xuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xuICAgIHN0YXRlLmVuZGVkID0gdHJ1ZTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICBkZWJ1ZygnZW5kUmVhZGFibGVOVCcsIHN0YXRlLmVuZEVtaXR0ZWQsIHN0YXRlLmxlbmd0aCk7IC8vIENoZWNrIHRoYXQgd2UgZGlkbid0IGdldCBvbmUgbGFzdCB1bnNoaWZ0LlxuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG5cbiAgICBpZiAoc3RhdGUuYXV0b0Rlc3Ryb3kpIHtcbiAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgIC8vIGlmIHRoZSB3cml0YWJsZSBzaWRlIGlzIHJlYWR5IGZvciBhdXRvRGVzdHJveSBhcyB3ZWxsXG4gICAgICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuXG4gICAgICBpZiAoIXdTdGF0ZSB8fCB3U3RhdGUuYXV0b0Rlc3Ryb3kgJiYgd1N0YXRlLmZpbmlzaGVkKSB7XG4gICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nKSB7XG4gIFJlYWRhYmxlLmZyb20gPSBmdW5jdGlvbiAoaXRlcmFibGUsIG9wdHMpIHtcbiAgICBpZiAoZnJvbSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmcm9tID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Zyb20nKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnJvbShSZWFkYWJsZSwgaXRlcmFibGUsIG9wdHMpO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgfVxuXG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cbi8vIGEgdHJhbnNmb3JtIHN0cmVhbSBpcyBhIHJlYWRhYmxlL3dyaXRhYmxlIHN0cmVhbSB3aGVyZSB5b3UgZG9cbi8vIHNvbWV0aGluZyB3aXRoIHRoZSBkYXRhLiAgU29tZXRpbWVzIGl0J3MgY2FsbGVkIGEgXCJmaWx0ZXJcIixcbi8vIGJ1dCB0aGF0J3Mgbm90IGEgZ3JlYXQgbmFtZSBmb3IgaXQsIHNpbmNlIHRoYXQgaW1wbGllcyBhIHRoaW5nIHdoZXJlXG4vLyBzb21lIGJpdHMgcGFzcyB0aHJvdWdoLCBhbmQgb3RoZXJzIGFyZSBzaW1wbHkgaWdub3JlZC4gIChUaGF0IHdvdWxkXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXG4vL1xuLy8gV2hpbGUgdGhlIG91dHB1dCBpcyBjYXVzYWxseSByZWxhdGVkIHRvIHRoZSBpbnB1dCwgaXQncyBub3QgYVxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXG4vLyBhIHpsaWIgc3RyZWFtIG1pZ2h0IHRha2UgbXVsdGlwbGUgcGxhaW4tdGV4dCB3cml0ZXMoKSwgYW5kIHRoZW5cbi8vIGVtaXQgYSBzaW5nbGUgY29tcHJlc3NlZCBjaHVuayBzb21lIHRpbWUgaW4gdGhlIGZ1dHVyZS5cbi8vXG4vLyBIZXJlJ3MgaG93IHRoaXMgd29ya3M6XG4vL1xuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXG4vLyBzdHJlYW0gY2xhc3Nlcy4gIFdoZW4geW91IHdyaXRlKGNodW5rKSwgdGhhdCBjYWxscyBfd3JpdGUoY2h1bmssY2IpXG4vLyBpbnRlcm5hbGx5LCBhbmQgcmV0dXJucyBmYWxzZSBpZiB0aGVyZSdzIGEgbG90IG9mIHBlbmRpbmcgd3JpdGVzXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXG4vLyB0aGVyZSdzIGVub3VnaCBwZW5kaW5nIHJlYWRhYmxlIGRhdGEgYnVmZmVyZWQgdXAuXG4vL1xuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cbi8vIF9yZWFkKG4pIGlzIGNhbGxlZCwgaXQgdHJhbnNmb3JtcyB0aGUgcXVldWVkIHVwIGRhdGEsIGNhbGxpbmcgdGhlXG4vLyBidWZmZXJlZCBfd3JpdGUgY2IncyBhcyBpdCBjb25zdW1lcyBjaHVua3MuICBJZiBjb25zdW1pbmcgYSBzaW5nbGVcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XG4vLyBvdXRwdXR0ZWQgYml0IGNhbGxzIHRoZSByZWFkY2IsIGFuZCBzdWJzZXF1ZW50IGNodW5rcyBqdXN0IGdvIGludG9cbi8vIHRoZSByZWFkIGJ1ZmZlciwgYW5kIHdpbGwgY2F1c2UgaXQgdG8gZW1pdCAncmVhZGFibGUnIGlmIG5lY2Vzc2FyeS5cbi8vXG4vLyBUaGlzIHdheSwgYmFjay1wcmVzc3VyZSBpcyBhY3R1YWxseSBkZXRlcm1pbmVkIGJ5IHRoZSByZWFkaW5nIHNpZGUsXG4vLyBzaW5jZSBfcmVhZCBoYXMgdG8gYmUgY2FsbGVkIHRvIHN0YXJ0IHByb2Nlc3NpbmcgYSBuZXcgY2h1bmsuICBIb3dldmVyLFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xuLy8gaGVyZS4gIEZvciBleGFtcGxlLCBpbWFnaW5lIGEgc3RyZWFtIHdoZXJlIGV2ZXJ5IGJ5dGUgb2YgaW5wdXQgaXNcbi8vIGludGVycHJldGVkIGFzIGFuIGludGVnZXIgZnJvbSAwLTI1NSwgYW5kIHRoZW4gcmVzdWx0cyBpbiB0aGF0IG1hbnlcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cbi8vIDFrYiBvZiBkYXRhIGJlaW5nIG91dHB1dC4gIEluIHRoaXMgY2FzZSwgeW91IGNvdWxkIHdyaXRlIGEgdmVyeSBzbWFsbFxuLy8gYW1vdW50IG9mIGlucHV0LCBhbmQgZW5kIHVwIHdpdGggYSB2ZXJ5IGxhcmdlIGFtb3VudCBvZiBvdXRwdXQuICBJblxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXG4vLyB0aGUgc3lzdGVtIHRvIHN0b3AgZG9pbmcgdGhlIHRyYW5zZm9ybS4gIEEgc2luZ2xlIDRNQiB3cml0ZSBjb3VsZFxuLy8gY2F1c2UgdGhlIHN5c3RlbSB0byBydW4gb3V0IG9mIG1lbW9yeS5cbi8vXG4vLyBIb3dldmVyLCBldmVuIGluIHN1Y2ggYSBwYXRob2xvZ2ljYWwgY2FzZSwgb25seSBhIHNpbmdsZSB3cml0dGVuIGNodW5rXG4vLyB3b3VsZCBiZSBjb25zdW1lZCwgYW5kIHRoZW4gdGhlIHJlc3Qgd291bGQgd2FpdCAodW4tdHJhbnNmb3JtZWQpIHVudGlsXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfVFJBTlNGT1JNX0FMUkVBRFlfVFJBTlNGT1JNSU5HLFxuICAgIEVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMCA9IF9yZXF1aXJlJGNvZGVzLkVSUl9UUkFOU0ZPUk1fV0lUSF9MRU5HVEhfMDtcblxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdmFyIGNiID0gdHMud3JpdGVjYjtcblxuICBpZiAoY2IgPT09IG51bGwpIHtcbiAgICByZXR1cm4gdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG4gIGlmIChkYXRhICE9IG51bGwpIC8vIHNpbmdsZSBlcXVhbHMgY2hlY2sgZm9yIGJvdGggYG51bGxgIGFuZCBgdW5kZWZpbmVkYFxuICAgIHRoaXMucHVzaChkYXRhKTtcbiAgY2IoZXIpO1xuICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG5cbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IHtcbiAgICBhZnRlclRyYW5zZm9ybTogYWZ0ZXJUcmFuc2Zvcm0uYmluZCh0aGlzKSxcbiAgICBuZWVkVHJhbnNmb3JtOiBmYWxzZSxcbiAgICB0cmFuc2Zvcm1pbmc6IGZhbHNlLFxuICAgIHdyaXRlY2I6IG51bGwsXG4gICAgd3JpdGVjaHVuazogbnVsbCxcbiAgICB3cml0ZWVuY29kaW5nOiBudWxsXG4gIH07IC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTsgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXG4gIC8vIHRoYXQgUmVhZGFibGUgd2FudHMgYmVmb3JlIHRoZSBmaXJzdCBfcmVhZCBjYWxsLCBzbyB1bnNldCB0aGVcbiAgLy8gc3luYyBndWFyZCBmbGFnLlxuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaCA9IG9wdGlvbnMuZmx1c2g7XG4gIH0gLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuXG5cbiAgdGhpcy5vbigncHJlZmluaXNoJywgcHJlZmluaXNoKTtcbn1cblxuZnVuY3Rpb24gcHJlZmluaXNoKCkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIGlmICh0eXBlb2YgdGhpcy5fZmx1c2ggPT09ICdmdW5jdGlvbicgJiYgIXRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkKSB7XG4gICAgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKF90aGlzLCBlciwgZGF0YSk7XG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgZG9uZSh0aGlzLCBudWxsLCBudWxsKTtcbiAgfVxufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59OyAvLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuXG5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFUlJfTUVUSE9EX05PVF9JTVBMRU1FTlRFRCgnX3RyYW5zZm9ybSgpJykpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcblxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07IC8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHRzLnRyYW5zZm9ybWluZyA9IHRydWU7XG5cbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIER1cGxleC5wcm90b3R5cGUuX2Rlc3Ryb3kuY2FsbCh0aGlzLCBlcnIsIGZ1bmN0aW9uIChlcnIyKSB7XG4gICAgY2IoZXJyMik7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgaWYgKGRhdGEgIT0gbnVsbCkgLy8gc2luZ2xlIGVxdWFscyBjaGVjayBmb3IgYm90aCBgbnVsbGAgYW5kIGB1bmRlZmluZWRgXG4gICAgc3RyZWFtLnB1c2goZGF0YSk7IC8vIFRPRE8oQnJpZGdlQVIpOiBXcml0ZSBhIHRlc3QgZm9yIHRoZXNlIHR3byBlcnJvciBjYXNlc1xuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuXG4gIGlmIChzdHJlYW0uX3dyaXRhYmxlU3RhdGUubGVuZ3RoKSB0aHJvdyBuZXcgRVJSX1RSQU5TRk9STV9XSVRIX0xFTkdUSF8wKCk7XG4gIGlmIChzdHJlYW0uX3RyYW5zZm9ybVN0YXRlLnRyYW5zZm9ybWluZykgdGhyb3cgbmV3IEVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkcoKTtcbiAgcmV0dXJuIHN0cmVhbS5wdXNoKG51bGwpO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuLyogPHJlcGxhY2VtZW50PiAqL1xuXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59IC8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5cblxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHRoaXMubmV4dCA9IG51bGw7XG4gIHRoaXMuZW50cnkgPSBudWxsO1xuXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuV3JpdGFibGUuV3JpdGFibGVTdGF0ZSA9IFdyaXRhYmxlU3RhdGU7XG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdidWZmZXInKS5CdWZmZXI7XG5cbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5cbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcbiAgcmV0dXJuIEJ1ZmZlci5mcm9tKGNodW5rKTtcbn1cblxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG5cbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XG5cbnZhciBfcmVxdWlyZSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdGF0ZScpLFxuICAgIGdldEhpZ2hXYXRlck1hcmsgPSBfcmVxdWlyZS5nZXRIaWdoV2F0ZXJNYXJrO1xuXG52YXIgX3JlcXVpcmUkY29kZXMgPSByZXF1aXJlKCcuLi9lcnJvcnMnKS5jb2RlcyxcbiAgICBFUlJfSU5WQUxJRF9BUkdfVFlQRSA9IF9yZXF1aXJlJGNvZGVzLkVSUl9JTlZBTElEX0FSR19UWVBFLFxuICAgIEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEID0gX3JlcXVpcmUkY29kZXMuRVJSX01FVEhPRF9OT1RfSU1QTEVNRU5URUQsXG4gICAgRVJSX01VTFRJUExFX0NBTExCQUNLID0gX3JlcXVpcmUkY29kZXMuRVJSX01VTFRJUExFX0NBTExCQUNLLFxuICAgIEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX0NBTk5PVF9QSVBFLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQsXG4gICAgRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9TVFJFQU1fTlVMTF9WQUxVRVMsXG4gICAgRVJSX1NUUkVBTV9XUklURV9BRlRFUl9FTkQgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfU1RSRUFNX1dSSVRFX0FGVEVSX0VORCxcbiAgICBFUlJfVU5LTk9XTl9FTkNPRElORyA9IF9yZXF1aXJlJGNvZGVzLkVSUl9VTktOT1dOX0VOQ09ESU5HO1xuXG52YXIgZXJyb3JPckRlc3Ryb3kgPSBkZXN0cm95SW1wbC5lcnJvck9yRGVzdHJveTtcblxucmVxdWlyZSgnaW5oZXJpdHMnKShXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0sIGlzRHVwbGV4KSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9OyAvLyBEdXBsZXggc3RyZWFtcyBhcmUgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUsIGJ1dCBzaGFyZVxuICAvLyB0aGUgc2FtZSBvcHRpb25zIG9iamVjdC5cbiAgLy8gSG93ZXZlciwgc29tZSBjYXNlcyByZXF1aXJlIHNldHRpbmcgb3B0aW9ucyB0byBkaWZmZXJlbnRcbiAgLy8gdmFsdWVzIGZvciB0aGUgcmVhZGFibGUgYW5kIHRoZSB3cml0YWJsZSBzaWRlcyBvZiB0aGUgZHVwbGV4IHN0cmVhbSxcbiAgLy8gZS5nLiBvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZSB2cy4gb3B0aW9ucy53cml0YWJsZU9iamVjdE1vZGUsIGV0Yy5cblxuICBpZiAodHlwZW9mIGlzRHVwbGV4ICE9PSAnYm9vbGVhbicpIGlzRHVwbGV4ID0gc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4OyAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuICBpZiAoaXNEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlOyAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcblxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBnZXRIaWdoV2F0ZXJNYXJrKHRoaXMsIG9wdGlvbnMsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCBpc0R1cGxleCk7IC8vIGlmIF9maW5hbCBoYXMgYmVlbiBjYWxsZWRcblxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7IC8vIGRyYWluIGV2ZW50IGZsYWcuXG5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTsgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcblxuICB0aGlzLmVuZGluZyA9IGZhbHNlOyAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG5cbiAgdGhpcy5lbmRlZCA9IGZhbHNlOyAvLyB3aGVuICdmaW5pc2gnIGlzIGVtaXR0ZWRcblxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7IC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7IC8vIHNob3VsZCB3ZSBkZWNvZGUgc3RyaW5ncyBpbnRvIGJ1ZmZlcnMgYmVmb3JlIHBhc3NpbmcgdG8gX3dyaXRlP1xuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcbiAgLy8gaGFuZGxpbmcgYXQgYSBsb3dlciBsZXZlbC5cblxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7IC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7IC8vIG5vdCBhbiBhY3R1YWwgYnVmZmVyIHdlIGtlZXAgdHJhY2sgb2YsIGJ1dCBhIG1lYXN1cmVtZW50XG4gIC8vIG9mIGhvdyBtdWNoIHdlJ3JlIHdhaXRpbmcgdG8gZ2V0IHB1c2hlZCB0byBzb21lIHVuZGVybHlpbmdcbiAgLy8gc29ja2V0IG9yIGZpbGUuXG5cbiAgdGhpcy5sZW5ndGggPSAwOyAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlOyAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXG5cbiAgdGhpcy5jb3JrZWQgPSAwOyAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcbiAgLy8gb3Igb24gYSBsYXRlciB0aWNrLiAgV2Ugc2V0IHRoaXMgdG8gdHJ1ZSBhdCBmaXJzdCwgYmVjYXVzZSBhbnlcbiAgLy8gYWN0aW9ucyB0aGF0IHNob3VsZG4ndCBoYXBwZW4gdW50aWwgXCJsYXRlclwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xuICAvLyBub3QgaGFwcGVuIGJlZm9yZSB0aGUgZmlyc3Qgd3JpdGUgY2FsbC5cblxuICB0aGlzLnN5bmMgPSB0cnVlOyAvLyBhIGZsYWcgdG8ga25vdyBpZiB3ZSdyZSBwcm9jZXNzaW5nIHByZXZpb3VzbHkgYnVmZmVyZWQgaXRlbXMsIHdoaWNoXG4gIC8vIG1heSBjYWxsIHRoZSBfd3JpdGUoKSBjYWxsYmFjayBpbiB0aGUgc2FtZSB0aWNrLCBzbyB0aGF0IHdlIGRvbid0XG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxuXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlOyAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXG5cbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTsgLy8gdGhlIGNhbGxiYWNrIHRoYXQgdGhlIHVzZXIgc3VwcGxpZXMgdG8gd3JpdGUoY2h1bmssZW5jb2RpbmcsY2IpXG5cblxuICB0aGlzLndyaXRlY2IgPSBudWxsOyAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDsgLy8gbnVtYmVyIG9mIHBlbmRpbmcgdXNlci1zdXBwbGllZCB3cml0ZSBjYWxsYmFja3NcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXG5cbiAgdGhpcy5wZW5kaW5nY2IgPSAwOyAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXG4gIC8vIFRoaXMgaXMgcmVsZXZhbnQgZm9yIHN5bmNocm9ub3VzIFRyYW5zZm9ybSBzdHJlYW1zXG5cbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlOyAvLyBUcnVlIGlmIHRoZSBlcnJvciB3YXMgYWxyZWFkeSBlbWl0dGVkIGFuZCBzaG91bGQgbm90IGJlIHRocm93biBhZ2FpblxuXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7IC8vIFNob3VsZCBjbG9zZSBiZSBlbWl0dGVkIG9uIGRlc3Ryb3kuIERlZmF1bHRzIHRvIHRydWUuXG5cbiAgdGhpcy5lbWl0Q2xvc2UgPSBvcHRpb25zLmVtaXRDbG9zZSAhPT0gZmFsc2U7IC8vIFNob3VsZCAuZGVzdHJveSgpIGJlIGNhbGxlZCBhZnRlciAnZmluaXNoJyAoYW5kIHBvdGVudGlhbGx5ICdlbmQnKVxuXG4gIHRoaXMuYXV0b0Rlc3Ryb3kgPSAhIW9wdGlvbnMuYXV0b0Rlc3Ryb3k7IC8vIGNvdW50IGJ1ZmZlcmVkIHJlcXVlc3RzXG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7IC8vIGFsbG9jYXRlIHRoZSBmaXJzdCBDb3JrZWRSZXF1ZXN0LCB0aGVyZSBpcyBhbHdheXNcbiAgLy8gb25lIGFsbG9jYXRlZCBhbmQgZnJlZSB0byB1c2UsIGFuZCB3ZSBtYWludGFpbiBhdCBtb3N0IHR3b1xuXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuXG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuXG4gIHJldHVybiBvdXQ7XG59O1xuXG4oZnVuY3Rpb24gKCkge1xuICB0cnkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcbiAgICAgIGdldDogaW50ZXJuYWxVdGlsLmRlcHJlY2F0ZShmdW5jdGlvbiB3cml0YWJsZVN0YXRlQnVmZmVyR2V0dGVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTsgLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG5cblxudmFyIHJlYWxIYXNJbnN0YW5jZTtcblxuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUob2JqZWN0KSB7XG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcyAhPT0gV3JpdGFibGUpIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgb2JqZWN0Ll93cml0YWJsZVN0YXRlIGluc3RhbmNlb2YgV3JpdGFibGVTdGF0ZTtcbiAgICB9XG4gIH0pO1xufSBlbHNlIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gcmVhbEhhc0luc3RhbmNlKG9iamVjdCkge1xuICAgIHJldHVybiBvYmplY3QgaW5zdGFuY2VvZiB0aGlzO1xuICB9O1xufVxuXG5mdW5jdGlvbiBXcml0YWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7IC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgLy8gQ2hlY2tpbmcgZm9yIGEgU3RyZWFtLkR1cGxleCBpbnN0YW5jZSBpcyBmYXN0ZXIgaGVyZSBpbnN0ZWFkIG9mIGluc2lkZVxuICAvLyB0aGUgV3JpdGFibGVTdGF0ZSBjb25zdHJ1Y3RvciwgYXQgbGVhc3Qgd2l0aCBWOCA2LjVcblxuICB2YXIgaXNEdXBsZXggPSB0aGlzIGluc3RhbmNlb2YgRHVwbGV4O1xuICBpZiAoIWlzRHVwbGV4ICYmICFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykpIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzLCBpc0R1cGxleCk7IC8vIGxlZ2FjeS5cblxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59IC8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cblxuXG5Xcml0YWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uICgpIHtcbiAgZXJyb3JPckRlc3Ryb3kodGhpcywgbmV3IEVSUl9TVFJFQU1fQ0FOTk9UX1BJUEUoKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EKCk7IC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG5cbiAgZXJyb3JPckRlc3Ryb3koc3RyZWFtLCBlcik7XG4gIHByb2Nlc3MubmV4dFRpY2soY2IsIGVyKTtcbn0gLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuXG5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciBlcjtcblxuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBlciA9IG5ldyBFUlJfU1RSRUFNX05VTExfVkFMVUVTKCk7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IEVSUl9JTlZBTElEX0FSR19UWVBFKCdjaHVuaycsIFsnc3RyaW5nJywgJ0J1ZmZlciddLCBjaHVuayk7XG4gIH1cblxuICBpZiAoZXIpIHtcbiAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVyKTtcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcblxuICB2YXIgaXNCdWYgPSAhc3RhdGUub2JqZWN0TW9kZSAmJiBfaXNVaW50OEFycmF5KGNodW5rKTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuICBpZiAoc3RhdGUuZW5kaW5nKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fd3JpdGFibGVTdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuICAgIGlmICghc3RhdGUud3JpdGluZyAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgRVJSX1VOS05PV05fRU5DT0RJTkcoZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUJ1ZmZlcicsIHtcbiAgLy8gbWFraW5nIGl0IGV4cGxpY2l0IHRoaXMgcHJvcGVydHkgaXMgbm90IGVudW1lcmFibGVcbiAgLy8gYmVjYXVzZSBvdGhlcndpc2Ugc29tZSBwcm90b3R5cGUgbWFuaXB1bGF0aW9uIGluXG4gIC8vIHVzZXJsYW5kIHdpbGwgZmFpbFxuICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgZ2V0OiBmdW5jdGlvbiBnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIoKTtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cblxuICByZXR1cm4gY2h1bms7XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICd3cml0YWJsZUhpZ2hXYXRlck1hcmsnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIH1cbn0pOyAvLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcblxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcbiAgICAgIGlzQnVmID0gdHJ1ZTtcbiAgICAgIGVuY29kaW5nID0gJ2J1ZmZlcic7XG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xuICAgIH1cbiAgfVxuXG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgc3RhdGUubGVuZ3RoICs9IGxlbjtcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7IC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xuXG4gIGlmIChzdGF0ZS53cml0aW5nIHx8IHN0YXRlLmNvcmtlZCkge1xuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0ge1xuICAgICAgY2h1bms6IGNodW5rLFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgaXNCdWY6IGlzQnVmLFxuICAgICAgY2FsbGJhY2s6IGNiLFxuICAgICAgbmV4dDogbnVsbFxuICAgIH07XG5cbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHN0YXRlLmRlc3Ryb3llZCkgc3RhdGUub253cml0ZShuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3dyaXRlJykpO2Vsc2UgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzLm5leHRUaWNrKGNiLCBlcik7IC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBhbmQgaXQgd2lsbCBhbHdheXMgaGFwcGVuXG4gICAgLy8gYWZ0ZXIgZXJyb3JcblxuICAgIHByb2Nlc3MubmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIGVycm9yT3JEZXN0cm95KHN0cmVhbSwgZXIpOyAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBFUlJfTVVMVElQTEVfQ0FMTEJBQ0soKTtcbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpIHx8IHN0cmVhbS5kZXN0cm95ZWQ7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufSAvLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cblxuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59IC8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5cblxuZnVuY3Rpb24gY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSkge1xuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcbiAgdmFyIGVudHJ5ID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0O1xuXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XG4gICAgLy8gRmFzdCBjYXNlLCB3cml0ZSBldmVyeXRoaW5nIHVzaW5nIF93cml0ZXYoKVxuICAgIHZhciBsID0gc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQ7XG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcbiAgICB2YXIgaG9sZGVyID0gc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlO1xuICAgIGhvbGRlci5lbnRyeSA9IGVudHJ5O1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICBidWZmZXJbY291bnRdID0gZW50cnk7XG4gICAgICBpZiAoIWVudHJ5LmlzQnVmKSBhbGxCdWZmZXJzID0gZmFsc2U7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cblxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHRydWUsIHN0YXRlLmxlbmd0aCwgYnVmZmVyLCAnJywgaG9sZGVyLmZpbmlzaCk7IC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG5cbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAgIGlmIChob2xkZXIubmV4dCkge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XG4gICAgICBob2xkZXIubmV4dCA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgdmFyIGNodW5rID0gZW50cnkuY2h1bms7XG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcbiAgICAgIHZhciBjYiA9IGVudHJ5LmNhbGxiYWNrO1xuICAgICAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50LS07IC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG5cbiAgICAgIGlmIChzdGF0ZS53cml0aW5nKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gIH1cblxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEKCdfd3JpdGUoKScpKTtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcblxuV3JpdGFibGUucHJvdG90eXBlLmVuZCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gY2h1bms7XG4gICAgY2h1bmsgPSBudWxsO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChjaHVuayAhPT0gbnVsbCAmJiBjaHVuayAhPT0gdW5kZWZpbmVkKSB0aGlzLndyaXRlKGNodW5rLCBlbmNvZGluZyk7IC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZCA9IDE7XG4gICAgdGhpcy51bmNvcmsoKTtcbiAgfSAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG5cblxuICBpZiAoIXN0YXRlLmVuZGluZykgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnd3JpdGFibGVMZW5ndGgnLCB7XG4gIC8vIG1ha2luZyBpdCBleHBsaWNpdCB0aGlzIHByb3BlcnR5IGlzIG5vdCBlbnVtZXJhYmxlXG4gIC8vIGJlY2F1c2Ugb3RoZXJ3aXNlIHNvbWUgcHJvdG90eXBlIG1hbmlwdWxhdGlvbiBpblxuICAvLyB1c2VybGFuZCB3aWxsIGZhaWxcbiAgZW51bWVyYWJsZTogZmFsc2UsXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmxlbmd0aDtcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cblxuZnVuY3Rpb24gY2FsbEZpbmFsKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG5cbiAgICBpZiAoZXJyKSB7XG4gICAgICBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgc3RhdGUucHJlZmluaXNoZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nICYmICFzdGF0ZS5kZXN0cm95ZWQpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcblxuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcblxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcbiAgICAgIHN0YXRlLmZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdmaW5pc2gnKTtcblxuICAgICAgaWYgKHN0YXRlLmF1dG9EZXN0cm95KSB7XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgZHVwbGV4IHN0cmVhbXMgd2UgbmVlZCBhIHdheSB0byBkZXRlY3RcbiAgICAgICAgLy8gaWYgdGhlIHJlYWRhYmxlIHNpZGUgaXMgcmVhZHkgZm9yIGF1dG9EZXN0cm95IGFzIHdlbGxcbiAgICAgICAgdmFyIHJTdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAgICAgICBpZiAoIXJTdGF0ZSB8fCByU3RhdGUuYXV0b0Rlc3Ryb3kgJiYgclN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWQ7XG59XG5cbmZ1bmN0aW9uIGVuZFdyaXRhYmxlKHN0cmVhbSwgc3RhdGUsIGNiKSB7XG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuXG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzcy5uZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xuICB9XG5cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcblxuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfSAvLyByZXVzZSB0aGUgZnJlZSBjb3JrUmVxLlxuXG5cbiAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICAvLyBtYWtpbmcgaXQgZXhwbGljaXQgdGhpcyBwcm9wZXJ0eSBpcyBub3QgZW51bWVyYWJsZVxuICAvLyBiZWNhdXNlIG90aGVyd2lzZSBzb21lIHByb3RvdHlwZSBtYW5pcHVsYXRpb24gaW5cbiAgLy8gdXNlcmxhbmQgd2lsbCBmYWlsXG4gIGVudW1lcmFibGU6IGZhbHNlLFxuICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uIHNldCh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9IC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcblxuXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgX09iamVjdCRzZXRQcm90b3R5cGVPO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7IGlmIChrZXkgaW4gb2JqKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgeyB2YWx1ZTogdmFsdWUsIGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfSk7IH0gZWxzZSB7IG9ialtrZXldID0gdmFsdWU7IH0gcmV0dXJuIG9iajsgfVxuXG52YXIgZmluaXNoZWQgPSByZXF1aXJlKCcuL2VuZC1vZi1zdHJlYW0nKTtcblxudmFyIGtMYXN0UmVzb2x2ZSA9IFN5bWJvbCgnbGFzdFJlc29sdmUnKTtcbnZhciBrTGFzdFJlamVjdCA9IFN5bWJvbCgnbGFzdFJlamVjdCcpO1xudmFyIGtFcnJvciA9IFN5bWJvbCgnZXJyb3InKTtcbnZhciBrRW5kZWQgPSBTeW1ib2woJ2VuZGVkJyk7XG52YXIga0xhc3RQcm9taXNlID0gU3ltYm9sKCdsYXN0UHJvbWlzZScpO1xudmFyIGtIYW5kbGVQcm9taXNlID0gU3ltYm9sKCdoYW5kbGVQcm9taXNlJyk7XG52YXIga1N0cmVhbSA9IFN5bWJvbCgnc3RyZWFtJyk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUl0ZXJSZXN1bHQodmFsdWUsIGRvbmUpIHtcbiAgcmV0dXJuIHtcbiAgICB2YWx1ZTogdmFsdWUsXG4gICAgZG9uZTogZG9uZVxuICB9O1xufVxuXG5mdW5jdGlvbiByZWFkQW5kUmVzb2x2ZShpdGVyKSB7XG4gIHZhciByZXNvbHZlID0gaXRlcltrTGFzdFJlc29sdmVdO1xuXG4gIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgdmFyIGRhdGEgPSBpdGVyW2tTdHJlYW1dLnJlYWQoKTsgLy8gd2UgZGVmZXIgaWYgZGF0YSBpcyBudWxsXG4gICAgLy8gd2UgY2FuIGJlIGV4cGVjdGluZyBlaXRoZXIgJ2VuZCcgb3JcbiAgICAvLyAnZXJyb3InXG5cbiAgICBpZiAoZGF0YSAhPT0gbnVsbCkge1xuICAgICAgaXRlcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICBpdGVyW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gb25SZWFkYWJsZShpdGVyKSB7XG4gIC8vIHdlIHdhaXQgZm9yIHRoZSBuZXh0IHRpY2ssIGJlY2F1c2UgaXQgbWlnaHRcbiAgLy8gZW1pdCBhbiBlcnJvciB3aXRoIHByb2Nlc3MubmV4dFRpY2tcbiAgcHJvY2Vzcy5uZXh0VGljayhyZWFkQW5kUmVzb2x2ZSwgaXRlcik7XG59XG5cbmZ1bmN0aW9uIHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCBpdGVyKSB7XG4gIHJldHVybiBmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgbGFzdFByb21pc2UudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoaXRlcltrRW5kZWRdKSB7XG4gICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpdGVyW2tIYW5kbGVQcm9taXNlXShyZXNvbHZlLCByZWplY3QpO1xuICAgIH0sIHJlamVjdCk7XG4gIH07XG59XG5cbnZhciBBc3luY0l0ZXJhdG9yUHJvdG90eXBlID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKGZ1bmN0aW9uICgpIHt9KTtcbnZhciBSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3JQcm90b3R5cGUgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YoKF9PYmplY3Qkc2V0UHJvdG90eXBlTyA9IHtcbiAgZ2V0IHN0cmVhbSgpIHtcbiAgICByZXR1cm4gdGhpc1trU3RyZWFtXTtcbiAgfSxcblxuICBuZXh0OiBmdW5jdGlvbiBuZXh0KCkge1xuICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAvLyBpZiB3ZSBoYXZlIGRldGVjdGVkIGFuIGVycm9yIGluIHRoZSBtZWFud2hpbGVcbiAgICAvLyByZWplY3Qgc3RyYWlnaHQgYXdheVxuICAgIHZhciBlcnJvciA9IHRoaXNba0Vycm9yXTtcblxuICAgIGlmIChlcnJvciAhPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcbiAgICB9XG5cbiAgICBpZiAodGhpc1trRW5kZWRdKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQodW5kZWZpbmVkLCB0cnVlKSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXNba1N0cmVhbV0uZGVzdHJveWVkKSB7XG4gICAgICAvLyBXZSBuZWVkIHRvIGRlZmVyIHZpYSBuZXh0VGljayBiZWNhdXNlIGlmIC5kZXN0cm95KGVycikgaXNcbiAgICAgIC8vIGNhbGxlZCwgdGhlIGVycm9yIHdpbGwgYmUgZW1pdHRlZCB2aWEgbmV4dFRpY2ssIGFuZFxuICAgICAgLy8gd2UgY2Fubm90IGd1YXJhbnRlZSB0aGF0IHRoZXJlIGlzIG5vIGVycm9yIGxpbmdlcmluZyBhcm91bmRcbiAgICAgIC8vIHdhaXRpbmcgdG8gYmUgZW1pdHRlZC5cbiAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGlmIChfdGhpc1trRXJyb3JdKSB7XG4gICAgICAgICAgICByZWplY3QoX3RoaXNba0Vycm9yXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSAvLyBpZiB3ZSBoYXZlIG11bHRpcGxlIG5leHQoKSBjYWxsc1xuICAgIC8vIHdlIHdpbGwgd2FpdCBmb3IgdGhlIHByZXZpb3VzIFByb21pc2UgdG8gZmluaXNoXG4gICAgLy8gdGhpcyBsb2dpYyBpcyBvcHRpbWl6ZWQgdG8gc3VwcG9ydCBmb3IgYXdhaXQgbG9vcHMsXG4gICAgLy8gd2hlcmUgbmV4dCgpIGlzIG9ubHkgY2FsbGVkIG9uY2UgYXQgYSB0aW1lXG5cblxuICAgIHZhciBsYXN0UHJvbWlzZSA9IHRoaXNba0xhc3RQcm9taXNlXTtcbiAgICB2YXIgcHJvbWlzZTtcblxuICAgIGlmIChsYXN0UHJvbWlzZSkge1xuICAgICAgcHJvbWlzZSA9IG5ldyBQcm9taXNlKHdyYXBGb3JOZXh0KGxhc3RQcm9taXNlLCB0aGlzKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZhc3QgcGF0aCBuZWVkZWQgdG8gc3VwcG9ydCBtdWx0aXBsZSB0aGlzLnB1c2goKVxuICAgICAgLy8gd2l0aG91dCB0cmlnZ2VyaW5nIHRoZSBuZXh0KCkgcXVldWVcbiAgICAgIHZhciBkYXRhID0gdGhpc1trU3RyZWFtXS5yZWFkKCk7XG5cbiAgICAgIGlmIChkYXRhICE9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoY3JlYXRlSXRlclJlc3VsdChkYXRhLCBmYWxzZSkpO1xuICAgICAgfVxuXG4gICAgICBwcm9taXNlID0gbmV3IFByb21pc2UodGhpc1trSGFuZGxlUHJvbWlzZV0pO1xuICAgIH1cblxuICAgIHRoaXNba0xhc3RQcm9taXNlXSA9IHByb21pc2U7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbn0sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFN5bWJvbC5hc3luY0l0ZXJhdG9yLCBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzO1xufSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JHNldFByb3RvdHlwZU8sIFwicmV0dXJuXCIsIGZ1bmN0aW9uIF9yZXR1cm4oKSB7XG4gIHZhciBfdGhpczIgPSB0aGlzO1xuXG4gIC8vIGRlc3Ryb3koZXJyLCBjYikgaXMgYSBwcml2YXRlIEFQSVxuICAvLyB3ZSBjYW4gZ3VhcmFudGVlIHdlIGhhdmUgdGhhdCBoZXJlLCBiZWNhdXNlIHdlIGNvbnRyb2wgdGhlXG4gIC8vIFJlYWRhYmxlIGNsYXNzIHRoaXMgaXMgYXR0YWNoZWQgdG9cbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICBfdGhpczJba1N0cmVhbV0uZGVzdHJveShudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICBpZiAoZXJyKSB7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9KTtcbiAgfSk7XG59KSwgX09iamVjdCRzZXRQcm90b3R5cGVPKSwgQXN5bmNJdGVyYXRvclByb3RvdHlwZSk7XG5cbnZhciBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IgPSBmdW5jdGlvbiBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3Ioc3RyZWFtKSB7XG4gIHZhciBfT2JqZWN0JGNyZWF0ZTtcblxuICB2YXIgaXRlcmF0b3IgPSBPYmplY3QuY3JlYXRlKFJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYXRvclByb3RvdHlwZSwgKF9PYmplY3QkY3JlYXRlID0ge30sIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga1N0cmVhbSwge1xuICAgIHZhbHVlOiBzdHJlYW0sXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZXNvbHZlLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0xhc3RSZWplY3QsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRXJyb3IsIHtcbiAgICB2YWx1ZTogbnVsbCxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX2RlZmluZVByb3BlcnR5KF9PYmplY3QkY3JlYXRlLCBrRW5kZWQsIHtcbiAgICB2YWx1ZTogc3RyZWFtLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQsXG4gICAgd3JpdGFibGU6IHRydWVcbiAgfSksIF9kZWZpbmVQcm9wZXJ0eShfT2JqZWN0JGNyZWF0ZSwga0hhbmRsZVByb21pc2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgZGF0YSA9IGl0ZXJhdG9yW2tTdHJlYW1dLnJlYWQoKTtcblxuICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSBudWxsO1xuICAgICAgICByZXNvbHZlKGNyZWF0ZUl0ZXJSZXN1bHQoZGF0YSwgZmFsc2UpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSByZXNvbHZlO1xuICAgICAgICBpdGVyYXRvcltrTGFzdFJlamVjdF0gPSByZWplY3Q7XG4gICAgICB9XG4gICAgfSxcbiAgICB3cml0YWJsZTogdHJ1ZVxuICB9KSwgX09iamVjdCRjcmVhdGUpKTtcbiAgaXRlcmF0b3Jba0xhc3RQcm9taXNlXSA9IG51bGw7XG4gIGZpbmlzaGVkKHN0cmVhbSwgZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChlcnIgJiYgZXJyLmNvZGUgIT09ICdFUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRScpIHtcbiAgICAgIHZhciByZWplY3QgPSBpdGVyYXRvcltrTGFzdFJlamVjdF07IC8vIHJlamVjdCBpZiB3ZSBhcmUgd2FpdGluZyBmb3IgZGF0YSBpbiB0aGUgUHJvbWlzZVxuICAgICAgLy8gcmV0dXJuZWQgYnkgbmV4dCgpIGFuZCBzdG9yZSB0aGUgZXJyb3JcblxuICAgICAgaWYgKHJlamVjdCAhPT0gbnVsbCkge1xuICAgICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgICAgaXRlcmF0b3Jba0xhc3RSZXNvbHZlXSA9IG51bGw7XG4gICAgICAgIGl0ZXJhdG9yW2tMYXN0UmVqZWN0XSA9IG51bGw7XG4gICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgfVxuXG4gICAgICBpdGVyYXRvcltrRXJyb3JdID0gZXJyO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciByZXNvbHZlID0gaXRlcmF0b3Jba0xhc3RSZXNvbHZlXTtcblxuICAgIGlmIChyZXNvbHZlICE9PSBudWxsKSB7XG4gICAgICBpdGVyYXRvcltrTGFzdFByb21pc2VdID0gbnVsbDtcbiAgICAgIGl0ZXJhdG9yW2tMYXN0UmVzb2x2ZV0gPSBudWxsO1xuICAgICAgaXRlcmF0b3Jba0xhc3RSZWplY3RdID0gbnVsbDtcbiAgICAgIHJlc29sdmUoY3JlYXRlSXRlclJlc3VsdCh1bmRlZmluZWQsIHRydWUpKTtcbiAgICB9XG5cbiAgICBpdGVyYXRvcltrRW5kZWRdID0gdHJ1ZTtcbiAgfSk7XG4gIHN0cmVhbS5vbigncmVhZGFibGUnLCBvblJlYWRhYmxlLmJpbmQobnVsbCwgaXRlcmF0b3IpKTtcbiAgcmV0dXJuIGl0ZXJhdG9yO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3I7IiwiJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkKHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkgeyBpZiAoa2V5IGluIG9iaikgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHsgdmFsdWU6IHZhbHVlLCBlbnVtZXJhYmxlOiB0cnVlLCBjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH0pOyB9IGVsc2UgeyBvYmpba2V5XSA9IHZhbHVlOyB9IHJldHVybiBvYmo7IH1cblxuZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3RvcikgeyBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkgeyB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpOyB9IH1cblxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykgeyBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7IHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07IGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTsgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlOyBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlOyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7IH0gfVxuXG5mdW5jdGlvbiBfY3JlYXRlQ2xhc3MoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7IGlmIChwcm90b1Byb3BzKSBfZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpOyBpZiAoc3RhdGljUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7IHJldHVybiBDb25zdHJ1Y3RvcjsgfVxuXG52YXIgX3JlcXVpcmUgPSByZXF1aXJlKCdidWZmZXInKSxcbiAgICBCdWZmZXIgPSBfcmVxdWlyZS5CdWZmZXI7XG5cbnZhciBfcmVxdWlyZTIgPSByZXF1aXJlKCd1dGlsJyksXG4gICAgaW5zcGVjdCA9IF9yZXF1aXJlMi5pbnNwZWN0O1xuXG52YXIgY3VzdG9tID0gaW5zcGVjdCAmJiBpbnNwZWN0LmN1c3RvbSB8fCAnaW5zcGVjdCc7XG5cbmZ1bmN0aW9uIGNvcHlCdWZmZXIoc3JjLCB0YXJnZXQsIG9mZnNldCkge1xuICBCdWZmZXIucHJvdG90eXBlLmNvcHkuY2FsbChzcmMsIHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPVxuLyojX19QVVJFX18qL1xuZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xuICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBCdWZmZXJMaXN0KTtcblxuICAgIHRoaXMuaGVhZCA9IG51bGw7XG4gICAgdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH1cblxuICBfY3JlYXRlQ2xhc3MoQnVmZmVyTGlzdCwgW3tcbiAgICBrZXk6IFwicHVzaFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogbnVsbFxuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICAgIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwidW5zaGlmdFwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICAgIHZhciBlbnRyeSA9IHtcbiAgICAgICAgZGF0YTogdixcbiAgICAgICAgbmV4dDogdGhpcy5oZWFkXG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICAgKyt0aGlzLmxlbmd0aDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwic2hpZnRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2hpZnQoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSkgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtlbHNlIHRoaXMuaGVhZCA9IHRoaXMuaGVhZC5uZXh0O1xuICAgICAgLS10aGlzLmxlbmd0aDtcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiBcImNsZWFyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiam9pblwiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBqb2luKHMpIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgICB2YXIgcmV0ID0gJycgKyBwLmRhdGE7XG5cbiAgICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICAgIHJldCArPSBzICsgcC5kYXRhO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmV0O1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogXCJjb25jYXRcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICAgIHZhciByZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobiA+Pj4gMCk7XG4gICAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICAgIHZhciBpID0gMDtcblxuICAgICAgd2hpbGUgKHApIHtcbiAgICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICAgIGkgKz0gcC5kYXRhLmxlbmd0aDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9IC8vIENvbnN1bWVzIGEgc3BlY2lmaWVkIGFtb3VudCBvZiBieXRlcyBvciBjaGFyYWN0ZXJzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJjb25zdW1lXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGNvbnN1bWUobiwgaGFzU3RyaW5ncykge1xuICAgICAgdmFyIHJldDtcblxuICAgICAgaWYgKG4gPCB0aGlzLmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgLy8gYHNsaWNlYCBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5ncy5cbiAgICAgICAgcmV0ID0gdGhpcy5oZWFkLmRhdGEuc2xpY2UoMCwgbik7XG4gICAgICAgIHRoaXMuaGVhZC5kYXRhID0gdGhpcy5oZWFkLmRhdGEuc2xpY2Uobik7XG4gICAgICB9IGVsc2UgaWYgKG4gPT09IHRoaXMuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgICAgICAvLyBGaXJzdCBjaHVuayBpcyBhIHBlcmZlY3QgbWF0Y2guXG4gICAgICAgIHJldCA9IHRoaXMuc2hpZnQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlci5cbiAgICAgICAgcmV0ID0gaGFzU3RyaW5ncyA/IHRoaXMuX2dldFN0cmluZyhuKSA6IHRoaXMuX2dldEJ1ZmZlcihuKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJldDtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6IFwiZmlyc3RcIixcbiAgICB2YWx1ZTogZnVuY3Rpb24gZmlyc3QoKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgfSAvLyBDb25zdW1lcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuXG4gIH0sIHtcbiAgICBrZXk6IFwiX2dldFN0cmluZ1wiLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBfZ2V0U3RyaW5nKG4pIHtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgdmFyIHJldCA9IHAuZGF0YTtcbiAgICAgIG4gLT0gcmV0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSByZXQgKz0gc3RyO2Vsc2UgcmV0ICs9IHN0ci5zbGljZSgwLCBuKTtcbiAgICAgICAgbiAtPSBuYjtcblxuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICAgICAgKytjO1xuICAgICAgICAgICAgaWYgKHAubmV4dCkgdGhpcy5oZWFkID0gcC5uZXh0O2Vsc2UgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5oZWFkID0gcDtcbiAgICAgICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICArK2M7XG4gICAgICB9XG5cbiAgICAgIHRoaXMubGVuZ3RoIC09IGM7XG4gICAgICByZXR1cm4gcmV0O1xuICAgIH0gLy8gQ29uc3VtZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGJ1ZmZlcmVkIGRhdGEuXG5cbiAgfSwge1xuICAgIGtleTogXCJfZ2V0QnVmZmVyXCIsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIF9nZXRCdWZmZXIobikge1xuICAgICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgICAgdmFyIGMgPSAxO1xuICAgICAgcC5kYXRhLmNvcHkocmV0KTtcbiAgICAgIG4gLT0gcC5kYXRhLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcbiAgICAgICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICAgICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICAgICAgYnVmLmNvcHkocmV0LCByZXQubGVuZ3RoIC0gbiwgMCwgbmIpO1xuICAgICAgICBuIC09IG5iO1xuXG4gICAgICAgIGlmIChuID09PSAwKSB7XG4gICAgICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICAgICArK2M7XG4gICAgICAgICAgICBpZiAocC5uZXh0KSB0aGlzLmhlYWQgPSBwLm5leHQ7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmhlYWQgPSBwO1xuICAgICAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgICsrYztcbiAgICAgIH1cblxuICAgICAgdGhpcy5sZW5ndGggLT0gYztcbiAgICAgIHJldHVybiByZXQ7XG4gICAgfSAvLyBNYWtlIHN1cmUgdGhlIGxpbmtlZCBsaXN0IG9ubHkgc2hvd3MgdGhlIG1pbmltYWwgbmVjZXNzYXJ5IGluZm9ybWF0aW9uLlxuXG4gIH0sIHtcbiAgICBrZXk6IGN1c3RvbSxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdmFsdWUoXywgb3B0aW9ucykge1xuICAgICAgcmV0dXJuIGluc3BlY3QodGhpcywgX29iamVjdFNwcmVhZCh7fSwgb3B0aW9ucywge1xuICAgICAgICAvLyBPbmx5IGluc3BlY3Qgb25lIGxldmVsLlxuICAgICAgICBkZXB0aDogMCxcbiAgICAgICAgLy8gSXQgc2hvdWxkIG5vdCByZWN1cnNlLlxuICAgICAgICBjdXN0b21JbnNwZWN0OiBmYWxzZVxuICAgICAgfSkpO1xuICAgIH1cbiAgfV0pO1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JzsgLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB2YXIgd3JpdGFibGVEZXN0cm95ZWQgPSB0aGlzLl93cml0YWJsZVN0YXRlICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xuICAgIGlmIChjYikge1xuICAgICAgY2IoZXJyKTtcbiAgICB9IGVsc2UgaWYgKGVycikge1xuICAgICAgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9IGVsc2UgaWYgKCF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0gLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG5cbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH0gLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuXG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIGlmICghX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZU5ULCBfdGhpcywgZXJyKTtcbiAgICAgIH0gZWxzZSBpZiAoIV90aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRFcnJvckFuZENsb3NlTlQsIF90aGlzLCBlcnIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2VOVCwgX3RoaXMpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlTlQsIF90aGlzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB0aGlzO1xufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZU5UKHNlbGYsIGVycikge1xuICBlbWl0RXJyb3JOVChzZWxmLCBlcnIpO1xuICBlbWl0Q2xvc2VOVChzZWxmKTtcbn1cblxuZnVuY3Rpb24gZW1pdENsb3NlTlQoc2VsZikge1xuICBpZiAoc2VsZi5fd3JpdGFibGVTdGF0ZSAmJiAhc2VsZi5fd3JpdGFibGVTdGF0ZS5lbWl0Q2xvc2UpIHJldHVybjtcbiAgaWYgKHNlbGYuX3JlYWRhYmxlU3RhdGUgJiYgIXNlbGYuX3JlYWRhYmxlU3RhdGUuZW1pdENsb3NlKSByZXR1cm47XG4gIHNlbGYuZW1pdCgnY2xvc2UnKTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluYWxDYWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLnByZWZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdEVycm9yTlQoc2VsZiwgZXJyKSB7XG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xufVxuXG5mdW5jdGlvbiBlcnJvck9yRGVzdHJveShzdHJlYW0sIGVycikge1xuICAvLyBXZSBoYXZlIHRlc3RzIHRoYXQgcmVseSBvbiBlcnJvcnMgYmVpbmcgZW1pdHRlZFxuICAvLyBpbiB0aGUgc2FtZSB0aWNrLCBzbyBjaGFuZ2luZyB0aGlzIGlzIHNlbXZlciBtYWpvci5cbiAgLy8gRm9yIG5vdyB3aGVuIHlvdSBvcHQtaW4gdG8gYXV0b0Rlc3Ryb3kgd2UgYWxsb3dcbiAgLy8gdGhlIGVycm9yIHRvIGJlIGVtaXR0ZWQgbmV4dFRpY2suIEluIGEgZnV0dXJlXG4gIC8vIHNlbXZlciBtYWpvciB1cGRhdGUgd2Ugc2hvdWxkIGNoYW5nZSB0aGUgZGVmYXVsdCB0byB0aGlzLlxuICB2YXIgclN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgd1N0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICBpZiAoclN0YXRlICYmIHJTdGF0ZS5hdXRvRGVzdHJveSB8fCB3U3RhdGUgJiYgd1N0YXRlLmF1dG9EZXN0cm95KSBzdHJlYW0uZGVzdHJveShlcnIpO2Vsc2Ugc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95LFxuICBlcnJvck9yRGVzdHJveTogZXJyb3JPckRlc3Ryb3lcbn07IiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9lbmQtb2Ytc3RyZWFtIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UgPSByZXF1aXJlKCcuLi8uLi8uLi9lcnJvcnMnKS5jb2Rlcy5FUlJfU1RSRUFNX1BSRU1BVFVSRV9DTE9TRTtcblxuZnVuY3Rpb24gb25jZShjYWxsYmFjaykge1xuICB2YXIgY2FsbGVkID0gZmFsc2U7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGNhbGxlZCkgcmV0dXJuO1xuICAgIGNhbGxlZCA9IHRydWU7XG5cbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcbiAgICAgIGFyZ3NbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncyk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5mdW5jdGlvbiBpc1JlcXVlc3Qoc3RyZWFtKSB7XG4gIHJldHVybiBzdHJlYW0uc2V0SGVhZGVyICYmIHR5cGVvZiBzdHJlYW0uYWJvcnQgPT09ICdmdW5jdGlvbic7XG59XG5cbmZ1bmN0aW9uIGVvcyhzdHJlYW0sIG9wdHMsIGNhbGxiYWNrKSB7XG4gIGlmICh0eXBlb2Ygb3B0cyA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIGVvcyhzdHJlYW0sIG51bGwsIG9wdHMpO1xuICBpZiAoIW9wdHMpIG9wdHMgPSB7fTtcbiAgY2FsbGJhY2sgPSBvbmNlKGNhbGxiYWNrIHx8IG5vb3ApO1xuICB2YXIgcmVhZGFibGUgPSBvcHRzLnJlYWRhYmxlIHx8IG9wdHMucmVhZGFibGUgIT09IGZhbHNlICYmIHN0cmVhbS5yZWFkYWJsZTtcbiAgdmFyIHdyaXRhYmxlID0gb3B0cy53cml0YWJsZSB8fCBvcHRzLndyaXRhYmxlICE9PSBmYWxzZSAmJiBzdHJlYW0ud3JpdGFibGU7XG5cbiAgdmFyIG9ubGVnYWN5ZmluaXNoID0gZnVuY3Rpb24gb25sZWdhY3lmaW5pc2goKSB7XG4gICAgaWYgKCFzdHJlYW0ud3JpdGFibGUpIG9uZmluaXNoKCk7XG4gIH07XG5cbiAgdmFyIHdyaXRhYmxlRW5kZWQgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGUgJiYgc3RyZWFtLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkO1xuXG4gIHZhciBvbmZpbmlzaCA9IGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIHdyaXRhYmxlID0gZmFsc2U7XG4gICAgd3JpdGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCFyZWFkYWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciByZWFkYWJsZUVuZGVkID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlICYmIHN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkO1xuXG4gIHZhciBvbmVuZCA9IGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIHJlYWRhYmxlID0gZmFsc2U7XG4gICAgcmVhZGFibGVFbmRlZCA9IHRydWU7XG4gICAgaWYgKCF3cml0YWJsZSkgY2FsbGJhY2suY2FsbChzdHJlYW0pO1xuICB9O1xuXG4gIHZhciBvbmVycm9yID0gZnVuY3Rpb24gb25lcnJvcihlcnIpIHtcbiAgICBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgfTtcblxuICB2YXIgb25jbG9zZSA9IGZ1bmN0aW9uIG9uY2xvc2UoKSB7XG4gICAgdmFyIGVycjtcblxuICAgIGlmIChyZWFkYWJsZSAmJiAhcmVhZGFibGVFbmRlZCkge1xuICAgICAgaWYgKCFzdHJlYW0uX3JlYWRhYmxlU3RhdGUgfHwgIXN0cmVhbS5fcmVhZGFibGVTdGF0ZS5lbmRlZCkgZXJyID0gbmV3IEVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFKCk7XG4gICAgICByZXR1cm4gY2FsbGJhY2suY2FsbChzdHJlYW0sIGVycik7XG4gICAgfVxuXG4gICAgaWYgKHdyaXRhYmxlICYmICF3cml0YWJsZUVuZGVkKSB7XG4gICAgICBpZiAoIXN0cmVhbS5fd3JpdGFibGVTdGF0ZSB8fCAhc3RyZWFtLl93cml0YWJsZVN0YXRlLmVuZGVkKSBlcnIgPSBuZXcgRVJSX1NUUkVBTV9QUkVNQVRVUkVfQ0xPU0UoKTtcbiAgICAgIHJldHVybiBjYWxsYmFjay5jYWxsKHN0cmVhbSwgZXJyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG9ucmVxdWVzdCA9IGZ1bmN0aW9uIG9ucmVxdWVzdCgpIHtcbiAgICBzdHJlYW0ucmVxLm9uKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gIH07XG5cbiAgaWYgKGlzUmVxdWVzdChzdHJlYW0pKSB7XG4gICAgc3RyZWFtLm9uKCdjb21wbGV0ZScsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Fib3J0Jywgb25jbG9zZSk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIG9ucmVxdWVzdCgpO2Vsc2Ugc3RyZWFtLm9uKCdyZXF1ZXN0Jywgb25yZXF1ZXN0KTtcbiAgfSBlbHNlIGlmICh3cml0YWJsZSAmJiAhc3RyZWFtLl93cml0YWJsZVN0YXRlKSB7XG4gICAgLy8gbGVnYWN5IHN0cmVhbXNcbiAgICBzdHJlYW0ub24oJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ub24oJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICB9XG5cbiAgc3RyZWFtLm9uKCdlbmQnLCBvbmVuZCk7XG4gIHN0cmVhbS5vbignZmluaXNoJywgb25maW5pc2gpO1xuICBpZiAob3B0cy5lcnJvciAhPT0gZmFsc2UpIHN0cmVhbS5vbignZXJyb3InLCBvbmVycm9yKTtcbiAgc3RyZWFtLm9uKCdjbG9zZScsIG9uY2xvc2UpO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignY29tcGxldGUnLCBvbmZpbmlzaCk7XG4gICAgc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdhYm9ydCcsIG9uY2xvc2UpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcigncmVxdWVzdCcsIG9ucmVxdWVzdCk7XG4gICAgaWYgKHN0cmVhbS5yZXEpIHN0cmVhbS5yZXEucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9ubGVnYWN5ZmluaXNoKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25sZWdhY3lmaW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZmluaXNoJywgb25maW5pc2gpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBzdHJlYW0ucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZW9zOyIsIm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ1JlYWRhYmxlLmZyb20gaXMgbm90IGF2YWlsYWJsZSBpbiB0aGUgYnJvd3NlcicpXG59O1xuIiwiLy8gUG9ydGVkIGZyb20gaHR0cHM6Ly9naXRodWIuY29tL21hZmludG9zaC9wdW1wIHdpdGhcbi8vIHBlcm1pc3Npb24gZnJvbSB0aGUgYXV0aG9yLCBNYXRoaWFzIEJ1dXMgKEBtYWZpbnRvc2gpLlxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZW9zO1xuXG5mdW5jdGlvbiBvbmNlKGNhbGxiYWNrKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSByZXR1cm47XG4gICAgY2FsbGVkID0gdHJ1ZTtcbiAgICBjYWxsYmFjay5hcHBseSh2b2lkIDAsIGFyZ3VtZW50cyk7XG4gIH07XG59XG5cbnZhciBfcmVxdWlyZSRjb2RlcyA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLFxuICAgIEVSUl9NSVNTSU5HX0FSR1MgPSBfcmVxdWlyZSRjb2Rlcy5FUlJfTUlTU0lOR19BUkdTLFxuICAgIEVSUl9TVFJFQU1fREVTVFJPWUVEID0gX3JlcXVpcmUkY29kZXMuRVJSX1NUUkVBTV9ERVNUUk9ZRUQ7XG5cbmZ1bmN0aW9uIG5vb3AoZXJyKSB7XG4gIC8vIFJldGhyb3cgdGhlIGVycm9yIGlmIGl0IGV4aXN0cyB0byBhdm9pZCBzd2FsbG93aW5nIGl0XG4gIGlmIChlcnIpIHRocm93IGVycjtcbn1cblxuZnVuY3Rpb24gaXNSZXF1ZXN0KHN0cmVhbSkge1xuICByZXR1cm4gc3RyZWFtLnNldEhlYWRlciAmJiB0eXBlb2Ygc3RyZWFtLmFib3J0ID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95ZXIoc3RyZWFtLCByZWFkaW5nLCB3cml0aW5nLCBjYWxsYmFjaykge1xuICBjYWxsYmFjayA9IG9uY2UoY2FsbGJhY2spO1xuICB2YXIgY2xvc2VkID0gZmFsc2U7XG4gIHN0cmVhbS5vbignY2xvc2UnLCBmdW5jdGlvbiAoKSB7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgfSk7XG4gIGlmIChlb3MgPT09IHVuZGVmaW5lZCkgZW9zID0gcmVxdWlyZSgnLi9lbmQtb2Ytc3RyZWFtJyk7XG4gIGVvcyhzdHJlYW0sIHtcbiAgICByZWFkYWJsZTogcmVhZGluZyxcbiAgICB3cml0YWJsZTogd3JpdGluZ1xuICB9LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKGVycikgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgY2xvc2VkID0gdHJ1ZTtcbiAgICBjYWxsYmFjaygpO1xuICB9KTtcbiAgdmFyIGRlc3Ryb3llZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKGVycikge1xuICAgIGlmIChjbG9zZWQpIHJldHVybjtcbiAgICBpZiAoZGVzdHJveWVkKSByZXR1cm47XG4gICAgZGVzdHJveWVkID0gdHJ1ZTsgLy8gcmVxdWVzdC5kZXN0cm95IGp1c3QgZG8gLmVuZCAtIC5hYm9ydCBpcyB3aGF0IHdlIHdhbnRcblxuICAgIGlmIChpc1JlcXVlc3Qoc3RyZWFtKSkgcmV0dXJuIHN0cmVhbS5hYm9ydCgpO1xuICAgIGlmICh0eXBlb2Ygc3RyZWFtLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHJldHVybiBzdHJlYW0uZGVzdHJveSgpO1xuICAgIGNhbGxiYWNrKGVyciB8fCBuZXcgRVJSX1NUUkVBTV9ERVNUUk9ZRUQoJ3BpcGUnKSk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIGNhbGwoZm4pIHtcbiAgZm4oKTtcbn1cblxuZnVuY3Rpb24gcGlwZShmcm9tLCB0bykge1xuICByZXR1cm4gZnJvbS5waXBlKHRvKTtcbn1cblxuZnVuY3Rpb24gcG9wQ2FsbGJhY2soc3RyZWFtcykge1xuICBpZiAoIXN0cmVhbXMubGVuZ3RoKSByZXR1cm4gbm9vcDtcbiAgaWYgKHR5cGVvZiBzdHJlYW1zW3N0cmVhbXMubGVuZ3RoIC0gMV0gIT09ICdmdW5jdGlvbicpIHJldHVybiBub29wO1xuICByZXR1cm4gc3RyZWFtcy5wb3AoKTtcbn1cblxuZnVuY3Rpb24gcGlwZWxpbmUoKSB7XG4gIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBzdHJlYW1zID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgIHN0cmVhbXNbX2tleV0gPSBhcmd1bWVudHNbX2tleV07XG4gIH1cblxuICB2YXIgY2FsbGJhY2sgPSBwb3BDYWxsYmFjayhzdHJlYW1zKTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoc3RyZWFtc1swXSkpIHN0cmVhbXMgPSBzdHJlYW1zWzBdO1xuXG4gIGlmIChzdHJlYW1zLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgRVJSX01JU1NJTkdfQVJHUygnc3RyZWFtcycpO1xuICB9XG5cbiAgdmFyIGVycm9yO1xuICB2YXIgZGVzdHJveXMgPSBzdHJlYW1zLm1hcChmdW5jdGlvbiAoc3RyZWFtLCBpKSB7XG4gICAgdmFyIHJlYWRpbmcgPSBpIDwgc3RyZWFtcy5sZW5ndGggLSAxO1xuICAgIHZhciB3cml0aW5nID0gaSA+IDA7XG4gICAgcmV0dXJuIGRlc3Ryb3llcihzdHJlYW0sIHJlYWRpbmcsIHdyaXRpbmcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuICAgICAgaWYgKGVycikgZGVzdHJveXMuZm9yRWFjaChjYWxsKTtcbiAgICAgIGlmIChyZWFkaW5nKSByZXR1cm47XG4gICAgICBkZXN0cm95cy5mb3JFYWNoKGNhbGwpO1xuICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIHN0cmVhbXMucmVkdWNlKHBpcGUpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHBpcGVsaW5lOyIsIid1c2Ugc3RyaWN0JztcblxudmFyIEVSUl9JTlZBTElEX09QVF9WQUxVRSA9IHJlcXVpcmUoJy4uLy4uLy4uL2Vycm9ycycpLmNvZGVzLkVSUl9JTlZBTElEX09QVF9WQUxVRTtcblxuZnVuY3Rpb24gaGlnaFdhdGVyTWFya0Zyb20ob3B0aW9ucywgaXNEdXBsZXgsIGR1cGxleEtleSkge1xuICByZXR1cm4gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrICE9IG51bGwgPyBvcHRpb25zLmhpZ2hXYXRlck1hcmsgOiBpc0R1cGxleCA/IG9wdGlvbnNbZHVwbGV4S2V5XSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEhpZ2hXYXRlck1hcmsoc3RhdGUsIG9wdGlvbnMsIGR1cGxleEtleSwgaXNEdXBsZXgpIHtcbiAgdmFyIGh3bSA9IGhpZ2hXYXRlck1hcmtGcm9tKG9wdGlvbnMsIGlzRHVwbGV4LCBkdXBsZXhLZXkpO1xuXG4gIGlmIChod20gIT0gbnVsbCkge1xuICAgIGlmICghKGlzRmluaXRlKGh3bSkgJiYgTWF0aC5mbG9vcihod20pID09PSBod20pIHx8IGh3bSA8IDApIHtcbiAgICAgIHZhciBuYW1lID0gaXNEdXBsZXggPyBkdXBsZXhLZXkgOiAnaGlnaFdhdGVyTWFyayc7XG4gICAgICB0aHJvdyBuZXcgRVJSX0lOVkFMSURfT1BUX1ZBTFVFKG5hbWUsIGh3bSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoaHdtKTtcbiAgfSAvLyBEZWZhdWx0IHZhbHVlXG5cblxuICByZXR1cm4gc3RhdGUub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZ2V0SGlnaFdhdGVyTWFyazogZ2V0SGlnaFdhdGVyTWFya1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG5leHBvcnRzLmZpbmlzaGVkID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9lbmQtb2Ytc3RyZWFtLmpzJyk7XG5leHBvcnRzLnBpcGVsaW5lID0gcmVxdWlyZSgnLi9saWIvaW50ZXJuYWwvc3RyZWFtcy9waXBlbGluZS5qcycpO1xuIiwiLyohIHNhZmUtYnVmZmVyLiBNSVQgTGljZW5zZS4gRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnL29wZW5zb3VyY2U+ICovXG4vKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShCdWZmZXIucHJvdG90eXBlKVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBDbGllbnRSZXF1ZXN0ID0gcmVxdWlyZSgnLi9saWIvcmVxdWVzdCcpXG52YXIgcmVzcG9uc2UgPSByZXF1aXJlKCcuL2xpYi9yZXNwb25zZScpXG52YXIgZXh0ZW5kID0gcmVxdWlyZSgneHRlbmQnKVxudmFyIHN0YXR1c0NvZGVzID0gcmVxdWlyZSgnYnVpbHRpbi1zdGF0dXMtY29kZXMnKVxudmFyIHVybCA9IHJlcXVpcmUoJ3VybCcpXG5cbnZhciBodHRwID0gZXhwb3J0c1xuXG5odHRwLnJlcXVlc3QgPSBmdW5jdGlvbiAob3B0cywgY2IpIHtcblx0aWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJylcblx0XHRvcHRzID0gdXJsLnBhcnNlKG9wdHMpXG5cdGVsc2Vcblx0XHRvcHRzID0gZXh0ZW5kKG9wdHMpXG5cblx0Ly8gTm9ybWFsbHksIHRoZSBwYWdlIGlzIGxvYWRlZCBmcm9tIGh0dHAgb3IgaHR0cHMsIHNvIG5vdCBzcGVjaWZ5aW5nIGEgcHJvdG9jb2xcblx0Ly8gd2lsbCByZXN1bHQgaW4gYSAodmFsaWQpIHByb3RvY29sLXJlbGF0aXZlIHVybC4gSG93ZXZlciwgdGhpcyB3b24ndCB3b3JrIGlmXG5cdC8vIHRoZSBwcm90b2NvbCBpcyBzb21ldGhpbmcgZWxzZSwgbGlrZSAnZmlsZTonXG5cdHZhciBkZWZhdWx0UHJvdG9jb2wgPSBnbG9iYWwubG9jYXRpb24ucHJvdG9jb2wuc2VhcmNoKC9eaHR0cHM/OiQvKSA9PT0gLTEgPyAnaHR0cDonIDogJydcblxuXHR2YXIgcHJvdG9jb2wgPSBvcHRzLnByb3RvY29sIHx8IGRlZmF1bHRQcm90b2NvbFxuXHR2YXIgaG9zdCA9IG9wdHMuaG9zdG5hbWUgfHwgb3B0cy5ob3N0XG5cdHZhciBwb3J0ID0gb3B0cy5wb3J0XG5cdHZhciBwYXRoID0gb3B0cy5wYXRoIHx8ICcvJ1xuXG5cdC8vIE5lY2Vzc2FyeSBmb3IgSVB2NiBhZGRyZXNzZXNcblx0aWYgKGhvc3QgJiYgaG9zdC5pbmRleE9mKCc6JykgIT09IC0xKVxuXHRcdGhvc3QgPSAnWycgKyBob3N0ICsgJ10nXG5cblx0Ly8gVGhpcyBtYXkgYmUgYSByZWxhdGl2ZSB1cmwuIFRoZSBicm93c2VyIHNob3VsZCBhbHdheXMgYmUgYWJsZSB0byBpbnRlcnByZXQgaXQgY29ycmVjdGx5LlxuXHRvcHRzLnVybCA9IChob3N0ID8gKHByb3RvY29sICsgJy8vJyArIGhvc3QpIDogJycpICsgKHBvcnQgPyAnOicgKyBwb3J0IDogJycpICsgcGF0aFxuXHRvcHRzLm1ldGhvZCA9IChvcHRzLm1ldGhvZCB8fCAnR0VUJykudG9VcHBlckNhc2UoKVxuXHRvcHRzLmhlYWRlcnMgPSBvcHRzLmhlYWRlcnMgfHwge31cblxuXHQvLyBBbHNvIHZhbGlkIG9wdHMuYXV0aCwgb3B0cy5tb2RlXG5cblx0dmFyIHJlcSA9IG5ldyBDbGllbnRSZXF1ZXN0KG9wdHMpXG5cdGlmIChjYilcblx0XHRyZXEub24oJ3Jlc3BvbnNlJywgY2IpXG5cdHJldHVybiByZXFcbn1cblxuaHR0cC5nZXQgPSBmdW5jdGlvbiBnZXQgKG9wdHMsIGNiKSB7XG5cdHZhciByZXEgPSBodHRwLnJlcXVlc3Qob3B0cywgY2IpXG5cdHJlcS5lbmQoKVxuXHRyZXR1cm4gcmVxXG59XG5cbmh0dHAuQ2xpZW50UmVxdWVzdCA9IENsaWVudFJlcXVlc3Rcbmh0dHAuSW5jb21pbmdNZXNzYWdlID0gcmVzcG9uc2UuSW5jb21pbmdNZXNzYWdlXG5cbmh0dHAuQWdlbnQgPSBmdW5jdGlvbiAoKSB7fVxuaHR0cC5BZ2VudC5kZWZhdWx0TWF4U29ja2V0cyA9IDRcblxuaHR0cC5nbG9iYWxBZ2VudCA9IG5ldyBodHRwLkFnZW50KClcblxuaHR0cC5TVEFUVVNfQ09ERVMgPSBzdGF0dXNDb2Rlc1xuXG5odHRwLk1FVEhPRFMgPSBbXG5cdCdDSEVDS09VVCcsXG5cdCdDT05ORUNUJyxcblx0J0NPUFknLFxuXHQnREVMRVRFJyxcblx0J0dFVCcsXG5cdCdIRUFEJyxcblx0J0xPQ0snLFxuXHQnTS1TRUFSQ0gnLFxuXHQnTUVSR0UnLFxuXHQnTUtBQ1RJVklUWScsXG5cdCdNS0NPTCcsXG5cdCdNT1ZFJyxcblx0J05PVElGWScsXG5cdCdPUFRJT05TJyxcblx0J1BBVENIJyxcblx0J1BPU1QnLFxuXHQnUFJPUEZJTkQnLFxuXHQnUFJPUFBBVENIJyxcblx0J1BVUkdFJyxcblx0J1BVVCcsXG5cdCdSRVBPUlQnLFxuXHQnU0VBUkNIJyxcblx0J1NVQlNDUklCRScsXG5cdCdUUkFDRScsXG5cdCdVTkxPQ0snLFxuXHQnVU5TVUJTQ1JJQkUnXG5dIiwiZXhwb3J0cy5mZXRjaCA9IGlzRnVuY3Rpb24oZ2xvYmFsLmZldGNoKSAmJiBpc0Z1bmN0aW9uKGdsb2JhbC5SZWFkYWJsZVN0cmVhbSlcblxuZXhwb3J0cy53cml0YWJsZVN0cmVhbSA9IGlzRnVuY3Rpb24oZ2xvYmFsLldyaXRhYmxlU3RyZWFtKVxuXG5leHBvcnRzLmFib3J0Q29udHJvbGxlciA9IGlzRnVuY3Rpb24oZ2xvYmFsLkFib3J0Q29udHJvbGxlcilcblxuLy8gVGhlIHhociByZXF1ZXN0IHRvIGV4YW1wbGUuY29tIG1heSB2aW9sYXRlIHNvbWUgcmVzdHJpY3RpdmUgQ1NQIGNvbmZpZ3VyYXRpb25zLFxuLy8gc28gaWYgd2UncmUgcnVubmluZyBpbiBhIGJyb3dzZXIgdGhhdCBzdXBwb3J0cyBgZmV0Y2hgLCBhdm9pZCBjYWxsaW5nIGdldFhIUigpXG4vLyBhbmQgYXNzdW1lIHN1cHBvcnQgZm9yIGNlcnRhaW4gZmVhdHVyZXMgYmVsb3cuXG52YXIgeGhyXG5mdW5jdGlvbiBnZXRYSFIgKCkge1xuXHQvLyBDYWNoZSB0aGUgeGhyIHZhbHVlXG5cdGlmICh4aHIgIT09IHVuZGVmaW5lZCkgcmV0dXJuIHhoclxuXG5cdGlmIChnbG9iYWwuWE1MSHR0cFJlcXVlc3QpIHtcblx0XHR4aHIgPSBuZXcgZ2xvYmFsLlhNTEh0dHBSZXF1ZXN0KClcblx0XHQvLyBJZiBYRG9tYWluUmVxdWVzdCBpcyBhdmFpbGFibGUgKGllIG9ubHksIHdoZXJlIHhociBtaWdodCBub3Qgd29ya1xuXHRcdC8vIGNyb3NzIGRvbWFpbiksIHVzZSB0aGUgcGFnZSBsb2NhdGlvbi4gT3RoZXJ3aXNlIHVzZSBleGFtcGxlLmNvbVxuXHRcdC8vIE5vdGU6IHRoaXMgZG9lc24ndCBhY3R1YWxseSBtYWtlIGFuIGh0dHAgcmVxdWVzdC5cblx0XHR0cnkge1xuXHRcdFx0eGhyLm9wZW4oJ0dFVCcsIGdsb2JhbC5YRG9tYWluUmVxdWVzdCA/ICcvJyA6ICdodHRwczovL2V4YW1wbGUuY29tJylcblx0XHR9IGNhdGNoKGUpIHtcblx0XHRcdHhociA9IG51bGxcblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU2VydmljZSB3b3JrZXJzIGRvbid0IGhhdmUgWEhSXG5cdFx0eGhyID0gbnVsbFxuXHR9XG5cdHJldHVybiB4aHJcbn1cblxuZnVuY3Rpb24gY2hlY2tUeXBlU3VwcG9ydCAodHlwZSkge1xuXHR2YXIgeGhyID0gZ2V0WEhSKClcblx0aWYgKCF4aHIpIHJldHVybiBmYWxzZVxuXHR0cnkge1xuXHRcdHhoci5yZXNwb25zZVR5cGUgPSB0eXBlXG5cdFx0cmV0dXJuIHhoci5yZXNwb25zZVR5cGUgPT09IHR5cGVcblx0fSBjYXRjaCAoZSkge31cblx0cmV0dXJuIGZhbHNlXG59XG5cbi8vIElmIGZldGNoIGlzIHN1cHBvcnRlZCwgdGhlbiBhcnJheWJ1ZmZlciB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gY2hlY2tUeXBlU3VwcG9ydCgpLCBzaW5jZSB0aGF0IGNhbGxzIGdldFhIUigpLlxuZXhwb3J0cy5hcnJheWJ1ZmZlciA9IGV4cG9ydHMuZmV0Y2ggfHwgY2hlY2tUeXBlU3VwcG9ydCgnYXJyYXlidWZmZXInKVxuXG4vLyBUaGVzZSBuZXh0IHR3byB0ZXN0cyB1bmF2b2lkYWJseSBzaG93IHdhcm5pbmdzIGluIENocm9tZS4gU2luY2UgZmV0Y2ggd2lsbCBhbHdheXNcbi8vIGJlIHVzZWQgaWYgaXQncyBhdmFpbGFibGUsIGp1c3QgcmV0dXJuIGZhbHNlIGZvciB0aGVzZSB0byBhdm9pZCB0aGUgd2FybmluZ3MuXG5leHBvcnRzLm1zc3RyZWFtID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbXMtc3RyZWFtJylcbmV4cG9ydHMubW96Y2h1bmtlZGFycmF5YnVmZmVyID0gIWV4cG9ydHMuZmV0Y2ggJiYgY2hlY2tUeXBlU3VwcG9ydCgnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKVxuXG4vLyBJZiBmZXRjaCBpcyBzdXBwb3J0ZWQsIHRoZW4gb3ZlcnJpZGVNaW1lVHlwZSB3aWxsIGJlIHN1cHBvcnRlZCB0b28uIFNraXAgY2FsbGluZ1xuLy8gZ2V0WEhSKCkuXG5leHBvcnRzLm92ZXJyaWRlTWltZVR5cGUgPSBleHBvcnRzLmZldGNoIHx8IChnZXRYSFIoKSA/IGlzRnVuY3Rpb24oZ2V0WEhSKCkub3ZlcnJpZGVNaW1lVHlwZSkgOiBmYWxzZSlcblxuZnVuY3Rpb24gaXNGdW5jdGlvbiAodmFsdWUpIHtcblx0cmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJ1xufVxuXG54aHIgPSBudWxsIC8vIEhlbHAgZ2NcbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciByZXNwb25zZSA9IHJlcXVpcmUoJy4vcmVzcG9uc2UnKVxudmFyIHN0cmVhbSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbScpXG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSByZXNwb25zZS5JbmNvbWluZ01lc3NhZ2VcbnZhciByU3RhdGVzID0gcmVzcG9uc2UucmVhZHlTdGF0ZXNcblxuZnVuY3Rpb24gZGVjaWRlTW9kZSAocHJlZmVyQmluYXJ5LCB1c2VGZXRjaCkge1xuXHRpZiAoY2FwYWJpbGl0eS5mZXRjaCAmJiB1c2VGZXRjaCkge1xuXHRcdHJldHVybiAnZmV0Y2gnXG5cdH0gZWxzZSBpZiAoY2FwYWJpbGl0eS5tb3pjaHVua2VkYXJyYXlidWZmZXIpIHtcblx0XHRyZXR1cm4gJ21vei1jaHVua2VkLWFycmF5YnVmZmVyJ1xuXHR9IGVsc2UgaWYgKGNhcGFiaWxpdHkubXNzdHJlYW0pIHtcblx0XHRyZXR1cm4gJ21zLXN0cmVhbSdcblx0fSBlbHNlIGlmIChjYXBhYmlsaXR5LmFycmF5YnVmZmVyICYmIHByZWZlckJpbmFyeSkge1xuXHRcdHJldHVybiAnYXJyYXlidWZmZXInXG5cdH0gZWxzZSB7XG5cdFx0cmV0dXJuICd0ZXh0J1xuXHR9XG59XG5cbnZhciBDbGllbnRSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob3B0cykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLldyaXRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9vcHRzID0gb3B0c1xuXHRzZWxmLl9ib2R5ID0gW11cblx0c2VsZi5faGVhZGVycyA9IHt9XG5cdGlmIChvcHRzLmF1dGgpXG5cdFx0c2VsZi5zZXRIZWFkZXIoJ0F1dGhvcml6YXRpb24nLCAnQmFzaWMgJyArIEJ1ZmZlci5mcm9tKG9wdHMuYXV0aCkudG9TdHJpbmcoJ2Jhc2U2NCcpKVxuXHRPYmplY3Qua2V5cyhvcHRzLmhlYWRlcnMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcblx0XHRzZWxmLnNldEhlYWRlcihuYW1lLCBvcHRzLmhlYWRlcnNbbmFtZV0pXG5cdH0pXG5cblx0dmFyIHByZWZlckJpbmFyeVxuXHR2YXIgdXNlRmV0Y2ggPSB0cnVlXG5cdGlmIChvcHRzLm1vZGUgPT09ICdkaXNhYmxlLWZldGNoJyB8fCAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzICYmICFjYXBhYmlsaXR5LmFib3J0Q29udHJvbGxlcikpIHtcblx0XHQvLyBJZiB0aGUgdXNlIG9mIFhIUiBzaG91bGQgYmUgcHJlZmVycmVkLiBOb3QgdHlwaWNhbGx5IG5lZWRlZC5cblx0XHR1c2VGZXRjaCA9IGZhbHNlXG5cdFx0cHJlZmVyQmluYXJ5ID0gdHJ1ZVxuXHR9IGVsc2UgaWYgKG9wdHMubW9kZSA9PT0gJ3ByZWZlci1zdHJlYW1pbmcnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIGEgaGlnaCBwcmlvcml0eSBidXQgYmluYXJ5IGNvbXBhdGliaWxpdHkgYW5kXG5cdFx0Ly8gdGhlIGFjY3VyYWN5IG9mIHRoZSAnY29udGVudC10eXBlJyBoZWFkZXIgYXJlbid0XG5cdFx0cHJlZmVyQmluYXJ5ID0gZmFsc2Vcblx0fSBlbHNlIGlmIChvcHRzLm1vZGUgPT09ICdhbGxvdy13cm9uZy1jb250ZW50LXR5cGUnKSB7XG5cdFx0Ly8gSWYgc3RyZWFtaW5nIGlzIG1vcmUgaW1wb3J0YW50IHRoYW4gcHJlc2VydmluZyB0aGUgJ2NvbnRlbnQtdHlwZScgaGVhZGVyXG5cdFx0cHJlZmVyQmluYXJ5ID0gIWNhcGFiaWxpdHkub3ZlcnJpZGVNaW1lVHlwZVxuXHR9IGVsc2UgaWYgKCFvcHRzLm1vZGUgfHwgb3B0cy5tb2RlID09PSAnZGVmYXVsdCcgfHwgb3B0cy5tb2RlID09PSAncHJlZmVyLWZhc3QnKSB7XG5cdFx0Ly8gVXNlIGJpbmFyeSBpZiB0ZXh0IHN0cmVhbWluZyBtYXkgY29ycnVwdCBkYXRhIG9yIHRoZSBjb250ZW50LXR5cGUgaGVhZGVyLCBvciBmb3Igc3BlZWRcblx0XHRwcmVmZXJCaW5hcnkgPSB0cnVlXG5cdH0gZWxzZSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHZhbHVlIGZvciBvcHRzLm1vZGUnKVxuXHR9XG5cdHNlbGYuX21vZGUgPSBkZWNpZGVNb2RlKHByZWZlckJpbmFyeSwgdXNlRmV0Y2gpXG5cdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSBudWxsXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdHNlbGYub24oJ2ZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcblx0XHRzZWxmLl9vbkZpbmlzaCgpXG5cdH0pXG59XG5cbmluaGVyaXRzKENsaWVudFJlcXVlc3QsIHN0cmVhbS5Xcml0YWJsZSlcblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0SGVhZGVyID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXHR2YXIgbG93ZXJOYW1lID0gbmFtZS50b0xvd2VyQ2FzZSgpXG5cdC8vIFRoaXMgY2hlY2sgaXMgbm90IG5lY2Vzc2FyeSwgYnV0IGl0IHByZXZlbnRzIHdhcm5pbmdzIGZyb20gYnJvd3NlcnMgYWJvdXQgc2V0dGluZyB1bnNhZmVcblx0Ly8gaGVhZGVycy4gVG8gYmUgaG9uZXN0IEknbSBub3QgZW50aXJlbHkgc3VyZSBoaWRpbmcgdGhlc2Ugd2FybmluZ3MgaXMgYSBnb29kIHRoaW5nLCBidXRcblx0Ly8gaHR0cC1icm93c2VyaWZ5IGRpZCBpdCwgc28gSSB3aWxsIHRvby5cblx0aWYgKHVuc2FmZUhlYWRlcnMuaW5kZXhPZihsb3dlck5hbWUpICE9PSAtMSlcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9oZWFkZXJzW2xvd2VyTmFtZV0gPSB7XG5cdFx0bmFtZTogbmFtZSxcblx0XHR2YWx1ZTogdmFsdWVcblx0fVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5nZXRIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgaGVhZGVyID0gdGhpcy5faGVhZGVyc1tuYW1lLnRvTG93ZXJDYXNlKCldXG5cdGlmIChoZWFkZXIpXG5cdFx0cmV0dXJuIGhlYWRlci52YWx1ZVxuXHRyZXR1cm4gbnVsbFxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5yZW1vdmVIZWFkZXIgPSBmdW5jdGlvbiAobmFtZSkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0ZGVsZXRlIHNlbGYuX2hlYWRlcnNbbmFtZS50b0xvd2VyQ2FzZSgpXVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fb25GaW5pc2ggPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cdHZhciBvcHRzID0gc2VsZi5fb3B0c1xuXG5cdGlmICgndGltZW91dCcgaW4gb3B0cyAmJiBvcHRzLnRpbWVvdXQgIT09IDApIHtcblx0XHRzZWxmLnNldFRpbWVvdXQob3B0cy50aW1lb3V0KVxuXHR9XG5cblx0dmFyIGhlYWRlcnNPYmogPSBzZWxmLl9oZWFkZXJzXG5cdHZhciBib2R5ID0gbnVsbFxuXHRpZiAob3B0cy5tZXRob2QgIT09ICdHRVQnICYmIG9wdHMubWV0aG9kICE9PSAnSEVBRCcpIHtcbiAgICAgICAgYm9keSA9IG5ldyBCbG9iKHNlbGYuX2JvZHksIHtcbiAgICAgICAgICAgIHR5cGU6IChoZWFkZXJzT2JqWydjb250ZW50LXR5cGUnXSB8fCB7fSkudmFsdWUgfHwgJydcbiAgICAgICAgfSk7XG4gICAgfVxuXG5cdC8vIGNyZWF0ZSBmbGF0dGVuZWQgbGlzdCBvZiBoZWFkZXJzXG5cdHZhciBoZWFkZXJzTGlzdCA9IFtdXG5cdE9iamVjdC5rZXlzKGhlYWRlcnNPYmopLmZvckVhY2goZnVuY3Rpb24gKGtleU5hbWUpIHtcblx0XHR2YXIgbmFtZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0ubmFtZVxuXHRcdHZhciB2YWx1ZSA9IGhlYWRlcnNPYmpba2V5TmFtZV0udmFsdWVcblx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcblx0XHRcdFx0aGVhZGVyc0xpc3QucHVzaChbbmFtZSwgdl0pXG5cdFx0XHR9KVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoZWFkZXJzTGlzdC5wdXNoKFtuYW1lLCB2YWx1ZV0pXG5cdFx0fVxuXHR9KVxuXG5cdGlmIChzZWxmLl9tb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0dmFyIHNpZ25hbCA9IG51bGxcblx0XHRpZiAoY2FwYWJpbGl0eS5hYm9ydENvbnRyb2xsZXIpIHtcblx0XHRcdHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpXG5cdFx0XHRzaWduYWwgPSBjb250cm9sbGVyLnNpZ25hbFxuXHRcdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIgPSBjb250cm9sbGVyXG5cblx0XHRcdGlmICgncmVxdWVzdFRpbWVvdXQnIGluIG9wdHMgJiYgb3B0cy5yZXF1ZXN0VGltZW91dCAhPT0gMCkge1xuXHRcdFx0XHRzZWxmLl9mZXRjaFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0XHRcdGlmIChzZWxmLl9mZXRjaEFib3J0Q29udHJvbGxlcilcblx0XHRcdFx0XHRcdHNlbGYuX2ZldGNoQWJvcnRDb250cm9sbGVyLmFib3J0KClcblx0XHRcdFx0fSwgb3B0cy5yZXF1ZXN0VGltZW91dClcblx0XHRcdH1cblx0XHR9XG5cblx0XHRnbG9iYWwuZmV0Y2goc2VsZi5fb3B0cy51cmwsIHtcblx0XHRcdG1ldGhvZDogc2VsZi5fb3B0cy5tZXRob2QsXG5cdFx0XHRoZWFkZXJzOiBoZWFkZXJzTGlzdCxcblx0XHRcdGJvZHk6IGJvZHkgfHwgdW5kZWZpbmVkLFxuXHRcdFx0bW9kZTogJ2NvcnMnLFxuXHRcdFx0Y3JlZGVudGlhbHM6IG9wdHMud2l0aENyZWRlbnRpYWxzID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJyxcblx0XHRcdHNpZ25hbDogc2lnbmFsXG5cdFx0fSkudGhlbihmdW5jdGlvbiAocmVzcG9uc2UpIHtcblx0XHRcdHNlbGYuX2ZldGNoUmVzcG9uc2UgPSByZXNwb25zZVxuXHRcdFx0c2VsZi5fcmVzZXRUaW1lcnMoZmFsc2UpXG5cdFx0XHRzZWxmLl9jb25uZWN0KClcblx0XHR9LCBmdW5jdGlvbiAocmVhc29uKSB7XG5cdFx0XHRzZWxmLl9yZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCByZWFzb24pXG5cdFx0fSlcblx0fSBlbHNlIHtcblx0XHR2YXIgeGhyID0gc2VsZi5feGhyID0gbmV3IGdsb2JhbC5YTUxIdHRwUmVxdWVzdCgpXG5cdFx0dHJ5IHtcblx0XHRcdHhoci5vcGVuKHNlbGYuX29wdHMubWV0aG9kLCBzZWxmLl9vcHRzLnVybCwgdHJ1ZSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblxuXHRcdC8vIENhbid0IHNldCByZXNwb25zZVR5cGUgb24gcmVhbGx5IG9sZCBicm93c2Vyc1xuXHRcdGlmICgncmVzcG9uc2VUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIucmVzcG9uc2VUeXBlID0gc2VsZi5fbW9kZVxuXG5cdFx0aWYgKCd3aXRoQ3JlZGVudGlhbHMnIGluIHhocilcblx0XHRcdHhoci53aXRoQ3JlZGVudGlhbHMgPSAhIW9wdHMud2l0aENyZWRlbnRpYWxzXG5cblx0XHRpZiAoc2VsZi5fbW9kZSA9PT0gJ3RleHQnICYmICdvdmVycmlkZU1pbWVUeXBlJyBpbiB4aHIpXG5cdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSgndGV4dC9wbGFpbjsgY2hhcnNldD14LXVzZXItZGVmaW5lZCcpXG5cblx0XHRpZiAoJ3JlcXVlc3RUaW1lb3V0JyBpbiBvcHRzKSB7XG5cdFx0XHR4aHIudGltZW91dCA9IG9wdHMucmVxdWVzdFRpbWVvdXRcblx0XHRcdHhoci5vbnRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRcdHNlbGYuZW1pdCgncmVxdWVzdFRpbWVvdXQnKVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhlYWRlcnNMaXN0LmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoaGVhZGVyWzBdLCBoZWFkZXJbMV0pXG5cdFx0fSlcblxuXHRcdHNlbGYuX3Jlc3BvbnNlID0gbnVsbFxuXHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRzd2l0Y2ggKHhoci5yZWFkeVN0YXRlKSB7XG5cdFx0XHRcdGNhc2UgclN0YXRlcy5MT0FESU5HOlxuXHRcdFx0XHRjYXNlIHJTdGF0ZXMuRE9ORTpcblx0XHRcdFx0XHRzZWxmLl9vblhIUlByb2dyZXNzKClcblx0XHRcdFx0XHRicmVha1xuXHRcdFx0fVxuXHRcdH1cblx0XHQvLyBOZWNlc3NhcnkgZm9yIHN0cmVhbWluZyBpbiBGaXJlZm94LCBzaW5jZSB4aHIucmVzcG9uc2UgaXMgT05MWSBkZWZpbmVkXG5cdFx0Ly8gaW4gb25wcm9ncmVzcywgbm90IGluIG9ucmVhZHlzdGF0ZWNoYW5nZSB3aXRoIHhoci5yZWFkeVN0YXRlID0gM1xuXHRcdGlmIChzZWxmLl9tb2RlID09PSAnbW96LWNodW5rZWQtYXJyYXlidWZmZXInKSB7XG5cdFx0XHR4aHIub25wcm9ncmVzcyA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdFx0c2VsZi5fb25YSFJQcm9ncmVzcygpXG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0eGhyLm9uZXJyb3IgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRyZXR1cm5cblx0XHRcdHNlbGYuX3Jlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdYSFIgZXJyb3InKSlcblx0XHR9XG5cblx0XHR0cnkge1xuXHRcdFx0eGhyLnNlbmQoYm9keSlcblx0XHR9IGNhdGNoIChlcnIpIHtcblx0XHRcdHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHRcdFx0fSlcblx0XHRcdHJldHVyblxuXHRcdH1cblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBpZiB4aHIuc3RhdHVzIGlzIHJlYWRhYmxlIGFuZCBub24temVybywgaW5kaWNhdGluZyBubyBlcnJvci5cbiAqIEV2ZW4gdGhvdWdoIHRoZSBzcGVjIHNheXMgaXQgc2hvdWxkIGJlIGF2YWlsYWJsZSBpbiByZWFkeVN0YXRlIDMsXG4gKiBhY2Nlc3NpbmcgaXQgdGhyb3dzIGFuIGV4Y2VwdGlvbiBpbiBJRThcbiAqL1xuZnVuY3Rpb24gc3RhdHVzVmFsaWQgKHhocikge1xuXHR0cnkge1xuXHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzXG5cdFx0cmV0dXJuIChzdGF0dXMgIT09IG51bGwgJiYgc3RhdHVzICE9PSAwKVxuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlXG5cdH1cbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX29uWEhSUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxuXG5cdGlmICghc3RhdHVzVmFsaWQoc2VsZi5feGhyKSB8fCBzZWxmLl9kZXN0cm95ZWQpXG5cdFx0cmV0dXJuXG5cblx0aWYgKCFzZWxmLl9yZXNwb25zZSlcblx0XHRzZWxmLl9jb25uZWN0KClcblxuXHRzZWxmLl9yZXNwb25zZS5fb25YSFJQcm9ncmVzcyhzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5fY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKHNlbGYuX2Rlc3Ryb3llZClcblx0XHRyZXR1cm5cblxuXHRzZWxmLl9yZXNwb25zZSA9IG5ldyBJbmNvbWluZ01lc3NhZ2Uoc2VsZi5feGhyLCBzZWxmLl9mZXRjaFJlc3BvbnNlLCBzZWxmLl9tb2RlLCBzZWxmLl9yZXNldFRpbWVycy5iaW5kKHNlbGYpKVxuXHRzZWxmLl9yZXNwb25zZS5vbignZXJyb3InLCBmdW5jdGlvbihlcnIpIHtcblx0XHRzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKVxuXHR9KVxuXG5cdHNlbGYuZW1pdCgncmVzcG9uc2UnLCBzZWxmLl9yZXNwb25zZSlcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0c2VsZi5fYm9keS5wdXNoKGNodW5rKVxuXHRjYigpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLl9yZXNldFRpbWVycyA9IGZ1bmN0aW9uIChkb25lKSB7XG5cdHZhciBzZWxmID0gdGhpc1xuXG5cdGdsb2JhbC5jbGVhclRpbWVvdXQoc2VsZi5fc29ja2V0VGltZXIpXG5cdHNlbGYuX3NvY2tldFRpbWVyID0gbnVsbFxuXG5cdGlmIChkb25lKSB7XG5cdFx0Z2xvYmFsLmNsZWFyVGltZW91dChzZWxmLl9mZXRjaFRpbWVyKVxuXHRcdHNlbGYuX2ZldGNoVGltZXIgPSBudWxsXG5cdH0gZWxzZSBpZiAoc2VsZi5fc29ja2V0VGltZW91dCkge1xuXHRcdHNlbGYuX3NvY2tldFRpbWVyID0gZ2xvYmFsLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuXHRcdFx0c2VsZi5lbWl0KCd0aW1lb3V0Jylcblx0XHR9LCBzZWxmLl9zb2NrZXRUaW1lb3V0KVxuXHR9XG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cdHNlbGYuX2Rlc3Ryb3llZCA9IHRydWVcblx0c2VsZi5fcmVzZXRUaW1lcnModHJ1ZSlcblx0aWYgKHNlbGYuX3Jlc3BvbnNlKVxuXHRcdHNlbGYuX3Jlc3BvbnNlLl9kZXN0cm95ZWQgPSB0cnVlXG5cdGlmIChzZWxmLl94aHIpXG5cdFx0c2VsZi5feGhyLmFib3J0KClcblx0ZWxzZSBpZiAoc2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIpXG5cdFx0c2VsZi5fZmV0Y2hBYm9ydENvbnRyb2xsZXIuYWJvcnQoKVxuXG5cdGlmIChlcnIpXG5cdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcbn1cblxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGRhdGEsIGVuY29kaW5nLCBjYikge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0aWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0Y2IgPSBkYXRhXG5cdFx0ZGF0YSA9IHVuZGVmaW5lZFxuXHR9XG5cblx0c3RyZWFtLldyaXRhYmxlLnByb3RvdHlwZS5lbmQuY2FsbChzZWxmLCBkYXRhLCBlbmNvZGluZywgY2IpXG59XG5cbkNsaWVudFJlcXVlc3QucHJvdG90eXBlLnNldFRpbWVvdXQgPSBmdW5jdGlvbiAodGltZW91dCwgY2IpIHtcblx0dmFyIHNlbGYgPSB0aGlzXG5cblx0aWYgKGNiKVxuXHRcdHNlbGYub25jZSgndGltZW91dCcsIGNiKVxuXG5cdHNlbGYuX3NvY2tldFRpbWVvdXQgPSB0aW1lb3V0XG5cdHNlbGYuX3Jlc2V0VGltZXJzKGZhbHNlKVxufVxuXG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5mbHVzaEhlYWRlcnMgPSBmdW5jdGlvbiAoKSB7fVxuQ2xpZW50UmVxdWVzdC5wcm90b3R5cGUuc2V0Tm9EZWxheSA9IGZ1bmN0aW9uICgpIHt9XG5DbGllbnRSZXF1ZXN0LnByb3RvdHlwZS5zZXRTb2NrZXRLZWVwQWxpdmUgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBUYWtlbiBmcm9tIGh0dHA6Ly93d3cudzMub3JnL1RSL1hNTEh0dHBSZXF1ZXN0LyN0aGUtc2V0cmVxdWVzdGhlYWRlciUyOCUyOS1tZXRob2RcbnZhciB1bnNhZmVIZWFkZXJzID0gW1xuXHQnYWNjZXB0LWNoYXJzZXQnLFxuXHQnYWNjZXB0LWVuY29kaW5nJyxcblx0J2FjY2Vzcy1jb250cm9sLXJlcXVlc3QtaGVhZGVycycsXG5cdCdhY2Nlc3MtY29udHJvbC1yZXF1ZXN0LW1ldGhvZCcsXG5cdCdjb25uZWN0aW9uJyxcblx0J2NvbnRlbnQtbGVuZ3RoJyxcblx0J2Nvb2tpZScsXG5cdCdjb29raWUyJyxcblx0J2RhdGUnLFxuXHQnZG50Jyxcblx0J2V4cGVjdCcsXG5cdCdob3N0Jyxcblx0J2tlZXAtYWxpdmUnLFxuXHQnb3JpZ2luJyxcblx0J3JlZmVyZXInLFxuXHQndGUnLFxuXHQndHJhaWxlcicsXG5cdCd0cmFuc2Zlci1lbmNvZGluZycsXG5cdCd1cGdyYWRlJyxcblx0J3ZpYSdcbl1cbiIsInZhciBjYXBhYmlsaXR5ID0gcmVxdWlyZSgnLi9jYXBhYmlsaXR5JylcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJylcbnZhciBzdHJlYW0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0nKVxuXG52YXIgclN0YXRlcyA9IGV4cG9ydHMucmVhZHlTdGF0ZXMgPSB7XG5cdFVOU0VOVDogMCxcblx0T1BFTkVEOiAxLFxuXHRIRUFERVJTX1JFQ0VJVkVEOiAyLFxuXHRMT0FESU5HOiAzLFxuXHRET05FOiA0XG59XG5cbnZhciBJbmNvbWluZ01lc3NhZ2UgPSBleHBvcnRzLkluY29taW5nTWVzc2FnZSA9IGZ1bmN0aW9uICh4aHIsIHJlc3BvbnNlLCBtb2RlLCByZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblx0c3RyZWFtLlJlYWRhYmxlLmNhbGwoc2VsZilcblxuXHRzZWxmLl9tb2RlID0gbW9kZVxuXHRzZWxmLmhlYWRlcnMgPSB7fVxuXHRzZWxmLnJhd0hlYWRlcnMgPSBbXVxuXHRzZWxmLnRyYWlsZXJzID0ge31cblx0c2VsZi5yYXdUcmFpbGVycyA9IFtdXG5cblx0Ly8gRmFrZSB0aGUgJ2Nsb3NlJyBldmVudCwgYnV0IG9ubHkgb25jZSAnZW5kJyBmaXJlc1xuXHRzZWxmLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XG5cdFx0Ly8gVGhlIG5leHRUaWNrIGlzIG5lY2Vzc2FyeSB0byBwcmV2ZW50IHRoZSAncmVxdWVzdCcgbW9kdWxlIGZyb20gY2F1c2luZyBhbiBpbmZpbml0ZSBsb29wXG5cdFx0cHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG5cdFx0XHRzZWxmLmVtaXQoJ2Nsb3NlJylcblx0XHR9KVxuXHR9KVxuXG5cdGlmIChtb2RlID09PSAnZmV0Y2gnKSB7XG5cdFx0c2VsZi5fZmV0Y2hSZXNwb25zZSA9IHJlc3BvbnNlXG5cblx0XHRzZWxmLnVybCA9IHJlc3BvbnNlLnVybFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHJlc3BvbnNlLnN0YXR1c1xuXHRcdHNlbGYuc3RhdHVzTWVzc2FnZSA9IHJlc3BvbnNlLnN0YXR1c1RleHRcblx0XHRcblx0XHRyZXNwb25zZS5oZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlciwga2V5KXtcblx0XHRcdHNlbGYuaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSBoZWFkZXJcblx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKGtleSwgaGVhZGVyKVxuXHRcdH0pXG5cblx0XHRpZiAoY2FwYWJpbGl0eS53cml0YWJsZVN0cmVhbSkge1xuXHRcdFx0dmFyIHdyaXRhYmxlID0gbmV3IFdyaXRhYmxlU3RyZWFtKHtcblx0XHRcdFx0d3JpdGU6IGZ1bmN0aW9uIChjaHVuaykge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKGZhbHNlKVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG5cdFx0XHRcdFx0XHRpZiAoc2VsZi5fZGVzdHJveWVkKSB7XG5cdFx0XHRcdFx0XHRcdHJlamVjdCgpXG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYoc2VsZi5wdXNoKEJ1ZmZlci5mcm9tKGNodW5rKSkpIHtcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZSgpXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRzZWxmLl9yZXN1bWVGZXRjaCA9IHJlc29sdmVcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KVxuXHRcdFx0XHR9LFxuXHRcdFx0XHRjbG9zZTogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdFx0aWYgKCFzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0fSxcblx0XHRcdFx0YWJvcnQ6IGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fVxuXHRcdFx0fSlcblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVzcG9uc2UuYm9keS5waXBlVG8od3JpdGFibGUpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcblx0XHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdFx0c2VsZi5lbWl0KCdlcnJvcicsIGVycilcblx0XHRcdFx0fSlcblx0XHRcdFx0cmV0dXJuXG5cdFx0XHR9IGNhdGNoIChlKSB7fSAvLyBwaXBlVG8gbWV0aG9kIGlzbid0IGRlZmluZWQuIENhbid0IGZpbmQgYSBiZXR0ZXIgd2F5IHRvIGZlYXR1cmUgdGVzdCB0aGlzXG5cdFx0fVxuXHRcdC8vIGZhbGxiYWNrIGZvciB3aGVuIHdyaXRhYmxlU3RyZWFtIG9yIHBpcGVUbyBhcmVuJ3QgYXZhaWxhYmxlXG5cdFx0dmFyIHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcblx0XHRmdW5jdGlvbiByZWFkICgpIHtcblx0XHRcdHJlYWRlci5yZWFkKCkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG5cdFx0XHRcdGlmIChzZWxmLl9kZXN0cm95ZWQpXG5cdFx0XHRcdFx0cmV0dXJuXG5cdFx0XHRcdHJlc2V0VGltZXJzKHJlc3VsdC5kb25lKVxuXHRcdFx0XHRpZiAocmVzdWx0LmRvbmUpIHtcblx0XHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdFx0XHRyZXR1cm5cblx0XHRcdFx0fVxuXHRcdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20ocmVzdWx0LnZhbHVlKSlcblx0XHRcdFx0cmVhZCgpXG5cdFx0XHR9KS5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG5cdFx0XHRcdHJlc2V0VGltZXJzKHRydWUpXG5cdFx0XHRcdGlmICghc2VsZi5fZGVzdHJveWVkKVxuXHRcdFx0XHRcdHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpXG5cdFx0XHR9KVxuXHRcdH1cblx0XHRyZWFkKClcblx0fSBlbHNlIHtcblx0XHRzZWxmLl94aHIgPSB4aHJcblx0XHRzZWxmLl9wb3MgPSAwXG5cblx0XHRzZWxmLnVybCA9IHhoci5yZXNwb25zZVVSTFxuXHRcdHNlbGYuc3RhdHVzQ29kZSA9IHhoci5zdGF0dXNcblx0XHRzZWxmLnN0YXR1c01lc3NhZ2UgPSB4aHIuc3RhdHVzVGV4dFxuXHRcdHZhciBoZWFkZXJzID0geGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpLnNwbGl0KC9cXHI/XFxuLylcblx0XHRoZWFkZXJzLmZvckVhY2goZnVuY3Rpb24gKGhlYWRlcikge1xuXHRcdFx0dmFyIG1hdGNoZXMgPSBoZWFkZXIubWF0Y2goL14oW146XSspOlxccyooLiopLylcblx0XHRcdGlmIChtYXRjaGVzKSB7XG5cdFx0XHRcdHZhciBrZXkgPSBtYXRjaGVzWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0aWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XG5cdFx0XHRcdFx0aWYgKHNlbGYuaGVhZGVyc1trZXldID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gW11cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VsZi5oZWFkZXJzW2tleV0ucHVzaChtYXRjaGVzWzJdKVxuXHRcdFx0XHR9IGVsc2UgaWYgKHNlbGYuaGVhZGVyc1trZXldICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHRzZWxmLmhlYWRlcnNba2V5XSArPSAnLCAnICsgbWF0Y2hlc1syXVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYuaGVhZGVyc1trZXldID0gbWF0Y2hlc1syXVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYucmF3SGVhZGVycy5wdXNoKG1hdGNoZXNbMV0sIG1hdGNoZXNbMl0pXG5cdFx0XHR9XG5cdFx0fSlcblxuXHRcdHNlbGYuX2NoYXJzZXQgPSAneC11c2VyLWRlZmluZWQnXG5cdFx0aWYgKCFjYXBhYmlsaXR5Lm92ZXJyaWRlTWltZVR5cGUpIHtcblx0XHRcdHZhciBtaW1lVHlwZSA9IHNlbGYucmF3SGVhZGVyc1snbWltZS10eXBlJ11cblx0XHRcdGlmIChtaW1lVHlwZSkge1xuXHRcdFx0XHR2YXIgY2hhcnNldE1hdGNoID0gbWltZVR5cGUubWF0Y2goLztcXHMqY2hhcnNldD0oW147XSkoO3wkKS8pXG5cdFx0XHRcdGlmIChjaGFyc2V0TWF0Y2gpIHtcblx0XHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gY2hhcnNldE1hdGNoWzFdLnRvTG93ZXJDYXNlKClcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHRzZWxmLl9jaGFyc2V0ID0gJ3V0Zi04JyAvLyBiZXN0IGd1ZXNzXG5cdFx0fVxuXHR9XG59XG5cbmluaGVyaXRzKEluY29taW5nTWVzc2FnZSwgc3RyZWFtLlJlYWRhYmxlKVxuXG5JbmNvbWluZ01lc3NhZ2UucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKCkge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgcmVzb2x2ZSA9IHNlbGYuX3Jlc3VtZUZldGNoXG5cdGlmIChyZXNvbHZlKSB7XG5cdFx0c2VsZi5fcmVzdW1lRmV0Y2ggPSBudWxsXG5cdFx0cmVzb2x2ZSgpXG5cdH1cbn1cblxuSW5jb21pbmdNZXNzYWdlLnByb3RvdHlwZS5fb25YSFJQcm9ncmVzcyA9IGZ1bmN0aW9uIChyZXNldFRpbWVycykge1xuXHR2YXIgc2VsZiA9IHRoaXNcblxuXHR2YXIgeGhyID0gc2VsZi5feGhyXG5cblx0dmFyIHJlc3BvbnNlID0gbnVsbFxuXHRzd2l0Y2ggKHNlbGYuX21vZGUpIHtcblx0XHRjYXNlICd0ZXh0Jzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlVGV4dFxuXHRcdFx0aWYgKHJlc3BvbnNlLmxlbmd0aCA+IHNlbGYuX3Bvcykge1xuXHRcdFx0XHR2YXIgbmV3RGF0YSA9IHJlc3BvbnNlLnN1YnN0cihzZWxmLl9wb3MpXG5cdFx0XHRcdGlmIChzZWxmLl9jaGFyc2V0ID09PSAneC11c2VyLWRlZmluZWQnKSB7XG5cdFx0XHRcdFx0dmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYyhuZXdEYXRhLmxlbmd0aClcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG5ld0RhdGEubGVuZ3RoOyBpKyspXG5cdFx0XHRcdFx0XHRidWZmZXJbaV0gPSBuZXdEYXRhLmNoYXJDb2RlQXQoaSkgJiAweGZmXG5cblx0XHRcdFx0XHRzZWxmLnB1c2goYnVmZmVyKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHNlbGYucHVzaChuZXdEYXRhLCBzZWxmLl9jaGFyc2V0KVxuXHRcdFx0XHR9XG5cdFx0XHRcdHNlbGYuX3BvcyA9IHJlc3BvbnNlLmxlbmd0aFxuXHRcdFx0fVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdhcnJheWJ1ZmZlcic6XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuRE9ORSB8fCAheGhyLnJlc3BvbnNlKVxuXHRcdFx0XHRicmVha1xuXHRcdFx0cmVzcG9uc2UgPSB4aHIucmVzcG9uc2Vcblx0XHRcdHNlbGYucHVzaChCdWZmZXIuZnJvbShuZXcgVWludDhBcnJheShyZXNwb25zZSkpKVxuXHRcdFx0YnJlYWtcblx0XHRjYXNlICdtb3otY2h1bmtlZC1hcnJheWJ1ZmZlcic6IC8vIHRha2Ugd2hvbGVcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORyB8fCAhcmVzcG9uc2UpXG5cdFx0XHRcdGJyZWFrXG5cdFx0XHRzZWxmLnB1c2goQnVmZmVyLmZyb20obmV3IFVpbnQ4QXJyYXkocmVzcG9uc2UpKSlcblx0XHRcdGJyZWFrXG5cdFx0Y2FzZSAnbXMtc3RyZWFtJzpcblx0XHRcdHJlc3BvbnNlID0geGhyLnJlc3BvbnNlXG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgIT09IHJTdGF0ZXMuTE9BRElORylcblx0XHRcdFx0YnJlYWtcblx0XHRcdHZhciByZWFkZXIgPSBuZXcgZ2xvYmFsLk1TU3RyZWFtUmVhZGVyKClcblx0XHRcdHJlYWRlci5vbnByb2dyZXNzID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRpZiAocmVhZGVyLnJlc3VsdC5ieXRlTGVuZ3RoID4gc2VsZi5fcG9zKSB7XG5cdFx0XHRcdFx0c2VsZi5wdXNoKEJ1ZmZlci5mcm9tKG5ldyBVaW50OEFycmF5KHJlYWRlci5yZXN1bHQuc2xpY2Uoc2VsZi5fcG9zKSkpKVxuXHRcdFx0XHRcdHNlbGYuX3BvcyA9IHJlYWRlci5yZXN1bHQuYnl0ZUxlbmd0aFxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZWFkZXIub25sb2FkID0gZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdFx0XHRzZWxmLnB1c2gobnVsbClcblx0XHRcdH1cblx0XHRcdC8vIHJlYWRlci5vbmVycm9yID0gPz8/IC8vIFRPRE86IHRoaXNcblx0XHRcdHJlYWRlci5yZWFkQXNBcnJheUJ1ZmZlcihyZXNwb25zZSlcblx0XHRcdGJyZWFrXG5cdH1cblxuXHQvLyBUaGUgbXMtc3RyZWFtIGNhc2UgaGFuZGxlcyBlbmQgc2VwYXJhdGVseSBpbiByZWFkZXIub25sb2FkKClcblx0aWYgKHNlbGYuX3hoci5yZWFkeVN0YXRlID09PSByU3RhdGVzLkRPTkUgJiYgc2VsZi5fbW9kZSAhPT0gJ21zLXN0cmVhbScpIHtcblx0XHRyZXNldFRpbWVycyh0cnVlKVxuXHRcdHNlbGYucHVzaChudWxsKVxuXHR9XG59XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcgPSAnJyArIGVuY29kaW5nO1xuICBzd2l0Y2ggKGVuY29kaW5nICYmIGVuY29kaW5nLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIF9ub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgaWYgKCFlbmMpIHJldHVybiAndXRmOCc7XG4gIHZhciByZXRyaWVkO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIHN3aXRjaCAoZW5jKSB7XG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuICd1dGY4JztcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiAndXRmMTZsZSc7XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuICdsYXRpbjEnO1xuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBlbmM7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAocmV0cmllZCkgcmV0dXJuOyAvLyB1bmRlZmluZWRcbiAgICAgICAgZW5jID0gKCcnICsgZW5jKS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cbn07XG5cbi8vIERvIG5vdCBjYWNoZSBgQnVmZmVyLmlzRW5jb2RpbmdgIHdoZW4gY2hlY2tpbmcgZW5jb2RpbmcgbmFtZXMgYXMgc29tZVxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xuZnVuY3Rpb24gbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIHZhciBuZW5jID0gX25vcm1hbGl6ZUVuY29kaW5nKGVuYyk7XG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xuICByZXR1cm4gbmVuYyB8fCBlbmM7XG59XG5cbi8vIFN0cmluZ0RlY29kZXIgcHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBlZmZpY2llbnRseSBzcGxpdHRpbmcgYSBzZXJpZXMgb2Zcbi8vIGJ1ZmZlcnMgaW50byBhIHNlcmllcyBvZiBKUyBzdHJpbmdzIHdpdGhvdXQgYnJlYWtpbmcgYXBhcnQgbXVsdGktYnl0ZVxuLy8gY2hhcmFjdGVycy5cbmV4cG9ydHMuU3RyaW5nRGVjb2RlciA9IFN0cmluZ0RlY29kZXI7XG5mdW5jdGlvbiBTdHJpbmdEZWNvZGVyKGVuY29kaW5nKSB7XG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XG4gIHZhciBuYjtcbiAgc3dpdGNoICh0aGlzLmVuY29kaW5nKSB7XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICB0aGlzLnRleHQgPSB1dGYxNlRleHQ7XG4gICAgICB0aGlzLmVuZCA9IHV0ZjE2RW5kO1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAndXRmOCc6XG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xuICAgICAgbmIgPSA0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgIHRoaXMudGV4dCA9IGJhc2U2NFRleHQ7XG4gICAgICB0aGlzLmVuZCA9IGJhc2U2NEVuZDtcbiAgICAgIG5iID0gMztcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XG4gICAgICB0aGlzLmVuZCA9IHNpbXBsZUVuZDtcbiAgICAgIHJldHVybjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgdGhpcy5sYXN0VG90YWwgPSAwO1xuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcbn1cblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmIChidWYubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gIHZhciByO1xuICB2YXIgaTtcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICByID0gdGhpcy5maWxsTGFzdChidWYpO1xuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcbiAgICBpID0gdGhpcy5sYXN0TmVlZDtcbiAgICB0aGlzLmxhc3ROZWVkID0gMDtcbiAgfSBlbHNlIHtcbiAgICBpID0gMDtcbiAgfVxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XG4gIHJldHVybiByIHx8ICcnO1xufTtcblxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZW5kID0gdXRmOEVuZDtcblxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLnRleHQgPSB1dGY4VGV4dDtcblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUuZmlsbExhc3QgPSBmdW5jdGlvbiAoYnVmKSB7XG4gIGlmICh0aGlzLmxhc3ROZWVkIDw9IGJ1Zi5sZW5ndGgpIHtcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59O1xuXG4vLyBDaGVja3MgdGhlIHR5cGUgb2YgYSBVVEYtOCBieXRlLCB3aGV0aGVyIGl0J3MgQVNDSUksIGEgbGVhZGluZyBieXRlLCBvciBhXG4vLyBjb250aW51YXRpb24gYnl0ZS4gSWYgYW4gaW52YWxpZCBieXRlIGlzIGRldGVjdGVkLCAtMiBpcyByZXR1cm5lZC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xuICBpZiAoYnl0ZSA8PSAweDdGKSByZXR1cm4gMDtlbHNlIGlmIChieXRlID4+IDUgPT09IDB4MDYpIHJldHVybiAyO2Vsc2UgaWYgKGJ5dGUgPj4gNCA9PT0gMHgwRSkgcmV0dXJuIDM7ZWxzZSBpZiAoYnl0ZSA+PiAzID09PSAweDFFKSByZXR1cm4gNDtcbiAgcmV0dXJuIGJ5dGUgPj4gNiA9PT0gMHgwMiA/IC0xIDogLTI7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDI7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpIHx8IG5iID09PSAtMikgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIGEgc2luZ2xlIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlciAoJ1xcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xuLy8gYmVoYXZpb3IuIFRoZSBjb250aW51YXRpb24gYnl0ZSBjaGVjayBpcyBpbmNsdWRlZCB0aHJlZSB0aW1lcyBpbiB0aGUgY2FzZVxuLy8gd2hlcmUgYWxsIG9mIHRoZSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgY2hhcmFjdGVyIGV4aXN0IGluIHRoZSBzYW1lIGJ1ZmZlci5cbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcbi8vIGxvb3AuXG5mdW5jdGlvbiB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHNlbGYsIGJ1ZiwgcCkge1xuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgc2VsZi5sYXN0TmVlZCA9IDA7XG4gICAgcmV0dXJuICdcXHVmZmZkJztcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCc7XG4gICAgfVxuICAgIGlmIChzZWxmLmxhc3ROZWVkID4gMiAmJiBidWYubGVuZ3RoID4gMikge1xuICAgICAgaWYgKChidWZbMl0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcbiAgICAgICAgcmV0dXJuICdcXHVmZmZkJztcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBpcyBhZGRlZCB3aGVuIGVuZGluZyBvbiBhIHBhcnRpYWxcbi8vIGNoYXJhY3Rlci5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjMuMiBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgUmFuZ2VFcnJvcihlcnJvcnNbdHlwZV0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBgQXJyYXkjbWFwYCB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnkgYXJyYXlcblx0ICogaXRlbS5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBhcnJheSBvZiB2YWx1ZXMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwKGFycmF5LCBmbikge1xuXHRcdHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cdFx0dmFyIHJlc3VsdCA9IFtdO1xuXHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0cmVzdWx0W2xlbmd0aF0gPSBmbihhcnJheVtsZW5ndGhdKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIHNpbXBsZSBgQXJyYXkjbWFwYC1saWtlIHdyYXBwZXIgdG8gd29yayB3aXRoIGRvbWFpbiBuYW1lIHN0cmluZ3Mgb3IgZW1haWxcblx0ICogYWRkcmVzc2VzLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gZG9tYWluIFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzLlxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdGhhdCBnZXRzIGNhbGxlZCBmb3IgZXZlcnlcblx0ICogY2hhcmFjdGVyLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IHN0cmluZyBvZiBjaGFyYWN0ZXJzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFja1xuXHQgKiBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcERvbWFpbihzdHJpbmcsIGZuKSB7XG5cdFx0dmFyIHBhcnRzID0gc3RyaW5nLnNwbGl0KCdAJyk7XG5cdFx0dmFyIHJlc3VsdCA9ICcnO1xuXHRcdGlmIChwYXJ0cy5sZW5ndGggPiAxKSB7XG5cdFx0XHQvLyBJbiBlbWFpbCBhZGRyZXNzZXMsIG9ubHkgdGhlIGRvbWFpbiBuYW1lIHNob3VsZCBiZSBwdW55Y29kZWQuIExlYXZlXG5cdFx0XHQvLyB0aGUgbG9jYWwgcGFydCAoaS5lLiBldmVyeXRoaW5nIHVwIHRvIGBAYCkgaW50YWN0LlxuXHRcdFx0cmVzdWx0ID0gcGFydHNbMF0gKyAnQCc7XG5cdFx0XHRzdHJpbmcgPSBwYXJ0c1sxXTtcblx0XHR9XG5cdFx0Ly8gQXZvaWQgYHNwbGl0KHJlZ2V4KWAgZm9yIElFOCBjb21wYXRpYmlsaXR5LiBTZWUgIzE3LlxuXHRcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4U2VwYXJhdG9ycywgJ1xceDJFJyk7XG5cdFx0dmFyIGxhYmVscyA9IHN0cmluZy5zcGxpdCgnLicpO1xuXHRcdHZhciBlbmNvZGVkID0gbWFwKGxhYmVscywgZm4pLmpvaW4oJy4nKTtcblx0XHRyZXR1cm4gcmVzdWx0ICsgZW5jb2RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIG51bWVyaWMgY29kZSBwb2ludHMgb2YgZWFjaCBVbmljb2RlXG5cdCAqIGNoYXJhY3RlciBpbiB0aGUgc3RyaW5nLiBXaGlsZSBKYXZhU2NyaXB0IHVzZXMgVUNTLTIgaW50ZXJuYWxseSxcblx0ICogdGhpcyBmdW5jdGlvbiB3aWxsIGNvbnZlcnQgYSBwYWlyIG9mIHN1cnJvZ2F0ZSBoYWx2ZXMgKGVhY2ggb2Ygd2hpY2hcblx0ICogVUNTLTIgZXhwb3NlcyBhcyBzZXBhcmF0ZSBjaGFyYWN0ZXJzKSBpbnRvIGEgc2luZ2xlIGNvZGUgcG9pbnQsXG5cdCAqIG1hdGNoaW5nIFVURi0xNi5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5lbmNvZGVgXG5cdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBkZWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgVW5pY29kZSBpbnB1dCBzdHJpbmcgKFVDUy0yKS5cblx0ICogQHJldHVybnMge0FycmF5fSBUaGUgbmV3IGFycmF5IG9mIGNvZGUgcG9pbnRzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmRlY29kZShzdHJpbmcpIHtcblx0XHR2YXIgb3V0cHV0ID0gW10sXG5cdFx0ICAgIGNvdW50ZXIgPSAwLFxuXHRcdCAgICBsZW5ndGggPSBzdHJpbmcubGVuZ3RoLFxuXHRcdCAgICB2YWx1ZSxcblx0XHQgICAgZXh0cmE7XG5cdFx0d2hpbGUgKGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdHZhbHVlID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdGlmICh2YWx1ZSA+PSAweEQ4MDAgJiYgdmFsdWUgPD0gMHhEQkZGICYmIGNvdW50ZXIgPCBsZW5ndGgpIHtcblx0XHRcdFx0Ly8gaGlnaCBzdXJyb2dhdGUsIGFuZCB0aGVyZSBpcyBhIG5leHQgY2hhcmFjdGVyXG5cdFx0XHRcdGV4dHJhID0gc3RyaW5nLmNoYXJDb2RlQXQoY291bnRlcisrKTtcblx0XHRcdFx0aWYgKChleHRyYSAmIDB4RkMwMCkgPT0gMHhEQzAwKSB7IC8vIGxvdyBzdXJyb2dhdGVcblx0XHRcdFx0XHRvdXRwdXQucHVzaCgoKHZhbHVlICYgMHgzRkYpIDw8IDEwKSArIChleHRyYSAmIDB4M0ZGKSArIDB4MTAwMDApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC8vIHVubWF0Y2hlZCBzdXJyb2dhdGU7IG9ubHkgYXBwZW5kIHRoaXMgY29kZSB1bml0LCBpbiBjYXNlIHRoZSBuZXh0XG5cdFx0XHRcdFx0Ly8gY29kZSB1bml0IGlzIHRoZSBoaWdoIHN1cnJvZ2F0ZSBvZiBhIHN1cnJvZ2F0ZSBwYWlyXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0XHRcdGNvdW50ZXItLTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3V0cHV0LnB1c2godmFsdWUpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gb3V0cHV0O1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYSBzdHJpbmcgYmFzZWQgb24gYW4gYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHNlZSBgcHVueWNvZGUudWNzMi5kZWNvZGVgXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGVuY29kZVxuXHQgKiBAcGFyYW0ge0FycmF5fSBjb2RlUG9pbnRzIFRoZSBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgbmV3IFVuaWNvZGUgc3RyaW5nIChVQ1MtMikuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZW5jb2RlKGFycmF5KSB7XG5cdFx0cmV0dXJuIG1hcChhcnJheSwgZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHZhciBvdXRwdXQgPSAnJztcblx0XHRcdGlmICh2YWx1ZSA+IDB4RkZGRikge1xuXHRcdFx0XHR2YWx1ZSAtPSAweDEwMDAwO1xuXHRcdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKTtcblx0XHRcdFx0dmFsdWUgPSAweERDMDAgfCB2YWx1ZSAmIDB4M0ZGO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSk7XG5cdFx0XHRyZXR1cm4gb3V0cHV0O1xuXHRcdH0pLmpvaW4oJycpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgYmFzaWMgY29kZSBwb2ludCBpbnRvIGEgZGlnaXQvaW50ZWdlci5cblx0ICogQHNlZSBgZGlnaXRUb0Jhc2ljKClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlUG9pbnQgVGhlIGJhc2ljIG51bWVyaWMgY29kZSBwb2ludCB2YWx1ZS5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50IChmb3IgdXNlIGluXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaW4gdGhlIHJhbmdlIGAwYCB0byBgYmFzZSAtIDFgLCBvciBgYmFzZWAgaWZcblx0ICogdGhlIGNvZGUgcG9pbnQgZG9lcyBub3QgcmVwcmVzZW50IGEgdmFsdWUuXG5cdCAqL1xuXHRmdW5jdGlvbiBiYXNpY1RvRGlnaXQoY29kZVBvaW50KSB7XG5cdFx0aWYgKGNvZGVQb2ludCAtIDQ4IDwgMTApIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSAyMjtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDY1IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA2NTtcblx0XHR9XG5cdFx0aWYgKGNvZGVQb2ludCAtIDk3IDwgMjYpIHtcblx0XHRcdHJldHVybiBjb2RlUG9pbnQgLSA5Nztcblx0XHR9XG5cdFx0cmV0dXJuIGJhc2U7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBkaWdpdC9pbnRlZ2VyIGludG8gYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAc2VlIGBiYXNpY1RvRGlnaXQoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGRpZ2l0IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHJldHVybnMge051bWJlcn0gVGhlIGJhc2ljIGNvZGUgcG9pbnQgd2hvc2UgdmFsdWUgKHdoZW4gdXNlZCBmb3Jcblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpcyBgZGlnaXRgLCB3aGljaCBuZWVkcyB0byBiZSBpbiB0aGUgcmFuZ2Vcblx0ICogYDBgIHRvIGBiYXNlIC0gMWAuIElmIGBmbGFnYCBpcyBub24temVybywgdGhlIHVwcGVyY2FzZSBmb3JtIGlzXG5cdCAqIHVzZWQ7IGVsc2UsIHRoZSBsb3dlcmNhc2UgZm9ybSBpcyB1c2VkLiBUaGUgYmVoYXZpb3IgaXMgdW5kZWZpbmVkXG5cdCAqIGlmIGBmbGFnYCBpcyBub24temVybyBhbmQgYGRpZ2l0YCBoYXMgbm8gdXBwZXJjYXNlIGZvcm0uXG5cdCAqL1xuXHRmdW5jdGlvbiBkaWdpdFRvQmFzaWMoZGlnaXQsIGZsYWcpIHtcblx0XHQvLyAgMC4uMjUgbWFwIHRvIEFTQ0lJIGEuLnogb3IgQS4uWlxuXHRcdC8vIDI2Li4zNSBtYXAgdG8gQVNDSUkgMC4uOVxuXHRcdHJldHVybiBkaWdpdCArIDIyICsgNzUgKiAoZGlnaXQgPCAyNikgLSAoKGZsYWcgIT0gMCkgPDwgNSk7XG5cdH1cblxuXHQvKipcblx0ICogQmlhcyBhZGFwdGF0aW9uIGZ1bmN0aW9uIGFzIHBlciBzZWN0aW9uIDMuNCBvZiBSRkMgMzQ5Mi5cblx0ICogaHR0cDovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS4zLjInLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7IC8vIGluIE5vZGUuanMgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2UgeyAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHsgLy8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBleHRlbmRcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxuZnVuY3Rpb24gZXh0ZW5kKCkge1xuICAgIHZhciB0YXJnZXQgPSB7fVxuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXVxuXG4gICAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHNvdXJjZSwga2V5KSkge1xuICAgICAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0YXJnZXRcbn1cbiJdLCJuYW1lcyI6WyJfX2ltcG9ydERlZmF1bHQiLCJtb2QiLCJfX2VzTW9kdWxlIiwiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJibGFrZTJiXzEiLCJyZXF1aXJlIiwiYmVjaDMyXzEiLCJEQVRBIiwiQXNzZXRGaW5nZXJwcmludCIsImhhc2hCdWYiLCJ3b3JkcyIsImJlY2gzMiIsInRvV29yZHMiLCJlbmNvZGUiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJmaW5nZXJwcmludCIsInNsaWNlIiwiaGFzaCIsInBvbGljeUlkIiwiYXNzZXROYW1lIiwidXBkYXRlIiwiVWludDhBcnJheSIsImRpZ2VzdCIsImZyb21IYXNoIiwiZGVjb2RlIiwicHJlZml4IiwiRXJyb3IiLCJmcm9tV29yZHMiLCJtb2R1bGUiLCJ1dGlscyIsInNldHRsZSIsImNvb2tpZXMiLCJidWlsZFVSTCIsImJ1aWxkRnVsbFBhdGgiLCJwYXJzZUhlYWRlcnMiLCJpc1VSTFNhbWVPcmlnaW4iLCJjcmVhdGVFcnJvciIsInhockFkYXB0ZXIiLCJjb25maWciLCJQcm9taXNlIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3REYXRhIiwiZGF0YSIsInJlcXVlc3RIZWFkZXJzIiwiaGVhZGVycyIsInJlc3BvbnNlVHlwZSIsImlzRm9ybURhdGEiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJhdXRoIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsInVuZXNjYXBlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwiQXV0aG9yaXphdGlvbiIsImJ0b2EiLCJmdWxsUGF0aCIsImJhc2VVUkwiLCJ1cmwiLCJvcGVuIiwibWV0aG9kIiwidG9VcHBlckNhc2UiLCJwYXJhbXMiLCJwYXJhbXNTZXJpYWxpemVyIiwidGltZW91dCIsIm9ubG9hZGVuZCIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwic3RhdHVzIiwic3RhdHVzVGV4dCIsIm9ucmVhZHlzdGF0ZWNoYW5nZSIsImhhbmRsZUxvYWQiLCJyZWFkeVN0YXRlIiwicmVzcG9uc2VVUkwiLCJpbmRleE9mIiwic2V0VGltZW91dCIsIm9uYWJvcnQiLCJoYW5kbGVBYm9ydCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsIm9udGltZW91dCIsImhhbmRsZVRpbWVvdXQiLCJ0aW1lb3V0RXJyb3JNZXNzYWdlIiwidHJhbnNpdGlvbmFsIiwiY2xhcmlmeVRpbWVvdXRFcnJvciIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwieHNyZlZhbHVlIiwid2l0aENyZWRlbnRpYWxzIiwieHNyZkNvb2tpZU5hbWUiLCJyZWFkIiwidW5kZWZpbmVkIiwieHNyZkhlYWRlck5hbWUiLCJmb3JFYWNoIiwic2V0UmVxdWVzdEhlYWRlciIsInZhbCIsImtleSIsInRvTG93ZXJDYXNlIiwiaXNVbmRlZmluZWQiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsInRoZW4iLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiYmluZCIsIkF4aW9zIiwibWVyZ2VDb25maWciLCJkZWZhdWx0cyIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImNvbnRleHQiLCJpbnN0YW5jZSIsInByb3RvdHlwZSIsImV4dGVuZCIsImF4aW9zIiwiY3JlYXRlIiwiaW5zdGFuY2VDb25maWciLCJDYW5jZWwiLCJDYW5jZWxUb2tlbiIsImlzQ2FuY2VsIiwiYWxsIiwicHJvbWlzZXMiLCJzcHJlYWQiLCJpc0F4aW9zRXJyb3IiLCJtZXNzYWdlIiwiX19DQU5DRUxfXyIsImV4ZWN1dG9yIiwiVHlwZUVycm9yIiwicmVzb2x2ZVByb21pc2UiLCJwcm9taXNlRXhlY3V0b3IiLCJ0b2tlbiIsInJlYXNvbiIsInRocm93SWZSZXF1ZXN0ZWQiLCJzb3VyY2UiLCJjIiwiSW50ZXJjZXB0b3JNYW5hZ2VyIiwiZGlzcGF0Y2hSZXF1ZXN0IiwidmFsaWRhdG9yIiwidmFsaWRhdG9ycyIsImludGVyY2VwdG9ycyIsImFyZ3VtZW50cyIsImFzc2VydE9wdGlvbnMiLCJzaWxlbnRKU09OUGFyc2luZyIsImZvcmNlZEpTT05QYXJzaW5nIiwicmVxdWVzdEludGVyY2VwdG9yQ2hhaW4iLCJzeW5jaHJvbm91c1JlcXVlc3RJbnRlcmNlcHRvcnMiLCJ1bnNoaWZ0UmVxdWVzdEludGVyY2VwdG9ycyIsImludGVyY2VwdG9yIiwicnVuV2hlbiIsInN5bmNocm9ub3VzIiwidW5zaGlmdCIsImZ1bGZpbGxlZCIsInJlamVjdGVkIiwicmVzcG9uc2VJbnRlcmNlcHRvckNoYWluIiwicHVzaFJlc3BvbnNlSW50ZXJjZXB0b3JzIiwicHVzaCIsImNoYWluIiwiQXJyYXkiLCJhcHBseSIsImNvbmNhdCIsImxlbmd0aCIsInNoaWZ0IiwibmV3Q29uZmlnIiwib25GdWxmaWxsZWQiLCJvblJlamVjdGVkIiwiZXJyb3IiLCJnZXRVcmkiLCJyZXBsYWNlIiwiZm9yRWFjaE1ldGhvZE5vRGF0YSIsImZvckVhY2hNZXRob2RXaXRoRGF0YSIsImhhbmRsZXJzIiwidXNlIiwib3B0aW9ucyIsImVqZWN0IiwiaWQiLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsInJlcXVlc3RlZFVSTCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJ0cmFuc2Zvcm1EYXRhIiwidGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZCIsImNhbGwiLCJ0cmFuc2Zvcm1SZXF1ZXN0IiwibWVyZ2UiLCJjb21tb24iLCJjbGVhbkhlYWRlckNvbmZpZyIsImFkYXB0ZXIiLCJvbkFkYXB0ZXJSZXNvbHV0aW9uIiwidHJhbnNmb3JtUmVzcG9uc2UiLCJvbkFkYXB0ZXJSZWplY3Rpb24iLCJ0b0pTT04iLCJuYW1lIiwiZGVzY3JpcHRpb24iLCJudW1iZXIiLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJjb2x1bW5OdW1iZXIiLCJzdGFjayIsImNvbmZpZzEiLCJjb25maWcyIiwidmFsdWVGcm9tQ29uZmlnMktleXMiLCJtZXJnZURlZXBQcm9wZXJ0aWVzS2V5cyIsImRlZmF1bHRUb0NvbmZpZzJLZXlzIiwiZGlyZWN0TWVyZ2VLZXlzIiwiZ2V0TWVyZ2VkVmFsdWUiLCJ0YXJnZXQiLCJpc1BsYWluT2JqZWN0IiwiaXNBcnJheSIsIm1lcmdlRGVlcFByb3BlcnRpZXMiLCJwcm9wIiwidmFsdWVGcm9tQ29uZmlnMiIsImRlZmF1bHRUb0NvbmZpZzIiLCJheGlvc0tleXMiLCJvdGhlcktleXMiLCJrZXlzIiwiZmlsdGVyIiwiZmlsdGVyQXhpb3NLZXlzIiwidmFsaWRhdGVTdGF0dXMiLCJmbnMiLCJ0cmFuc2Zvcm0iLCJub3JtYWxpemVIZWFkZXJOYW1lIiwiREVGQVVMVF9DT05URU5UX1RZUEUiLCJzZXRDb250ZW50VHlwZUlmVW5zZXQiLCJnZXREZWZhdWx0QWRhcHRlciIsInByb2Nlc3MiLCJzdHJpbmdpZnlTYWZlbHkiLCJyYXdWYWx1ZSIsInBhcnNlciIsImVuY29kZXIiLCJpc1N0cmluZyIsIkpTT04iLCJwYXJzZSIsInRyaW0iLCJlIiwic3RyaW5naWZ5IiwiaXNBcnJheUJ1ZmZlciIsImlzQnVmZmVyIiwiaXNTdHJlYW0iLCJpc0ZpbGUiLCJpc0Jsb2IiLCJpc0FycmF5QnVmZmVyVmlldyIsImJ1ZmZlciIsImlzVVJMU2VhcmNoUGFyYW1zIiwiaXNPYmplY3QiLCJzdHJpY3RKU09OUGFyc2luZyIsIm1heENvbnRlbnRMZW5ndGgiLCJtYXhCb2R5TGVuZ3RoIiwidGhpc0FyZyIsIndyYXAiLCJhcmdzIiwiaSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJwYXJ0cyIsInNlcmlhbGl6ZSIsInBhcnNlVmFsdWUiLCJ2IiwiaXNEYXRlIiwidG9JU09TdHJpbmciLCJqb2luIiwiaGFzaG1hcmtJbmRleCIsInJlbGF0aXZlVVJMIiwic3RhbmRhcmRCcm93c2VyRW52Iiwid3JpdGUiLCJleHBpcmVzIiwicGF0aCIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsImlzTnVtYmVyIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwiZG9jdW1lbnQiLCJtYXRjaCIsIlJlZ0V4cCIsImRlY29kZVVSSUNvbXBvbmVudCIsInJlbW92ZSIsIm5vdyIsIm5vblN0YW5kYXJkQnJvd3NlckVudiIsInRlc3QiLCJwYXlsb2FkIiwibXNpZSIsIm5hdmlnYXRvciIsInVzZXJBZ2VudCIsInVybFBhcnNpbmdOb2RlIiwiY3JlYXRlRWxlbWVudCIsIm9yaWdpblVSTCIsInJlc29sdmVVUkwiLCJocmVmIiwic2V0QXR0cmlidXRlIiwicHJvdG9jb2wiLCJob3N0Iiwic2VhcmNoIiwiaG9zdG5hbWUiLCJwb3J0IiwicGF0aG5hbWUiLCJjaGFyQXQiLCJ3aW5kb3ciLCJsb2NhdGlvbiIsInJlcXVlc3RVUkwiLCJwYXJzZWQiLCJub3JtYWxpemVkTmFtZSIsInByb2Nlc3NIZWFkZXIiLCJpZ25vcmVEdXBsaWNhdGVPZiIsInNwbGl0IiwibGluZSIsInN1YnN0ciIsImNhbGxiYWNrIiwiYXJyIiwicGtnIiwidHlwZSIsInRoaW5nIiwiZGVwcmVjYXRlZFdhcm5pbmdzIiwiY3VycmVudFZlckFyciIsInZlcnNpb24iLCJpc09sZGVyVmVyc2lvbiIsInRoYW5WZXJzaW9uIiwicGtnVmVyc2lvbkFyciIsImRlc3RWZXIiLCJpc0RlcHJlY2F0ZWQiLCJmb3JtYXRNZXNzYWdlIiwib3B0IiwiZGVzYyIsIm9wdHMiLCJjb25zb2xlIiwid2FybiIsInNjaGVtYSIsImFsbG93VW5rbm93biIsInJlc3VsdCIsImNvbnN0cnVjdG9yIiwiRm9ybURhdGEiLCJBcnJheUJ1ZmZlciIsImlzVmlldyIsImdldFByb3RvdHlwZU9mIiwiaXNGdW5jdGlvbiIsInBpcGUiLCJVUkxTZWFyY2hQYXJhbXMiLCJzdHIiLCJwcm9kdWN0Iiwib2JqIiwibCIsImhhc093blByb3BlcnR5IiwiYXNzaWduVmFsdWUiLCJhIiwiYiIsInN0cmlwQk9NIiwiY29udGVudCIsImNoYXJDb2RlQXQiLCJieXRlTGVuZ3RoIiwidG9CeXRlQXJyYXkiLCJmcm9tQnl0ZUFycmF5IiwibG9va3VwIiwicmV2TG9va3VwIiwiQXJyIiwibGVuIiwiZ2V0TGVucyIsImI2NCIsInZhbGlkTGVuIiwicGxhY2VIb2xkZXJzTGVuIiwibGVucyIsIl9ieXRlTGVuZ3RoIiwidG1wIiwiY3VyQnl0ZSIsInRyaXBsZXRUb0Jhc2U2NCIsIm51bSIsImVuY29kZUNodW5rIiwidWludDgiLCJzdGFydCIsImVuZCIsIm91dHB1dCIsImV4dHJhQnl0ZXMiLCJtYXhDaHVua0xlbmd0aCIsImxlbjIiLCJiZWNoMzJtIiwiQUxQSEFCRVQiLCJBTFBIQUJFVF9NQVAiLCJ6IiwieCIsInBvbHltb2RTdGVwIiwicHJlIiwicHJlZml4Q2hrIiwiY2hrIiwiY29udmVydCIsImluQml0cyIsIm91dEJpdHMiLCJwYWQiLCJiaXRzIiwibWF4ViIsImJ5dGVzIiwiZnJvbVdvcmRzVW5zYWZlIiwicmVzIiwiZ2V0TGlicmFyeUZyb21FbmNvZGluZyIsImVuY29kaW5nIiwiRU5DT0RJTkdfQ09OU1QiLCJMSU1JVCIsIl9fZGVjb2RlIiwibG93ZXJlZCIsInVwcGVyZWQiLCJsYXN0SW5kZXhPZiIsIndvcmRDaGFycyIsImRlY29kZVVuc2FmZSIsImxvYWRXZWJBc3NlbWJseSIsInN1cHBvcnRlZCIsIldlYkFzc2VtYmx5IiwiaW1wIiwiaW1wb3J0cyIsIndhc20iLCJ0b1VpbnQ4QXJyYXkiLCJyZWFkeSIsIm1lbW9yeSIsInJlYWxsb2MiLCJvbmxvYWQiLCJzaXplIiwiZ3JvdyIsIk1hdGgiLCJjZWlsIiwiYWJzIiwiY2IiLCJhc3luYyIsInNldHVwIiwiSW5zdGFuY2UiLCJNb2R1bGUiLCJlcnIiLCJpbnN0YW50aWF0ZSIsInciLCJzIiwiYXRvYiIsIm1hcCIsImFzc2VydCIsImhlYWQiLCJmcmVlTGlzdCIsIkJsYWtlMmIiLCJCWVRFU19NSU4iLCJCWVRFU19NQVgiLCJCWVRFUyIsIktFWUJZVEVTX01JTiIsIktFWUJZVEVTX01BWCIsIktFWUJZVEVTIiwiU0FMVEJZVEVTIiwiUEVSU09OQUxCWVRFUyIsImRpZ2VzdExlbmd0aCIsInNhbHQiLCJwZXJzb25hbCIsIm5vQXNzZXJ0IiwiZmluYWxpemVkIiwicG9pbnRlciIsInBvcCIsImZpbGwiLCJzZXQiLCJibGFrZTJiX2luaXQiLCJpbnB1dCIsImJsYWtlMmJfdXBkYXRlIiwiZW5jIiwiYmxha2UyYl9maW5hbCIsImhleFNsaWNlIiwiV0FTTSIsIlNVUFBPUlRFRCIsIm5vb3AiLCJwIiwiYnVmIiwidG9IZXgiLCJuIiwiYjJ3YXNtIiwiQURENjRBQSIsIm8wIiwibzEiLCJBREQ2NEFDIiwiYjAiLCJiMSIsIkIyQl9HRVQzMiIsIkIyQl9HIiwiZCIsIml4IiwiaXkiLCJ4MCIsIm0iLCJ4MSIsInkwIiwieTEiLCJ4b3IwIiwieG9yMSIsIkJMQUtFMkJfSVYzMiIsIlVpbnQzMkFycmF5IiwiU0lHTUE4IiwiU0lHTUE4MiIsImJsYWtlMmJDb21wcmVzcyIsImN0eCIsImxhc3QiLCJ0IiwicGFyYW1ldGVyX2Jsb2NrIiwib3V0bGVuIiwiYmxha2UyYlVwZGF0ZSIsIm91dCIsImJsYWtlMmJGaW5hbCIsIlByb3RvIiwiY3JlYXRlSGFzaCIsIldBU01fU1VQUE9SVEVEIiwiV0FTTV9MT0FERUQiLCJiYXNlNjQiLCJpZWVlNzU0IiwiY3VzdG9tSW5zcGVjdFN5bWJvbCIsIlN5bWJvbCIsIlNsb3dCdWZmZXIiLCJJTlNQRUNUX01BWF9CWVRFUyIsIktfTUFYX0xFTkdUSCIsImtNYXhMZW5ndGgiLCJUWVBFRF9BUlJBWV9TVVBQT1JUIiwidHlwZWRBcnJheVN1cHBvcnQiLCJwcm90byIsImZvbyIsInNldFByb3RvdHlwZU9mIiwiZW51bWVyYWJsZSIsImdldCIsImJ5dGVPZmZzZXQiLCJjcmVhdGVCdWZmZXIiLCJSYW5nZUVycm9yIiwiYXJnIiwiZW5jb2RpbmdPck9mZnNldCIsImFsbG9jVW5zYWZlIiwicG9vbFNpemUiLCJmcm9tU3RyaW5nIiwiZnJvbUFycmF5VmlldyIsImlzSW5zdGFuY2UiLCJmcm9tQXJyYXlCdWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsInZhbHVlT2YiLCJmcm9tT2JqZWN0IiwidG9QcmltaXRpdmUiLCJhc3NlcnRTaXplIiwiYWxsb2MiLCJjaGVja2VkIiwiYWxsb2NVbnNhZmVTbG93Iiwic3RyaW5nIiwiaXNFbmNvZGluZyIsImFjdHVhbCIsImZyb21BcnJheUxpa2UiLCJhcnJheSIsImFycmF5VmlldyIsImNvcHkiLCJudW1iZXJJc05hTiIsIl9pc0J1ZmZlciIsImNvbXBhcmUiLCJvZmZzZXQiLCJ5IiwibWluIiwiU3RyaW5nIiwibGlzdCIsInBvcyIsIm11c3RNYXRjaCIsImxvd2VyZWRDYXNlIiwidXRmOFRvQnl0ZXMiLCJiYXNlNjRUb0J5dGVzIiwic2xvd1RvU3RyaW5nIiwidXRmOFNsaWNlIiwiYXNjaWlTbGljZSIsImxhdGluMVNsaWNlIiwiYmFzZTY0U2xpY2UiLCJ1dGYxNmxlU2xpY2UiLCJzd2FwIiwic3dhcDE2Iiwic3dhcDMyIiwic3dhcDY0IiwidG9Mb2NhbGVTdHJpbmciLCJlcXVhbHMiLCJpbnNwZWN0IiwibWF4IiwidGhpc1N0YXJ0IiwidGhpc0VuZCIsInRoaXNDb3B5IiwidGFyZ2V0Q29weSIsImJpZGlyZWN0aW9uYWxJbmRleE9mIiwiZGlyIiwiYXJyYXlJbmRleE9mIiwiaW5kZXhTaXplIiwiYXJyTGVuZ3RoIiwidmFsTGVuZ3RoIiwicmVhZFVJbnQxNkJFIiwiZm91bmRJbmRleCIsImZvdW5kIiwiaiIsImluY2x1ZGVzIiwiaGV4V3JpdGUiLCJOdW1iZXIiLCJyZW1haW5pbmciLCJzdHJMZW4iLCJwYXJzZUludCIsInV0ZjhXcml0ZSIsImJsaXRCdWZmZXIiLCJhc2NpaVdyaXRlIiwiYXNjaWlUb0J5dGVzIiwiYmFzZTY0V3JpdGUiLCJ1Y3MyV3JpdGUiLCJ1dGYxNmxlVG9CeXRlcyIsImlzRmluaXRlIiwiX2FyciIsImZpcnN0Qnl0ZSIsImNvZGVQb2ludCIsImJ5dGVzUGVyU2VxdWVuY2UiLCJzZWNvbmRCeXRlIiwidGhpcmRCeXRlIiwiZm91cnRoQnl0ZSIsInRlbXBDb2RlUG9pbnQiLCJkZWNvZGVDb2RlUG9pbnRzQXJyYXkiLCJNQVhfQVJHVU1FTlRTX0xFTkdUSCIsImNvZGVQb2ludHMiLCJmcm9tQ2hhckNvZGUiLCJyZXQiLCJoZXhTbGljZUxvb2t1cFRhYmxlIiwibmV3QnVmIiwic3ViYXJyYXkiLCJjaGVja09mZnNldCIsImV4dCIsInJlYWRVaW50TEUiLCJyZWFkVUludExFIiwibXVsIiwicmVhZFVpbnRCRSIsInJlYWRVSW50QkUiLCJyZWFkVWludDgiLCJyZWFkVUludDgiLCJyZWFkVWludDE2TEUiLCJyZWFkVUludDE2TEUiLCJyZWFkVWludDE2QkUiLCJyZWFkVWludDMyTEUiLCJyZWFkVUludDMyTEUiLCJyZWFkVWludDMyQkUiLCJyZWFkVUludDMyQkUiLCJyZWFkQmlnVUludDY0TEUiLCJkZWZpbmVCaWdJbnRNZXRob2QiLCJ2YWxpZGF0ZU51bWJlciIsImZpcnN0IiwiYm91bmRzRXJyb3IiLCJsbyIsImhpIiwiQmlnSW50IiwicmVhZEJpZ1VJbnQ2NEJFIiwicmVhZEludExFIiwicG93IiwicmVhZEludEJFIiwicmVhZEludDgiLCJyZWFkSW50MTZMRSIsInJlYWRJbnQxNkJFIiwicmVhZEludDMyTEUiLCJyZWFkSW50MzJCRSIsInJlYWRCaWdJbnQ2NExFIiwicmVhZEJpZ0ludDY0QkUiLCJyZWFkRmxvYXRMRSIsInJlYWRGbG9hdEJFIiwicmVhZERvdWJsZUxFIiwicmVhZERvdWJsZUJFIiwiY2hlY2tJbnQiLCJ3cml0ZVVpbnRMRSIsIndyaXRlVUludExFIiwibWF4Qnl0ZXMiLCJ3cml0ZVVpbnRCRSIsIndyaXRlVUludEJFIiwid3JpdGVVaW50OCIsIndyaXRlVUludDgiLCJ3cml0ZVVpbnQxNkxFIiwid3JpdGVVSW50MTZMRSIsIndyaXRlVWludDE2QkUiLCJ3cml0ZVVJbnQxNkJFIiwid3JpdGVVaW50MzJMRSIsIndyaXRlVUludDMyTEUiLCJ3cml0ZVVpbnQzMkJFIiwid3JpdGVVSW50MzJCRSIsIndydEJpZ1VJbnQ2NExFIiwiY2hlY2tJbnRCSSIsIndydEJpZ1VJbnQ2NEJFIiwid3JpdGVCaWdVSW50NjRMRSIsIndyaXRlQmlnVUludDY0QkUiLCJ3cml0ZUludExFIiwibGltaXQiLCJzdWIiLCJ3cml0ZUludEJFIiwid3JpdGVJbnQ4Iiwid3JpdGVJbnQxNkxFIiwid3JpdGVJbnQxNkJFIiwid3JpdGVJbnQzMkxFIiwid3JpdGVJbnQzMkJFIiwid3JpdGVCaWdJbnQ2NExFIiwid3JpdGVCaWdJbnQ2NEJFIiwiY2hlY2tJRUVFNzU0Iiwid3JpdGVGbG9hdCIsImxpdHRsZUVuZGlhbiIsIndyaXRlRmxvYXRMRSIsIndyaXRlRmxvYXRCRSIsIndyaXRlRG91YmxlIiwid3JpdGVEb3VibGVMRSIsIndyaXRlRG91YmxlQkUiLCJ0YXJnZXRTdGFydCIsImNvcHlXaXRoaW4iLCJlcnJvcnMiLCJFIiwic3ltIiwiZ2V0TWVzc2FnZSIsIkJhc2UiLCJ3cml0YWJsZSIsImNvbmZpZ3VyYWJsZSIsInJhbmdlIiwibXNnIiwicmVjZWl2ZWQiLCJpc0ludGVnZXIiLCJhZGROdW1lcmljYWxTZXBhcmF0b3IiLCJjaGVja0JvdW5kcyIsIkVSUl9PVVRfT0ZfUkFOR0UiLCJFUlJfSU5WQUxJRF9BUkdfVFlQRSIsImZsb29yIiwiRVJSX0JVRkZFUl9PVVRfT0ZfQk9VTkRTIiwiSU5WQUxJRF9CQVNFNjRfUkUiLCJiYXNlNjRjbGVhbiIsInVuaXRzIiwiSW5maW5pdHkiLCJsZWFkU3Vycm9nYXRlIiwiYnl0ZUFycmF5Iiwic3JjIiwiZHN0IiwiYWxwaGFiZXQiLCJ0YWJsZSIsImkxNiIsIkJ1ZmZlckJpZ0ludE5vdERlZmluZWQiLCJSIiwiUmVmbGVjdCIsIlJlZmxlY3RBcHBseSIsInJlY2VpdmVyIiwiRnVuY3Rpb24iLCJSZWZsZWN0T3duS2V5cyIsIm93bktleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eU5hbWVzIiwiUHJvY2Vzc0VtaXRXYXJuaW5nIiwid2FybmluZyIsIk51bWJlcklzTmFOIiwiaXNOYU4iLCJFdmVudEVtaXR0ZXIiLCJpbml0Iiwib25jZSIsIl9ldmVudHMiLCJfZXZlbnRzQ291bnQiLCJfbWF4TGlzdGVuZXJzIiwiZGVmYXVsdE1heExpc3RlbmVycyIsImNoZWNrTGlzdGVuZXIiLCJsaXN0ZW5lciIsInNldE1heExpc3RlbmVycyIsIl9nZXRNYXhMaXN0ZW5lcnMiLCJ0aGF0IiwiZ2V0TWF4TGlzdGVuZXJzIiwiZW1pdCIsImRvRXJyb3IiLCJldmVudHMiLCJlciIsImhhbmRsZXIiLCJsaXN0ZW5lcnMiLCJhcnJheUNsb25lIiwiX2FkZExpc3RlbmVyIiwicHJlcGVuZCIsImV4aXN0aW5nIiwibmV3TGlzdGVuZXIiLCJ3YXJuZWQiLCJlbWl0dGVyIiwiY291bnQiLCJhZGRMaXN0ZW5lciIsIm9uIiwicHJlcGVuZExpc3RlbmVyIiwib25jZVdyYXBwZXIiLCJmaXJlZCIsInJlbW92ZUxpc3RlbmVyIiwid3JhcEZuIiwiX29uY2VXcmFwIiwic3RhdGUiLCJ3cmFwcGVkIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsInBvc2l0aW9uIiwib3JpZ2luYWxMaXN0ZW5lciIsInNwbGljZU9uZSIsIm9mZiIsInJlbW92ZUFsbExpc3RlbmVycyIsIl9saXN0ZW5lcnMiLCJ1bndyYXAiLCJldmxpc3RlbmVyIiwidW53cmFwTGlzdGVuZXJzIiwicmF3TGlzdGVuZXJzIiwibGlzdGVuZXJDb3VudCIsImV2ZW50TmFtZXMiLCJpbmRleCIsImVycm9yTGlzdGVuZXIiLCJyZXNvbHZlciIsImV2ZW50VGFyZ2V0QWdub3N0aWNBZGRMaXN0ZW5lciIsImFkZEVycm9ySGFuZGxlcklmRXZlbnRFbWl0dGVyIiwiZmxhZ3MiLCJ3cmFwTGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2VsZiIsImlzTEUiLCJtTGVuIiwibkJ5dGVzIiwiZUxlbiIsImVNYXgiLCJlQmlhcyIsIm5CaXRzIiwiTmFOIiwicnQiLCJsb2ciLCJMTjIiLCJpbmhlcml0cyIsImN0b3IiLCJzdXBlckN0b3IiLCJzdXBlcl8iLCJUZW1wQ3RvciIsIm5vdEVxdWFsIiwibm90T2siLCJlcXVhbCIsIm9rIiwicXMiLCJzZXAiLCJlcSIsInJlZ2V4cCIsIm1heEtleXMiLCJpZHgiLCJrc3RyIiwidnN0ciIsImsiLCJzdHJpbmdpZnlQcmltaXRpdmUiLCJrcyIsIl9pbmhlcml0c0xvb3NlIiwic3ViQ2xhc3MiLCJzdXBlckNsYXNzIiwiX19wcm90b19fIiwiY29kZXMiLCJjcmVhdGVFcnJvclR5cGUiLCJhcmcxIiwiYXJnMiIsImFyZzMiLCJOb2RlRXJyb3IiLCJfQmFzZSIsIm9uZU9mIiwiZXhwZWN0ZWQiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJ0aGlzX2xlbiIsInN1YnN0cmluZyIsImRldGVybWluZXIiLCJvYmplY3RLZXlzIiwiRHVwbGV4IiwiUmVhZGFibGUiLCJXcml0YWJsZSIsImFsbG93SGFsZk9wZW4iLCJyZWFkYWJsZSIsIm9uZW5kIiwiX3dyaXRhYmxlU3RhdGUiLCJoaWdoV2F0ZXJNYXJrIiwiZ2V0QnVmZmVyIiwiZW5kZWQiLCJuZXh0VGljayIsIm9uRW5kTlQiLCJfcmVhZGFibGVTdGF0ZSIsImRlc3Ryb3llZCIsIlBhc3NUaHJvdWdoIiwiVHJhbnNmb3JtIiwiX3RyYW5zZm9ybSIsImNodW5rIiwiUmVhZGFibGVTdGF0ZSIsIkVFIiwiRUVsaXN0ZW5lckNvdW50IiwiU3RyZWFtIiwiT3VyVWludDhBcnJheSIsImdsb2JhbCIsIl91aW50OEFycmF5VG9CdWZmZXIiLCJfaXNVaW50OEFycmF5IiwiZGVidWdVdGlsIiwiZGVidWciLCJkZWJ1Z2xvZyIsIkJ1ZmZlckxpc3QiLCJkZXN0cm95SW1wbCIsIl9yZXF1aXJlIiwiZ2V0SGlnaFdhdGVyTWFyayIsIl9yZXF1aXJlJGNvZGVzIiwiRVJSX1NUUkVBTV9QVVNIX0FGVEVSX0VPRiIsIkVSUl9NRVRIT0RfTk9UX0lNUExFTUVOVEVEIiwiRVJSX1NUUkVBTV9VTlNISUZUX0FGVEVSX0VORF9FVkVOVCIsIlN0cmluZ0RlY29kZXIiLCJjcmVhdGVSZWFkYWJsZVN0cmVhbUFzeW5jSXRlcmF0b3IiLCJlcnJvck9yRGVzdHJveSIsImtQcm94eUV2ZW50cyIsImV2ZW50Iiwic3RyZWFtIiwiaXNEdXBsZXgiLCJvYmplY3RNb2RlIiwicmVhZGFibGVPYmplY3RNb2RlIiwicGlwZXMiLCJwaXBlc0NvdW50IiwiZmxvd2luZyIsImVuZEVtaXR0ZWQiLCJyZWFkaW5nIiwic3luYyIsIm5lZWRSZWFkYWJsZSIsImVtaXR0ZWRSZWFkYWJsZSIsInJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lU2NoZWR1bGVkIiwicGF1c2VkIiwiZW1pdENsb3NlIiwiYXV0b0Rlc3Ryb3kiLCJkZWZhdWx0RW5jb2RpbmciLCJhd2FpdERyYWluIiwicmVhZGluZ01vcmUiLCJkZWNvZGVyIiwiX3JlYWQiLCJkZXN0cm95IiwiX2Rlc3Ryb3kiLCJfdW5kZXN0cm95IiwidW5kZXN0cm95Iiwic2tpcENodW5rQ2hlY2siLCJyZWFkYWJsZUFkZENodW5rIiwiYWRkVG9Gcm9udCIsIm9uRW9mQ2h1bmsiLCJjaHVua0ludmFsaWQiLCJhZGRDaHVuayIsIm1heWJlUmVhZE1vcmUiLCJlbWl0UmVhZGFibGUiLCJpc1BhdXNlZCIsInNldEVuY29kaW5nIiwibmV4dCIsImNsZWFyIiwiTUFYX0hXTSIsImNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrIiwiaG93TXVjaFRvUmVhZCIsIm5PcmlnIiwiZW5kUmVhZGFibGUiLCJkb1JlYWQiLCJmcm9tTGlzdCIsImVtaXRSZWFkYWJsZV8iLCJmbG93IiwibWF5YmVSZWFkTW9yZV8iLCJkZXN0IiwicGlwZU9wdHMiLCJkb0VuZCIsInN0ZG91dCIsInN0ZGVyciIsImVuZEZuIiwidW5waXBlIiwib251bnBpcGUiLCJ1bnBpcGVJbmZvIiwiaGFzVW5waXBlZCIsImNsZWFudXAiLCJvbmRyYWluIiwicGlwZU9uRHJhaW4iLCJjbGVhbmVkVXAiLCJvbmNsb3NlIiwib25maW5pc2giLCJvbmRhdGEiLCJuZWVkRHJhaW4iLCJwYXVzZSIsInJlc3VtZSIsInBpcGVPbkRyYWluRnVuY3Rpb25SZXN1bHQiLCJkZXN0cyIsInNwbGljZSIsImV2IiwiblJlYWRpbmdOZXh0VGljayIsInVwZGF0ZVJlYWRhYmxlTGlzdGVuaW5nIiwicmVzdW1lXyIsIl90aGlzIiwibWV0aG9kV3JhcCIsIm1ldGhvZFdyYXBSZXR1cm5GdW5jdGlvbiIsImFzeW5jSXRlcmF0b3IiLCJfZnJvbUxpc3QiLCJjb25zdW1lIiwiZW5kUmVhZGFibGVOVCIsIndTdGF0ZSIsImZpbmlzaGVkIiwiaXRlcmFibGUiLCJ4cyIsIkVSUl9NVUxUSVBMRV9DQUxMQkFDSyIsIkVSUl9UUkFOU0ZPUk1fQUxSRUFEWV9UUkFOU0ZPUk1JTkciLCJFUlJfVFJBTlNGT1JNX1dJVEhfTEVOR1RIXzAiLCJhZnRlclRyYW5zZm9ybSIsInRzIiwiX3RyYW5zZm9ybVN0YXRlIiwidHJhbnNmb3JtaW5nIiwid3JpdGVjYiIsIndyaXRlY2h1bmsiLCJycyIsIm5lZWRUcmFuc2Zvcm0iLCJ3cml0ZWVuY29kaW5nIiwiZmx1c2giLCJfZmx1c2giLCJwcmVmaW5pc2giLCJkb25lIiwiX3dyaXRlIiwiZXJyMiIsIldyaXRlUmVxIiwiQ29ya2VkUmVxdWVzdCIsImVudHJ5IiwiZmluaXNoIiwib25Db3JrZWRGaW5pc2giLCJXcml0YWJsZVN0YXRlIiwiaW50ZXJuYWxVdGlsIiwiZGVwcmVjYXRlIiwiRVJSX1NUUkVBTV9DQU5OT1RfUElQRSIsIkVSUl9TVFJFQU1fREVTVFJPWUVEIiwiRVJSX1NUUkVBTV9OVUxMX1ZBTFVFUyIsIkVSUl9TVFJFQU1fV1JJVEVfQUZURVJfRU5EIiwiRVJSX1VOS05PV05fRU5DT0RJTkciLCJub3AiLCJ3cml0YWJsZU9iamVjdE1vZGUiLCJmaW5hbENhbGxlZCIsImVuZGluZyIsIm5vRGVjb2RlIiwiZGVjb2RlU3RyaW5ncyIsIndyaXRpbmciLCJjb3JrZWQiLCJidWZmZXJQcm9jZXNzaW5nIiwib253cml0ZSIsIndyaXRlbGVuIiwiYnVmZmVyZWRSZXF1ZXN0IiwibGFzdEJ1ZmZlcmVkUmVxdWVzdCIsInBlbmRpbmdjYiIsInByZWZpbmlzaGVkIiwiZXJyb3JFbWl0dGVkIiwiYnVmZmVyZWRSZXF1ZXN0Q291bnQiLCJjb3JrZWRSZXF1ZXN0c0ZyZWUiLCJjdXJyZW50Iiwid3JpdGFibGVTdGF0ZUJ1ZmZlckdldHRlciIsIl8iLCJyZWFsSGFzSW5zdGFuY2UiLCJoYXNJbnN0YW5jZSIsIm9iamVjdCIsIndyaXRldiIsIl93cml0ZXYiLCJfZmluYWwiLCJ3cml0ZUFmdGVyRW5kIiwidmFsaWRDaHVuayIsImlzQnVmIiwid3JpdGVPckJ1ZmZlciIsImNvcmsiLCJ1bmNvcmsiLCJjbGVhckJ1ZmZlciIsInNldERlZmF1bHRFbmNvZGluZyIsImRlY29kZUNodW5rIiwibmV3Q2h1bmsiLCJkb1dyaXRlIiwib253cml0ZUVycm9yIiwiZmluaXNoTWF5YmUiLCJvbndyaXRlU3RhdGVVcGRhdGUiLCJuZWVkRmluaXNoIiwiYWZ0ZXJXcml0ZSIsIm9ud3JpdGVEcmFpbiIsImhvbGRlciIsImFsbEJ1ZmZlcnMiLCJlbmRXcml0YWJsZSIsImNhbGxGaW5hbCIsIm5lZWQiLCJyU3RhdGUiLCJjb3JrUmVxIiwiX09iamVjdCRzZXRQcm90b3R5cGVPIiwiX2RlZmluZVByb3BlcnR5Iiwia0xhc3RSZXNvbHZlIiwia0xhc3RSZWplY3QiLCJrRXJyb3IiLCJrRW5kZWQiLCJrTGFzdFByb21pc2UiLCJrSGFuZGxlUHJvbWlzZSIsImtTdHJlYW0iLCJjcmVhdGVJdGVyUmVzdWx0IiwicmVhZEFuZFJlc29sdmUiLCJpdGVyIiwib25SZWFkYWJsZSIsIndyYXBGb3JOZXh0IiwibGFzdFByb21pc2UiLCJBc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiUmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhdG9yUHJvdG90eXBlIiwiX3JldHVybiIsIl90aGlzMiIsIl9PYmplY3QkY3JlYXRlIiwiaXRlcmF0b3IiLCJlbnVtZXJhYmxlT25seSIsInN5bWJvbHMiLCJnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IiLCJfb2JqZWN0U3ByZWFkIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsIl9kZWZpbmVQcm9wZXJ0aWVzIiwicHJvcHMiLCJkZXNjcmlwdG9yIiwiX2NyZWF0ZUNsYXNzIiwicHJvdG9Qcm9wcyIsInN0YXRpY1Byb3BzIiwiX3JlcXVpcmUyIiwiY3VzdG9tIiwiY29weUJ1ZmZlciIsInRhaWwiLCJoYXNTdHJpbmdzIiwiX2dldFN0cmluZyIsIl9nZXRCdWZmZXIiLCJuYiIsImRlcHRoIiwiY3VzdG9tSW5zcGVjdCIsInJlYWRhYmxlRGVzdHJveWVkIiwid3JpdGFibGVEZXN0cm95ZWQiLCJlbWl0RXJyb3JOVCIsImVtaXRFcnJvckFuZENsb3NlTlQiLCJlbWl0Q2xvc2VOVCIsIkVSUl9TVFJFQU1fUFJFTUFUVVJFX0NMT1NFIiwiY2FsbGVkIiwiX2xlbiIsIl9rZXkiLCJpc1JlcXVlc3QiLCJzZXRIZWFkZXIiLCJlb3MiLCJvbmxlZ2FjeWZpbmlzaCIsIndyaXRhYmxlRW5kZWQiLCJyZWFkYWJsZUVuZGVkIiwib25yZXF1ZXN0IiwicmVxIiwiRVJSX01JU1NJTkdfQVJHUyIsImRlc3Ryb3llciIsImNsb3NlZCIsInRvIiwicG9wQ2FsbGJhY2siLCJzdHJlYW1zIiwicGlwZWxpbmUiLCJkZXN0cm95cyIsInJlZHVjZSIsIkVSUl9JTlZBTElEX09QVF9WQUxVRSIsImhpZ2hXYXRlck1hcmtGcm9tIiwiZHVwbGV4S2V5IiwiaHdtIiwiY29weVByb3BzIiwiU2FmZUJ1ZmZlciIsIkNsaWVudFJlcXVlc3QiLCJzdGF0dXNDb2RlcyIsImh0dHAiLCJkZWZhdWx0UHJvdG9jb2wiLCJJbmNvbWluZ01lc3NhZ2UiLCJBZ2VudCIsImRlZmF1bHRNYXhTb2NrZXRzIiwiZ2xvYmFsQWdlbnQiLCJTVEFUVVNfQ09ERVMiLCJNRVRIT0RTIiwiZmV0Y2giLCJSZWFkYWJsZVN0cmVhbSIsIndyaXRhYmxlU3RyZWFtIiwiV3JpdGFibGVTdHJlYW0iLCJhYm9ydENvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ4aHIiLCJnZXRYSFIiLCJYRG9tYWluUmVxdWVzdCIsImNoZWNrVHlwZVN1cHBvcnQiLCJhcnJheWJ1ZmZlciIsIm1zc3RyZWFtIiwibW96Y2h1bmtlZGFycmF5YnVmZmVyIiwib3ZlcnJpZGVNaW1lVHlwZSIsImNhcGFiaWxpdHkiLCJyU3RhdGVzIiwicmVhZHlTdGF0ZXMiLCJkZWNpZGVNb2RlIiwicHJlZmVyQmluYXJ5IiwidXNlRmV0Y2giLCJfb3B0cyIsIl9ib2R5IiwiX2hlYWRlcnMiLCJtb2RlIiwiX21vZGUiLCJfZmV0Y2hUaW1lciIsIl9zb2NrZXRUaW1lb3V0IiwiX3NvY2tldFRpbWVyIiwiX29uRmluaXNoIiwibG93ZXJOYW1lIiwidW5zYWZlSGVhZGVycyIsImdldEhlYWRlciIsImhlYWRlciIsInJlbW92ZUhlYWRlciIsIl9kZXN0cm95ZWQiLCJoZWFkZXJzT2JqIiwiYm9keSIsIkJsb2IiLCJoZWFkZXJzTGlzdCIsImtleU5hbWUiLCJzaWduYWwiLCJjb250cm9sbGVyIiwiX2ZldGNoQWJvcnRDb250cm9sbGVyIiwicmVxdWVzdFRpbWVvdXQiLCJjcmVkZW50aWFscyIsIl9mZXRjaFJlc3BvbnNlIiwiX3Jlc2V0VGltZXJzIiwiX2Nvbm5lY3QiLCJfeGhyIiwiX3Jlc3BvbnNlIiwiTE9BRElORyIsIkRPTkUiLCJfb25YSFJQcm9ncmVzcyIsIm9ucHJvZ3Jlc3MiLCJzdGF0dXNWYWxpZCIsImNsZWFyVGltZW91dCIsImZsdXNoSGVhZGVycyIsInNldE5vRGVsYXkiLCJzZXRTb2NrZXRLZWVwQWxpdmUiLCJVTlNFTlQiLCJPUEVORUQiLCJIRUFERVJTX1JFQ0VJVkVEIiwicmVzZXRUaW1lcnMiLCJyYXdIZWFkZXJzIiwidHJhaWxlcnMiLCJyYXdUcmFpbGVycyIsInJlYWRlciIsInN0YXR1c0NvZGUiLCJzdGF0dXNNZXNzYWdlIiwiX3Jlc3VtZUZldGNoIiwiY2xvc2UiLCJwaXBlVG8iLCJnZXRSZWFkZXIiLCJfcG9zIiwibWF0Y2hlcyIsIl9jaGFyc2V0IiwibWltZVR5cGUiLCJjaGFyc2V0TWF0Y2giLCJuZXdEYXRhIiwiTVNTdHJlYW1SZWFkZXIiLCJyZWFkQXNBcnJheUJ1ZmZlciIsIl9ub3JtYWxpemVFbmNvZGluZyIsInJldHJpZWQiLCJub3JtYWxpemVFbmNvZGluZyIsIm5lbmMiLCJ0ZXh0IiwidXRmMTZUZXh0IiwidXRmMTZFbmQiLCJmaWxsTGFzdCIsInV0ZjhGaWxsTGFzdCIsImJhc2U2NFRleHQiLCJiYXNlNjRFbmQiLCJzaW1wbGVXcml0ZSIsInNpbXBsZUVuZCIsImxhc3ROZWVkIiwibGFzdFRvdGFsIiwibGFzdENoYXIiLCJyIiwidXRmOEVuZCIsInV0ZjhUZXh0IiwidXRmOENoZWNrQnl0ZSIsImJ5dGUiLCJ1dGY4Q2hlY2tJbmNvbXBsZXRlIiwidXRmOENoZWNrRXh0cmFCeXRlcyIsInRvdGFsIiwicm9vdCIsImZyZWVFeHBvcnRzIiwibm9kZVR5cGUiLCJmcmVlTW9kdWxlIiwiZnJlZUdsb2JhbCIsInB1bnljb2RlIiwibWF4SW50IiwiYmFzZSIsInRNaW4iLCJ0TWF4Iiwic2tldyIsImRhbXAiLCJpbml0aWFsQmlhcyIsImluaXRpYWxOIiwiZGVsaW1pdGVyIiwicmVnZXhQdW55Y29kZSIsInJlZ2V4Tm9uQVNDSUkiLCJyZWdleFNlcGFyYXRvcnMiLCJiYXNlTWludXNUTWluIiwic3RyaW5nRnJvbUNoYXJDb2RlIiwibWFwRG9tYWluIiwibGFiZWxzIiwiZW5jb2RlZCIsInVjczJkZWNvZGUiLCJjb3VudGVyIiwiZXh0cmEiLCJ1Y3MyZW5jb2RlIiwiYmFzaWNUb0RpZ2l0IiwiZGlnaXRUb0Jhc2ljIiwiZGlnaXQiLCJmbGFnIiwiYWRhcHQiLCJkZWx0YSIsIm51bVBvaW50cyIsImZpcnN0VGltZSIsImlucHV0TGVuZ3RoIiwiYmlhcyIsImJhc2ljIiwib2xkaSIsImJhc2VNaW51c1QiLCJoYW5kbGVkQ1BDb3VudCIsImJhc2ljTGVuZ3RoIiwicSIsImN1cnJlbnRWYWx1ZSIsImhhbmRsZWRDUENvdW50UGx1c09uZSIsInFNaW51c1QiLCJ0b1VuaWNvZGUiLCJ0b0FTQ0lJIiwiZGVmaW5lIiwiYW1kIiwidXRpbCIsInVybFBhcnNlIiwidXJsUmVzb2x2ZSIsInJlc29sdmVPYmplY3QiLCJ1cmxSZXNvbHZlT2JqZWN0IiwiZm9ybWF0IiwidXJsRm9ybWF0IiwiVXJsIiwic2xhc2hlcyIsInF1ZXJ5IiwicHJvdG9jb2xQYXR0ZXJuIiwicG9ydFBhdHRlcm4iLCJzaW1wbGVQYXRoUGF0dGVybiIsImRlbGltcyIsInVud2lzZSIsImF1dG9Fc2NhcGUiLCJub25Ib3N0Q2hhcnMiLCJob3N0RW5kaW5nQ2hhcnMiLCJob3N0bmFtZU1heExlbiIsImhvc3RuYW1lUGFydFBhdHRlcm4iLCJob3N0bmFtZVBhcnRTdGFydCIsInVuc2FmZVByb3RvY29sIiwiaG9zdGxlc3NQcm90b2NvbCIsInNsYXNoZWRQcm90b2NvbCIsInF1ZXJ5c3RyaW5nIiwicGFyc2VRdWVyeVN0cmluZyIsInNsYXNoZXNEZW5vdGVIb3N0IiwidSIsInF1ZXJ5SW5kZXgiLCJzcGxpdHRlciIsInVTcGxpdCIsInNsYXNoUmVnZXgiLCJyZXN0Iiwic2ltcGxlUGF0aCIsImV4ZWMiLCJsb3dlclByb3RvIiwiaG9zdEVuZCIsImhlYyIsImF0U2lnbiIsInBhcnNlSG9zdCIsImlwdjZIb3N0bmFtZSIsImhvc3RwYXJ0cyIsInBhcnQiLCJuZXdwYXJ0IiwidmFsaWRQYXJ0cyIsIm5vdEhvc3QiLCJiaXQiLCJhZSIsImVzYyIsImVzY2FwZSIsInFtIiwicmVsYXRpdmUiLCJyZWwiLCJ0a2V5cyIsInRrIiwidGtleSIsInJrZXlzIiwicmsiLCJya2V5IiwicmVsUGF0aCIsImlzU291cmNlQWJzIiwiaXNSZWxBYnMiLCJtdXN0RW5kQWJzIiwicmVtb3ZlQWxsRG90cyIsInNyY1BhdGgiLCJwc3ljaG90aWMiLCJpc051bGxPclVuZGVmaW5lZCIsImF1dGhJbkhvc3QiLCJpc051bGwiLCJoYXNUcmFpbGluZ1NsYXNoIiwidXAiLCJpc0Fic29sdXRlIiwiZGVwcmVjYXRlZCIsInRyYWNlIiwibG9jYWxTdG9yYWdlIl0sInNvdXJjZVJvb3QiOiIifQ==